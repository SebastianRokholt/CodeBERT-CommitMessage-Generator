{"commit_tokens": ["added", "CoreShowChannel", "()", "execution", "to", "sample", "run", ".", "Added", "actions", "events", "and", "responses", "to", "nami", "exports"], "add_tokens": "var namiLib = require ( \"./nami.js\" ) ; var nami = new namiLib . Nami ( namiConfig ) ; nami . on ( 'namiConnected' , function ( event ) { nami . send ( new namiLib . Actions . CoreShowChannelsAction ( ) , function ( response ) { logger . debug ( ' ---- Response: ' + util . inspect ( response ) ) ; } ) ; } ) ;", "del_tokens": "var nami = new ( require ( \"./nami.js\" ) . Nami ) ( namiConfig ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "method", "for", "starting", "async", "functions"], "add_tokens": "import { awaitable , start } from '../lib' ; describe ( 'sync start' , function ( ) { it ( 'should let you set up the first await after starting the async function' , async function ( ) { const log = awaitable ( ) ; const result = start ( ( ) => doSomethingMoreComplexAsync ( log ) ) ; await log . calledWith ( 'hello' ) ; await log . calledWith ( 'bye' ) ; return await result ; } ) ; } ) ; } async function doSomethingMoreComplexAsync ( log ) { log ( 'hello' ) ; await Promise . resolve ( ) ; log ( 'bye' ) ; return 50 ;", "del_tokens": "import { awaitable } from '../lib' ;", "commit_type": "add"}
{"commit_tokens": ["allow", "config", "to", "be", "updated", "between", "requests"], "add_tokens": "var resolved = _ . omit ( requestClauses , \"untils\" , \"nevers\" , \"expectations\" ) ; config : that . _config , return doUpload ( actor . jar , req , reqClauses . config ) ; return doRequest ( actor . jar , req , reqConfig ( reqClauses . config ) ) ;", "del_tokens": "var resolved = _ . pick ( requestClauses , \"log\" , \"timeout\" ) ; return doUpload ( actor . jar , req , that . _config ) ; return doRequest ( actor . jar , req , reqConfig ( that . _config ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["add", "bower", "components", "inside", "gruntFile"], "add_tokens": "'bower_components/jquery/jquery.min.js' , 'bower_components/angular/angular.min.js' , 'bower_components/bootstrap/docs/assets/js/bootstrap.min.js' , 'bower_components/momentjs/min/moment.min.js' , 'bower_components/momentjs/min/locales.min.js' , 'bower_components/humanize-duration/humanize-duration.js' , 'app/**/*.js'", "del_tokens": "'app/**/*.js'", "commit_type": "add"}
{"commit_tokens": ["Created", "exports", ".", "js", "to", "hold", "the", "public", "exports", "that", "are", "common", "between", "Node", "and", "browser"], "add_tokens": "module . exports = require ( './exports' ) ;", "del_tokens": "var jsonSchemaLib = require ( './api' ) ; var promiseConfig = require ( './plugins/promiseConfig' ) ; var readAsyncMethod = require ( './plugins/readAsyncMethod' ) ; var readSyncMethod = require ( './plugins/readSyncMethod' ) ; module . exports = jsonSchemaLib ; // Load the default plugins for web browsers jsonSchemaLib . use ( promiseConfig ) ; jsonSchemaLib . use ( readAsyncMethod ) ; jsonSchemaLib . use ( readSyncMethod ) ;", "commit_type": "create"}
{"commit_tokens": ["Using", "async", "to", "clean", "up", "the", "code"], "add_tokens": "newTags : function ( ) { var self = this ; function process ( tag , next ) { var model = App . tags . create ( tag ) ; model . on ( 'sync' , function ( ) { self . updateTag ( model ) ; next ( ) ; async . forEach ( this . newTags ( ) , process , this . commit . bind ( this ) ) ;", "del_tokens": "newTag : function ( ) { var self = this , saved = 0 , unsaved = this . newTag ( ) ; if ( unsaved . length > 0 ) { _ . each ( unsaved , function ( tag , index , tags ) { var model = App . tags . create ( tag ) ; model . on ( 'sync' , function ( ) { saved += 1 ; self . updateTag ( model ) ; if ( saved === tags . length ) { self . commit ( ) ; } } ) ; } else { this . commit ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Move", "built", "-", "in", "to", "maha", "directory", "move", "in", "partial", "functions"], "add_tokens": "const globfs = require ( 'globfs' ) ; const ejs = require ( 'ejs' ) ; // TBD configuration for partialDirs var partialFound = yield globfs . findAsync ( module . exports . configuration . partialDirs , fname ) ; if ( ! partialFound ) throw new Error ( ` ${ fname } ` ) ; // Pick the first partial found partialFound = partialFound [ 0 ] ; var partialFname = path . join ( partialFound . basedir , partialFound . path ) ; var partialText = yield fs . readFile ( partialFname , 'utf8' ) ; // TBD based on file extension render through a template engine // TBD Need support for a broader spectrum of template engines dirty ( ) ; if ( / \\.ejs$ / i . test ( partialFname ) ) { try { return ejs . render ( partialText , d ) ; } catch ( e ) { throw new Error ( ` ${ fname } ${ e } ` ) ; } } else if ( / \\.html$ / i . test ( partialFname ) ) { // NOTE: The partialBody gets lost in this case return partialText ; } else { throw new Error ( \"No rendering support for ${fname}\" ) ; } / * if (module.exports.configuration.renderPartial) { } * /", "del_tokens": "if ( module . exports . configuration . renderPartial ) { }", "commit_type": "move"}
{"commit_tokens": ["Add", "support", "for", "rendering", "to", "different", "height", "and", "width"], "add_tokens": "* @ param geoJson the geoJson object to render * @ param height the height in A - Frame units * @ param width the width in A - Frame units renderGeoJson : function ( geoJson , height , width ) { var projection = projectionLib . getFittedProjection ( 'geoIdentity' , geoJson , height , width ) ;", "del_tokens": "* @ param geoJson renderGeoJson : function ( geoJson ) { var projection = projectionLib . getFittedProjection ( 'geoIdentity' , geoJson , 10 , 10 ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "more", "tests", "for", "getConfig", "method"], "add_tokens": "\"getConfig – error with empty object\": f nction( t st ) { \"getConfig – error with incorrect config\": f nction( t st ) { \"getConfig – with inline options\": f nction( t st ) { var config = new JSCS ( { requireCurlyBraces : [ \"if\" ] , config : \"config\" , force : true , reporterOutput : \"reporterOutput\" , reporter : \"\" } ) . getConfig ( ) ; test . ok ( ! config . config , \"config option should be removed\" ) ; test . ok ( ! config . force , \"force option should be removed\" ) ; test . ok ( ! config . reporterOuput , \"reporterOuput option should be removed\" ) ; test . ok ( ! config . reporter , \"reporter option should be removed\" ) ; test . ok ( ! ! config . requireCurlyBraces , \"requireCurlyBraces should stay\" ) ; test . done ( ) ; } , \"getConfig – merge inline and config options\": f nction( t st ) { var config = new JSCS ( { requireCurlyBraces : [ \"if\" ] , config : \"merge.json\" , disallowMultipleVarDecl : true } ) . getConfig ( ) ; test . equal ( config . requireCurlyBraces [ 0 ] , \"if\" , \"inline option should rewrite config one\" ) ; test . ok ( config . disallowMultipleVarDecl , \"\\\"disallowMultipleVarDecl\\\" option should be present\" ) ; test . done ( ) ; } , \"testAdditionalRules\" : true , config : \"empty\"", "del_tokens": "\"getConfig error with empty object\" : function ( test ) { \"getConfig error with incorrect config\" : function ( test ) { \"testAdditionalRules\" : true", "commit_type": "add"}
{"commit_tokens": ["change", "name", "of", "functions", "moveToBack", "moveFront", "etc"], "add_tokens": "JSYG . prototype . moveBackwards = function ( ) { JSYG . prototype . moveBack = function ( ) { JSYG . prototype . moveForwards = function ( ) { JSYG . prototype . moveFront = function ( ) {", "del_tokens": "JSYG . prototype . moveBack = function ( ) { JSYG . prototype . moveToBack = function ( ) { JSYG . prototype . moveFront = function ( ) { JSYG . prototype . moveToFront = function ( ) {", "commit_type": "change"}
{"commit_tokens": ["Add", "inline", "-", "ability", "to", "Text", "components"], "add_tokens": "const style = { inlineTextFlow : css ( { marginRight : '1ch' } ) } /* eslint-disable sort-keys */ trafalgar : 3 , body : null , // NO-OP longPrimer : - 1 , brevier : - 2 , minion : - 3 /* eslint-enable sort-keys */ { as , children , className , inline , size , ... props } , let inlineClassName if ( ! as && inline ) { as = 'span' } if ( inline ) { inlineClassName = style . inlineTextFlow } < Bit as = { as } className = { css ( inlineClassName , className , typeClassName ) } { ... props } > Text . defaultProps = { inline : true } className : PropTypes . object , inline : PropTypes . bool ,", "del_tokens": "body : null , // NO-OP brevier : - 2 , longPrimer : - 1 , minion : - 3 , trafalgar : 3 { as , children , size , ... props } , < Bit as = { as } className = { typeClassName } { ... props } >", "commit_type": "add"}
{"commit_tokens": ["Add", "intial", "DB", "query", "function"], "add_tokens": "* @ param { string = } statusId Right Track Stop Status ID * @ param { int = } transferWeight Right Track Stop Transfer Weight url = \"\" , wheelchairBoarding = Stop . WHEELCHAIR_BOARDING_UNKNOWN , statusId = \"-1\" , transferWeight = 1 ) { this . statusID = statusId ; this . transferWeight = transferWeight ; if ( a . transferWeight > b . transferWeight ) { else if ( a . transferWeight < b . transferWeight ) {", "del_tokens": "* @ param { string = } rtStatusId Right Track Stop Status ID * @ param { int = } rtTransferWeight Right Track Stop Transfer Weight url = undefined , wheelchairBoarding = Stop . WHEELCHAIR_BOARDING_UNKNOWN , rtStatusId = \"-1\" , rtTransferWeight = 1 ) { this . rtStatusId = rtStatusId ; this . rtTransferWeight = rtTransferWeight ; if ( a . rtTransferWeight > b . rtTransferWeight ) { else if ( a . rtTransferWeight < b . rtTransferWeight ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "middleware", "()", "function", "for", "creating", "custom", "routes"], "add_tokens": "app = _app ; locals = require ( './poet/locals' ) ( app , options , storage ) ; routeFns = require ( './poet/routes' ) ( options , storage ) ; refs = require ( './poet/references' ) ( options , storage ) ; utils = require ( './poet/utils' ) ; function returnMiddleware ( ) { return require ( './poet/middleware' ) ( options , storage ) ; } exports . middleware = returnMiddleware ;", "del_tokens": "app = _app ; locals = require ( './poet/locals' ) ( app , options , storage ) ; routeFns = require ( './poet/routes' ) ( options , storage ) ; refs = require ( './poet/references' ) ( options , storage ) ; utils = require ( './poet/utils' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "issue", "with", "YB", "adapter", "not", "sending", "no", "bid", "response", "."], "add_tokens": "bid = bidfactory . createBid ( ybotlib . BID_STATUS . EMPTY ) ;", "del_tokens": "bid = bidfactory . createBid ( BID_STATUS . EMPTY ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "directories", "friendlier", "to", "an", "alpha", "release", "."], "add_tokens": ". concat ( [ \"../../elm-test/src/\" ] ) ;", "del_tokens": ". concat ( [ \"/Users/rtfeldman/code/elm-test/src/\" ] ) ;", "commit_type": "make"}
{"commit_tokens": ["Fixing", "some", "minor", "code", "style", "issues", "in", "the", "runtime", "."], "add_tokens": "var context = new Context ( ) ; do { var value = innerFn . call ( self , context ) ; } while ( value === ContinueSentinel ) ; while ( ( tempName = \"t\" + tempIndex ) && ( tempIndex < 20 || hasOwn . call ( this , tempName ) ) ) {", "del_tokens": "var context = new Context ; do var value = innerFn . call ( self , context ) ; while ( value === ContinueSentinel ) ; while ( tempName = \"t\" + tempIndex , // N.B. Comma operator! tempIndex < 20 || hasOwn . call ( this , tempName ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "an", "error", "in", "the", "lint", "script"], "add_tokens": "exec ( ` ${ name } ${ name } ` ) ;", "del_tokens": "exec ( ` ${ name } ${ name } ` ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "--", "version", "option", "in", "cli", "."], "add_tokens": ", fs = require ( 'fs' ) if ( argv . version ) { console . log ( \"intervals v\" + JSON . parse ( fs . readFileSync ( __dirname + '/../package.json' ) ) . version ) ; } else { processTime ( value . token ) ; }", "del_tokens": "processTime ( value . token ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "default", "environment", "to", "development"], "add_tokens": "process . env . NODE_ENV = 'development' ;", "del_tokens": "process . env . NODE_ENV = 'production' ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "wrong", "usage", "of", "grunt", "-", "browserify", "due", "to", "change", "from", "1", ".", "x", "to", "2", ".", "x"], "add_tokens": "bundleOptions : { standalone : '<%= pkg.name %>' } src : [ 'test/browser_suite.js' ] , bundleOptions : { // Embed source map for tests debug : true }", "del_tokens": "standalone : '<%= pkg.name %>' src : [ 'browser/test/suite.js' ] , // Embed source map for tests debug : true", "commit_type": "fix"}
{"commit_tokens": ["Added", "pointSize", "property", ";", "Added", "support", "for", "custom", "fn", "for", "drawing", "points"], "add_tokens": "if ( typeof pointType === 'function' ) { return pointType . call ( this , cx , cy ) ; } throw new Error ( 'Unknown ' + pointType + ' point type!' ) ; return this . nested . circle ( this . options . pointSize ) return this . nested . rect ( this . options . pointSize , this . options . pointSize ) pointSize : 7 , // size of point", "del_tokens": "throw 'Unknown ' + pointType + ' point type!' return this . nested . circle ( this . options . radius ) return this . nested . rect ( this . options . rectSize , this . options . rectSize ) radius : 7 , // radius of the points, only for pointType: 'circle' rectSize : 8 , // size of rect points, only for pointType: 'rect'", "commit_type": "add"}
{"commit_tokens": ["add", "options", ".", "hardlinks", "boolean", "for", "treating", "hardlinks", "as", "Link", "or", "File"], "add_tokens": "var handleHardlinks = props . hardlinks !== false if ( handleHardlinks && type !== \"Directory\" && props . nlink && props . nlink > 1 ) {", "del_tokens": "if ( type !== \"Directory\" && props . nlink && props . nlink > 1 ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "order", "of", "operations", "in", "calculating", "if", "inNode"], "add_tokens": "var inNode = typeof ( process ) !== 'undefined' && process . title === 'node' ; opts = _ . defaults ( opts || { } , { inNode : inNode } ) ; this . inNode = opts . inNode ;", "del_tokens": "inNode : typeof ( process ) !== 'undefined' && process . title === 'node' this . inNode = opts . inNode ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "enchancements", "suggested", ".", "See", "changelog"], "add_tokens": "failAsserts : [ ] , tap . on ( 'fail' , assert => { testCase . failAsserts . push ( assert ) ; if ( parsedArgs . output ) { return writeOutput ( xmlString , ( output . fail . length === 0 ) ) ; } return process . stdout . write ( ` ${ xmlString } \\n ` ) ;", "del_tokens": "tap . on ( 'fail' , ( ) => { writeOutput ( xmlString , ( output . fail . length === 0 ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "missing", "reset", "total", "rows", "and", "columns"], "add_tokens": "runtime . totalCol = 0 ; runtime . totalRow = 0 ; totalRow : 0 ,", "del_tokens": "totalRow : 1 ,", "commit_type": "add"}
{"commit_tokens": ["Remove", "express", "and", "clean", "up", "."], "add_tokens": "* process . on ( \"uncaughtException\" , winMid . uncaught ( { // Try real logger. . addError ( err ) // Else, give up and use straight console logging. uncaught : middleware . uncaught ,", "del_tokens": "* app . use ( winMid . error ( { . addErr ( err )", "commit_type": "remove"}
{"commit_tokens": ["Added", "queue", "and", "interface", "(", "required", ")", "parameter", "to", "QueueRemove"], "add_tokens": "function QueueRemove ( queue , interface ) { this . set ( 'queue' , queue ) ; this . set ( 'interface' , interface ) ;", "del_tokens": "function QueueRemove ( ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "PostCSS", "parser", "in", "testing", "to", "assert", "against", "AST"], "add_tokens": "return postcss . parse ( result . css ) ;", "del_tokens": "import css from 'css' ; return css . parse ( result . css ) . stylesheet ;", "commit_type": "use"}
{"commit_tokens": ["fixing", "the", "aug", "code", "formatting", "screw", "ups"], "add_tokens": "path = ~ path . indexOf ( ':' ) ? path : 'prefix:' + path var parts = path . split ( ':' ) seneca . act ( 'role:user,cmd:login,auto:true,nick:' + nick , function ( err , out ) { urlhost : 'http://127.0.0.1:3333'", "del_tokens": "path = ~ path . indexOf ( ': ' ) ? path : 'prefix: ' + path var parts = path . split ( ': ' ) seneca . act ( 'role: user, cmd: login, auto: true, nick: ' + nick , function ( err , out ) { urlhost : 'http: //127.0.0.1: 3333'", "commit_type": "fix"}
{"commit_tokens": ["update", "crypto", "-", "encodeAddress", "update", "to", "use", "type", "instead", "option", "field"], "add_tokens": "cxo . encodeAddress = ( address , type ) => { if ( type === 1 ) suffix = _AC_ADDR_PREFIX ; else if ( type === 2 ) suffix = _VA_ADDR_PREFIX ;", "del_tokens": "cxo . encodeAddress = ( address , option ) => { if ( option . asAc ) suffix = _AC_ADDR_PREFIX ; else if ( option . asVa ) suffix = _VA_ADDR_PREFIX ;", "commit_type": "update"}
{"commit_tokens": ["Add", "a", "test", "about", "options", "when", "pipe", "into", "postcss"], "add_tokens": "expect ( expected ) . toBe ( 'a { width: 32px; width: 2rem }' ) ; } ) ; it ( 'should expose processor and allow options' , function ( ) { var expected = postcss ( ) . use ( pixrem ( '10px' , { replace : true } ) ) . process ( 'a { width: 2rem }' ) . css ; expect ( expected ) . toBe ( 'a { width: 20px }' ) ; } ) ;", "del_tokens": "expect ( 'a { width: 32px; width: 2rem }' ) . toBe ( expected ) ; } )", "commit_type": "add"}
{"commit_tokens": ["Added", "serviceworker", "-", "cache", "-", "polyfill", ".", "Cache", "offline", "message", "on", "serviceworker", "install", ".", "Concatenate", "polyfill", "script", "to", "serviceworker", "script", "."], "add_tokens": "'dist/upup.sw.min.js' : [ 'src/vendor/serviceworker-cache-polyfill.js' , 'src/upup.sw.js' ] ,", "del_tokens": "'dist/upup.sw.min.js' : [ 'src/upup.sw.js' ] ,", "commit_type": "add"}
{"commit_tokens": ["Added", "autoprefixer", "and", "reintroduced", "browserslist", "."], "add_tokens": "import autoprefixer from \"autoprefixer\" ; autoprefixer ( ) ,", "del_tokens": "browserslist : false ,", "commit_type": "add"}
{"commit_tokens": ["Adding", "grunt", "multitask", "support", "with", "a", "grunt", "integration", "test"], "add_tokens": "grunt . registerMultiTask ( 'devserver' , 'Start a static web server.' , devServerTask ) ; , done = this . async ( ) , promise = startServer ( options ) promise . then ( onServerStarted ) function onServerStarted ( ) { if ( options . async === false ) done ( ) } return promise", "del_tokens": "grunt . registerTask ( 'devserver' , 'Start a static web server.' , devServerTask ) ; if ( ! options . hasOwnProperty ( 'async' ) || options . async === true ) this . async ( ) return startServer ( options )", "commit_type": "add"}
{"commit_tokens": ["improved", "the", "story", "with", "bindings", "value", "-", "producing", "expressions", "semantic", "action", "formals", "etc"], "add_tokens": "b . inline ( 'space-singleLine' , b . seq ( b . _ ( '//' ) , b . many ( b . seq ( b . not ( b . _ ( '\\n' ) ) , b . app ( '_' ) ) , 0 ) , b . _ ( '\\n' ) ) ) b . inline ( 'space-multiLine' , b . seq ( b . _ ( '/*' ) , b . many ( b . seq ( b . not ( b . _ ( '*/' ) ) , b . app ( '_' ) ) , 0 ) , b . _ ( '*/' ) ) ) b . extend ( 'space' , b . alt ( b . app ( 'space-singleLine' ) , b . app ( 'space-multiLine' ) ) )", "del_tokens": "b . extend ( 'space' , b . alt ( b . seq ( b . _ ( '//' ) , b . many ( b . seq ( b . not ( b . _ ( '\\n' ) ) , b . app ( '_' ) ) , 0 ) , b . _ ( '\\n' ) ) , b . seq ( b . _ ( '/*' ) , b . many ( b . seq ( b . not ( b . _ ( '*/' ) ) , b . app ( '_' ) ) , 0 ) , b . _ ( '*/' ) ) ) )", "commit_type": "improve"}
{"commit_tokens": ["Use", "the", "beautified", "lib", "while", "debugging"], "add_tokens": "required . utilx = require ( '../lib/util-x' ) ; //required.utilx = require('../lib/util-x.min');", "del_tokens": "required . utilx = require ( '../lib/util-x.min' ) ;", "commit_type": "use"}
{"commit_tokens": ["fixed", "ctrl", "+", "c", "event"], "add_tokens": "// filter $ node.. o $ geena with or without env //process.argv.splice(1,2); var env ; //if (process.argv[0] == 'node') { // env = ( typeof(process.argv[1]) != 'undefined') ? process.argv[1].toLowerCase() : 'prod'; //} else { env = ( typeof ( process . argv [ 2 ] ) != 'undefined' ) ? process . argv [ 2 ] . toLowerCase ( ) : 'prod' ; //} callback ( 'Found no release to mount for: ' , source ) ; //path = ( process.argv[0] == 'node' ) ? process.argv[2] : process.argv[1]; path = process . argv [ 1 ] ; //path = ( process.argv[0] == 'node' ) ? process.argv[2] : process.argv[1]; var tmpSource = _ ( bundlesPath + '/' + core . startingApp ) ;", "del_tokens": "var env = ( typeof ( process . argv [ 2 ] ) != 'undefined' ) ? process . argv [ 2 ] . toLowerCase ( ) : 'prod' ; callback ( 'No release was found to mount for: ' , source ) ; path = process . argv [ 1 ] var tmpSource = _ ( bundlesPath + '/' + core . startingApp ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "version", "of", "selenium", "standalone"], "add_tokens": "version : '2.42.2' ,", "del_tokens": "version : '2.42.0' ,", "commit_type": "update"}
{"commit_tokens": ["Changed", "break", "down", "of", "Packet", "test", "."], "add_tokens": "'Packet can read' : { 'a byte from a buffer' : function ( topic ) { 'a 16 bit number from a buffer' : function ( topic ) { 'a 16 bit big-endian number from a buffer' : function ( topic ) { 'a 16 bit litte-endian number from a buffer' : function ( topic ) { 'a signed byte from a buffer' : function ( topic ) { 'a signed short from a buffer' : function ( topic ) { 'a little-endian 32 bit hex string from a buffer' : function ( topic ) { 'a big-endian 32 bit hex string from a buffer' : function ( topic ) { 'a 64 bit float from a buffer' : function ( topic ) {", "del_tokens": "'Packet can' : { 'read a byte from a buffer' : function ( topic ) { 'read a 16 bit number from a buffer' : function ( topic ) { 'read a 16 bit big-endian number from a buffer' : function ( topic ) { 'read a 16 bit litte-endian number from a buffer' : function ( topic ) { 'read a signed byte from a buffer' : function ( topic ) { 'read a signed short from a buffer' : function ( topic ) { 'read a little-endian 32 bit hex string from a buffer' : function ( topic ) { 'read a big-endian 32 bit hex string from a buffer' : function ( topic ) { 'read a 64 bit float from a buffer' : function ( topic ) {", "commit_type": "change"}
{"commit_tokens": ["Allow", "zero", "as", "valid", "segment", "name"], "add_tokens": "if ( identifier === undefined || identifier === null || identifier . length === 0 ) { identifier = \"default\" ; }", "del_tokens": "identifier = identifier || \"default\" ;", "commit_type": "allow"}
{"commit_tokens": ["Changed", "default", "to", "saving", "bundles", "in", "the", "main", "staticbuild", ".", "json", "file", "instead", "of", "a", "separate", "file", "."], "add_tokens": "this . bundlefile = '' ; else if ( istype ( 'String' , data . bundlefile ) ) { build . bundlefile = data . bundlefile . trim ( ) ; if ( build . bundlefile . length > 0 ) { build . bundlefilepath = path . resolve ( build . basedir , build . bundlefile ) ; if ( build . bundlefile ) {", "del_tokens": "this . bundlefile = 'staticbuild.bundles.json' ; if ( istype ( 'String' , data . bundlefile ) ) build . bundlefile = data . bundlefile ; if ( build . bundlefile . length > 0 ) { build . bundlefilepath = path . resolve ( build . basedir , build . bundlefile ) ; if ( build . bundlefile !== build . filename ) { if ( build . bundlefilepath ) {", "commit_type": "change"}
{"commit_tokens": ["Removed", "adaptive", "bitrate", "video", "example"], "add_tokens": "window . addEventListener ( 'load' , onLoad ) ;", "del_tokens": "window . addEventListener ( 'load' , onLoad ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "mobile", "to", "HTML", "s", "class", "list", "."], "add_tokens": "this . _iniHtmlClass ( ) ; _iniHtmlClass : function ( ) { //set css hook on html element. var ua = _ . ua ; ua . isWebKit ? 'webkit' : '' , ua . isSafari ? 'safari' : '' , ua . isChrome ? 'chrome' : '' , ua . isMoz ? 'moz' : '' , ua . isIOS ? 'ios' : '' , ua . isAndroid ? 'android android-' + ( _ . str . toFloat ( ua . version ) >= 4 ? 'high' : 'low' ) : '' , ua . isTouchDevice ? 'touch' : 'mouse' , ua . isMobileDevice ? 'mobile ' + ua . mobileDeviceType : 'desktop' //or 'phone', 'pad'", "del_tokens": "this . iniHtmlClass ( ) ; iniHtmlClass : function ( ) { //set css hook on html element. _ . ua . isWebKit ? 'webkit' : '' , _ . ua . isSafari ? 'safari' : '' , _ . ua . isChrome ? 'chrome' : '' , _ . ua . isMoz ? 'moz' : '' , _ . ua . isIOS ? 'ios' : '' , _ . ua . isAndroid ? 'android android-' + ( _ . str . toFloat ( _ . ua . version ) >= 4 ? 'high' : 'low' ) : '' , _ . ua . isTouchDevice ? 'touch' : 'mouse' , _ . ua . mobileDeviceType || 'desktop' //or 'phone', 'pad'", "commit_type": "add"}
{"commit_tokens": ["Change", "self", "back", "to", "this"], "add_tokens": "this . columns . add ( column , options ) ; return this ; this . columns . remove ( column , options ) ; return this ;", "del_tokens": "var self = this ; self . columns . add ( column , options ) ; return self ; var self = this ; self . columns . remove ( column , options ) ; return self ;", "commit_type": "change"}
{"commit_tokens": ["adding", "integration", "tests", "to", "task", ".", "test"], "add_tokens": "// function for running one of the tests function runTest ( targetCode , testCode , done ) { gulp . src ( targetCode ) gulp . src ( testCode ) gulp . src ( testCode ) } return { integration : function ( done ) { runTest ( opts . intTargetCode , opts . intTestCode , done ) ; } , 'default' : function ( done ) { runTest ( opts . unitTargetCode , opts . unitTestCode , done ) ; } } ;", "del_tokens": "return function ( done ) { gulp . src ( opts . unitTargetCode ) gulp . src ( opts . unitTestCode ) gulp . src ( opts . unitTestCode ) } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "case", "where", "the", "first", "letter", "is", "not", "an", "uppercased", "letter"], "add_tokens": "_ = require ( 'lodash' ) , return ` ${ _ . upperFirst ( entityName ) } ` ;", "del_tokens": "return ` ${ entityName } ` ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "event", "trigger", "logic"], "add_tokens": "/ ** var events = this . events || { } ; if ( events . hasOwnProperty ( eventName ) === false ) { return this ; }", "del_tokens": "/ ** var events = this . events = this . events || { } ; events [ eventName ] = events [ eventName ] || [ ] ;", "commit_type": "fix"}
{"commit_tokens": ["Allowing", "users", "to", "override", "the", "used", "xhr", "object", "."], "add_tokens": "var xhr = this . xhrProvider ( ) ; / ** * Returns an XMLHttpRequest object . * * This is in its own method , so it can be easily overridden . * * @ return { XMLHttpRequest } * / xhrProvider : function ( ) { var xhr = new XMLHttpRequest ( ) ; } ,", "del_tokens": "var xhr = new XMLHttpRequest ( ) ;", "commit_type": "allow"}
{"commit_tokens": ["Moved", "from", "UMD", "to", "CommonJS"], "add_tokens": "\"use strict\" ; Object . defineProperty ( exports , \"__esModule\" , { value : true } ) ; const Iterables = require ( \"./iterable/operators\" ) ; exports . Iterables = Iterables ; const Generators = require ( \"./iterable/generators\" ) ; exports . Generators = Generators ; const pipe_1 = require ( \"./pipe\" ) ; exports . $$ = pipe_1 . $$ ;", "del_tokens": "( function ( factory ) { if ( typeof module === \"object\" && typeof module . exports === \"object\" ) { var v = factory ( require , exports ) ; if ( v !== undefined ) module . exports = v ; } else if ( typeof define === \"function\" && define . amd ) { define ( [ \"require\" , \"exports\" , \"./iterable/operators\" , \"./iterable/generators\" , \"./pipe\" ] , factory ) ; } } ) ( function ( require , exports ) { \"use strict\" ; Object . defineProperty ( exports , \"__esModule\" , { value : true } ) ; const Iterables = require ( \"./iterable/operators\" ) ; exports . Iterables = Iterables ; const Generators = require ( \"./iterable/generators\" ) ; exports . Generators = Generators ; const pipe_1 = require ( \"./pipe\" ) ; exports . $$ = pipe_1 . $$ ; } ) ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "@param", "named", "comment", "handling", "."], "add_tokens": "options = { name : options } ;", "del_tokens": "options = { name : options } ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "iwconfig", ".", "status", "(", "[", "interface", "]", "callback", ")"], "add_tokens": "ifconfig : require ( './ifconfig' ) , iwconfig : require ( './iwconfig' )", "del_tokens": "ifconfig : require ( './ifconfig' )", "commit_type": "add"}
{"commit_tokens": ["Allow", "to", "export", "CSV", "without", "separator", "identifier"], "add_tokens": "separator : ',' , withSeparator : true if ( options . withSeparator ) { // add separator identifier; str += ` ${ options . separator } \\r \\n ` ; }", "del_tokens": "separator : ',' // add separator identifier; str += ` ${ options . separator } \\r \\n ` ;", "commit_type": "allow"}
{"commit_tokens": ["move", "walk", "into", "separate", "file"], "add_tokens": "var util = require ( './util' ) ; util . walk ( modulePath ( this . name , 'server' ) , 'models' , null , function ( model ) { util . walk ( modulePath ( this . name , 'server' ) , 'routes' , 'middlewares' , function ( route ) {", "del_tokens": "walk ( modulePath ( this . name , 'server' ) , 'models' , null , function ( model ) { walk ( modulePath ( this . name , 'server' ) , 'routes' , 'middlewares' , function ( route ) { // copied from mean/config/util.js // potential to merge with functions in aggregate() function walk ( wpath , type , excludeDir , callback ) { wpath = path . join ( wpath , type ) ; if ( ! fs . existsSync ( wpath ) ) return ; fs . readdirSync ( wpath ) . forEach ( function ( file ) { var newPath = wpath + '/' + file ; var stat = fs . statSync ( newPath ) ; if ( stat . isFile ( ) && / (.*)\\.(js|coffee)$ / . test ( file ) ) { callback ( newPath ) ; } else if ( stat . isDirectory ( ) && file !== excludeDir ) { walk ( newPath , excludeDir , callback ) ; } } ) ; }", "commit_type": "move"}
{"commit_tokens": ["Fix", "type", "error", "check", ".", "Turn", "strict", "mode", "back", "on"], "add_tokens": "'use strict' ;", "del_tokens": "//'use strict'; for ( var rule in ruleObj . required_instructions ) { if ( ruleObj . required_instructions . hasOwnProperty ( rule ) ) { rule . exists = false ; } }", "commit_type": "fix"}
{"commit_tokens": ["added", "test", "for", "when", "interceptor", "gets", "string", "response"], "add_tokens": "inject ( function ( _SpringDataRestAdapter_ , $httpBackend , _$http_ ) { $http = _$http_ ; it ( \" it must not execute when a response is of type string\" , function ( ) { var linkHref = \"http://localhost:8080/categories\" ; var responseString = \"<html>test</html>\" ; this . httpBackend . whenGET ( linkHref ) . respond ( 200 , responseString ) ; this . httpBackend . expectGET ( linkHref ) ; var data = $http . get ( linkHref ) . then ( function ( response ) { data = response . data ; } ) ; this . httpBackend . flush ( ) ; expect ( data ) . toBe ( responseString ) ; } ) ;", "del_tokens": "inject ( function ( _SpringDataRestAdapter_ , $httpBackend ) {", "commit_type": "add"}
{"commit_tokens": ["Remove", "phantom", "activity", "(", "replaced", "by", "webdriver", ")", "deathbycaptcha", "in", "a", "npm", "package"], "add_tokens": "exports . username = \"neyric\" ; exports . password = 'xxxxxxxxx' ;", "del_tokens": "exports . CAPTCHA_FILE = 'captcha_sdfqdf.jpg' ; exports . USERNAME = \"neyric\" ; exports . PASSWORD = 'xxxxxxxxx' ;", "commit_type": "remove"}
{"commit_tokens": ["removing", "bower", "vendor", "folder", "and", "testing", "travis"], "add_tokens": "'node_modules/angular/angular.js' , 'node_modules/angular-mocks/angular-mocks.js'", "del_tokens": "'vendor/angular/angular.js' , 'vendor/angular-mocks/angular-mocks.js'", "commit_type": "remove"}
{"commit_tokens": ["updating", "test", "for", "default", "routes"], "add_tokens": "this . route ( / .* / , function ( value , key , next ) {", "del_tokens": "this . route ( '*' , function ( value , key , next ) {", "commit_type": "update"}
{"commit_tokens": ["Fixed", ":", "function", ".", "name", "is", "read", "-", "only", "now"], "add_tokens": "* @ version 0.1 .5", "del_tokens": "* @ version 0.1 .4 CustomError . name = name ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "babel", "support", "and", "update", "test", "cases"], "add_tokens": "const wget = require ( './lib/wget' ) ; module . exports = wget ;", "del_tokens": "import { download } from './lib/wget' ; export default download ;", "commit_type": "remove"}
{"commit_tokens": ["use", "checkType", "and", "quadtile", "index"], "add_tokens": "qidx = require ( 'quadtile-index' ) , checkType = require ( 'kartotherian-input-validator' ) , params . x = checkType . strToInt ( params . x ) ; params . y = checkType . strToInt ( params . y ) ; if ( ! qidx . isValidCoordinate ( params . x , params . z ) || ! qidx . isValidCoordinate ( params . y , params . z ) ) {", "del_tokens": "params . x = core . strToInt ( params . x ) ; params . y = core . strToInt ( params . y ) ; if ( ! core . isValidCoordinate ( params . x , params . z ) || ! core . isValidCoordinate ( params . y , params . z ) ) {", "commit_type": "use"}
{"commit_tokens": ["fixes", "handling", "of", "tenantOrga", "when", "assigning", "server", "options"], "add_tokens": "return _ . assignWith ( this . options , serverInitOptions , function ( left , right ) { return _ . isUndefined ( left ) ? right : left ; } ) ;", "del_tokens": "return _ . assign ( this . options , serverInitOptions ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "chai", "and", "removed", "unit", "from", "the", "node", "modules", "added", "uniqueID", "function", "to", "clipPath", "added", "an", "index", ".", "html", "file", "to", "testing", "framework"], "add_tokens": "var id = uniqueID ( ) ; var width = 50 ; var height = 50 ; function uniqueID ( ) { var randomNumber = Math . floor ( Math . random * 100 ) ; return \"uniqueId_\" + randomNumber ; }", "del_tokens": "var id = \"uniqueID\" ; var width = null ; var height = null ;", "commit_type": "add"}
{"commit_tokens": ["add", "test", "is", "-", "exists"], "add_tokens": "} ;", "del_tokens": "} ; var path = 'z:/workspaces/qiao.plugin.coder/lib/qiao.plugin.coder.js' ; var s = exports . isExists ( path ) ; console . log ( s ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "documentElement", ".", "contains", "()"], "add_tokens": "if ( ! el . ownerDocument . documentElement . contains ( el ) ) {", "del_tokens": "if ( ! el . ownerDocument . contains ( el ) ) {", "commit_type": "use"}
{"commit_tokens": ["Use", "griddle", "instead", "of", "bundle", "for", "script", "name", "."], "add_tokens": "filename : 'build/griddle.js' ,", "del_tokens": "filename : 'build/bundle.js' ,", "commit_type": "use"}
{"commit_tokens": ["added", "support", "for", "reverse", "ordering"], "add_tokens": "options : \"=?\" , orderBy : \"@\" , reverseOrder : \"@\" '<li ng-repeat=\"node in node.' + $scope . options . nodeChildren + ' | orderBy:orderBy:reverseOrder\" ng-class=\"headClass(node)\" ' + classIfDefined ( $scope . options . injectClasses . li , true ) + '>' +", "del_tokens": "options : \"=?\" // orderBy clause (if any) for template var orderByClause = ( function ( ) { if ( angular . isDefined ( $scope . orderBy ) ) { return \" | orderBy:'\" + $scope . orderBy + \"'\" ; } else { return '' ; } } ) ( ) ; '<li ng-repeat=\"node in node.' + $scope . options . nodeChildren + orderByClause + '\" ng-class=\"headClass(node)\" ' + classIfDefined ( $scope . options . injectClasses . li , true ) + '>' +", "commit_type": "add"}
{"commit_tokens": ["Improving", "check", "for", "path", "condition", "."], "add_tokens": "callback ( result !== undefined ) ;", "del_tokens": "callback ( Boolean ( result ) ) ;", "commit_type": "improve"}
{"commit_tokens": ["using", "the", "new", "revamped", "soajs", "code", "base"], "add_tokens": "\"type\" : 'service' , \"prerequisites\" : { \"cpu\" : '' , \"memory\" : '' \"readiness\" : \"/heartbeat\" , \"port\" : { \"type\" : \"maintenance\" } , { \"label\" : \"Reload Provision\" , \"path\" : \"/loadProvision\" , \"icon\" : \"fas fa-download\" } , { \"label\" : \"Reload Registry\" , \"path\" : \"/reloadRegistry\" , \"icon\" : \"fas fa-undo\" } , { \"label\" : \"Resource Info\" , \"path\" : \"/resourceInfo\" , \"icon\" : \"fas fa-info\" } //------------------------------------- \"hashIterations\" : 12 ,", "del_tokens": "type : 'service' , prerequisites : { cpu : '' , memory : '' { \"label\" : \"Releoad Provision\" , \"path\" : \"/loadProvision\" , \"icon\" : \"provision\" } \"hashIterations\" : 1024 , \"seedLength\" : 32 ,", "commit_type": "use"}
{"commit_tokens": ["add", "namespaceConnector", "conf", "for", "isomorphic"], "add_tokens": "var namespaceConnector = conf . namespaceConnector || ':' ; if ( request . indexOf ( namespaceConnector ) === - 1 ) {", "del_tokens": "if ( request . indexOf ( ':' ) === - 1 ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "various", "issues", "discovered", "when", "attempting", "to", "run", "acceptance", "tests", "."], "add_tokens": "this . listHandler = defaultHandlers . doList ; this . createHandler = defaultHandlers . doCreate ; this . readHandler = defaultHandlers . doRead ; this . updateHandler = defaultHandlers . doUpdate ; this . deleteHandler = defaultHandlers . doDelete ; this . collisionHandler = defaultHandlers . handleCollision ; this . listCollisionsHandler = defaultHandlers . listCollisions ; this . removeCollisionHandler = defaultHandlers . removeCollision ;", "del_tokens": "this . listHandler = defaultHandlers . listHandler ; this . createHandler = defaultHandlers . createHandler ; this . readHandler = defaultHandlers . readHandler ; this . updateHandler = defaultHandlers . updateHandler ; this . deleteHandler = defaultHandlers . deleteHandler ; this . collisionHandler = defaultHandlers . collisionHandler ; this . listCollisionsHandler = defaultHandlers . listCollisionsHandler ; this . removeCollisionHandler = defaultHandlers . removeCollisionHandler ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "bug", "about", "number", "regexp", "pattern"], "add_tokens": "regNumber = new RegExp ( / ^[\\-\\+]?\\d+\\.?\\d+$ / ) ,", "del_tokens": "regNumber = new RegExp ( / ^[\\-\\+]?\\d+\\.?\\d*$ / ) ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "some", "transfer", "/", "recipient", "requests"], "add_tokens": "get ( \"/v1/recipients/\" + recipient_id , { } , cb ) ; del ( \"/v1/recipients/\" + recipient_id , { } , cb ) ; get ( \"/v1/transfers/\" + transfer_id , { } , cb ) ; post ( \"/v1/transfers/\" + transfer_id + \"/cancel\" , { } , cb ) ; get ( \"/v1/balance\" , { } , cb ) ;", "del_tokens": "get ( \"/v1/recipients/\" + recipient_id , cb ) ; del ( \"/v1/recipients/\" + recipient_id , cb ) ; get ( \"/v1/transfers/\" + transfer_id , cb ) ; post ( \"/v1/transfers/\" + transfer_id + \"/cancel\" , cb ) ; get ( \"/v1/balance\" , cb ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "ember", "-", "alpha", "to", "ember", "-", "try", "matrix", "(", "allowed", "to", "fail", ")"], "add_tokens": "useVersionCompatibility : true , scenarios : [ { name : 'ember-alpha' , allowedToFail : true , bower : { dependencies : { 'ember' : 'alpha' , } } } ]", "del_tokens": "useVersionCompatibility : true", "commit_type": "add"}
{"commit_tokens": ["Remove", "unused", "constants", "for", "types", "bitsyntax", "library"], "add_tokens": "var debug = require ( 'debug' ) ( 'amqp10-Codec' ) , * Build a codec .", "del_tokens": "var bitsyntax = require ( 'bitsyntax' ) , debug = require ( 'debug' ) ( 'amqp10-Codec' ) , * Build a codec , turning constants defining AMQP1 .0 types into specific bitsyntax parsers and builders .", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "the", "issue", "that", "downloading", "block", "blob", "with", "size", "bigger", "than", "32MB", "will", "fail", "when", "using", "anonymous", "credential", "."], "add_tokens": "leaseId : options . leaseId , blockListFilter : BlobUtilities . BlockListFilter . COMMITTED", "del_tokens": "leaseId : options . leaseId", "commit_type": "fix"}
{"commit_tokens": ["added", "app", "touch", "logs", "also", "get", "printed", "if", "provided", "-", "d"], "add_tokens": "app . stderr . on ( 'data' , onErrorData ) ; logger . touch ( data . toString ( ) ) ; } function onErrorData ( data ) { logger . touch ( data . toString ( ) ) ; app . stdout . removeListener ( 'data' , onData ) ; app . stderr . removeListener ( 'data' , onErrorData ) ;", "del_tokens": "app . removeListener ( 'data' , onData ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "to", "customize", "allign", "per", "column"], "add_tokens": "var options = Object ( arguments [ 1 ] ) , cols = [ ] , colsOptions = options . cols || [ ] ; var pad , align = 'left' , colOptions = colsOptions && colsOptions [ index ] ; align = ( colOptions && ( colOptions . align === 'right' ) ) ? 'right' : 'left' ; pad = repeat . call ( ' ' , cols [ index ] . width - item . length ) ; if ( align === 'left' ) return item . str + pad ; else return pad + item . str ;", "del_tokens": "var options = Object ( arguments [ 1 ] ) , cols = [ ] ; var pad = repeat . call ( ' ' , cols [ index ] . width - item . length ) ; return item . str + pad ;", "commit_type": "allow"}
{"commit_tokens": ["improving", "regex", "to", "no", "longer", "transform", "json", "files"], "add_tokens": "filePattern = filePattern || / \\.js$ / ;", "del_tokens": "filePattern = filePattern || / \\.js / ;", "commit_type": "improve"}
{"commit_tokens": ["Added", "a", "fallback", "to", "using", "$http", "if", "js", "-", "data", "-", "http", "isn", "t", "loaded", "."], "add_tokens": "'* @author Jason Dobry <jason.dobry@gmail.com>\\n' + '* @file js-data-angular.min.js\\n' + '* @version <%= pkg.version %> - Homepage <https://www.js-data.io/js-data-angular/>\\n' + '* @copyright (c) 2014 Jason Dobry <https://github.com/jmdobry/>\\n' + '* @license MIT <https://github.com/js-data/js-data-angular/blob/master/LICENSE>\\n' + '*\\n' + '* @overview Angular wrapper for js-data.\\n' + '*/\\n' } , karma : { options : { configFile : './karma.conf.js' } , dev : { browsers : [ 'Chrome' ] , autoWatch : true , singleRun : false , reporters : [ 'spec' ] , preprocessors : { } } , min : { browsers : [ 'Firefox' , 'PhantomJS' ] , options : { files : [ 'bower_components/angular-1.3.2/angular.js' , 'bower_components/angular-mocks-1.3.2/angular-mocks.js' , 'bower_components/js-data/dist/js-data.js' , 'dist/js-data-angular.min.js' , 'karma.start.js' , 'test/**/*.js' ] } } , ci : { browsers : [ 'Firefox' , 'PhantomJS' ] } } , coveralls : { options : { coverage_dir : 'coverage' } grunt . registerTask ( 'test' , [ 'build' , 'karma:min' ] ) ;", "del_tokens": "'* @author Jason Dobry <jason.dobry@gmail.com>\\n' + '* @file js-data-angular.min.js\\n' + '* @version <%= pkg.version %> - Homepage <https://www.js-data.io/js-data-angular/>\\n' + '* @copyright (c) 2014 Jason Dobry <https://github.com/jmdobry/>\\n' + '* @license MIT <https://github.com/js-data/js-data-angular/blob/master/LICENSE>\\n' + '*\\n' + '* @overview Angular wrapper for js-data.\\n' + '*/\\n'", "commit_type": "add"}
{"commit_tokens": ["add", "middleware", "via", "router", ".", "use", "()", "."], "add_tokens": "var connect = require ( 'connect' ) ; this . connect = connect ( ) ; Router . prototype . use = function ( middleware ) { this . connect . use ( middleware ) ; } ; req . detourHandler = resource ; router . use ( function ( req , res , next ) { resource [ resourceMethod ] ( req , res , next ) ; } ) ; //resource[resourceMethod](req, res, next); router . connect ( req , res , next ) ;", "del_tokens": "var debug = require ( 'debug' ) ( 'router' ) ; // create the route debug ( 'defined %s ' , path ) ; debug ( 'dispatching %s %s' , req . method , req . url ) ; resource [ resourceMethod ] ( req , res , next ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "stack", "traces", "to", "all", "Stripe", "errors"], "add_tokens": "this . stack = ( new Error ( this . message ) ) . stack ; this . stack = ( new Error ( raw . message ) ) . stack ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "test", "script", "for", "Travis", "testing", "bump", "version"], "add_tokens": "require ( './test/parse' )", "del_tokens": "import postcss from 'postcss' ; import test from 'ava' ; import plugin from './' ; function run ( t , input , output , opts = { } ) { return postcss ( [ plugin ( opts ) ] ) . process ( input ) . then ( result => { t . same ( result . css , output ) ; t . same ( result . warnings ( ) . length , 0 ) ; } ) ; } / * Write tests here test ( 'does something' , t => { return run ( t , 'a{ }' , 'a{ }' , { } ) ; } ) ; * /", "commit_type": "fix"}
{"commit_tokens": ["Add", "testcase", "for", "testing", "email", "with", "attachment", "file"], "add_tokens": "* - type { String } String of the file mime type message . attach ( attachment . path , attachment . type , attachment . name ) ;", "del_tokens": "* - mimeType { String } String of the file mime type message . attach ( attachment . path , attachment . mimeType , attachment . name ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "new", "self", "-", "written", "event", "emitter"], "add_tokens": "* @ since 0.0 .1 * @ version 0.0 .8 var clientpath = path . resolve ( __dirname , 'hawkejs-client.js' ) , mainpath = path . resolve ( __dirname , 'hawkejs.js' ) , helperpath = path . resolve ( __dirname , 'helpers.js' ) , paths = require . main . paths . slice ( 0 ) , ejspath = '' ; // Add the client specific code var data = clientfile ;", "del_tokens": "* @ since 2013.01 .20 * @ version 2013.03 .21 console . log ( 'Using temppath: ' + tempPath ) ; var clientpath = path . resolve ( __dirname , 'hawkejs-client.js' ) ; var mainpath = path . resolve ( __dirname , 'hawkejs.js' ) ; var helperpath = path . resolve ( __dirname , 'helpers.js' ) ; var eepath = path . resolve ( __dirname , 'eventemitter.js' ) ; var ejspath = '' ; var paths = require . main . paths . slice ( 0 ) ; var eefile = fs . readFileSync ( eepath , 'utf-8' ) ; // First: add the event emitter code var data = eefile + '\\n' ; // Now add the client specific code data += clientfile ;", "commit_type": "add"}
{"commit_tokens": ["add", "instanbul", "instrumenter", "to", "Karma"], "add_tokens": "debug : true , module : { postLoaders : [ { test : / \\.js$ / , exclude : / (-spec.js|node_modules|bower_components|specs.js|module.js|vendor.js) / , loader : 'istanbul-instrumenter' } ] } type : 'text-summary' } , { require ( 'istanbul-instrumenter-loader' ) ,", "del_tokens": "debug : true type : 'text-summary' , file : 'text-summary.txt' } , {", "commit_type": "add"}
{"commit_tokens": ["Fix", "caching", "of", "CANNON", ".", "Body", "instances", "."], "add_tokens": "body = this . fingerBodies [ finger . type ] || this . createFingerBody ( finger ) ; this . fingerBodies [ finger . type ] = body ;", "del_tokens": "body = this . fingerBodies [ finger . id ] || this . createFingerBody ( finger ) ; this . fingerBodies [ finger . id ] = body ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "tabs", "and", "error", "feedback"], "add_tokens": "window . browser . tabs . query ( { active : true , currentWindow : true } , function ( tabs ) {", "del_tokens": "window . browser . tabs . query ( { active : true } , function ( tabs ) {", "commit_type": "fix"}
{"commit_tokens": ["updated", "doc", "+", "added", "test", "against", "pipo", "output"], "add_tokens": "* Perfom a Fast Fourier Transform on the incomming signal , [ FFT implementation * by Nayuki ] ( https : //code.soundsoftware.ac.uk/projects/js-dsp-test/repository/entry/fft/nayuki-obj/fft.js). * * _This node only accepts ` ` inputs_ * 2. If the frame size of the incomming signal is lower than this value , * Use the FFT operator outside of a graph ( i . e . ` ` mode ) . * * @ param { Array } signal - Input values . * @ return { Array } - FFT of the input signal . * * @ example * const fft = new lfo . operator . FFT ( { size : 512 , window : 'hann' } ) ; * // mandatory for use in standalone mode * fft . initStream ( { frameSize : 256 , frameType : 'signal' } ) ; * fft . inputSignal ( signal ) ;", "del_tokens": "* Perfom a Fast Fourier Transform on the incomming signal . * This node is based on the [ FFT implementation by Nayuki ] ( https : //code.soundsoftware.ac.uk/projects/js-dsp-test/repository/entry/fft/nayuki-obj/fft.js) * 2. If the the frame size of the incomming signal is lower than this value , * @ todo - doc", "commit_type": "update"}
{"commit_tokens": ["adds", "file", "methods", "to", "Phaser", ".", "these", "are", "here", "as", "temporary", "placeholders", "until", "I", "can", "expose", "fs", "-", "utils", "on", "the", "phaser", ".", "file", "object", "."], "add_tokens": "phaser . file = require ( './lib/file' ) ; // Initalize logging phaser . log = require ( './lib/log' ) . init ( opts , phaser ) ; phaser . verbose = phaser . log . verbose ;", "del_tokens": "phaser . log = require ( './lib/log' ) . init ( opts , phaser ) ; phaser . verbose = phaser . log . verbose ;", "commit_type": "add"}
{"commit_tokens": ["added", "registration", "spec", "for", "acyclic", "dependencies"], "add_tokens": "this . inject = ( this . impl . inject || [ ] )", "del_tokens": "this . inject = this . impl . inject", "commit_type": "add"}
{"commit_tokens": ["updated", "filename", "sanitizer", "&", "readme"], "add_tokens": "var cleanedSelectorName = o . replace ( / [^a-z0-9_\\-] / gi , '' ) ; //remove anything that's not a letter or a number", "del_tokens": "var cleanedSelectorName = o . replace ( / [^a-zA-Z\\d] / , '' ) ; //remove anything that's not a letter or a number", "commit_type": "update"}
{"commit_tokens": ["Allow", "promiseBinds", "to", "gracefully", "handle", "rejection", "."], "add_tokens": "export let promiseBind = ( init , f , catcher = ( ) => null ) => asyncBind ( function ( ) { let promise = this . record ( f ) ; promise . then ( result => this . done ( result ) ) . catch ( reason => this . done ( catcher ( reason ) ) ) ; return promise ; }", "del_tokens": "export let promiseBind = ( init , f ) => asyncBind ( function ( ) { return this . record ( f ) . then ( this . done ) ; }", "commit_type": "allow"}
{"commit_tokens": ["Fix", "typo", "in", "endpoint", "URL", "/", "contactus"], "add_tokens": "contactUs : generate . newPostOne ( \"contactus\" , paramsConfig . contactUs . create ) ,", "del_tokens": "contactUs : generate . newPostOne ( \"contactUs\" , paramsConfig . contactUs . create ) ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "end", "test", "coverage", "method"], "add_tokens": "import coverageCommands from './coverage' ; screenshotCommands , safariCommands , coverageCommands", "del_tokens": "screenshotCommands , safariCommands", "commit_type": "add"}
{"commit_tokens": ["added", "href", "support", ".", "Now", "can", "associate", "links", "with", "tags", "."], "add_tokens": "{ text : \"Lorem\" , weight : 15 , link : \"https://google.com\" } ,", "del_tokens": "{ text : \"Lorem\" , weight : 15 } ,", "commit_type": "add"}
{"commit_tokens": ["Implement", "simple", "head", "attach", "/", "detach"], "add_tokens": "var InvalidHydraHeadStateException = function ( attachedState ) { this . name = \"InvalidHydraHeadStateException\" ; this . message = \"Can't execute that operation when the hydra head is \" + attachedState ? \"attached\" : \"detached\" ; } ; InvalidHydraHeadStateException . prototype . toString = function ( ) { return \"InvalidHydraHeadStateException\" ; } ; self . _name = props . name ; self . _attached = ! props . detached ; self . path = props . path || '/.*' ; HydraHead . prototype . attached = function ( ) { return this . _attached ; } ; HydraHead . prototype . attach = function ( ) { if ( this . _attached ) { throw new InvalidHydraHeadStateException ( this . _attached ) ; } this . _attached = true ; } ; HydraHead . prototype . detach = function ( ) { if ( ! this . _attached ) { throw new InvalidHydraHeadStateException ( this . _attached ) ; } this . _attached = false ; } ; if ( ! this . _attached ) return false ;", "del_tokens": "self . _name = props . name ; self . path = props . path || '/.*' ;", "commit_type": "implement"}
{"commit_tokens": ["Making", ".", "dotChanges", "a", "method"], "add_tokens": "assert . equal ( 2 , results . docChanges ( ) . length ) ; it ( 'throws if QuerySnapshot.docChanges() is used as a property' , function ( ) { const overrides = { runQuery : ( request ) => { requestEquals ( request ) ; return stream ( document ( 'first' ) , document ( 'second' ) ) ; } } ; return createInstance ( overrides ) . then ( firestore => { let query = firestore . collection ( 'collectionId' ) ; return query . get ( ) . then ( snapshot => { assert . throws ( ( ) => { snapshot . docChanges . forEach ( ( ) => { } ) ; } , / QuerySnapshot.docChanges has been changed from a property into a method / ) ; assert . throws ( ( ) => { for ( const doc of snapshot . docChanges ) { } } , / QuerySnapshot.docChanges has been changed from a property into a method / ) ; } ) ; } ) ; } ) ;", "del_tokens": "assert . equal ( 2 , results . docChanges . length ) ;", "commit_type": "make"}
{"commit_tokens": ["fixed", "some", "syntax", "errors", "that", "resulted", "in", "a", "merge", "."], "add_tokens": "if ( ! picImg ) { picImg = w . document . createElement ( \"img\" ) ; picImg . alt = ps [ i ] . getAttribute ( \"data-alt\" ) ; ps [ i ] . appendChild ( picImg ) ; picImg . src = matches . pop ( ) . getAttribute ( \"data-src\" ) ; else if ( picImg ) { } } ( this ) ) ;", "del_tokens": "if ( ! picImg ) { picImg = w . document . createElement ( \"img\" ) ; picImg . alt = ps [ i ] . getAttribute ( \"data-alt\" ) ; ps [ i ] . appendChild ( picImg ) ; } picImg . src = matches . pop ( ) . getAttribute ( \"data-src\" ) ; } else if ( picImg ) { ps [ i ] . removeChild ( picImg ) ; else if ( picImg ) { } ) ( this ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "article", "about", "complex", "events", "routing"], "add_tokens": ", s = require ( './serializers' ) , r = require ( './routing' ) ; evalDefaults : s . evalDefaults , buildRouter : r . buildRouter", "del_tokens": ", s = require ( './serializers' ) ; evalDefaults : s . evalDefaults", "commit_type": "add"}
{"commit_tokens": ["improved", "log", "for", "websockets", "upgrade"], "add_tokens": "log . info ( { headers : req . headers , target : target } , \"upgrade to websockets\" ) ;", "del_tokens": "log . info ( { headers : req . headers } , \"upgrade to websockets\" ) ;", "commit_type": "improve"}
{"commit_tokens": ["add", "supporing", "multi", "slax", "application", "and", "context", "path"], "add_tokens": ". usage ( '[options]' ) . option ( '-r, --root <n>' , 'the root dicrectory to run' )", "del_tokens": ". usage ( '[options] <root_path>' )", "commit_type": "add"}
{"commit_tokens": ["Allowing", "null", "values", "in", "extend"], "add_tokens": "Object . keys ( orig || { } ) . forEach ( function ( key ) { Object . keys ( attributes || { } ) . forEach ( function ( key ) {", "del_tokens": "Object . keys ( orig ) . forEach ( function ( key ) { Object . keys ( attributes ) . forEach ( function ( key ) {", "commit_type": "allow"}
{"commit_tokens": ["fix", "fact", "resolution", "in", "Program"], "add_tokens": "if ( resolution . clause . isFact ( ) ) { resolution . clause . getHeadLiterals ( ) . forEach ( checkAndAdd ) ;", "del_tokens": "if ( resolution . isFact ( ) ) { resolution . getHeadLiterals ( ) . forEach ( checkAndAdd ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "lazy", "-", "init", "logic", "for", "server"], "add_tokens": "callbackFn . call ( self , false ) ; return ; // request.post('http://localhost:1061/phantom/functions/exit', {form:{ arguments:JSON.stringify( // [ // 0 // ], null, 4)}}, // function (error, response, body) { // callbackFn && callbackFn.call(this, body); // }); phantomProcess . kill ( 'SIGHUP' ) ; callbackFn ( ) ;", "del_tokens": "request . post ( 'http://localhost:1061/phantom/functions/exit' , { form : { arguments : JSON . stringify ( [ 0 ] , null , 4 ) } } , function ( error , response , body ) { callbackFn && callbackFn . call ( this , body ) ; } ) ; // phantomProcess.kill('SIGHUP'); // callbackFn();", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "sliders", "back", "to", "the", "way", "they", "were", ".", "Because", "feelings"], "add_tokens": "import { clamp } from \"../lib/utils.js\" ; if ( isPointerDown && relative !== \"Relative\" ) { if ( relative === \"Relative\" ) {", "del_tokens": "import { clamp , isMobileOrTabletDevice } from \"../lib/utils.js\" ; const USE_PSEUDORELATIVE_MODE = ! isMobileOrTabletDevice ( ) ; if ( isPointerDown && relative !== \"Relative\" && USE_PSEUDORELATIVE_MODE ) { if ( relative === \"Relative\" || USE_PSEUDORELATIVE_MODE ) { if ( usableSteps !== 0 ) { delta *= this . interactionRect [ orientation === \"Vertical\" ? 3 : 2 ] / usableSteps ; delta /= PIXELS_PER_STEP ; }", "commit_type": "change"}
{"commit_tokens": ["Improved", "info", "about", "form", "elements", "in", "exploration", "mode", "."], "add_tokens": "'\\ngetRawValue(): ' + ( comp . getRawValue ? comp . getRawValue ( ) : 'N/A' ) + '\\ngetSubmitValue(): ' + ( comp . getSubmitValue ? comp . getSubmitValue ( ) : 'N/A' ) + '\\ninitialConfig.inputType: ' + comp . initialConfig . inputType + '\\ninitialConfig.boxLabel: ' + comp . initialConfig . boxLabel + '\\ninputType: ' + comp . inputType + '\\ngetErrors(): ' + comp . getErrors ( ) . join ( '\\n' ) ; if ( comp . isPickerField ) { var pickerComp = comp . getPicker ( ) ; var store = comp . getStore ( ) ; if ( store ) { store = store . $className ; } formFieldStr += '\\nPicker field Info:' + '\\n $className: ' + pickerComp . $className + '\\n getStore().$className: ' + store + '\\n initialConfig.displayField: ' + comp . initialConfig . displayField + '\\n initialConfig.hiddenName: ' + comp . initialConfig . hiddenName ; // ?? getRecordDisplayData. TODO: } formFieldStr += this . consts . lnAvgSep ;", "del_tokens": "'\\ngetRawValue(): ' + comp . getRawValue ( ) + '\\ngetSubmitValue(): ' + comp . getSubmitValue ( ) + '\\ngetErrors(): ' + comp . getErrors ( ) . join ( '\\n' ) + this . consts . lnAvgSep", "commit_type": "improve"}
{"commit_tokens": ["Fix", "spaniel", "import", "for", "embroider", "builds"], "add_tokens": "import * as spaniel from 'spaniel' ;", "del_tokens": "import spaniel from 'spaniel' ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "livereload", "licence", "and", "link", "to", "website"], "add_tokens": "/*! Copyright (c) 2010-2012 Andrey TarantsovCopyright (c) 2010-2012 Andrey Tarantsov */ /*! https://github.com/livereload/livereload-js / http://livereload.com */", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["fixing", "refresh", "for", "attributes", "only"], "add_tokens": "// Similar to `goog.inherits`, but uses a hash of prototype properties and // static properties to be extended. var child = protoProps . hasOwnProperty ( 'constructor' ) ? protoProps . constructor : function ( ) { return parent . apply ( this , arguments ) ; } ; var collection = this ; models = _ . map ( models , function ( attrs , i ) { var model = new collection . model ( attrs ) ; return model ; } ) ;", "del_tokens": "if ( protoProps . hasOwnProperty ( 'constructor' ) ) { child = protoProps . constructor ; } else { child = function ( ) { return parent . apply ( this , arguments ) ; } ; } _ . each ( models , _ . bind ( function ( model , i ) { } , this ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "option", "to", "namespace", "matter", "by", "passing", "just", "a", "string", "as", "options"], "add_tokens": "* @ param { Object } options - ` ` is used , the rest is passed on to ` `", "del_tokens": "* @ param { Object | string } options - ` ` is used , the rest is passed on to ` ` if ( typeof opts === 'string' ) { opts = { namespace : opts } ; }", "commit_type": "remove"}
{"commit_tokens": ["Changed", "from", "using", "HTMLElement", "to", "Element", "for", "matches"], "add_tokens": "return ( p . matches || p . matchesSelector || p . webkitMatchesSelector || p . mozMatchesSelector || p . msMatchesSelector || p . oMatchesSelector ) ; } ( Element ) ) ;", "del_tokens": "return ( p . matchesSelector || p . webkitMatchesSelector || p . mozMatchesSelector || p . msMatchesSelector || p . oMatchesSelector ) ; } ( HTMLElement ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Updated", "package", ".", "json", "and", "tests"], "add_tokens": "var rdfext = require ( 'rdf-ext' ) ( ) , RdfXmlParser = new rdfext . RdfXmlParser ( ) ;", "del_tokens": "var rdflib = require ( 'rdflib' ) , RdfXmlParser = new rdflib . RDFParser ( ) ;", "commit_type": "update"}
{"commit_tokens": ["use", "Module", ".", "runMain", "instead", "of", "require", "to", "load", "script"], "add_tokens": "require ( 'module' ) . Module . runMain ( script , null , true ) ;", "del_tokens": "require ( script ) ;", "commit_type": "use"}
{"commit_tokens": ["Remove", "_", "-", "prefix", "on", "exported", "less", "files"], "add_tokens": "import 'file?name=colors.less!./colors.less' ; import 'file?name=variables.less!./variables.less' ;", "del_tokens": "import 'file?name=colors.less!./_colors.less' ; import 'file?name=variables.less!./_variables.less' ;", "commit_type": "remove"}
{"commit_tokens": ["Changing", "the", "onlyOneH1", "rule", "to", "match", "the", "description", "of", "the", "rule", "as", "stated", "in", "the", "URL", "shown", "."], "add_tokens": "maximumTwoH1 : new Rule ( { message : 'A document can contain no more than two H1 elements' , if ( e . length > 2 ) {", "del_tokens": "onlyOneH1 : new Rule ( { message : 'A document can only contain one H1 element' , if ( e . length > 1 ) {", "commit_type": "change"}
{"commit_tokens": ["Add", "CSS", "class", "es", "-", "viewBranchNode", "-", "firstChild", "to", "all", "first", "childs", "of", "ViewBranchNode"], "add_tokens": "// TODO: adding and deleting classes has to be implemented for unshift, shift, splice, sort // and reverse as well childView . $ . addClass ( 'es-viewBranchNode-firstChild' ) ;", "del_tokens": "childView . $ . addClass ( 'es-ViewBranchNode-firstChild' ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "environment", "variable", "to", "override", "flowBin"], "add_tokens": "function getFlowBin ( ) { return process . env . FLOW_BIN || flowBin ; } execFile ( getFlowBin ( ) , args , function ( err , stdout , stderr ) { execFile ( getFlowBin ( ) , [ 'stop' ] , {", "del_tokens": "execFile ( flowBin , args , function ( err , stdout , stderr ) { execFile ( flowBin , [ 'stop' ] , {", "commit_type": "allow"}
{"commit_tokens": ["Fixed", "accelerometer", ".", "js", "and", "updated", "accerelometer", ".", "tests", ".", "js"], "add_tokens": "var accelerometerTimers = { } ; // dictionary of timers in use a . timestamp . getTime ( ) * @ param { String } watchId The ID of the watch returned from # watchAcceleration if ( ( watchId !== undefined ) && ( accelerometerTimers [ watchId ] !== undefined ) ) { delete accelerometerTimers [ watchId ] ;", "del_tokens": "var accelerometerTimers = { } ; // list of timers in use a . timestamp * @ param { String } id The ID of the watch returned from # watchAcceleration if ( watchId && accelerometerTimers [ watchId ] !== undefined ) { delete accelerometerTimers [ id ] ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "updating", "of", "AreaText", "/", "-", "Group", "children"], "add_tokens": "{ this . state . bool && ( < Area . Path d = \"M14 12v1H0v-1l.73-.58c.77-.77.81-2.55 1.19-4.42C2.69 3.23 6 2 6 2c0-.55.45-1 1-1s1 .45 1 1c0 0 3.39 1.23 4.16 5 .38 1.88.42 3.66 1.19 4.42l.66.58H14zm-7 4c1.11 0 2-.89 2-2H5c0 1.11.89 2 2 2z\" // d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" // d=\"M10 80 Q 95 10 180 80\" // d=\"M10 10 H 90 V 90 H 10 Z\" // d=\"M10 315 // L 110 215 // A 30 50 0 0 1 162.55 162.45 // L 172.55 152.45 // A 30 50 -45 0 1 215.1 109.9 // L 315 10\" fill = \"grey\" transform = \"scale(2.2) translate(60, 90)\" / > ) }", "del_tokens": "< Area . Path d = \"M14 12v1H0v-1l.73-.58c.77-.77.81-2.55 1.19-4.42C2.69 3.23 6 2 6 2c0-.55.45-1 1-1s1 .45 1 1c0 0 3.39 1.23 4.16 5 .38 1.88.42 3.66 1.19 4.42l.66.58H14zm-7 4c1.11 0 2-.89 2-2H5c0 1.11.89 2 2 2z\" // d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" // d=\"M10 80 Q 95 10 180 80\" // d=\"M10 10 H 90 V 90 H 10 Z\" // d=\"M10 315 // L 110 215 // A 30 50 0 0 1 162.55 162.45 // L 172.55 152.45 // A 30 50 -45 0 1 215.1 109.9 // L 315 10\" fill = \"grey\" transform = \"scale(2.2) translate(60, 90)\" / >", "commit_type": "fix"}
{"commit_tokens": ["Updating", "documentation", "for", "search", "()"], "add_tokens": "* @ param { Object } options Optional Options to control search behavior . * Set 'timeout' to how long to search for devices * ( in milliseconds ) . * @ param { Function } listener Optional 'DeviceAvailable' listener ( sonos )", "del_tokens": "* @ param { Function } Optional 'DeviceAvailable' listener ( sonos )", "commit_type": "update"}
{"commit_tokens": ["add", "support", "for", "vedic", "numbering", "system"], "add_tokens": "const lastDecimalRegex = / \\.(\\d+)$ / ; const groupRegex = / (\\d)(?=(\\d{3})+\\b) / g ; const vedicRegex = / (\\d)(?=(\\d{2})+\\d\\b) / g ; // Support vedic numbering systems // see: https://en.wikipedia.org/wiki/Indian_numbering_system if ( settings . useVedic ) { settings . groups = vedicRegex ; } else { settings . groups = groupRegex ; } let { formatWithSymbol , symbol , separator , decimal , groups } = this . _settings ; . replace ( groups , '$1' + separator ) . replace ( lastDecimalRegex , decimal + '$1' ) ;", "del_tokens": "const regex = { groupedNumbers : / (\\d)(?=(\\d{3})+\\b) / g , lastDecimal : / \\.(\\d+)$ / } ; let { formatWithSymbol , symbol , separator , decimal } = this . _settings ; . replace ( regex . groupedNumbers , '$1' + separator ) . replace ( regex . lastDecimal , decimal + '$1' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "doc", "+", "more", "logging"], "add_tokens": "new date + ':@: Unable to listen to port `' + me . port + '` as your Node.js instance does not have root privileges.' + } else { me . log && console . error ( new date + ':@: FlashPolicyFileServer received a error event:\\n' + ( err . message ? err . message : err ) ) ;", "del_tokens": "'Unable to listen to port `' + me . port + '` as your node instance does not have root privileges.' +", "commit_type": "add"}
{"commit_tokens": ["Fix", "error", "parsing", "by", "HEAD", "for", "samples", "."], "add_tokens": "headerSpec = U . findWhere ( header . FORMAT , { ID : key } ) , type ;", "del_tokens": "headerSpec = U . findWhere ( header . format , { ID : key } ) , type ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "the", "README", ".", "md"], "add_tokens": "var node = EJS . registry . $getNode ( path , true ) ; var node = EJS . registry . $getNode ( path , false ) ;", "del_tokens": "var node = EJS . registry . getNode ( path , true ) ; var node = EJS . registry . getNode ( path , false ) ;", "commit_type": "update"}
{"commit_tokens": ["Change", "function", "name", "to", "reflect", "npm", "package", "and", "Github", "repo", "name"], "add_tokens": "function DuplicatePackageCheckerPlugin ( ) { } DuplicatePackageCheckerPlugin . prototype . apply = function ( compiler ) { module . exports = DuplicatePackageCheckerPlugin ;", "del_tokens": "function DuplicatePackagesCheckerPlugin ( ) { } DuplicatePackagesCheckerPlugin . prototype . apply = function ( compiler ) { module . exports = DuplicatePackagesCheckerPlugin ;", "commit_type": "change"}
{"commit_tokens": ["added", "demo", ";", "fixed", "tests"], "add_tokens": "import './jquery-tokeninput/' ; import './jquery-tokeninput/token-input-facebook.css!' ;", "del_tokens": "import 'rins_cutom_plugin/tokenInput/jquery.tokeninput' ; import './jquery.tokeninput-styles/token-input-facebook.css!' ;", "commit_type": "add"}
{"commit_tokens": ["Added", "npm", "-", "which", "for", "robustness", "."], "add_tokens": "const which = require ( 'npm-which' ) ( __dirname ) ; const mmdcExecutable = which . sync ( 'mmdc' ) ; execSync ( ` ${ mmdcExecutable } ${ mmdPath } ${ svgPath } ` ) ;", "del_tokens": "execSync ( ` ${ mmdPath } ${ svgPath } ` ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "proxy", "if", "env", "var", "is", "lowercase"], "add_tokens": "let httpsProxy = process . env . HTTPS_PROXY || process . env . https_proxy ; let proxy = url . parse ( httpsProxy ) ; if ( httpsProxy ) { setupHttpProxy ( ) ; }", "del_tokens": "if ( ! process . env . HTTP_PROXY ) { return ; } let proxy = url . parse ( process . env . HTTP_PROXY ) ; setupHttpProxy ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Removed", "setex", "and", "use", "default", "set", "and", "EX", "option", "because", "setex", "is", "deprecated", "."], "add_tokens": "var args = [ ] ; args . push ( key , res ) ; if ( ttl ) { args . push ( 'EX' , ttl ) ; } return redis . set ( args , function ( err , res ) { 'findOne' ,", "del_tokens": "return redis . setex ( key , ttl , res , function ( err , res ) {", "commit_type": "remove"}
{"commit_tokens": ["Added", "a", "safeguard", "against", "dotfiles"], "add_tokens": "var _files = [ ] ; if ( files [ i ] . charAt ( 0 ) !== '.' && ! exports . isDirectory ( destination + '/' + files [ i ] ) ) { _files . push ( files [ i ] ) ; return exports . file . create ( destination + '/index.html' , template ( { files : _files } ) ) ;", "del_tokens": "if ( exports . isDirectory ( destination + '/' + files [ i ] ) ) { files = files . splice ( i , 1 ) ; return exports . file . create ( destination + '/index.html' , template ( { files : files } ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "multiple", "HUDs", "via", "setting", "."], "add_tokens": "if ( Garnish . HUD . active && ! this . settings . closeOtherHUDs ) closeBtn : null , closeOtherHUDs : false", "del_tokens": "if ( Garnish . HUD . active ) closeBtn : null", "commit_type": "allow"}
{"commit_tokens": ["Adding", "chain", "function", "and", "associated", "tests"], "add_tokens": "const Maybe = require ( './lib' ) ; function chainIt ( bar ) { return Maybe . of ( bar ) . prop ( 'qux' ) ; } . prop ( 'bar' ) . chain ( chainIt )", "del_tokens": "const Maybe = require ( 'maybe-baby' ) ; . prop ( 'baz' )", "commit_type": "add"}
{"commit_tokens": ["Updated", "versions", ".", "Running", "Firefox", "in", "CI"], "add_tokens": "let config = { } ; // In CI, use firefox if ( process . env . TRAVIS ) { config . capabilities = { browserName : 'firefox' } ; } exports . config = merge ( commonConfig . config , config ) ;", "del_tokens": "exports . config = merge ( commonConfig . config , { capabilities : { 'browserName' : 'firefox' } , } ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "pasword", "checkbox", "and", "hidden", "widgets"], "add_tokens": "exports [ 'number toHTML' ] = function ( test ) { test . equals ( forms . fields . number ( ) . toHTML ( 'fieldname' ) , '<div class=\"field\">' + '<label for=\"id_fieldname\">Fieldname</label>' + '<input type=\"text\" name=\"fieldname\" id=\"id_fieldname\" />' + '</div>' ) ; test . done ( ) ; } ;", "del_tokens": "exports [ field ] = function ( test ) { var f = forms . fields [ field ] ( ) ; test . equals ( f . widget . toHTML ( 'test' ) , forms . widgets . text ( ) . toHTML ( 'test' ) ) ; test . done ( ) ; } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "Tox#bootstrap", "bootstrap", "error", "handling", "new_api", "examples", "updated", "save", "function", "names", "for", "latest", "tox", ".", "h"], "add_tokens": "/ ** * @ file consts . js * Specifies constants and enum values defined in tox . h . All enum values * are assumed to start at 0 and increment once per possible value . This * could be an issue if updated versions of toxcore have new enum values * inserted , instead of appended . * / TOX_ERR_NEW_PROXY_TYPE : 4 , TOX_ERR_OPTIONS_NEW_OK : 0 , TOX_ERR_OPTIONS_NEW_MALLOC : 1 , TOX_ERR_BOOTSTRAP_OK : 0 , TOX_ERR_BOOTSTRAP_NULL : 1 , TOX_ERR_BOOTSTRAP_BAD_HOST : 2 , TOX_ERR_BOOTSTRAP_BAD_PORT : 3 ,", "del_tokens": "TOX_ERR_PROXY_TYPE : 4 ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "some", "scope", "DOM", "copying", "order", "problems", "."], "add_tokens": "snaphotHtml = Ember . $ ( '#ember-testing-container' ) . find ( scope ) . html ( ) ;", "del_tokens": "snaphotHtml = testingContainer . find ( scope ) . html ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "for", "ObjectId", "auto", "-", "conversion", "when", "schema", "defines", "field", "as", "ObjectId"], "add_tokens": "var ObjectId = require ( 'leafnode' ) . BSON . ObjectID rawValue = rawValue . trim ( ) if ( schema . type === 'ObjectId' ) { if ( rawValue [ 0 ] !== '{' ) { if ( ObjectId . isValid ( rawValue ) ) { value = EJSON . inflate ( new ObjectId ( rawValue ) ) } } else { value = EJSON . parse ( rawValue ) } } else if ( schema . type === 'string' ) { // Be forgiving of unquoted strings. // (1) If schema defines parameter as a string and the value // is a string without quotes, auto-wrap. Otherwise just EJSON parse // ** note this converts numbers to strings. XXX do we want this?", "del_tokens": "var mongodb = require ( 'mongodb' ) . MongoClient // Be forgiving of unquoted strings. // (1) If schema defines parameter as a string and the value // is a string without quotes, auto-wrap. Otherwise just EJSON parse if ( schema . type === 'string' ) {", "commit_type": "allow"}
{"commit_tokens": ["Implement", "new", "path", "construction", "within", "TaxonomiesRequest"], "add_tokens": "expect ( taxonomies . _path . values ) . to . deep . equal ( { } ) ; var url = taxonomies . taxonomy ( 'my-tax' ) . _renderURI ( ) ; var url = taxonomies . taxonomy ( 'my-tax' ) . terms ( ) . _renderURI ( ) ; var url = taxonomies . taxonomy ( 'my-tax' ) . terms ( ) . term ( 1337 ) . _renderURI ( ) ;", "del_tokens": "expect ( taxonomies . _action ) . to . be . null ; expect ( taxonomies . _actionId ) . to . be . null ; expect ( taxonomies . _id ) . to . be . null ; var url = taxonomies . id ( 'my-tax' ) . _renderURI ( ) ; var url = taxonomies . id ( 'my-tax' ) . terms ( ) . _renderURI ( ) ; var url = taxonomies . id ( 'my-tax' ) . terms ( ) . id ( 1337 ) . _renderURI ( ) ;", "commit_type": "implement"}
{"commit_tokens": ["Moving", "some", "comments", "back", "to", "their", "previous", "location", "."], "add_tokens": "// GET /auth/user - returns info about the logged in user, in an envelope. // PUT /auth/user - update the current user's record. This is meant to be // used for the purpose of registration, etc. For now we only allow this // method to set username. This is currently working only for OAuth users. // POST /auth/user - Add (register) a new user // POST /auth/logout - logs out the user. // GET /auth/usernameAvailable - checks if a username is available.", "del_tokens": "// GET /auth/user - returns info about the logged in user, in an envelope. / * app . get ( '/auth/user' , getAuthUser ) ; // PUT /auth/user - update the current user's record. This is meant to be // used for the purpose of registration, etc. For now we only allow this // method to set username. This is currently working only for OAuth users. app . put ( '/auth/user' , putAuthUser ) ; // POST /auth/user - Add (register) a new user app . post ( '/auth/user' , postAuthUser ) ; // POST /auth/logout - logs out the user. app . post ( '/auth/logout' , postAuthLogout ) ; // GET /auth/usernameAvailable - checks if a username is available. app . get ( '/auth/usernameAvailable' , getAuthUsernameAvailable ) ; * /", "commit_type": "move"}
{"commit_tokens": ["Add", "more", "boilerplate", ".", "Add", "line", "splitting", "algorithm"], "add_tokens": "export { default as Log } from './Log' ; export { default as Pane } from './Pane' ;", "del_tokens": "export default null ;", "commit_type": "add"}
{"commit_tokens": ["add", "rule", "prefer", "-", "filter"], "add_tokens": "'prefer-reject' : require ( './lib/rules/prefer-reject' ) , 'prefer-filter' : require ( './lib/rules/prefer-filter' ) 'prefer-reject' : 0 , 'prefer-filter' : 0", "del_tokens": "'prefer-reject' : require ( './lib/rules/prefer-reject' ) 'prefer-reject' : 0", "commit_type": "add"}
{"commit_tokens": ["update", "export", "style", "with", "extend", "style"], "add_tokens": "module . exports = { think : { Model : Mysql } } ;", "del_tokens": "module . exports = Mysql ;", "commit_type": "update"}
{"commit_tokens": ["Allow", "the", "proxy", "wrapper", "to", "wrap", "around", "a", "different", "parentNode"], "add_tokens": "initSelector = \"[data-\" + componentName + \"]\" ; var $t = $ ( this ) ; if ( $t . data ( componentName ) ) { return ; } var polite = new Politespace ( this ) ; $sel [ componentName ] ( ) ;", "del_tokens": "enhancedAttr = \"data-enhanced\" , initSelector = \"[data-\" + componentName + \"]:not([\" + enhancedAttr + \"])\" ; var DOMLib = { getAttribute : function ( el , key ) { return $ ( el ) . attr ( key ) ; } , getStyle : function ( el , key ) { return $ ( el ) . css ( key ) ; } } ; var polite = new Politespace ( this , DOMLib ) ; $sel [ componentName ] ( ) . attr ( enhancedAttr , \"true\" ) ;", "commit_type": "allow"}
{"commit_tokens": ["Remove", "non", "-", "standard", "grey", "color", "from", "dev", "format"], "add_tokens": "var fn = compile ( '\\x1b[0m:method :url \\x1b[' + color + 'm:status \\x1b[0m:response-time ms - :res[content-length]\\x1b[0m' ) ;", "del_tokens": "var fn = compile ( '\\x1b[90m:method :url \\x1b[' + color + 'm:status \\x1b[90m:response-time ms - :res[content-length]\\x1b[0m' ) ;", "commit_type": "remove"}
{"commit_tokens": ["adding", "season_id", "to", "teaminstance", "url", "via", "options"], "add_tokens": "url : function ( options ) { // TODO: throw an error if no season_id? var base = config . urls && config . urls . sports || config . url base = Url . resolve ( base , '/seasons/' + options . season_id + '/teams' ) if ( ! this . id ) return base return base + ( base . charAt ( base . length - 1 ) === '/' ? '' : '/' ) + encodeURIComponent ( this . id ) } , return Url . resolve ( base , '/seasons' ) console . log ( 'TeamInstance#initialize' , attr , options )", "del_tokens": "return Url . resolve ( base , '/team_instances' )", "commit_type": "add"}
{"commit_tokens": ["Changed", "hyperlink", "regexp", "so", "punctuation", "at", "the", "end", "of", "an", "hyperlink", "is", "not", "included"], "add_tokens": "exports . pattern = / \\S{2,256}\\.[a-z]{2,3}(\\/[^\\s,.:]*)? / g ;", "del_tokens": "exports . pattern = / \\S{2,256}\\.[a-z]{2,3}(\\/\\S*)? / g ;", "commit_type": "change"}
{"commit_tokens": ["updated", "bin", "/", "browserify", "-", "editor"], "add_tokens": "function addLink ( href ) { return \"\" + \"var link = document.createElement('link')\\n\" + \"link.rel = 'stylesheet'\\n\" + \"link.href = '\" + href + \"'\\n\" + \"document.head.appendChild(link)\\n\" } addLink ( \"https://rawgithub.com/maxogden/\" + \"javascript-editor/master/css/codemirror.css\" ) + addLink ( \"https://rawgithub.com/maxogden/\" + \"javascript-editor/master/css/theme.css\" ) + \"document.body.appendChild(elem)\\n\" + \"setTimeout(function () {\\n\" + \" var editor = createEditor({\\n\" + \" container: elem,\\n\" + \" value: \" + JSON . stringify ( src ) + \",\\n\" + \" readOnly: true\\n\" + \" })\\n\" + \"}, 100)\"", "del_tokens": "\"createEditor({\\n\" + \" container: elem,\\n\" + \" value: \" + JSON . stringify ( src ) + \",\\n\" + \" readOnly: true\\n\" + \"})\\n\"", "commit_type": "update"}
{"commit_tokens": ["added", "stack", "trace", "output", "for", "failed", "tests", "or", "scaffolding"], "add_tokens": "grey : '\\u001b[30m' ,", "del_tokens": "black : '\\u001b[30m' ,", "commit_type": "add"}
{"commit_tokens": ["Update", "gitignore", "and", "e2e", "tests"], "add_tokens": "var gitignoreContent = '# .gitignore for Google Apps Script projects using https://www.npmjs.com/package/google-apps-script\\n' +", "del_tokens": "var gitignoreContent = '# Suggested .gitignore for gas projects\\n' +", "commit_type": "update"}
{"commit_tokens": ["added", "uglify", "and", "cssmin", "to", "watch", "task"], "add_tokens": "*", "del_tokens": "*", "commit_type": "add"}
{"commit_tokens": ["Fix", "tests", "with", "default", "graph", "type"], "add_tokens": "type : $rootScope . graphTypes . length == 1 ? $rootScope . graphTypes [ 0 ] : $rootScope . config ? $rootScope . config . defaultGraphType : null ,", "del_tokens": "type : $rootScope . graphTypes . length == 1 ? $rootScope . graphTypes [ 0 ] : $rootScope . config . defaultGraphType ,", "commit_type": "fix"}
{"commit_tokens": ["added", "ots", "support", "and", "decoding", "of", "xml", "entites"], "add_tokens": "\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\" , \"application/vnd.oasis.opendocument.spreadsheet-template\" ] ,", "del_tokens": "\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\" ] ,", "commit_type": "add"}
{"commit_tokens": ["fixed", "a", "bug", "with", "line", "endings", "in", "snapshots", "being", "different", "between", "windows", "and", "linux"], "add_tokens": "resultString = resultString . replace ( / \\r\\n / g , '\\n' ) ; let previousResult = fs . readFileSync ( fileName , 'utf-8' ) . replace ( / \\r / g , '' ) ;", "del_tokens": "let previousResult = fs . readFileSync ( fileName , 'utf-8' ) ;", "commit_type": "fix"}
{"commit_tokens": ["adds", "try", "catch", "in", "filters", ".", "js", "to", "catch", "errors", "from", "empty", "files"], "add_tokens": "try { // Catch errors from empty files. filters = _ . extend ( { } , filters , require ( name ) ( phaser ) ) ; } catch ( e ) { phaser . log . warn ( e ) ; }", "del_tokens": "filters = _ . extend ( { } , filters , require ( name ) ( phaser ) ) ; // return phaser.context;", "commit_type": "add"}
{"commit_tokens": ["Updating", "README", "and", "package", ".", "json", "(", "support", "for", "Jam", ")"], "add_tokens": "} ( ) ) ; // IIFE", "del_tokens": "} ( ) ) ; // IIEF", "commit_type": "update"}
{"commit_tokens": ["fix", "broken", "handling", "of", "timeout"], "add_tokens": "this . timedOut = false ; this . timedOut = true ; this . handleLocationNotShared ( ) ; function ( position ) { if ( this . timedOut ) return false ; clearTimeout ( this . timeoutCheck ) ; this . handleLocationShared ( position ) ; } . bind ( this ) , function ( ) { if ( this . timedOut ) return false ; clearTimeout ( this . timeoutCheck ) ; this . handleLocationNotShared ( ) ; } . bind ( this ) , { timeout : LOCATION_TIMEOUT } ) ; } , handleLocationShared : function ( position ) { publish ( 'enable-input' ) ; publish ( 'disable-loading' ) ; publish ( 'send' , { text : position . coords . latitude + ',' + position . coords . longitude , silent : true } ) ;", "del_tokens": "var locationShared = false ; if ( ! locationShared ) this . handleLocationNotShared ( ) ; function ( position ) { locationShared = true ; publish ( 'enable-input' ) ; publish ( 'disable-loading' ) ; publish ( 'send' , { text : position . coords . latitude + ',' + position . coords . longitude , silent : true } ) ; } , this . handleLocationNotShared ) ; this . timeoutCheck = null ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "for", "paired", "character", "handling"], "add_tokens": "const repeat = compiler . dsl . repeat ; const token = compiler . dsl . token ; variable : $ => token ( seq ( / \\a / , repeat ( choice ( / \\w / , \"👍\", \" 👎 )) ) ) , var inputString = \"a👍👎1 / b👎c👎\"; document . setInputString ( inputString ) . parse ( ) sumNode = document . rootNode . children [ 0 ] ; assert . equal ( 15 , sumNode . endIndex ) assert . deepEqual ( [ 0 , 7 , 9 ] , sumNode . children . map ( child => child . startIndex ) ) assert . deepEqual ( [ 6 , 8 , 15 ] , sumNode . children . map ( child => child . endIndex ) )", "del_tokens": "variable : $ => ( / \\a\\w+ / ) , assert . equal ( 10 , sumNode . endIndex ) assert . deepEqual ( [ 0 , 4 , 6 ] , sumNode . children . map ( child => child . startIndex ) ) assert . deepEqual ( [ 3 , 5 , 10 ] , sumNode . children . map ( child => child . endIndex ) )", "commit_type": "add"}
{"commit_tokens": ["use", "deepcopy", "instead", "of", "custom", "clone", "util"], "add_tokens": "var deepcopy = require ( 'deepcopy' ) cfGrammar [ def ] = deepcopy ( upwardOnly [ def ] ) var downwardDef = deepcopy ( upwardOnly [ def ] ) . map ( function ( definition ) {", "del_tokens": "var clone = require ( '../lib/utils/clone.js' ) cfGrammar [ def ] = clone ( upwardOnly [ def ] ) var downwardDef = clone ( upwardOnly [ def ] ) . map ( function ( definition ) {", "commit_type": "use"}
{"commit_tokens": ["fix", "hello", "world", "sample", "not", "appearing"], "add_tokens": "compileExamples ( stream ) ;", "del_tokens": "compileExamples ( stream ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "flag", "that", "disables", "LJM", "function", "-", "linking", "warning", "messages", "."], "add_tokens": "var SILENT_LJM_FUNCTION_LINKING = true ; if ( ! SILENT_LJM_FUNCTION_LINKING ) { console . log ( 'Warning: Failed to link function' , functionName ) ; }", "del_tokens": "console . log ( 'Warning: Failed to link function' , functionName ) ;", "commit_type": "add"}
{"commit_tokens": ["changed", "name", "of", "equality", "constraint", "suite"], "add_tokens": "function Equality_tests ( ) {", "del_tokens": "function Equality_constraint_tests ( ) {", "commit_type": "change"}
{"commit_tokens": ["Added", "version", "and", "dynamic", "ports", "for", "cloud", "hosting", "."], "add_tokens": "api = { } , PORT = process . env . PORT || 3000 ; app . listen ( PORT ) ; console . log ( 'Listening on port ' + PORT + '...' ) ;", "del_tokens": "api = { } ; app . listen ( 3000 ) ; console . log ( 'Listening on port 3000...' ) ;", "commit_type": "add"}
{"commit_tokens": ["changed", "event", "listener", "on", "client", "to", "listen", "to", "proper", "event"], "add_tokens": "socket . on ( 'variables-from-server' , loadVariables ( Variables ) ) ;", "del_tokens": "socket . on ( 'initial-values' , loadVariables ( Variables ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Update", "attach", "-", "middleware", ".", "js"], "add_tokens": "const modulePath = path . posix . relative ( root , filePath ) ;", "del_tokens": "const modulePath = path . relative ( root , filePath ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "style", "property", "to", "use", "$", ".", "css"], "add_tokens": "console . warn ( 'cssify is deprecated; set the `style` property directly to a JSON object.' ) ; return rx . autoSub ( rxt . cast ( value ) . onSet , function ( _arg ) { var n , o ; o = _arg [ 0 ] , n = _arg [ 1 ] ; if ( ( n == null ) || _ . isString ( n ) ) { return setProp ( elt , 'style' , n ) ; return elt . removeAttr ( 'style' ) . css ( n ) ;", "del_tokens": "return setDynProp ( elt , 'style' , value , function ( val ) { if ( _ . isString ( val ) ) { return val ; return rxt . cssify ( val ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "the", "on", "(", "ready", "...", ")", "feature"], "add_tokens": "// parse stderr of the inotifywatch command Lazy ( self . inwp . stderr ) . lines . map ( String ) . forEach ( function ( line ) { if ( / ^Watches established / . test ( line ) ) { // tell when the watch is ready self . emit ( 'ready' ) ; } else if ( / ^Setting up watches / . test ( line ) ) { // ignore this message } else { self . emit ( 'error' , new Error ( line ) ) ; } } ) ;", "del_tokens": "'-q' , self . inwp . stderr . on ( 'data' , function ( data ) { self . emit ( 'error' , new Error ( data . toString ( ) ) ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Implement", "HTTP", "cache", "middle", "in", "app", "."], "add_tokens": "// RAM cache // HTTP cache if ( route . httpCache ) routeMiddlewares . push ( middlewares . httpCache ( route . httpCache ) ) ;", "del_tokens": "// Cache", "commit_type": "implement"}
{"commit_tokens": ["Removes", "npm", "-", "exists", "and", "npm", "-", "install", ":", "no", "more", "automatic", "install"], "add_tokens": "throw new Error ( ` ${ pkgName } ` )", "del_tokens": "npmExists = require ( '../lib/npm-exists' ) , npmInstall = require ( '../lib/npm-install' ) , try { if ( yield npmExists ( pkgName ) ) { try { yield fsp . access ( path . join ( root , 'node_modules' ) , fsp . F_OK ) yield npmInstall ( pkgName , false ) console . log ( ` ${ pkgName } ` ) } catch ( err ) { yield npmInstall ( pkgName , true ) console . log ( ` ${ pkgName } ` ) } recipe = require ( pkgName ) } } catch ( err ) { throw new Error ( 'No valid recipe' ) }", "commit_type": "remove"}
{"commit_tokens": ["fix", "bug", "1", "/", "2", "by", "using", "monotonic", "-", "timestamp", "on", "put", "()"], "add_tokens": "exports . fromKeyValuePair = function ( key , value , ts ) {", "del_tokens": "exports . fromKeyValuePair = function ( key , value ) { var ts = Date . now ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updating", "example", "to", "use", "Server", "instead", "of", "middlewares"], "add_tokens": "var angularMiddlewares = angularserver . Server (", "del_tokens": "var angularMiddlewares = angularserver . middlewares (", "commit_type": "update"}
{"commit_tokens": ["fixed", "a", "nasty", "bug", "with", "the", "import", "order", "and", "added", "some", "examples", "to", "the", "readme"], "add_tokens": "const hive = require ( \"./build/lib/index\" ) ; hive . main ( )", "del_tokens": "let index = require ( './build/index.js' ) ; index . main ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implement", "arm", "/", "disarm", "add", "CLI", "example"], "add_tokens": "const yargs = require ( 'yargs' ) . usage ( 'Usage: $0 [options]' ) . option ( 'u' , { alias : 'username' , default : process . env . FRONTPOINT_USERNAME , defaultDescription : 'FRONTPOINT_USERNAME environment variable' , describe : 'FrontPoint username' , type : 'string' } ) . option ( 'p' , { alias : 'password' , default : process . env . FRONTPOINT_PASSWORD , defaultDescription : 'FRONTPOINT_PASSWORD environment variable' , describe : 'FrontPoint password' , type : 'string' } ) . help ( 'h' ) . alias ( 'h' , 'help' ) . version ( false ) const username = yargs . argv . username const password = yargs . argv . password console . error ( ` ` ) yargs . showHelp ( )", "del_tokens": "const username = process . argv [ 2 ] || process . env . FRONTPOINT_USERNAME const password = process . argv [ 3 ] || process . env . FRONTPOINT_PASSWORD console . error ( ` ` )", "commit_type": "implement"}
{"commit_tokens": ["Add", "test", "for", "response", "model", "validation"], "add_tokens": "exports . pets1 = function ( req , res , next ) { exports . pets2 = function ( req , res , next ) { exports . pets3 = function ( req , res , next ) { exports . pets4 = function ( req , res , next ) { exports . pets22 = function ( req , res , next ) { res . status ( 201 ) . send ( req . body ) ; } ;", "del_tokens": "exports . pets1 = function ( req , res , next ) { exports . pets2 = function ( req , res , next ) { exports . pets3 = function ( req , res , next ) { exports . pets4 = function ( req , res , next ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "directory", "option", "to", "run", "plugin", "from", "anywhere", "still", "keeping", "the", "sketch", "plugin", "folder", "as", "fallback"], "add_tokens": "const BINARY_PATH = '/Applications/Sketch.app/Contents/Resources/sketchtool/bin/sketchtool' ; 'artboards' , 'formats' , 'layers' , 'pages' , const pluginFolderPath = options . dir || pluginFolder ( ) ; invariant ( exists , ` ${ pluginPath } ` ) ; invariant ( ALLOWED_LIST_TYPES . includes ( type ) , ` ${ type } ` ) ; } ;", "del_tokens": "const BINARY_PATH = '/Applications/Sketch.app/Contents/Resources/sketchtool/bin/sketchtool' ; 'artboards' , 'formats' , 'layers' , 'pages' , const pluginFolderPath = pluginFolder ( ) ; invariant ( exists , ` ${ pluginPath } ` ) ; invariant ( ALLOWED_LIST_TYPES . includes ( type ) , ` ${ type } ` ) } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "writing", "diff", "when", "sub", "-", "directories", "are", "under", "base", "path"], "add_tokens": "imageOutputPath : path . join ( this . _basePath , 'diff' , path . basename ( tag ) ) , imageOutputPath : path . join ( this . _basePath , 'diff' , path . basename ( tag ) ) ,", "del_tokens": "imageOutputPath : path . join ( this . _basePath , 'diff' , tag ) , imageOutputPath : path . join ( this . _basePath , 'diff' , tag ) ,", "commit_type": "fix"}
{"commit_tokens": ["fixed", "some", "bugs", "in", "event", "handling"], "add_tokens": "let findEl = ( selector , target ) => { let node = find ( selector , el ) ; while ( node . length > 0 && target !== host ) { if ( node . indexOf ( target ) >= 0 ) return node [ node . indexOf ( target ) ] ; target = target . parentNode ; } return false ; } ; let target ; if ( eventObj . selector === ':host' || ( target = findEl ( eventObj . selector , e . target ) ) ) { target . getHost = ( ) => host . getHost ( ) ; eventObj . handlers [ event ] . call ( target , e ) ;", "del_tokens": "if ( find ( eventObj . selector , el ) . indexOf ( e . target ) >= 0 ) { e . target . getHost = ( ) => host . getHost ( ) ; eventObj . handlers [ event ] . call ( e . target , e ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "deps", ".", "Cleaned", "up", "code", "."], "add_tokens": "var cloneFunction = require ( 'fulcon' )", "del_tokens": "var cloneFunction = require ( '../lib/clone_function.js' )", "commit_type": "update"}
{"commit_tokens": ["upgraded", "ml", ".", "js", "and", "adding", "cross", "validation"], "add_tokens": "replaceVal = ml . ArrayStat [ config . strategy ] ( this . columnArray ( name , config . arrayOptions ) ) ; const fittedData = fittedColumns [ columnNames [ 0 ] ]", "del_tokens": "replaceVal = ml . Stat . array [ config . strategy ] ( this . columnArray ( name , config . arrayOptions ) ) ; const fittedData = fittedColumns [ config . columns [ 0 ] . name ]", "commit_type": "upgrade"}
{"commit_tokens": ["update", "the", "interfaces", "in", "dataHandlers", ".", "js", "and", "lock", ".", "js"], "add_tokens": "COLLISION : 'collisionHandler' , LIST_COLLISIONS : 'listCollisionsHandler' , REMOVE_COLLISION : 'removeCollisionHandler' } , / ** * @ param datasetId * @ param metaData * @ param callback * / listCollisions : function ( datasetId , metaData , callback ) { var handler = handlerFor ( datasetId , names . LIST_COLLISIONS ) ; handler ( datasetId , metaData , callback ) ; } , / ** * @ param datasetId * @ param dataHash * @ param metaData * @ param callback * / removeCollision : function ( datasetId , dataHash , metaData , callback ) { var handler = handlerFor ( datasetId , names . REMOVE_COLLISION ) ; handler ( datasetId , dataHash , metaData , callback ) ; this . listCollisionsHandler = defaultHandlers . listCollisionsHandler ; this . removeCollisionHandler = defaultHandlers . removeCollisionHandler ;", "del_tokens": "COLLISION : 'collisionHandler'", "commit_type": "update"}
{"commit_tokens": ["Fix", "library", "name", "in", "webpack", "config"], "add_tokens": "filename : 'flocs-visual-components.js' , library : 'flocsVisualComponents' ,", "del_tokens": "var libraryName = 'flocs-visual-components' ; filename : libraryName + '.js' , library : libraryName ,", "commit_type": "fix"}
{"commit_tokens": ["fix", "demo", "background", "path", "to", "lib"], "add_tokens": "import pack from \"../lib/pack\" document . body . style . background = \"whitesmoke\"", "del_tokens": "import pack from \"../lib\" document . body . style . background = \"black\"", "commit_type": "fix"}
{"commit_tokens": ["added", "better", "defaults", "to", "task"], "add_tokens": "width : 800 , urls : [ 'http://4waisenkinder.de' ]", "del_tokens": "width : 400 , urls : [ 'http://google.com' ]", "commit_type": "add"}
{"commit_tokens": ["Add", "naive", "pattern", "benchmark", "update", "readme"], "add_tokens": ". run ( ) ;", "del_tokens": ". run ( { 'async' : true } ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "the", "file", "extension", "from", "js", "to", "hbs"], "add_tokens": "path : \"/home/mattma/broken-promises/test/test1.hbs\" ,", "del_tokens": "path : \"/home/mattma/broken-promises/test/test1.js\" ,", "commit_type": "update"}
{"commit_tokens": ["fixing", "intersection", "vs", "count", "docs"], "add_tokens": "* @ function can - set . Algebra . prototype . count count", "del_tokens": "* @ function can - set . Algebra . prototype . intersection intersection", "commit_type": "fix"}
{"commit_tokens": ["Making", "marker", "drag", "end", "call", "repaint"], "add_tokens": "that . repaint ( ) ;", "del_tokens": "that . resetViewport ( ) ; that . redraw ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Allow", "chaining", "for", "combos", "creating"], "add_tokens": "this . _results = [ ] ; this . _results = this . _results . concat ( type ( Jsonium ) . is ( combos ) ? combos . getCombos ( ) : ( type ( Array ) . of ( Object ) . is ( combos ) ? combos : [ ] ) ) ; / ** * Move created combos to the templates * * @ returns { Jsonium } * / Jsonium . prototype . useCombosAsTemplates = function ( ) { this . _templates = cp ( this . _results ) ; return this ; } ;", "del_tokens": "this . _results . concat ( type ( Jsonium ) . is ( combos ) ? combos . getCombos ( ) : combos ) ;", "commit_type": "allow"}
{"commit_tokens": ["add", "a", "transformations", "prototype", "for", "changing", "attributes", "before", "they", "are"], "add_tokens": "required : true , // Custom Column Names can be used in an attributes object: columnName : 'login'", "del_tokens": "required : true", "commit_type": "add"}
{"commit_tokens": ["Adding", "tests", "against", "a", "stubbed", "out", "S3", "client"], "add_tokens": "var Uploader = require ( '../lib/s3-upload-stream.js' ) . Uploader , if ( err ) ) ;", "del_tokens": "var Uploader = require ( 's3-upload-stream' ) . Uploader , if ( err ) ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "module", "name", "and", "version", "parsing", "when", "separated", "by", "@"], "add_tokens": "var nameVersionParser = require ( './moduleName' ) ; var moduleName = nameVersionParser ( aModule ) . name ; return name === moduleName ;", "del_tokens": "return name === aModule ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bugs", ".", "Change", "PatternMatching", "tests", "coding", "expressions", "."], "add_tokens": "( adt ) => { let theType = TypeNull ; return adt === theType || theType . matches ( adt ) ? theType : undefined ; } , ( adt ) => { let theType = TypeInCaseOf ( ( v ) => ( ! ( TypeObject . matches ( v ) || TypeArray . matches ( v ) ) ) && TypeNaN . matches ( v ) ) ; return adt === TypeNaN || theType . matches ( adt ) ? theType : undefined ; } ,", "del_tokens": "( adt ) => { let theType = TypeNull ; // console.log('TypeNull'); return adt === theType || theType . matches ( adt ) ? theType : undefined ; } , ( adt ) => { let theType = TypeInCaseOf ( ( v ) => ( ! ( TypeObject . matches ( v ) || TypeArray . matches ( v ) ) ) && TypeNaN . matches ( v ) ) ; // console.log('TypeInCaseOf'); return adt === TypeNaN || theType . matches ( adt ) ? theType : undefined ; } , // console.log('TypeString'); // console.log('TypeNumber');", "commit_type": "fix"}
{"commit_tokens": ["Using", "$parse", "instead", "of", "crafting", "an", "expression", "by", "hand"], "add_tokens": "angular . module ( 'angular-inview' , [ ] ) . directive ( 'inView' , function ( $parse ) { var inViewFunc , item ; inViewFunc = $parse ( attrs . inView ) ; return scope . $apply ( function ( ) { return inViewFunc ( scope , { '$inview' : $inview , '$inviewpart' : $inviewpart } ) ; } ) ;", "del_tokens": "angular . module ( 'angular-inview' , [ ] ) . directive ( 'inView' , function ( ) { var item ; if ( $inviewpart ) { $inviewpart = \"'\" + $inviewpart + \"'\" ; } return scope . $apply ( \"$inview=\" + $inview + \";$inviewpart=\" + $inviewpart + \";\" + attrs . inView ) ;", "commit_type": "use"}
{"commit_tokens": ["Move", "validator", "into", "Strata", "."], "add_tokens": "function validator ( callback ) { return function ( forward ) { return check ( callback , forward ) } } function check ( callback , forward ) { ok ( forward , 'no forward function' ) ; ok ( callback , 'no callback function' ) ; return function ( error ) { if ( error ) { callback ( error ) ; } else { try { forward . apply ( null , __slice . call ( arguments , 1 ) ) ; } catch ( error ) { callback ( error ) ; } } } }", "del_tokens": "function validator ( callback ) { return function ( forward ) { return check ( callback , forward ) } } function check ( callback , forward ) { if ( ! forward ) throw Error ( \"No forward function.\" ) ; if ( ! callback ) throw Error ( \"No callback function.\" ) ; return function ( error ) { if ( error ) { callback ( error ) ; } else { try { forward . apply ( null , __slice . call ( arguments , 1 ) ) ; } catch ( error ) { callback ( error ) ; } } } }", "commit_type": "move"}
{"commit_tokens": ["Fixed", "a", "bug", "at", "copy", "watch", "directory"], "add_tokens": "watch . watchDirectory ( options . watchdirectory , options . exclude , function ( ) {", "del_tokens": "watch . watchDirectory ( options . watchdirectory , include , function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "dumb", "jshint", "issue", "."], "add_tokens": "} ; } ;", "del_tokens": "} }", "commit_type": "fix"}
{"commit_tokens": ["Allow", "a", "deep", "copy", "in", "kff", ".", "mixins", "function", "by", "passing", "true", "as", "the", "last", "argument", "."], "add_tokens": "* Function accepts multiple arguments with multiple extending objects * When passing true as the last argument , deep copy will be used * * @ param { Object } properties Extending object ( s ) var i = 1 , l = arguments . length , key , props , prop , objProp , deep = false ; if ( l > 2 && arguments [ l - 1 ] === true ) { deep = true ; l -- ; } for ( key in props ) { if ( props . hasOwnProperty ( key ) ) { prop = props [ key ] ; if ( deep && typeof prop === 'object' && prop !== null && prop . constructor === Object ) { objProp = obj [ key ] ; if ( typeof objProp !== 'object' || objProp === null ) objProp = { } ; kff . mixins ( objProp , prop , deep ) ; } else obj [ key ] = prop ; } }", "del_tokens": "* @ param { Object } properties Object by which to extend var i = 1 , l = arguments . length , key , props ; for ( key in props ) if ( props . hasOwnProperty ( key ) ) obj [ key ] = props [ key ] ;", "commit_type": "allow"}
{"commit_tokens": ["implement", "pattern", "/", "song", "jumps"], "add_tokens": "function eff_t0_b ( ch , data ) { // song jump (untested) if ( data < songpats . length ) { cur_songpos = data cur_pat = songpats [ cur_songpos ] ; } } function eff_t0_d ( ch , data ) { // pattern jump cur_songpos ++ ; if ( cur_songpos >= songpats . length ) cur_songpos = song_looppos ; cur_pat = songpats [ cur_songpos ] ; cur_row = data ; } eff_t0_b , // b eff_t0_d , // d eff_nop , // b eff_nop , // d eff_nop , // f", "del_tokens": "eff_unimplemented_t0 , // b eff_unimplemented_t0 , // d eff_unimplemented , // b eff_unimplemented , // d eff_unimplemented , // f", "commit_type": "implement"}
{"commit_tokens": ["added", "two", "way", "form", "binding", "plugin"], "add_tokens": "// the current library version var VERSION = \"1.1.0\" ; // no need for node js to hurt itself on any hard edges if ( ! process . browser ) return module . exports = { parse : require ( \"./m+xml\" ) . parse , VERSION : VERSION } ; // get on with the rest for the browser Mustache . VERSION = VERSION ;", "del_tokens": "Mustache . VERSION = \"1.1.0\" ;", "commit_type": "add"}
{"commit_tokens": ["Update", "ios", "-", "helper", ".", "js"], "add_tokens": "var script = \"./Fabric.framework/run\" + \"\\\"+ pluginConfig.apiKey + \" \\\" + pluginConfig . apiSecret ;", "del_tokens": "var script = \"/Fabric.framework/run \" + pluginConfig . apiKey + \" \" + pluginConfig . apiSecret ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "parsing", "of", "slide", "number", "option", "with", "more", "than", "one", "digit"], "add_tokens": "var regex = / (\\d+)(?:-(\\d+))? / g ;", "del_tokens": "var regex = / (\\d)+(?:-(\\d+))? / g ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "the", "children", "inherit", "the", "parent", "environment"], "add_tokens": "const env = Object . assign ( { } , process . env , { DP_PROJECT_ROOT : projectRoot } ) ; , { cwd : projectRoot , stdio : 'inherit' , env : env } const env = Object . assign ( { } , process . env , { DP_PROJECT_ROOT : projectRoot } ) ; , { cwd : projectRoot , stdio : 'inherit' , env : env } module . exports = DeskproProject ;", "del_tokens": ", { cwd : projectRoot , stdio : 'inherit' , env : { DP_PROJECT_ROOT : projectRoot , NODE_PATH : process . env . NODE_PATH } } , { cwd : projectRoot , stdio : 'inherit' , env : { DP_PROJECT_ROOT : projectRoot , NODE_PATH : process . env . NODE_PATH } } module . exports = DeskproProject ;", "commit_type": "make"}
{"commit_tokens": ["Add", "flexibility", "to", "eventlist", "placement"], "add_tokens": "var row = cell . closest ( '.cal-before-eventlist' ) ;", "del_tokens": "var row = that . closest ( '.cal-row-fluid' ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "initiatedOnce", "functionaty", "to", "store", "params", "as", "array", "of", "arrays", "added", "additional", "example", "to", "README", "created", "new", "test", "."], "add_tokens": "initiatedOnce [ name ] = ( initiatedOnce [ name ] || [ ] ) ; initiatedOnce [ name ] . push ( params ) ;", "del_tokens": "initiatedOnce [ name ] = ( initiatedOnce [ name ] || [ ] ) . concat ( params ) ;", "commit_type": "update"}
{"commit_tokens": ["use", "blacklist", "instead", "of", "whitelist", "for", "methods", "with", "bodies"], "add_tokens": "if ( opts . method !== 'GET' && opts . method !== 'HEAD' ) {", "del_tokens": "if ( opts . method === 'POST' || opts . method === 'PUT' || opts . method === 'PATCH' || opts . method === 'MERGE' ) {", "commit_type": "use"}
{"commit_tokens": ["Add", "photos", "to", "nested", "scrolling", "example"], "add_tokens": "var PhotoList = require ( '../photos' ) ; getInitialState : function ( ) { return { display : 'photos' , } ; } , toggle : function ( ) { this . setState ( { display : 'photos' === this . state . display ? 'patterns' : 'photos' , } ) ; } , { 'photos' === this . state . display && < PhotoList / > } { 'patterns' === this . state . display && < PatternsList / > } { 'photos' === this . state . display && < PhotoList / > } { 'patterns' === this . state . display && < PatternsList / > } < button onClick = { this . toggle } > Toggle between photos and CSS3 patterns < / button >", "del_tokens": "< PatternsList / > < PatternsList / >", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "to", "editor", "event", "handlers"], "add_tokens": "if ( container !== null ) { load ( container . getAttribute ( SECTION_TYPE_ATTR ) , container ) ; }", "del_tokens": "var type = container . getAttribute ( SECTION_TYPE_ATTR ) ; load ( type , container ) ;", "commit_type": "add"}
{"commit_tokens": ["Making", "space", "for", "new", "parser", "method", "in", "packet", ".", "js", "."], "add_tokens": "var pattern = require ( './__internal/pattern' ) . parse ; { pattern : packets [ nameOrPattern ] && packets [ nameOrPattern ] . pattern || pattern ( nameOrPattern ) { pattern : pattern ( nameOrPattern ) { pattern : pattern ( pattern ) { pattern : pattern ( nameOrPattern )", "del_tokens": "var parse = require ( './__internal/pattern' ) . parse ; { pattern : packets [ nameOrPattern ] && packets [ nameOrPattern ] . pattern || parse ( nameOrPattern ) { pattern : parse ( nameOrPattern ) { pattern : parse ( pattern ) { pattern : parse ( nameOrPattern )", "commit_type": "make"}
{"commit_tokens": ["fixed", "uuid", "room", "updates", "via", "api"], "add_tokens": "socket . broadcast . to ( uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid ) . emit ( 'message' , results ) ;", "del_tokens": "socket . broadcast . to ( uuid . uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid . uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid . uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid . uuid ) . emit ( 'message' , results ) ; socket . broadcast . to ( uuid . uuid ) . emit ( 'message' , results ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "setNetworkField", "function", "to", "modify", "values", "in", "network", "logs", "to", "tailor", "them", "to", "custom", "needs"], "add_tokens": "\"msg\" : \"\" ,", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Add", "ability", "to", "provide", "a", "target", "for", "links", "."], "add_tokens": "export function linkify ( textToLinkify , target ) { target = target || \"_self\" ; return ' <a href=\"' + s . trim ( ) + '\" target=\"' + target + '\">' + s . trim ( ) + '</a> ' ;", "del_tokens": "export function linkify ( textToLinkify ) { return ' <a href=\"' + s . trim ( ) + '\">' + s . trim ( ) + '</a> ' ;", "commit_type": "add"}
{"commit_tokens": ["Use", "a", "more", "universal", "shebang", "for", "CLI", "bin", "scripts"], "add_tokens": "#!/bin/sh ':' //; exec \"$(command -v nodejs || command -v node)\" \"$0\" \"$@\"", "del_tokens": "#!/usr/bin/env node 'use strict' ; // eslint-disable-line", "commit_type": "use"}
{"commit_tokens": ["Added", "--", "keeppath", "and", "--", "remotename", "options", "to", "upload", "command"], "add_tokens": "compile : false , keepPath : false config . keepPath = ( d . keepPath && d . keepPath === true ) ; // keep-path . option ( '-k, --keeppath' , 'Keep the original file path in the destination filename (i.e: static/test.html will be named static/test.html' , false ) . option ( '-n, --remotename <remotename>' , 'Set destination file name. Default is same as original' , false ) if ( ! options . keeppath ) { options . keeppath = defaults . keepPath ; }", "del_tokens": "compile : false", "commit_type": "add"}
{"commit_tokens": ["Fix", "scope", "end", "handling", "."], "add_tokens": "endScope ( scope ) . then ( function ( atScopeEnd ) { checkCharacter ( character ( ) , ',' ) ; walkString ( events . string ) . then ( endValue ) ;", "del_tokens": "console . log ( 'handleValue: ' + character ) ; console . log ( 'ignoreWhitespace: ' + character ( ) ) ; console . log ( 'walkString: ' + string ) ; endScope ( ) . then ( function ( atScopeEnd ) { next ( ) . then ( function ( character ) { checkCharacter ( character , ',' ) ; } ) ; console . log ( 'string' ) ; walkString ( events . string ) . then ( function ( ) { // TODO: Surely this defer is redundant??? next ( ) . then ( async . defer . bind ( null , endValue ) ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "character", "encoding", "test", "case", "."], "add_tokens": "res . send ( new Buffer ( \"<html><body>\\xc3\\xe5\\xe9\\xdc!</body></html>\" ) ) ;", "del_tokens": "res . send ( ` < html > < body > \\xc3\\xe5\\xe9\\xdc! < / body > < / html > `);", "commit_type": "fix"}
{"commit_tokens": ["Add", "secureDevice", "and", "manual", "test"], "add_tokens": "var SERVICE = 'testing' ; exports . defineManualTests = function ( contentEl , createActionButton ) { if ( cordova . platformId === 'android' ) { createActionButton ( 'Init tests for android' , function ( ) { alert ( 'You should run these tests twice. Oncee without screen locking, and once with screen locking set to PIN. When lock is disabled you should be prompted to set it.' ) ; ss = new cordova . plugins . SecureStorage ( function ( ) { alert ( 'Init successfull.' ) ; } , function ( ) { alert ( 'Init failed. The screen lock settings should now open. Set PIN or above.' ) ; ss . secureDevice ( function ( ) { } , function ( ) { } ) ; } , SERVICE ) ; } ) ; } } ;", "del_tokens": "var SERVICE = 'testing' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "bind", "context", "when", "calling", "loadPartials"], "add_tokens": "loadPartials . call ( this , template , file . path ) ; new gutil . PluginError ( 'gulp-mustache' , 'Unable to load partial file: ' + partialPath ) ) ;", "del_tokens": "loadPartials ( template , file . path ) ; new gutil . PluginError ( 'gulp-mustache' , \"Unable to load partial file: \" + partialPath ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "D2590", "-", "dataserviceadapter", "throws", "if", "ajax", "call", "throws"], "add_tokens": "Generated on: Tue May 06 2014 17:06:59 GMT-0700 (Pacific Daylight Time)", "del_tokens": "Generated on: Tue May 06 2014 12:40:38 GMT-0700 (Pacific Daylight Time)", "commit_type": "fix"}
{"commit_tokens": ["added", "tests", "for", "new", "asParam", "parameter", "propagation"], "add_tokens": "cls . fval = function ( ) { cls . fval_handler = function ( value , asParam ) { c = values . shift ( ) ; } ; cls . registerValueHandler ( cls . FuncVal , cls . fval_handler ) ; registerValueHandler : cls . registerValueHandler , fval : cls . fval", "del_tokens": "cls . func = function ( ) { cls . registerValueHandler ( cls . FuncVal , function ( value , asParam ) { c = values . unshift ( ) ; } ) ; registerValueHandler : cls . registerValueHandler", "commit_type": "add"}
{"commit_tokens": ["Move", "form", "test", "components", "to", "their", "own", "directory"], "add_tokens": "import Form from '../../resources/components/form/Form.vue' ; import Submit from '../../resources/components/form/Submit.vue' ;", "del_tokens": "import Form from '../../resources/components/Form.vue' ; import Submit from '../../resources/components/Submit.vue' ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "for", "component", "builds", ".", "Requiring", "component", "-", "emitter", "would", "fail", "inside", "component", "for", "whatever", "reason", ".", "Created", "a", "test", "object", "to", "handle", "this", "case", ".", "Bumped", "version", "a", "little", "."], "add_tokens": "var Emitter = ( typeof process != \"undefined\" ? require ( 'component-emitter' ) : require ( 'emitter' ) ) ;", "del_tokens": "var Emitter = require ( 'component-emitter' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Moved", "chickenKyiv", "functions", "to", "helper", ".", "js"], "add_tokens": "const { ingredients3 , menus , recipes , nutritions1 , nutritions2 , departments , users } = require ( './projects/ChickenKyiv/files' ) const getIngredients3 = function ( ) { return parser ( ingredients3 ) } const getMenu = function ( ) { return parser ( menus ) } const getRecipe = function ( ) { return parser ( recipes ) } const getNutritions1 = function ( ) { return parser ( nutritions1 ) } const getNutritions2 = function ( ) { return parser ( nutritions2 ) } const getDepartments = function ( ) { return parser ( departments ) } const getUsers = function ( ) { return parser ( users ) getIngredients3 , getMenu , getRecipe , getNutritions1 , getNutritions2 , getDepartments , getUsers", "del_tokens": "const __get = ( value ) => { return parser ( value ) __get", "commit_type": "move"}
{"commit_tokens": ["moving", "stuff", "around", "and", "getting", "the", "identity", "contract", "to", "mostly", "work", "with", "jquery"], "add_tokens": "/*global Proxy: true, */ if ( oc . hasOwnProperty ( name ) ) { // maybe this is wrong...allowing anything that isn't specified if ( oc . hasOwnProperty ( name ) ) { // maybe this is wrong...allowing anything that isn't specified return obj . apply ( this , arguments ) ; return obj . apply ( this , arguments ) ;", "del_tokens": "/*global Proxy: true */ if ( oc [ name ] ) { // maybe this is wrong...allowing anything that isn't specified if ( oc [ name ] ) { // maybe this is wrong...allowing anything that isn't specified return obj . apply ( args ) ; return obj . apply ( args ) ;", "commit_type": "move"}
{"commit_tokens": ["Adds", "test", "case", "for", "using", "globalName", "as", "a", "function"], "add_tokens": "test . done ( ) ; } , testExportWithGlobalNameFunction : function ( test ) { var babelOptions = getBabelOptions ( path . resolve ( 'foo/bar.js' ) , function ( state , filePath , name ) { return 'this.Test.Exports.' + ( name ? name : 'default' ) ; } ) ; var result = babel . transform ( 'export default foo;\\nexport {foo, bar};' , babelOptions ) ; var expectedResult = '(function () {\\n' + ' this.Test.Exports = {};\\n' + ' this.Test.Exports.default = foo;\\n' + ' this.Test.Exports.foo = foo;\\n' + ' this.Test.Exports.bar = bar;\\n' + '}).call(this);' ; assert . strictEqual ( expectedResult , result . code ) ; function getBabelOptions ( filename , globalName ) { globalName : globalName || 'myGlobal'", "del_tokens": "function getBabelOptions ( filename ) { globalName : 'myGlobal'", "commit_type": "add"}
{"commit_tokens": ["Use", "the", "fast", "shift", "for", "loading", "the", "database", "too", "."], "add_tokens": "queue . __proto__ = fastArray ; var next = queue . fastShift ( ) ;", "del_tokens": "var next = queue . shift ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "incorrect", "WOFF2", "media", "type"], "add_tokens": "url ( data : font / woff2 ; charset = utf - 8 ; base64 , $ { woff2 } ) format ( 'woff2' ) ,", "del_tokens": "url ( data : application / font - woff2 ; charset = utf - 8 ; base64 , $ { woff2 } ) format ( 'woff2' ) ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "hyper", "-", "schema", "links", "keyword", "."], "add_tokens": "this . watch_listener ( ) ; self . watch_listener ( ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Removed", "old", "delegate", "function", "when", "fetching", "module", "meta", "objects"], "add_tokens": "* @ returns { Promise } return Promise . resolve ( ) ; // If the module evaluation didn't register a new module, then we return whatever // was produced. // Right here is where we handle dynamic registration of modules while are being loaded. // E.g. System.register to register a module that's being loaded", "del_tokens": "* @ returns { Promise } A promise that when resolved will provide a delegate method * that can be called to build a Module instance return Promise . resolve ( getModuleDelegate ) ; // // Helper methods // return getModuleDelegate ; } function getModuleDelegate ( ) { return manager . getModule ( name ) ; // Right here is where we are handling when a module being loaded calls System.register // to register itself.", "commit_type": "remove"}
{"commit_tokens": ["Added", "zoom", "support", "to", "CSS", "3D", "renderer", "."], "add_tokens": "this . container = container ; var focal = 1 / Math . tan ( hfov / 2 ) ; console . log ( focal ) ; var zoom = focal * this . canvas . height / 2 + 'px' ; var transform = 'translate3d(0px, 0px, ' + zoom + ') rotateX(' + pitch + 'rad) rotateY(' + yaw + 'rad) rotateZ(0rad)' ; this . container . style . webkitPerspective = zoom ; this . container . style . perspective = zoom ;", "del_tokens": "var transform = 'translate3d(0px, 0px, 700px) rotateX(' + pitch + 'rad) rotateY(' + yaw + 'rad) rotateZ(0rad)' ;", "commit_type": "add"}
{"commit_tokens": ["updated", "downloading", "of", "resource", "container", "updated", "tests"], "add_tokens": "*", "del_tokens": "* todo : we need to properly load all of the formats", "commit_type": "update"}
{"commit_tokens": ["Add", "support", "for", "vendor", "prefixes", "in", "properties"], "add_tokens": "'matches' : { 1 : 'support.vendor-prefix' } , 'pattern' : / ( - o - | - moz - | - webkit - | - ms - ) ? [ \\w - ] + ( ? = \\s ? : ) ( ? ! . * \\{ ) / g", "del_tokens": "'pattern' : / [ \\w - ] + ( ? = \\s | : ) ( ? ! . * \\{ ) / g", "commit_type": "add"}
{"commit_tokens": ["Added", "showMousePointer", "config", "option", "to", "CanvasRecorder", "so", "that", "you", "can", "hide", "the", "mouse", "pointer", "if", "you", "dont", "want", "it", "to", "appear"], "add_tokens": "// Last time updated at Thursday, December 3rd, 2015, 9:54:34 PM grabMouse : typeof config . showMousePointer === 'undefined' || config . showMousePointer ,", "del_tokens": "// Last time updated at Tuesday, October 27th, 2015, 4:33:33 PM", "commit_type": "add"}
{"commit_tokens": ["updated", "readme", "updated", "package", ".", "json"], "add_tokens": "source : \"test/fixtures/default.html\" , outputDest : \"test/fixtures/default2.html\" ,", "del_tokens": "source : \"test/index.html\" , outputDest : \"test/index2.html\" ,", "commit_type": "update"}
{"commit_tokens": ["Added", "tests", "and", "stubs", "for", ".", "before", "()", "/", ".", "after", "()"], "add_tokens": "calls . should . eql ( [ 'before all' , 'before one' , 'after one' , 'before two' , 'after two' , 'before three' , 'after three' , 'after all' ] ) ; before ( function ( ) { calls . push ( 'before all' ) ; } ) ; after ( function ( ) { calls . push ( 'after all' ) ; } ) ; calls . should . eql ( [ 'before all' , 'before one' ] ) ; 'before all' , 'before one' 'before all' , 'before one' } )", "del_tokens": "calls . should . have . length ( 6 ) ; calls . should . eql ( [ 'before one' ] ) ; 'before one' 'before one' } )", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "HUD", "size", "smaller"], "add_tokens": "me . game . addHUD ( 0 , 0 , 480 , 30 ) ;", "del_tokens": "me . game . addHUD ( 0 , 0 , 480 , 100 ) ;", "commit_type": "make"}
{"commit_tokens": ["Removed", "extraneous", "argument", "for", "close", "all", "sync", "."], "add_tokens": "errorResult = this . ljm . LJM_CloseAll ( ) ;", "del_tokens": "errorResult = this . ljm . LJM_CloseAll ( 1 ) ;", "commit_type": "remove"}
{"commit_tokens": ["changed", "name", "building", "to", "use", "a", "regex"], "add_tokens": "'name' : '_Stub.js' , output [ i ] . name = ( path . replace ( / \\/ / g , '_' ) ) + output [ i ++ ] . name ; 'name' : ( targets [ path ] . replace ( / \\/ / g , '_' ) ) + '_Stub.js' ,", "del_tokens": "'name' : 'Stub.js' , output [ i ] . name = ( path . replace ( '/' , '_' ) ) + output [ i ++ ] . name ; 'name' : ( targets [ path ] . replace ( '/' , '_' ) ) + 'Stub.js' ,", "commit_type": "change"}
{"commit_tokens": ["added", "support", "for", "having", "a", "key", "be", "a", "composite", "type"], "add_tokens": "output . writeString ( new Buffer ( this . key , 'binary' ) ) ;", "del_tokens": "output . writeString ( this . key ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "API", "structure", "(", "seperated", "classes", ")"], "add_tokens": "exports . serializeString = serializeString ; exports . parseString = parseString ;", "del_tokens": "debugger ; exports . serializeString = serializeString ;", "commit_type": "update"}
{"commit_tokens": ["made", "http", "method", "for", "the", "products", "API", "configureable", "and", "put", "saved", "some", "demo", "data", "to", "hack", "offline"], "add_tokens": "return $http ( { method : cc . Config . apiHttpMethod , url : cc . Config . apiUrl + '&callback=JSON_CALLBACK' } ) . then ( function ( data ) { //FixMe we are effectively creating a memory leak here by caching all //seen products forever. This needs to be more sophisticated products [ categoryUrlId ] = data . data . products ; return data . data . products ; } ) ; return $http ( { method : 'get' , url : 'data/dasgibtesnureinmal/categories.json' } ) . then ( function ( data ) { self . categories = data . data ; augmentCategories ( self . categories ) ; currentCategory = self . categories ; return data . data ; } ) ;", "del_tokens": "return $http . jsonp ( cc . Config . apiUrl + '&callback=JSON_CALLBACK' ) . then ( function ( data ) { //FixMe we are effectively creating a memory leak here by caching all //seen products forever. This needs to be more sophisticated products [ categoryUrlId ] = data . data . products ; return data . data . products ; } ) ; return $http . get ( 'data/dasgibtesnureinmal/categories.json' ) . then ( function ( data ) { self . categories = data . data ; augmentCategories ( self . categories ) ; currentCategory = self . categories ; return data . data ; } ) ;", "commit_type": "make"}
{"commit_tokens": ["use", "css", "-", "select", "instead", "of", "CSSselect"], "add_tokens": "var cssSelect = require ( 'css-select' ) ; return cssSelect . selectOne ( selector , this ) || null ; return cssSelect ( selector , this ) ;", "del_tokens": "var cssSelect = require ( 'CSSselect' ) ; return cssSelect . selectOne ( selector , this . children ) || null ; return cssSelect ( selector , this . children ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "memoize", "test", "for", "getInitialBoard"], "add_tokens": "const board1 = Board . getInitialBoard ( Board . defaultBoardSize ) ; const board2 = Board . getInitialBoard ( Board . defaultBoardSize ) ; assert . equal ( board1 , board2 ) ;", "del_tokens": "// $FIX // const board1 = Board.getInitialBoard(Board.getBoardConf Board.defaultBoardSize); // const board2 = Board.getInitialBoard(Board.defaultBoardSize); // assert.equal(board1, board2);", "commit_type": "add"}
{"commit_tokens": ["Update", "the", "gulp", "config", "test", "only", "the", "main", "module"], "add_tokens": "return gulp . src ( './test/telegram.link.test.js' ) return gulp . src ( './test/telegram.link.test.js' )", "del_tokens": "return gulp . src ( './test/*.js' ) return gulp . src ( './test/*.js' )", "commit_type": "update"}
{"commit_tokens": ["allow", "for", "the", "ability", "to", "stream", "a", "git", "push", "command"], "add_tokens": "// - verbose: show output on the cli after execution, defaults to true // - stream: stream the command, defaults to false function execWrap ( command , verbose , stream ) { stream = typeof stream === 'undefined' ? false : stream ; if ( stream ) { verbose = false ; } var shellResult = shelljs . exec ( command , { silent : ( ! stream ) } ) ; execWrap ( 'git push ' + remoteName + ' ' + options . branch , false , true ) ;", "del_tokens": "// - verbose: show output on the cli, defaults to true function execWrap ( command , verbose ) { var shellResult = shelljs . exec ( command , { silent : true } ) ; execWrap ( 'git push ' + remoteName + ' ' + options . branch ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "support", "for", "function", "properties"], "add_tokens": "docket . title ( ` ` ) ;", "del_tokens": "docket . title ( ` ` ) ;", "commit_type": "add"}
{"commit_tokens": ["Upgraded", "SIGTERM", "to", "SIGKILL", "that", "should", "fix", "the", "phantomjs", "processes", "hanging", "around", "."], "add_tokens": "self . browserProcess . kill ( 'SIGKILL' )", "del_tokens": "self . browserProcess . kill ( 'SIGTERM' )", "commit_type": "upgrade"}
{"commit_tokens": ["Moving", "casper", "constructor", "to", "get", "cli", "options", "correctly", "in", "succss", "-", "bridge", ".", "js"], "add_tokens": "var dataFilePath = Succss . cliOptions . dataFile ; if ( fs . exists ( dataFilePath ) ) { phantom . injectJs ( dataFilePath ) ; } else { throw '[Succss] File \"' + dataFilePath + '\" not found. Please enter a valid relative path.' ; } Succss . casper = new casper . constructor ( Succss . allOptions ) ; Succss . mouse = require ( \"mouse\" ) . create ( Succss . casper ) ;", "del_tokens": "Succss . casper = new casper . constructor ( Succss . allOptions ) ; Succss . mouse = require ( \"mouse\" ) . create ( Succss . casper ) ; var dataFilePath = Succss . cliOptions . dataFile ; if ( fs . exists ( dataFilePath ) ) { phantom . injectJs ( dataFilePath ) ; } else { throw '[Succss] File \"' + dataFilePath + '\" not found. Please enter a valid relative path.' ; }", "commit_type": "move"}
{"commit_tokens": ["Add", "default", "value", "for", "titles", "."], "add_tokens": "page . title = $ ( 'title' ) . text ( ) || null ;", "del_tokens": "page . title = $ ( 'title' ) . text ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "icon", "to", "Data", "nav", "item"], "add_tokens": "data . buffer . push ( \"\\n Data\\n <svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n width=\\\"19px\\\" height=\\\"19px\\\" viewBox=\\\"0 0 19 19\\\" enable-background=\\\"new 0 0 19 19\\\" xml:space=\\\"preserve\\\">\\n <path d=\\\"M9.5,0.001C3.907,0.001,0,1.507,0,3.663v11.675C0,17.494,3.907,19,9.5,19c5.594,0,9.5-1.506,9.5-3.662V3.663\\n C19,1.507,15.094,0.001,9.5,0.001z M9.5,5.669c-4.768,0-7.81-1.318-7.81-2.007c0-0.689,3.042-2.008,7.81-2.008\\n c4.769,0,7.81,1.318,7.81,2.008C17.31,4.352,14.269,5.669,9.5,5.669z M17.31,15.338c0,0.689-3.041,2.007-7.81,2.007\\n c-4.768,0-7.81-1.317-7.81-2.007V5.852C3.39,6.77,6.282,7.324,9.5,7.324c3.217,0,6.108-0.554,7.81-1.472V15.338z\\\"/>\\n </svg>\\n \" ) ;", "del_tokens": "data . buffer . push ( \"\\n Data\\n \" ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "unneeded", "quotes", "on", "fieldnames", "if", "present"], "add_tokens": "field = ' (feature->\\'properties\\'->>\\'' + terms [ 0 ] . replace ( / \\'([^\\']*)' / g , \"$1\" ) + '\\')' ;", "del_tokens": "field = ' (feature->\\'properties\\'->>\\'' + terms [ 0 ] + '\\')' ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "edge", "creation", "to", "work", "with", "new", "navmesh", "polygon", "generation", "."], "add_tokens": "//this.original_polys = parsedMap.walls.concat(parsedMap.obstacles); //this.original_polys.forEach(function(poly) { areas . forEach ( function ( area ) { var polys = [ area . polygon ] . concat ( area . holes ) ; polys . forEach ( function ( poly ) { for ( var i = 0 , j = poly . numpoints - 1 ; i < poly . numpoints ; j = i ++ ) { this . obstacle_edges . push ( new Edge ( poly . points [ j ] , poly . points [ i ] ) ) ; } } , this ) ;", "del_tokens": "this . original_polys = parsedMap . walls . concat ( parsedMap . obstacles ) ; this . original_polys . forEach ( function ( poly ) { for ( var i = 0 , j = poly . numpoints - 1 ; i < poly . numpoints ; j = i ++ ) { this . obstacle_edges . push ( new Edge ( poly . points [ j ] , poly . points [ i ] ) ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Update", "for", "Hta", "-", "Sin", "-", "Htoo", "a", "Sint"], "add_tokens": "[ / [\\u1073\\u1074] / g , '\\u1039\\u1011' ] ,", "del_tokens": "[ / \\u1073 / g , '\\u1039\\u1011' ] ,", "commit_type": "update"}
{"commit_tokens": ["Fix", "value", "parsing", "and", "striping", "spaces", "around", "every", "slash"], "add_tokens": "function walkTrim ( nodes ) { var i ; parser . trim ( nodes ) ; for ( i = nodes . length - 1 ; ~ i ; i -= 1 ) { if ( nodes [ i ] . type === 'function' ) { walkTrim ( nodes [ i ] . nodes ) ; } } } if ( node . value === 'calc' ) { walkTrim ( node . nodes ) ; return false ; } if ( ! ~ functions . indexOf ( node . value ) ) { if ( node . type === 'div' ) {", "del_tokens": "if ( ! ~ functions . indexOf ( node . value ) ) { if ( node . type === 'div' && node . value === ',' ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "unit", "test", "for", "enveloped", "transformation", "with", "inclusivenamespaces"], "add_tokens": "passLoadSignature ( test , \"./test/static/valid_signature.xml\" ) passLoadSignature ( test , \"./test/static/valid_signature.xml\" , true ) passLoadSignature ( test , \"./test/static/valid_signature_with_root_level_sig_namespace.xml\" ) passValidSignature ( test , \"./test/static/valid_signature_with_lowercase_id_attribute.xml\" ) passValidSignature ( test , \"./test/static/valid_signature_with_unused_prefixes.xml\" ) var node = select ( \"//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\" , doc ) [ 0 ]", "del_tokens": "passLoadSignature ( test , \"./test/static/valid_signature.xml\" ) ; passLoadSignature ( test , \"./test/static/valid_signature.xml\" , true ) ; passLoadSignature ( test , \"./test/static/valid_signature_with_root_level_sig_namespace.xml\" ) ; passValidSignature ( test , \"./test/static/valid_signature_with_lowercase_id_attribute.xml\" ) ; var node = select ( \"/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\" , doc ) [ 0 ]", "commit_type": "add"}
{"commit_tokens": ["Updated", "the", "way", "params", "and", "returns", "are", "parsed"], "add_tokens": "var types = \"(?:null|\\\\*|number|color|string|list|map|bool|arglist)\" ; var multipleTypes = \"\\\\{\\\\s*(\" + types + \"(?:\\\\s*\\\\|\\\\s*\" + types + \")*)\\\\s*\\\\}\" ; var re = new RegExp ( \"^@(?:param|arg|argument)\\\\s+\" + multipleTypes + \"\\\\s+\\\\$([\\\\w-]+)(?:\\\\s+\\\\((.+)\\\\))?(?:\\\\s+-?\\\\s*(.+))?\" , \"i\" ) ; return line . match ( re ) ; var re = new RegExp ( \"^@returns?(?:\\\\s+\" + multipleTypes + \")(?:\\\\s+(.+))?\" , \"i\" ) ; return line . match ( re ) ;", "del_tokens": "return line . match ( / ^@(?:param|arg|argument)(?:\\s+{\\s*([\\w-](?:\\s*\\|?\\s*[\\w-])*)\\s*})?\\s+(?:\\$([\\w-]+))(?:\\s+\\(([\\w-\\s]+)\\))?(?:\\s+-\\s*?([\\w-\\s]+))? / i ) ; return line . match ( / ^@returns?(?:\\s+{\\s*([\\w-](?:\\s*\\|?\\s*[\\w-])*)\\s*})(?:\\s+([\\w-\\s]*))? / i ) ;", "commit_type": "update"}
{"commit_tokens": ["add", "forceInclude", "func", ":", "snaps", "to", "entire", "word"], "add_tokens": "/ ** * Force the Selection to include entire / expanded Words . * @ see http : //stackoverflow.com/questions/7380190/select-whole-word-with-getselection * @ param { Selection } sel * / function forceInclude ( sel ) { sel = sel || win . getSelection ( ) ; if ( isCollapsed ( sel ) ) return ; var dir = [ 'forward' , 'backward' ] ; isBackwards ( sel ) && dir . reverse ( ) ; // modify() works on the focus of the selection sel . collapse ( sel . anchorNode , sel . anchorOffset ) ; sel . modify ( 'move' , dir [ 0 ] , 'character' ) ; sel . modify ( 'move' , dir [ 1 ] , 'word' ) ; sel . extend ( sel . focusNode , sel . focusOffset ) ; sel . modify ( 'extend' , dir [ 1 ] , 'character' ) ; sel . modify ( 'extend' , dir [ 0 ] , 'word' ) ; } forceInclude : forceInclude ,", "del_tokens": "// snapToWord: snapToWord,", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "with", "ternary", "expressions", "in", "compile"], "add_tokens": "if ( links . length === 1 && ! continuation && ! parens [ paren ] ) {", "del_tokens": "if ( links . length === 1 && ! continuation && ! paren ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "tslint", ".", "fix", "command", "to", "the", "command", "palette"], "add_tokens": "let lastArgs = null const doLintForProject = ( args , autoFix ) => { lastArgs = args executeTsLint ( tslint , processArgs , currentWorkingDirectory , autoFix ) Oni . commands . registerCommand ( \"tslint.fix\" , ( args ) => { doLintForProject ( lastArgs , true ) } ) function executeTsLint ( configPath , args , workingDirectory , autoFix ) { let processArgs = [ ] if ( autoFix ) { processArgs = processArgs . concat ( [ \"--fix\" ] ) } processArgs = processArgs . concat ( [ \"--force\" , \"--format json\" ] )", "del_tokens": "const doLintForProject = ( args ) => { executeTsLint ( tslint , processArgs , currentWorkingDirectory ) function executeTsLint ( configPath , args , workingDirectory ) { let processArgs = [ \"--force\" , \"--format json\" ]", "commit_type": "add"}
{"commit_tokens": ["add", "moveBack", "option", "into", "js"], "add_tokens": "minimizeApp : function ( moveBack ) { return exec ( null , null , APP_PLUGIN_NAME , \"minimizeApp\" , [ moveBack ] ) ; } ;", "del_tokens": "minimizeApp : function ( ) { return exec ( null , null , APP_PLUGIN_NAME , \"minimizeApp\" , [ ] ) ; }", "commit_type": "add"}
{"commit_tokens": ["Fixed", ".", "to", "(", ")", ".", "map"], "add_tokens": "const type = typeof p . initial ; p . initialType = type !== 'object' ? type : getType ( p . initial ) ; const type = typeof value ; this . p . initialType = value != null && value !== 'object' ? type : getType ( value ) ;", "del_tokens": "p . initialType = getType ( p . initial ) ; this . p . initialType = getType ( value ) ;", "commit_type": "fix"}
{"commit_tokens": ["adding", "possibility", "to", "weakly", "reference", "an", "async", "wire"], "add_tokens": "var ref = { } ; wire = viperHTML . async ( ref ) ; tressa . assert ( wire === viperHTML . async ( ref ) , 'weakly referenced async wires' ) ;", "del_tokens": "wire = viperHTML . async ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "jschardet", "error", "in", "Node", "v6"], "add_tokens": "var _charset ; try { _charset = charset ( proxyRes , chunk ) || jschardet . detect ( chunk ) . encoding . toLowerCase ( ) ; } catch ( e ) { console . error ( e ) ; }", "del_tokens": "var _charset = charset ( proxyRes , chunk ) || jschardet . detect ( chunk ) . encoding . toLowerCase ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "memleak", "in", "ipc", ".", "js"], "add_tokens": "this . supervisedProcess . child . removeListener ( 'message' , waitForReturnValue )", "del_tokens": "this . supervisedProcess . removeListener ( 'message' , waitForReturnValue )", "commit_type": "fix"}
{"commit_tokens": ["adds", "notif", "for", "projects", "that", "don", "t", "exist"], "add_tokens": "if ( err ) { console . log ( chalk . yellow ( 'Oops! Travis doesn\\'t seem know about this project yet.' ) ) ; console . log ( chalk . yellow ( 'Check to make sure your projects are up-to-date.' ) ) ; process . exit ( 0 ) ; }", "del_tokens": "if ( err ) throw ( err ) ;", "commit_type": "add"}
{"commit_tokens": ["Improve", "performance", "of", "object", "creation", "from", "at", "least", "20%", "to", "200%", "(", "at", "least", "on", "V8", ")", "."], "add_tokens": "var deepClone = require ( 'mout/lang/deepClone' ) ; var factory = function factory ( properties , args ) { var state = properties ? merge ( { } , fixed . state , properties ) : deepClone ( fixed . state ) , instance = mixIn ( create ( fixed . methods ) , state ) ; if ( fixed . enclose . length > 0 ) { args = args && slice . call ( arguments , 1 ) ; forEach ( fixed . enclose , function ( fn ) { } return instance ; } ;", "del_tokens": "var factory = function factory ( properties ) { var state = merge ( { } , fixed . state , properties ) , instance = mixIn ( create ( fixed . methods ) , state ) , closures = fixed . enclose , args = slice . call ( arguments , 1 ) ; forEach ( closures , function ( fn ) { return instance ; } ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "start", "task", "on", "Windows"], "add_tokens": "var isRunning = require ( 'is-running' ) ; var pid = parseInt ( data ) ; if ( ! isRunning ( pid ) ) { start ( ) ; }", "del_tokens": "exec ( 'kill -0 ' + data , function ( error , stdout , stderr ) { if ( / no such process / i . test ( stderr ) ) start ( ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removing", "_init", "method", "from", "part", "interface"], "add_tokens": "partModule . __viewPartial = fs . readFileSync ( partViewPath , 'utf8' ) ;", "del_tokens": "var view = fs . readFileSync ( partViewPath , 'utf8' ) ; partModule . init ( view ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "Relative", "Path", "for", "Electron"], "add_tokens": "if ( ! $ ( \"link[href='player/css/webchimera.css']\" ) . length ) $ ( '<link href=\"player/css/webchimera.css\" rel=\"stylesheet\">' ) . appendTo ( \"head\" ) ;", "del_tokens": "if ( ! $ ( \"link[href='/player/css/webchimera.css']\" ) . length ) $ ( '<link href=\"/player/css/webchimera.css\" rel=\"stylesheet\">' ) . appendTo ( \"head\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "issues", "14", "15", ";", "fixed", "XOR"], "add_tokens": "else if ( node . op . match ( / xor / ) ) { return execute ( '(__arg1 || __arg2) && !(__arg1 && __arg2)' , data ) ; } return execute ( '__arg1 ' + node . op + ' __arg2' , data ) ; var a = null ; try { a = execute ( node . arr , data ) ; } catch ( e ) { } if ( ! a ) { a = trimQuotes ( node . arr ) ; } re : / \\s+xor\\s+ / , parseOperator ( 'xor' , 'binary' , 12 , e . tree ) ; if ( s . match ( / ^[|](\\w+)(?:\\s*(:)\\s*)? / ) )", "del_tokens": "return execute ( '__arg1 ' + node . op + '__arg2' , data ) ; var a = ( node . arr in data ) ? data [ node . arr ] : trimQuotes ( node . arr ) ; re : / \\s+xor\\s+ / , //TODO parseOperator ( RegExp . $1 , 'binary' , 12 , e . tree ) ; if ( s . match ( / ^[|](\\w+)(?:\\s*(:)\\s*)? / ) && ( RegExp . $1 in modifiers || RegExp . $1 == 'default' || eval ( 'typeof ' + RegExp . $1 ) == 'function' ) )", "commit_type": "fix"}
{"commit_tokens": ["Fix", "font", "paths", "static", "files", "in", "build", "process", "add", "autoprefixer"], "add_tokens": "fonts : 'build/demo/font' , 'node_modules/materialize-css/font/material-design-icons/*' const config = { autoprefixer : { browsers : [ 'last 2 Chrome versions' , 'last 2 Edge versions' , 'Firefox ESR' , 'IE 11' , '> 3%' ] , cascade : false } } ; paths , config", "del_tokens": "fonts : 'build/demo/font/roboto' , 'node_modules/materialize-css/font/material-design-icons/.*' paths", "commit_type": "fix"}
{"commit_tokens": ["Remove", "unused", "function", "Board", ".", "getStartRow"], "add_tokens": "export { defaultBoardSize , defaultBoardConf , getBoardAfterMove , clean , getInitialBoard , getToSearchOrder , getBoardConf , getColorStartEndRow , getJumpPosition , getNearPositions , getPosition , getPositionsWhereCanIGo , getY0Start7End , getY7Start0End , isBackGroundBlack , isBlackHome , isWhiteHome , printUnicode , whereCanIJump , setPosition , setWhereCanIGo , hasPosition } ;", "del_tokens": "function getStartRow ( boardConf , isBlack ) { const color = isBlack ? boardConf . black : boardConf . white ; return color . startRow ; } export { defaultBoardSize , defaultBoardConf , getBoardAfterMove , clean , getInitialBoard , getToSearchOrder , getBoardConf , getColorStartEndRow , getJumpPosition , getNearPositions , getPosition , getPositionsWhereCanIGo , getStartRow , getY0Start7End , getY7Start0End , isBackGroundBlack , isBlackHome , isWhiteHome , printUnicode , whereCanIJump , setPosition , setWhereCanIGo , hasPosition } ;", "commit_type": "remove"}
{"commit_tokens": ["move", "infiniteQueryParams", "route", "mixin", "method", "to", "more", "general", "mixin", "case"], "add_tokens": "} )", "del_tokens": "Allows a modelName and query to be specified in the method rather than defining properties for infiniteModelName and infiniteQueryParams on the route . @ method infiniteQuery @ param modelName { String } the model to be queried @ param params { Object } params to use in the query * / infiniteQuery ( modelName , params ) { if ( modelName ) { this . set ( 'infiniteModelName' , modelName ) ; } if ( params ) { let paramsToSet = Ember . keys ( params ) ; this . set ( 'infiniteQueryParams' , paramsToSet ) ; this . setProperties ( params ) ; } return this . _super . apply ( this , arguments ) ; } , / ** } ) , actions : { / ** Sends ` ` @ event didTransition * / didTransition : function ( ) { let cycle = this . get ( 'cycleCount' ) ; if ( cycle < 1 ) { this . send ( 'performInfinite' ) ; } } }", "commit_type": "move"}
{"commit_tokens": ["Add", "travis", "+", "update", "tests"], "add_tokens": "t . equals ( e . features [ 0 ] . text , 'London Market' , 'Result is returned within a bbox' ) ; geocoder . query ( 'Canada' ) ;", "del_tokens": "t . equals ( e . features [ 0 ] . text , 'London Street' , 'Result is returned within a bbox' ) ; geocoder . query ( 'United States' ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "al", "-", "repeat", "fast", "binding"], "add_tokens": "version : '0.14.0-alpha9' , date : '2017-01-13'", "del_tokens": "version : '0.14.0-alpha8' , date : '2017-01-08'", "commit_type": "fix"}
{"commit_tokens": ["Allow", "request", "body", "-", "only", "assets", "from", "Server"], "add_tokens": "* Server # compile ( pathname , bundle , callback ( err , asset ) ) - > Void * - bundle ( Boolean ) Server . prototype . compile = function compile ( pathname , bundle , callback ) { : this . environment . findAsset ( pathname , { bundle : ! ! bundle } ) ; bundle = ! / body=[1t] / . exec ( url . parse ( req . url ) ) , this . compile ( pathname , bundle , function ( err , asset ) {", "del_tokens": "* Server # compile ( pathname , callback ( err , asset ) ) - > Void Server . prototype . compile = function compile ( pathname , callback ) { : this . environment . findAsset ( pathname , { bundle : true } ) ; this . compile ( pathname , function ( err , asset ) {", "commit_type": "allow"}
{"commit_tokens": ["Add", "missing", "call", "to", "passTurn"], "add_tokens": "if ( typeof argv . time !== undefined ) {", "del_tokens": "if ( argv . time ) {", "commit_type": "add"}
{"commit_tokens": ["Improving", "side", "-", "menu", "control", "and", "root", "references", "."], "add_tokens": "// Find common root definitions (tilde references). var tildes = { } ; var re = / ^\\s*\\[(~\\d?)]\\s*: / g ; // Search common root pattern. var result = re . exec ( line ) ; if ( result ) { // Save common root value. tildes [ result [ 1 ] ] = line . substring ( line . indexOf ( ':' ) + 1 ) . trim ( ) ; // Remove this line from references. // Replace tilde+number pairs with common roots. var noIndex = false ; for ( var attr in tildes ) { if ( tildes . hasOwnProperty ( attr ) ) { if ( attr === '~' ) noIndex = true ; else { var re_n = new RegExp ( ' ' + attr , 'g' ) ; var re_value = ' ' + tildes [ attr ] ; text = text . replace ( re_n , re_value ) ; } } // Finally replace tildes with its common root. if ( noIndex ) text = text . replace ( / ~ / g , ' ' + tildes [ '~' ] ) ;", "del_tokens": "// Find common root definition (tilde reference). var tilde = '' ; if ( line . length >= 5 && line . substr ( 0 , 5 ) === '[~]: ' ) { tilde = line . substr ( 5 ) . trim ( ) ; break ; // Replace tildes with common root. if ( tilde ) { text = text . replace ( / ~ / g , ' ' + tilde ) ;", "commit_type": "improve"}
{"commit_tokens": ["add", "verify", "and", "recover", "methods"], "add_tokens": "var verify = function ( message , signature , publicKey ) { return secp256k1 . verify ( toBuffer ( message ) , toBuffer ( signature ) , toBuffer ( publicKey ) ) ; } ; var recover = function ( message , signature , recovery , compressed ) { return secp256k1 . recover ( toBuffer ( message ) , toBuffer ( signature ) , recovery , compressed ) ; } ; sign : sign , verify : verify , recover : recover", "del_tokens": "sign : sign", "commit_type": "add"}
{"commit_tokens": ["Added", "keyPress", "support", "in", "Window"], "add_tokens": "KeyboardEvent . KEY_DOWN = 'keydown' ; KeyboardEvent . KEY_PRESS = 'keypress' ; KeyboardEvent . KEY_UP = 'keyup' ;", "del_tokens": "KeyboardEvent . KEY_DOWN = 'keydown' ; KeyboardEvent . KEY_UP = 'keyup' ;", "commit_type": "add"}
{"commit_tokens": ["improved", "Function", ".", "prototype", ".", "async", "()", "added", "examples", "/", "simple2", ".", "js", "demonstration", "&", "tests"], "add_tokens": "var someSyncFunction = function ( file ) { } . async ( ) // <-- Turn someSyncFunction to asynchronous one someSyncFunction ( __filename , function ( err , source ) {", "del_tokens": "function someSyncFunction ( file ) { } // Turn someSyncFunction to asynchronous one var someSyncFunctionAsync = someSyncFunction . async ( null ) ; someSyncFunctionAsync ( __filename , function ( err , source ) {", "commit_type": "improve"}
{"commit_tokens": ["Added", "in", "files", "to", "assert", "against", "and", "everything", "works", "as", "expected", "=", "D"], "add_tokens": "// DEV: Write out fonts to files // if (true) { if ( false ) { // ANTI-PATTERN: Using a forEach for distinguishable items -- losing sense of the context/stackTrace [ 'svg' , 'eot' , 'ttf' , 'woff' ] . forEach ( function ( ext ) { var filepath = __dirname + '/expected_files/font.' + ext , actualContent = fonts [ ext ] , expectedContent = fs . readFileSync ( filepath , 'binary' ) ; assert . strictEqual ( actualContent , expectedContent ) ; } ) ;", "del_tokens": "// DEV: Write out fonts to files if ( true ) { fs . writeFileSync ( __dirname + '/actual_files/font.otf' , fonts . otf , 'binary' ) ; // TODO: Assert against expected_files // console.log(fonts);", "commit_type": "add"}
{"commit_tokens": ["added", "run", "for", "eager", "init"], "add_tokens": "if ( ! facet ) return ; if ( Array . isArray ( facet ) ) { m [ name ] = facet ; } else if ( typeof facet === 'function' ) { m [ name ] = [ 'factory' , facet ] ; } var injector = new di . Injector ( m ) ; injector . run = injector . invoke ;", "del_tokens": "m [ name ] = Array . isArray ( facet ) ? facet : [ typeof facet === 'function' ? 'factory' : 'value' , facet ] ; return new di . Injector ( m ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "positionDropdown", "()", "function", "as", "option", "."], "add_tokens": "var select3 = this . select3 ; var positionDropdown = select3 . options . positionDropdown || function ( $el , $selectEl ) { var offset = $selectEl . offset ( ) ; $el . css ( { left : offset . left + 'px' , top : offset . top + $selectEl . height ( ) + 'px' } ) . width ( $selectEl . width ( ) ) ; } ; positionDropdown ( this . $el , select3 . $el ) ;", "del_tokens": "var $selectEl = this . select3 . $el ; var offset = $selectEl . offset ( ) ; this . $el . css ( { left : offset . left + 'px' , top : offset . top + $selectEl . height ( ) + 'px' } ) . width ( $selectEl . width ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "undoable", "expand", "/", "collapse"], "add_tokens": "var ur ; if ( opts . undoable && ! ur ) ur = cy . undoRedo ( { defaultActions : false } ) ; if ( node . isCollapsible ( ) ) if ( opts . undoable ) ur . do ( \"collapse\" , { nodes : node , options : opts } ) ; else node . collapse ( opts ) ; else if ( node . isExpandable ( ) ) if ( opts . undoable ) ur . do ( \"expand\" , { nodes : node , options : opts } ) ; else node . expand ( opts ) ; undoRedoUtilities ( ) ;", "del_tokens": "if ( node . isCollapsible ( ) ) { node . collapse ( ) ; } else { node . expand ( ) ; } undoRedoUtilities ( options . undoable ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "less", "-", "loader", "to", "work", "with", "less", "2", ".", "x"], "add_tokens": "} ;", "del_tokens": "}", "commit_type": "update"}
{"commit_tokens": ["Add", "url", "and", "originalURL", "properties"], "add_tokens": ", enclosure , originalURL , updated , url ) { this . enclosure = enclosure this . originalURL = originalURL this . url = url , originalURL , updated , url ) { this . originalURL = originalURL this . url = url", "del_tokens": ", enclosure , feed , updated ) { this . enclosure = enclosure , updated ) {", "commit_type": "add"}
{"commit_tokens": ["use", "url", "instead", "of", "original", "url"], "add_tokens": "let matches = IMAGE_REGEX . xexec ( req . url ) ;", "del_tokens": "let matches = IMAGE_REGEX . xexec ( req . originalUrl ) ;", "commit_type": "use"}
{"commit_tokens": ["Move", "Less", "entrypoint", "into", "src", "dir"], "add_tokens": "return gulp . src ( './src/capital-framework.less' )", "del_tokens": "return gulp . src ( './capital-framework.less' )", "commit_type": "move"}
{"commit_tokens": ["fixed", "abstract", "method", "in", "Node"], "add_tokens": "accept : common . abstract", "del_tokens": "computeAttribute : common . abstract", "commit_type": "fix"}
{"commit_tokens": ["adding", "check", "for", "valid", "node", "to", "obm", "settings", "retrieval", "in", "run", "work", "items", "job"], "add_tokens": "if ( node ) { var obmSetting = _ . find ( node . obmSettings , { service : 'ipmi-obm-service' } ) ; if ( obmSetting ) { return obmSetting . config ; }", "del_tokens": "var obmSetting = _ . find ( node . obmSettings , { service : 'ipmi-obm-service' } ) ; if ( obmSetting ) { return obmSetting . config ;", "commit_type": "add"}
{"commit_tokens": ["Add", ":", "support", "more", "expect", "type", ":", "notContain"], "add_tokens": "'<li><label>' + __ ( 'dialog_expect_compare' ) + '</label><select id=\"uirecorder-expect-compare\"><option>equal</option><option>notEqual</option><option>contain</option><option>notContain</option><option>above</option><option>below</option><option>match</option><option>notMatch</option></select></li>' ,", "del_tokens": "'<li><label>' + __ ( 'dialog_expect_compare' ) + '</label><select id=\"uirecorder-expect-compare\"><option>equal</option><option>notEqual</option><option>contain</option><option>above</option><option>below</option><option>match</option><option>notMatch</option></select></li>' ,", "commit_type": "add"}
{"commit_tokens": ["move", "away", "from", "eval", "()", "!", "Use", "new", "Function", "instead"], "add_tokens": "new Function ( data ) . call ( obj ) ;", "del_tokens": "var read = function ( data ) { eval ( data ) ; } read . apply ( obj , Array ( data ) ) ;", "commit_type": "move"}
{"commit_tokens": ["Make", "sure", "to", "have", "a", "fall", "back"], "add_tokens": "return new Array ( ( count || 0 ) + 1 ) . join ( value || ' ' ) ; var num = '' ;", "del_tokens": "return new Array ( count + 1 ) . join ( value || ' ' ) ;", "commit_type": "make"}
{"commit_tokens": ["make", "mip", "-", "mapping", "on", "by", "default"], "add_tokens": "minFilter : WebGLConstants . NEAREST_MIPMAP_LINEAR ,", "del_tokens": "minFilter : WebGLConstants . LINEAR ,", "commit_type": "make"}
{"commit_tokens": ["add", "channel", "add", "rid", "view", "vars"], "add_tokens": "html += '<form action=\"/api/pico/' + pico . id + '/new-channel\" method=\"GET\">' ; html += '<input type=\"text\" name=\"name\" placeholder=\"name...\">' ; html += '<input type=\"text\" name=\"type\" placeholder=\"type...\">' ; html += '<button type=\"submit\">add channel</button>' ; html += '</form>' ; html += '<form action=\"/api/pico/' + pico . id + '/add-ruleset\" method=\"GET\">' ; html += '<input type=\"text\" name=\"rid\" placeholder=\"Ruleset id...\">' ; html += '<button type=\"submit\">add ruleset</button>' ; html += '</form>' ; html += '<h4>`ent` Variables</h4>' ; html += '<ul>' ; _ . each ( pico . vars , function ( v , k ) { html += '<li>' + k + ' = ' + v + '</li>' ; } ) html += '</ul>' ; router . set ( '/api/pico/:id/add-ruleset' , function ( req , res , route ) { var rid = route . data . rid ;", "del_tokens": "router . set ( '/api/pico/:id/add-ruleset/:rid' , function ( req , res , route ) { var rid = route . params . rid ;", "commit_type": "add"}
{"commit_tokens": ["Use", "can", "-", "assign", "instead", "of", "can", "-", "util", "/", "js", "/", "assign", "/"], "add_tokens": "var assign = require ( \"can-assign\" ) ;", "del_tokens": "var assign = require ( \"can-util/js/assign/assign\" ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "some", "api", "functions", ";", "queClear", "close", "closeAll"], "add_tokens": "$ . each ( notification . options . buttons , function ( i , button ) { $ . noty . clearQue = function ( ) { $ . noty . que = [ ] ; } ; $ . noty . close = function ( ) { $ ( '.noty_bar:first' ) . trigger ( 'noty.close' ) ; } ; $ . noty . closeAll = function ( ) { $ . noty . clearQue ( ) ; $ ( '.noty_bar' ) . trigger ( 'noty.close' ) ; } ; $ . noty . available = true ;", "del_tokens": "$ ( '#noty_que_list' ) . prepend ( $ ( '<li/>' ) . addClass ( base . options . type ) . html ( base . options . type ) ) ; $ ( '#noty_que_list' ) . append ( $ ( '<li/>' ) . addClass ( base . options . type ) . html ( base . options . type ) ) ; $ ( '#noty_que_list li:last' ) . slideUp ( ) . remove ( ) ; $ ( '#noty_que_list li:first' ) . slideUp ( ) . remove ( ) ; $ . each ( notification . options . buttons , function ( i , v ) { var button = v , $ . noty . available = true ;", "commit_type": "add"}
{"commit_tokens": ["added", "limit", "for", "runStep", "fixed", "some", "nodes"], "add_tokens": "* @ param { Boolean } do_not_catch_errors [ optional ] if you want to try / catch errors * @ param { number } limit max number of nodes to execute ( used to execute from start to a node ) LGraph . prototype . runStep = function ( num , do_not_catch_errors , limit ) { limit = limit || nodes . length ; for ( var j = 0 ; j < limit ; ++ j ) { for ( var j = 0 ; j < limit ; ++ j ) {", "del_tokens": "LGraph . prototype . runStep = function ( num , do_not_catch_errors ) { for ( var j = 0 , l = nodes . length ; j < l ; ++ j ) { for ( var j = 0 , l = nodes . length ; j < l ; ++ j ) {", "commit_type": "add"}
{"commit_tokens": ["Update", "common", "logger", "dependency", "module"], "add_tokens": "var SplunkLogger = require ( \"splunk-logging\" ) . Logger ;", "del_tokens": "var SplunkLogger = require ( \"splunk-logging\" ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "comments", "and", "test", "for", "Map", "type"], "add_tokens": "// Date, RegEx and other Built-ins are handled above", "del_tokens": "// Date, RegEx and other Built-ins are handled above as built-ins", "commit_type": "add"}
{"commit_tokens": ["change", "getOauthToken", "jsdoc", "to", "@public"], "add_tokens": "* @ public", "del_tokens": "* @ private", "commit_type": "change"}
{"commit_tokens": ["fix", "some", "audit", "issues", "with", "dev", "dependencies"], "add_tokens": ". run ( { 'async' : true } )", "del_tokens": ". run ( { 'async' : true } )", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "&", "support", "^", "=", "~", "=", "$", "=", "*", "="], "add_tokens": "cssParser . registerAttrEqualityMods ( '^' , '~' , '$' , '*' ) ; '>' : '(?:>|&gt;)' , + '|\\'' + singleQuoteValuePattern + '[^\\']*\\'))' ; } else if ( attr . operator === '$=' ) { res += '(?=[^>]*?\\\\s' + attr . name + '=(?:\"[^\"]*' + doubleQuoteValuePattern + '\"' + '|\\'[^\\']*' + singleQuoteValuePattern + '\\'))' ; } else if ( attr . operator === '~=' ) { res += '(?=[^>]*?\\\\s' + attr . name + '=(?:\"(?:[^\"]+\\\\s+)*' + doubleQuoteValuePattern + '(?:\\\\s+[^\"]+)*\"' + \"|'(?:[^']+\\\\s)*\" + singleQuoteValuePattern + \"(?:\\\\s[^']+)*'))\" ; } else if ( attr . operator === '*=' ) { res += '(?=[^>]*?\\\\s' + attr . name + '=(?:\"[^\"]*' + doubleQuoteValuePattern + '[^\"]*\"' + \"|'[^']*\" + singleQuoteValuePattern + \"[^']*'))\" ;", "del_tokens": "'>' : '(?:>|&lt;)' , + '|\\'' + singleQuoteValuePattern + '[^\\']*\\'' ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "title", "on", "item", "type", "pages", "."], "add_tokens": "$scope . view . title = '' ; $scope . view . title = response . title ; $scope . view . title = response . data . title ;", "del_tokens": "$scope . page . title = response . data . title ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "a", "cleaner", "and", "less", "hacky", "approach", "to", "implement", "the", "media", "frame", "add", "more", "flexibility", "improve", "code", "structure", "."], "add_tokens": "' * WP Media Picker - version <%= pkg.version %>\\n' +", "del_tokens": "' * WP Media Picker - version <%= pkg.version %>\\n' +", "commit_type": "use"}
{"commit_tokens": ["Make", "smartgame", "at", "init", "optional"], "add_tokens": "if ( smartgame ) { this . game = smartgame . gameTrees [ 0 ] ; this . reset ( ) ; } } , // Load a smartgame to make it possible to load new games or add one after // initialization, if desired load : function ( newSmartgame ) { smartgame = newSmartgame ; this . init ( ) ;", "del_tokens": "if ( typeof smartgame !== 'object' ) { throw new Error ( 'the smartgame navigator needs a smartgame to navigate' ) ; } this . game = smartgame . gameTrees [ 0 ] ; this . reset ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Changed", "how", "the", "examples", "get", "cleaned", "up", "."], "add_tokens": "if ( emitter ) emitter . update ( ( now - elapsed ) * 0.001 ) ; if ( emitter && particleCount ) //cancelAnimationFrame(updateId);", "del_tokens": "emitter . update ( ( now - elapsed ) * 0.001 ) ; if ( particleCount ) cancelAnimationFrame ( updateId ) ;", "commit_type": "change"}
{"commit_tokens": ["Adding", "commandline", "options", "to", "list", "boards", "and", "ports", ".", "Started", "adding", "some", "test", "boilerplate", "and", "tests", "for", "board", "detection", "."], "add_tokens": "var boards = { function pidLookupTable ( ) { var byPid = { } ; var boardNames = Object . keys ( boards ) ; for ( var i = 0 ; i < boardNames . length ; i ++ ) { var boardName = boardNames [ i ] ; var board = boards [ boardName ] ; if ( board . productId ) { for ( var j = 0 ; j < board . productId . length ; j ++ ) { var productId = board . productId [ j ] ; byPid [ productId ] = byPid [ productId ] || [ ] ; byPid [ productId ] . push ( boardName ) ; } } } return byPid ; } module . exports = { byName : boards , byPid : pidLookupTable ( ) }", "del_tokens": "module . exports = {", "commit_type": "add"}
{"commit_tokens": ["Implement", "copy2685", "for", "the", "install", "step", "."], "add_tokens": "gyp . verbose ( 'need to install the patch gypi file for version' , version ) var patchPath = path . join ( __dirname , '..' , '2685' , 'patch.gypi' ) , copyTo = path . join ( devDir , 'tools' , 'patch.gypi' ) gyp . verbose ( 'patch.gypi' , patchPath ) gyp . verbose ( 'copy to' , copyTo ) copy ( patchPath , copyTo , done )", "del_tokens": "//done(new Error('implement me!')) done ( )", "commit_type": "implement"}
{"commit_tokens": ["Add", "a", "custom", "Yuidoc", "theme"], "add_tokens": "lintNatives : true , url : '<%= pkg.homepage %>' , outdir : './build/documentation' , themedir : './node_modules/yuidoc-theme-blue'", "del_tokens": "url : '<%= pkg.homepage %>' , lintNatives : true , outdir : './build/documentation'", "commit_type": "add"}
{"commit_tokens": ["Fix", "JSON", "and", "update", "to", "a", "new", "marc", "record"], "add_tokens": "try { this . emit ( 'data' , new MarcRecord ( data . value ) ) ; } catch ( err ) { this . emit ( 'error' , err ) ; }", "del_tokens": "this . emit ( 'data' , new MarcRecord ( data . value ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removing", "protocal", "parameter", "from", "nodemailer", ".", "createTransport", "()"], "add_tokens": "var smtpTransport = nodemailer . createTransport ( mail . options ) ;", "del_tokens": "var smtpTransport = nodemailer . createTransport ( mail . protocol , mail . options ) ;", "commit_type": "remove"}
{"commit_tokens": ["remove", "unnecessary", "sourcemap", "setup", "in", "main", "process", "webpack", "config"], "add_tokens": "parallel : true parallel : true", "del_tokens": ". devtool ( 'source-map' ) parallel : true , sourceMap : true . devtool ( 'source-map' ) parallel : true , sourceMap : true", "commit_type": "remove"}
{"commit_tokens": ["fix", "hooksConfig", "missing", "after", "inherits"], "add_tokens": "this . __hooksConfig = Object . assign ( { } , this . __hooksConfig ) ;", "del_tokens": "this . __hooksConfig = { } ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "animation", "and", "display", "of", "progress", "bar"], "add_tokens": "var percent = 0 , prevPercent = 0 ; } else if ( done ) { prevPercent = nav . percent ; prevPercent : prevPercent ,", "del_tokens": "var percent = 0 ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "extension", "and", "sync", "error", "handling"], "add_tokens": "try { let absolutePath = path . join ( path . dirname ( prev ) , url ) ; let extension = path . extname ( prev ) ; // Ensure import directive path include extension if ( path . extname ( absolutePath ) !== extension ) { absolutePath += extension ; } return { file : absolutePath , contents : extractionMap [ absolutePath ] . injectedData } ; } catch ( err ) { // note: importer has to return any error return err ;", "del_tokens": "let absolutePath = path . join ( path . dirname ( prev ) , url ) ; if ( path . extname ( absolutePath ) !== '.scss' ) { absolutePath += '.scss' ; return { file : absolutePath , contents : extractionMap [ absolutePath ] . injectedData } ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "highlighting", "for", "CDATA", "sections"], "add_tokens": "'cdata' : / & lt ; ! \\[ CDATA \\[ [ \\w \\W ] + ] ] & gt ; / i, pattern : / (&lt;|<)\\/?[\\w:-]+\\s*[\\w\\W]*?(>|&gt;) / gi ,", "del_tokens": "pattern : / (&lt;|<)\\/?[\\w\\W]+?(>|&gt;) / gi ,", "commit_type": "add"}
{"commit_tokens": ["Updated", "bot", "and", "added", "some", "more", "helpful", "features", "such", "as", "isPM", "to", "messages", "to", "discover", "whether", "a", "message", "is", "from", "a", "PM"], "add_tokens": "exports . Discord = Discord ; console . log ( Authority . getLevel ( message . author ) ) ; hydrabot . reply ( message , \"you don't have authority to do this!\" ) ;", "del_tokens": "var channel = message . channel ; // set the channel variable to message.channel var sender = message . author ; // set the sender variable to the author of the message var isPM = ( message . channel instanceof Discord . PMChannel ) ; // set isPM to true if the channel is a Private Message Channel. console . log ( Authority . getLevel ( message . author ) ) ; hydrabolt . reply ( message , \"you don't have authority to do this!\" ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "bugs", "(", "added", "unit", "tests", ")", "in", "qty", ".", "inverse", "()", "and", "qty", ".", "to", "(", "inverse", ")"], "add_tokens": "return new Qty ( { \"scalar\" : 1 / this . scalar , \"numerator\" : this . denominator , \"denominator\" : this . numerator } ) ; return this . inverse ( ) . to ( other ) ;", "del_tokens": "return new Qty ( { \"scalar\" : 1 / this . base_scalar , \"numerator\" : this . denominator , \"denominator\" : this . numerator } ) ; return this . inverse ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["make", "timers", "use", "require", "from", "game"], "add_tokens": "module . exports = function ( ecs , data ) { var script = data . require ( timer . script ) ;", "del_tokens": "module . exports = function ( ecs ) { var script = require ( timer . script ) ;", "commit_type": "make"}
{"commit_tokens": ["Update", "inverted", "XY", "for", "values", "charts"], "add_tokens": "displayAdjacent : this . displayAdjacent ? this . displayAdjacent ( ) : false , invertedXY : this . invertedXY ? this . invertedXY ( ) : false", "del_tokens": "displayAdjacent : this . displayAdjacent ? this . displayAdjacent ( ) : false", "commit_type": "update"}
{"commit_tokens": ["Use", "gm", "identify", "to", "reduce", "dependency", "."], "add_tokens": "var cmd = 'gm identify -format \"%p \" \"' + input + '\"' ; var pageCount = execSync ( cmd ) . toString ( ) . match ( / [0-9]+ / g ) ; if ( ! pageCount . length ) { callback ( null , pageCount ) ; convertPdf2Img ( inputStream , outputFile , parseInt ( page ) , function ( error , result ) {", "del_tokens": "var cmd = 'identify -format %n ' + input ; var pageCount = parseInt ( execSync ( cmd ) . toString ( ) . trim ( ) ) ; callback ( null , pageCount ) } , // Convert pages count into array function ( pageCount , callback ) { var pages = [ ] ; if ( ! pageCount ) { for ( var i = 1 ; i <= pageCount ; i ++ ) { pages . push ( i ) ; if ( i == pageCount ) callback ( null , pages ) ; } convertPdf2Img ( inputStream , outputFile , page , function ( error , result ) {", "commit_type": "use"}
{"commit_tokens": ["Added", "a", "bunch", "more", "tests"], "add_tokens": "exports . assert = require ( 'assert' ) ;", "del_tokens": "exports . assert = require ( 'assert' ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "missing", "tests", "of", "timeouts", "and", "did", "a", "little", "renaming", "of", "switch", "root", "tests"], "add_tokens": "{ this . renderScreenButton ( 'Timeouts' , Screens . TimeoutsScreen ) }", "del_tokens": "setTimeout ( ( ) => { console . log ( \"Don't cry for me Argentina.\" ) } , 5000 ) ; setInterval ( ( ) => { console . log ( \"I am doing some periodic work.\" ) } , 1000 ) ;", "commit_type": "add"}
{"commit_tokens": ["move", "logging", "to", "its", "own", "package"], "add_tokens": "const logger = require ( '@todastic/logging' ) ;", "del_tokens": "const logger = require ( './winston' ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "bug", "that", "broke", "bold", "and", "italics"], "add_tokens": "if ( / editor-preview-active / . test ( editor . codemirror . getWrapperElement ( ) . lastChild . className ) )", "del_tokens": "if ( / editor-preview-active / . test ( cm . getWrapperElement ( ) . lastChild . className ) )", "commit_type": "fix"}
{"commit_tokens": ["Updated", "readme", "+", "enabled", "the", "11k", "ua", "strings", "test", "again"], "add_tokens": "// run over the testcases, some might fail, some might not. This is just qu // test to see if we can parse without errors, and with a reasonable amount // of errors. , 'pgts.yaml' // we need to test if v1 is a string, because the yamlparser transforms // empty v1: statements to {}", "del_tokens": "// , 'pgts.yaml' console . log ( js_ua ) ;", "commit_type": "update"}
{"commit_tokens": ["Updated", "rules", "added", "procedural", "interface", "to", "the", "library", "simplified", "tests"], "add_tokens": "var methodName = \"in\" + caseName . charAt ( 0 ) . toUpperCase ( ) + caseName . slice ( 1 ) ; var result = shevchenko [ methodName ] ( person ) ;", "del_tokens": "var result = shevchenko ( person , caseName ) ;", "commit_type": "update"}
{"commit_tokens": ["Updated", "send", "-", "tokens", "example"], "add_tokens": "//const Wormhole = new WH({ restURL: `https://trest.bitcoin.com/v1/` }) const Wormhole = new WH ( { restURL : ` ` } ) const propertyId = 1 // WH ID identifying the token. 1 === WHC. const cashAddress = Wormhole . HDNode . toCashAddress ( change ) const u = await Wormhole . Address . utxo ( [ cashAddress ] ) const broadcast = await Wormhole . RawTransactions . sendRawTransaction ( txHex )", "del_tokens": "\"use strict\" //let Wormhole = require(\"wormholecash/lib/Wormhole\").default; const Wormhole = new WH ( { restURL : ` ` } ) const BITBOXCli = require ( \"bitbox-cli/lib/bitbox-cli\" ) . default const BITBOX = new BITBOXCli ( { restURL : \"https://trest.bitcoin.com/v1/\" } ) const propertyId = 229 // WH ID identifying the token. const cashAddress = BITBOX . HDNode . toCashAddress ( change ) // const cashAddress = walletInfo.cashAddress; const u = await BITBOX . Address . utxo ( [ cashAddress ] ) console . log ( u ) // const utxo = u[0][1] //console.log(txHex); const broadcast = await BITBOX . RawTransactions . sendRawTransaction ( txHex )", "commit_type": "update"}
{"commit_tokens": ["Upgrade", "AddTrustFromDirectory", "to", "new", "directory", "format"], "add_tokens": "directory . addAsset ( 'naobtc.com' , {", "del_tokens": "directory . addAsset ( 'stellarterm.com' , {", "commit_type": "upgrade"}
{"commit_tokens": ["Removed", "dependency", "on", "bars", "graph", "type", "from", "findAxesValues", ".", "Generalized", "to", "let", "a", "graph", "type", "handle", "as", "necessary", "."], "add_tokens": "var i , j , s , t ; t = this . getType ( this . series ) ; if ( t . findAxesValues ) { // Graph Type t . findAxesValues ( s ) ; } else { // Default this . findXAxesValues ( s ) ; }", "del_tokens": "var i , j , s ; this . findXAxesValues ( s ) ; if ( s . bars . show && s . bars . horizontal && s . bars . stacked ) this . findYAxesValues ( s ) ;", "commit_type": "remove"}
{"commit_tokens": ["fix", "handling", "of", "special", "characters", "and", "add", "tests", "for", "it"], "add_tokens": "contents = file . contents . toString ( ) ; contents = cheerio . load ( '<root>' + contents + '</root>' ) ( 'root' ) . html ( ) ; var match = contents . search ( regExp ) ; if ( match > - 1 ) { excerpt = contents . slice ( 0 , Buffer . byteLength ( contents . slice ( 0 , match ) ) ) ; excerpt = _s . unescapeHTML ( excerpt ) ; } p = $ ( 'p' ) . first ( ) , excerpt = p . length ? p . html ( ) . trim ( ) : false ; if ( excerpt ) { excerpt = _s . unescapeHTML ( excerpt ) ; } return excerpt ;", "del_tokens": "contents = file . contents . toString ( ) , match = contents . search ( regExp ) ; if ( match > - 1 ) { excerpt = contents . slice ( 0 , Buffer . byteLength ( contents . slice ( 0 , match ) ) ) ; } p = $ ( 'p' ) . first ( ) ; return p . length ? p . html ( ) . trim ( ) : false ;", "commit_type": "fix"}
{"commit_tokens": ["added", "api", "metadata", "support", "for", "google", "."], "add_tokens": "{ urlRoot : process . env . DASHBOT_URL_ROOT , debug : true , redact : process . env . DASHBOT_REDACT } ) . google ; // second paramter is optional metadata dashbot . configHandler ( assistant , { we : 'like incoming metadata' } ) ; // optianally set metadata dashbot . setOutgoingMetadata ( { we : 'also like outgoing metadata' } )", "del_tokens": "{ urlRoot : process . env . DASHBOT_URL_ROOT , debug : true } ) . google ; dashbot . configHandler ( assistant ) ;", "commit_type": "add"}
{"commit_tokens": ["removing", "@flow", "need", "to", "figure", "out", "how", "it", "works", "first", "."], "add_tokens": "* @ exports swagger - spec - express /** Initialises the module */ /** Initialises the module */ /** Initialises the module */", "del_tokens": "// @flow * @ module Swagger - spec - express * @ type { { * initialise : * , * initialize : * , * compile : compile , * validate : callValidate , * json : json , * reset : reset , * swaggerise : * , * swaggerize : * , * common : { * addModel : addModel , * addTag : addTag , * parameters : { * addHeader : addHeaderParameter , * addBody : addBodyParameter , * addQuery : addQueryParameter , * addFormData : addFormDataParameter , * addPath : addPathParameter * } , * addResponse : addResponse , * addResponseHeader : addResponseHeader * } * } }", "commit_type": "remove"}
{"commit_tokens": ["added", "new", "option", "for", "mobile"], "add_tokens": "elementData . html = this . config . renderOption ( data ) ; // asume xss prevention in custom render function elementData . textContent = option . textContent ; // treat all as plain text elementData . html = this . config . renderSelection ( data ) ; // asume xss prevention in custom render function / ** * Enables / disables logic for mobile * @ type { Boolean } * / disabledMobile : false , if ( ! this . config . disabledMobile && / Android|webOS|iPhone|iPad|BlackBerry|Windows Phone|Opera Mini|IEMobile|Mobile / i . test ( navigator . userAgent ) ) { } } else { }", "del_tokens": "elementData . html = this . config . renderOption ( data ) ; // asume xss prevention in custom render function elementData . textContent = option . textContent ; // treat all as plain text elementData . html = this . config . renderSelection ( data ) ; // asume xss prevention in custom render function if ( / Android|webOS|iPhone|iPad|BlackBerry|Windows Phone|Opera Mini|IEMobile|Mobile / i . test ( navigator . userAgent ) ) { } } else { }", "commit_type": "add"}
{"commit_tokens": ["Fix", "IPv4", "/", "IPv6", "bindings", "for", "localhost", "in", "tests"], "add_tokens": "'127.0.0.1:' + handles . port ;", "del_tokens": "'http://127.0.0.1:' + handles . port ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "issue", "with", "wrong", "read", "location", "for", "filetypes"], "add_tokens": "const fs = require ( 'fs-extra' ) ; const path = require ( 'path' ) ; //read the filetypes from the configuration const fileTypes = patternlab . config . plugins [ 'plugin-node-tab' ] . options . tabsToAdd ; const fileType = fileTypes [ i ] . toLowerCase ( ) ; customFileTypePath = customFileTypePath . substr ( 0 , customFileTypePath . lastIndexOf ( \".\" ) ) + '.' + fileType ; var customFileTypeOutputPath = patternlab . config . paths . public . patterns + pattern . getPatternLink ( patternlab , 'custom' , '.' + fileType ) ;", "del_tokens": "const fs = require ( 'fs-extra' ) , path = require ( 'path' ) , fileTypes = require ( './../package.json' ) . fileTypes ; customFileTypePath = customFileTypePath . substr ( 0 , customFileTypePath . lastIndexOf ( \".\" ) ) + '.' + fileTypes [ i ] ; var customFileTypeOutputPath = patternlab . config . paths . public . patterns + pattern . getPatternLink ( patternlab , 'custom' , '.' + fileTypes [ i ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["moved", "to", "pointer", "events", "(", "using", "pep", ".", "js", ")"], "add_tokens": "Slider : require ( './slider.js' ) , PEP : require ( 'pepjs' )", "del_tokens": "Slider : require ( './slider.js' )", "commit_type": "move"}
{"commit_tokens": ["Add", "retries", "for", "rate", "limit", "exceeded", "exceptions"], "add_tokens": "try { res . body = JSON . parse ( res . body ) } catch ( e ) { } // eslint-disable-line no-empty if ( res . body . __type == 'LimitExceededException' && / ^Rate exceeded / . test ( res . body . message ) ) return setTimeout ( request , Math . floor ( Math . random ( ) * 1000 ) , opts , cb )", "del_tokens": "try { res . body = JSON . parse ( res . body ) } catch ( e ) { }", "commit_type": "add"}
{"commit_tokens": ["Remove", "error", "on", "empty", "content"], "add_tokens": "} else if ( typeof req . baucis . documents === 'object' && req . baucis . documents . populateFields ) {", "del_tokens": "} else if ( typeof req . baucis . documents === 'object' ) {", "commit_type": "remove"}
{"commit_tokens": ["Added", "simple", "wrapper", "for", "getBoxes", "()"], "add_tokens": "* @ param { string } [ options . mailbox ] The mailbox to append the message to . * @ param { string | Array < String > } [ options . flag ] A single flag ( e . g . 'Seen' ) or an array ImapSimple . prototype . getBoxes = function ( callback ) { if ( callback ) { return nodeify ( this . getBoxes ( ) ) ; } return new Promise ( ( resolve , reject ) => { this . imap . getBoxes ( ( err , boxes ) => { if ( err ) { reject ( err ) ; } else { resolve ( boxes ) ; } } ) } ) } ;", "del_tokens": "* @ param { string } [ options . mailbox ] The mailbox to append the message to . * @ param { string | Array < String > } [ options . flag ] A single flag ( e . g . 'Seen' ) or an array", "commit_type": "add"}
{"commit_tokens": ["Adds", "minify", ":", "false", "option", "to", "build"], "add_tokens": "module . exports = function ( config , options ) { options = options || { // Defaults minify : true } ; // Minification is optional var minify = ! ! options . minify ; if ( minify ) { minifyGraph ( dependencyGraph ) ; } var masterNodes = minify ? minifyGraph ( stealConfigAndMain ) : stealConfigAndMain ; nodes : masterNodes ,", "del_tokens": "module . exports = function ( config ) { minifyGraph ( dependencyGraph ) ; nodes : minifyGraph ( stealConfigAndMain ) ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "===", "instead", "of", "=="], "add_tokens": "if ( count === 0 ) {", "del_tokens": "if ( count == 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "new", "object", "type", "for", "plain", "javascript", "objects"], "add_tokens": "docket . title ( ` ` ) ;", "del_tokens": "docket . title ( ` ` ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "passing", "of", "req", "explicitly", "for", "now", "(", "YUCK", ")"], "add_tokens": "* Return a ` ` for ` ` and ` ` . * @ param { Request } req function send ( req , path ) { return new SendStream ( req , path ) ; * @ param { Request } req function SendStream ( req , path ) { this . req = req ;", "del_tokens": "* Return a ` ` for ` ` . function send ( path ) { return new SendStream ( path ) ; function SendStream ( path ) { this . req = res . socket . parser . incoming ; // TODO: wtf?", "commit_type": "add"}
{"commit_tokens": ["Fixed", "youtube", "video", "cannot", "seek", "before", "video", "started", "with", "controls"], "add_tokens": "player . embed . seekTo ( targetTime ) ;", "del_tokens": "player . embed . seekTo ( player . media . currentTime ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "another", "=", "to", "a", "test", "case"], "add_tokens": "if ( typeof window === \"undefined\" ) {", "del_tokens": "if ( typeof window == \"undefined\" ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "hidden", "particle", "values", "in", "vertex", "shader"], "add_tokens": "angle : { type : 'f' , value : [ ] } , colorMiddle : { type : 'c' , value : [ ] } , if ( that . angleAlignVelocity ) { angle [ i ] = - Math . atan2 ( velocity [ i ] . y , velocity [ i ] . x ) ; } else { angle [ i ] = that . _randomFloat ( emitter . angle , emitter . angleSpread ) ; age [ i ] = 0.0 ; 'vColor = vec4( 0.0, 0.0, 0.0, 0.0 );' , 'gl_Position = vec4(1000000000.0, 1000000000.0, 1000000000.0, 0.0);' ,", "del_tokens": "angle : { type : 'f' , value : [ ] } , colorMiddle : { type : 'c' , value : [ ] } , if ( that . angleAlignVelocity ) { angle [ i ] = - Math . atan2 ( velocity [ i ] . y , velocity [ i ] . x ) ; } else { angle [ i ] = that . _randomFloat ( emitter . angle , emitter . angleSpread ) ; age [ i ] = 0.0 ; 'vColor = vec4( colorStart, 0.0 );' , 'gl_Position = vec4(1e20, 1e20, 1e20, 0);' ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "for", "disabling", "/", "re", "-", "enabling", "stackPrefetch"], "add_tokens": "if ( stackPrefetchData === undefined ) { // If this is the first time enabling the prefetching, add tool data } else { // Otherwise, re-enable the prefetching stackPrefetchData . data [ 0 ] . enabled = true ; // If there is actually something to disable, disable it if ( stackPrefetchData !== undefined ) { stackPrefetchData . data [ 0 ] . enabled = false ;", "del_tokens": "if ( stackPrefetchData === undefined ) { if ( stackPrefetchData === undefined ) { stackPrefetchData = { prefetchImageIdIndex : - 1 , enabled : false } ; cornerstoneTools . removeToolState ( element , toolType , stackPrefetchData ) ; } else { stackPrefetchData . enabled = false ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "printRow", "when", "using", "ANSI", "escapes"], "add_tokens": "import stringWidth from 'string-width' ; const rowWidth = screenWidth - 1 ; // Consider line break length. const messageWidth = stringWidth ( message ) ; const paddingWidth = ( rowWidth - messageWidth ) / 2 ; const startPadding = padding . repeat ( Math . floor ( paddingWidth ) ) ; const endPadding = padding . repeat ( Math . ceil ( paddingWidth ) ) ;", "del_tokens": "const rowLength = screenWidth - 1 ; // Consider line break length. const startPadding = padding . repeat ( Math . floor ( ( rowLength - message . length ) / 2 ) , ) ; const endPadding = padding . repeat ( Math . ceil ( ( rowLength - message . length ) / 2 ) , ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "passing", "array", "of", "streams"], "add_tokens": "var streams if ( arguments . length == 1 && Array . isArray ( arguments [ 0 ] ) ) { streams = arguments [ 0 ] } else { streams = [ ] . slice . call ( arguments ) } recurse ( streams . slice ( 1 ) )", "del_tokens": "var streams = [ ] . slice . call ( arguments ) recurse ( streams . slice ( 1 ) )", "commit_type": "allow"}
{"commit_tokens": ["updated", "the", "tests", "the", "reflect", "the", "current", "behavior"], "add_tokens": "expect ( migrationDone ) . toBeTruthy ( )", "del_tokens": "expect ( migrationDone ) . toBeFalsy ( )", "commit_type": "update"}
{"commit_tokens": ["Use", "container", ".", "resolve", "()", "instead", "of", "the", "cradle", "to", "avoid", "unnecessary", "proxy", "hit", "."], "add_tokens": "* @ this { Registration } * The ` ` context is a registration . * const resolutionMode = ( this . resolutionMode || container . options . resolutionMode || ResolutionMode . PROXY ) const dependencies = getDependencies ( dependencyParseTarget ) dependencies . forEach ( ( d ) => children . push ( container . resolve ( d ) ) )", "del_tokens": "let resolutionMode = ( this . resolutionMode || container . options . resolutionMode || ResolutionMode . PROXY ) let dependencies = getDependencies ( dependencyParseTarget ) dependencies . forEach ( ( d ) => children . push ( container . cradle [ d ] ) )", "commit_type": "use"}
{"commit_tokens": ["fix", "some", "failing", "tests", ":"], "add_tokens": "expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ? 'anonymous' : null ) ; expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ? 'anonymous' : null ) ; expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ? 'anonymous' : null ) ; expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ? 'anonymous' : null ) ;", "del_tokens": "expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ) ; expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ) ; expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ) ; expect ( res ) . to . have . property ( 'crossOrigin' , options . crossOrigin ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "incorrect", "variable", "name", "that", "was", "preventing", "final", "flush", "in", "browser", "JS"], "add_tokens": "let protocol = ( this . _encryption === 'none' ) ? 'http' : 'https' ; let url = ` ${ protocol } ${ this . _host } ${ this . _port } ` +", "del_tokens": "let url = ` ${ this . _hostport } ` +", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "ARM", "architecture"], "add_tokens": "if ( process . arch === \"arm\" || process . arch === \"arm64\" ) return \"mkcert-\" + MKCERT_VERSION + \"-linux-arm\" else return \"mkcert-\" + MKCERT_VERSION + \"-linux-amd64\" /* falls through */", "del_tokens": "return \"mkcert-\" + MKCERT_VERSION + \"-linux-amd64\"", "commit_type": "add"}
{"commit_tokens": ["fixed", "typo", "since", "I", "was", "testing", "with", "a", "blue", "line", "oops"], "add_tokens": "//this assumes we're following a blue line on a white background", "del_tokens": "//this assumes we're following a black line on a white background", "commit_type": "fix"}
{"commit_tokens": ["Add", "better", "targeting", "for", "counting", ".", "slides", "li", "s", "."], "add_tokens": "if ( $ ( this ) . find ( '.slides > li' ) . length == 1 ) { $ ( this ) . find ( '.slides > li' ) . fadeIn ( 400 ) ;", "del_tokens": "if ( $ ( this ) . find ( '.slides li' ) . length == 1 ) { $ ( this ) . find ( '.slides li' ) . fadeIn ( 400 ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "list", "of", "supported", "type", "options"], "add_tokens": "// Get cast options for ( const key of [ 'decimalChar' , 'groupChar' , 'bareNumber' , 'trueValues' , 'falseValues' ] ) { const value = this . descriptor [ key ] if ( value !== undefined ) { options [ key ] = value", "del_tokens": "// Get cast options for number if ( this . type === 'number' ) { for ( const key of [ 'decimalChar' , 'groupChar' , 'currency' ] ) { const value = this . descriptor [ key ] if ( value !== undefined ) { options [ key ] = value }", "commit_type": "update"}
{"commit_tokens": ["Move", "from", "React", ".", "addons", ".", "classSet", "to", "classnames", "module"], "add_tokens": "var classNames = require ( \"classnames\" ) ; var dropdownClassSet = classNames ( {", "del_tokens": "var dropdownClassSet = React . addons . classSet ( {", "commit_type": "move"}
{"commit_tokens": ["Fix", "type", "of", "websocket", "event"], "add_tokens": "onmessage : ( ev : MessageEvent ) => any ;", "del_tokens": "onmessage : ( ev : Event ) => any ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "error", "handling", "to", "async", "done", "()", "callback"], "add_tokens": "} , function done ( err ) { // Handle errors if ( err ) { return cb ( err ) ; }", "del_tokens": "} , function done ( ) {", "commit_type": "add"}
{"commit_tokens": ["make", "sure", "to", "add", "command", "to", "domain"], "add_tokens": ", path = require ( 'path' ) , domain = require ( './domain' ) domain . add ( this ) ; let questions = [ ] , that = this , flags ; flags = Object that . validate ( ) ; let UNDEF ; let that = this ;", "del_tokens": ", path = require ( 'path' ) var questions = [ ] , that = this ; let flags = Object that . validate ( cmd ) ; var UNDEF ; var that = this ; console . log ( that ) ;", "commit_type": "make"}
{"commit_tokens": ["Make", "fsevents", "mode", "the", "mac", "default", "again"], "add_tokens": "// Use polling by default on Linux and Mac (if not using fsevents). // Disable polling on Windows. if ( opts . usePolling == null && ! opts . useFsEvents ) opts . usePolling = ! isWindows ;", "del_tokens": "// Use polling on Mac and Linux. // Disable polling on Windows. if ( opts . usePolling == null ) opts . usePolling = ! isWindows ;", "commit_type": "make"}
{"commit_tokens": ["Move", "sample", "code", "to", "index", ".", "html", "."], "add_tokens": "code : [ 'src/utils.js' , 'src/**/index.js' , 'src/**/*.js' ] ,", "del_tokens": "code : [ 'src/utils.js' , 'src/**/index.js' , 'src/**/*.js' , 'test.js' ] ,", "commit_type": "move"}
{"commit_tokens": ["updated", "the", "exmaple", "to", "use", "the", "lastest", "version"], "add_tokens": "version : '0.11.0' ,", "del_tokens": "version : 'latest' ,", "commit_type": "update"}
{"commit_tokens": ["Updated", "docket", "parser", "package", "to", "fix", "jQuery", "vuln"], "add_tokens": "docket . title ( ` ` ) ;", "del_tokens": "docket . title ( ` ` ) ;", "commit_type": "update"}
{"commit_tokens": ["use", "error", "-", "cat", "singleton"], "add_tokens": "const errorCat = require ( 'error-cat' ) this . errorCat = this . opts . errorCat || errorCat", "del_tokens": "const ErrorCat = require ( 'error-cat' ) this . errorCat = this . opts . errorCat || new ErrorCat ( )", "commit_type": "use"}
{"commit_tokens": ["Moved", "definition", "of", "publicPath", "to", "package", "-", "webpack"], "add_tokens": "import { addTrailingSlash , getDevPath } from '../helpers' ; publicPath : DIST ? addTrailingSlash ( buildSettings . path ) : getDevPath ( )", "del_tokens": "publicPath : ''", "commit_type": "move"}
{"commit_tokens": ["add", "Z", "format", "for", "dates", "/", "times", "to", "use", "UTC"], "add_tokens": "var FORMAT_REGEX = / %([^%|\\s]*|(?:\\[[^\\[|\\]]*\\]))?([sjdDZ]) / g ; * * format ( \"%[h:mm a]D\" , [ date ] ) => 7 : 32 PM - local - 5 * format ( \"%[h:mm a]Z\" , [ date ] ) => 12 : 32 PM - UTC * * //When using object formats they must be in an array otherwise case \"Z\" : ret = date . date . format ( replacer , format , true ) ; break ;", "del_tokens": "var FORMAT_REGEX = / %([^%|\\s]*|(?:\\[[^\\[|\\]]*\\]))?([sjdD]) / g ; * //When using object formats they must be in an array otherwise", "commit_type": "add"}
{"commit_tokens": ["removing", "some", "invalid", "asset", "path", "code", "and", "adding", "to", "the", "multi", "dest", "example"], "add_tokens": "'test/actual/multi/dest2' : [ 'test/files/**/*.md' ] , 'test/actual/multi/dest2/sub-dest' : [ 'test/files/**/*.hbs' , '!test/files/layout*.*' ]", "del_tokens": "'test/actual/multi/dest2' : [ 'test/files/**/*.md' ]", "commit_type": "remove"}
{"commit_tokens": ["Fix", "passing", "data", "to", "request", ".", "end", "()"], "add_tokens": "stream . Writable . prototype . end . call ( self , data , encoding , cb )", "del_tokens": "if ( data ) stream . Writable . push . call ( self , data , encoding ) stream . Writable . prototype . end . call ( self , cb )", "commit_type": "fix"}
{"commit_tokens": ["Added", "babel", "plugin", "deps", "and", "babel", "-", "polyfill", "."], "add_tokens": "var fs = require ( 'fs' ) ; var path = require ( 'path' ) ; var webpack = require ( 'webpack' ) ; var pkg = require ( './package.json' ) ;", "del_tokens": "const fs = require ( 'fs' ) ; const path = require ( 'path' ) ; const webpack = require ( 'webpack' ) ; const pkg = require ( './package.json' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "way", "to", "generate", "docs", "that", "have", "the", "same", "content", "in", "places"], "add_tokens": "docInjector = require ( './docInjector' ) , docInjector ( __dirname + '/generatedDocs/' ) ; fs . writeFileSync ( __dirname + '/generatedDocs/docs.js' , buffer ) ;", "del_tokens": "fs . writeFileSync ( __dirname + '/../lib/docs.js' , buffer ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "renderer", "use", "module", ".", "view", "()", "to", "add", "module", "to", "structure"], "add_tokens": "import merge from 'deepmerge' ; _createBody ( start ) { const structure = merge ( { } , this . bodyStructure ) ; for ( const moduleName in this . modules ) { if ( ! this . modules [ moduleName ] . view ) { continue ; } const view = this . modules [ moduleName ] . view ( ) ; view . forEach ( ( singleView ) => { structure [ singleView . name ] = singleView ; structure [ singleView . parent ] . children . push ( singleView . name ) ; } ) ; } return structureParser ( structure , start ) ; } this . body = this . _createBody ( 'root' ) ;", "del_tokens": "this . body = structureParser ( this . bodyStructure , 'root' ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "some", "bugz", "in", "resolveFileFromPointers"], "add_tokens": "var json ; json = JSON . parse ( e . data ) ; if ( json . code && json . code !== 200 ) { return emitter . emit ( 'error' , new Error ( json . message ) ) ; emitter . emit ( 'data' , e . data ) ;", "del_tokens": "var data ; data = JSON . parse ( e . data ) ; if ( data . code && data . code !== 200 ) { return emitter . emit ( 'error' , new Error ( data . message ) ) ; emitter . emit ( 'data' , data ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "Sockbot", "take", "a", "userspecified", "config", "file", "to", "override", "default", "conf"], "add_tokens": "if ( ( ! module . configuration || module . configuration . enabled ) && module . name !== 'NotifyPrint' ) { console . warn ( 'Ingoring module: `' + ( module . name || name ) + '` Does not default to disabled' ) ; } else { sock_modules . push ( module ) ; console . log ( 'Loaded module: ' + module . name + ' v' + module . version ) ; } config = config . loadConfiguration ( sock_modules , process . argv [ 2 ] ) ; sock_modules = sock_modules . filter ( function ( module ) { return config . modules [ module . name ] . enabled ; } ) ;", "del_tokens": "sock_modules . push ( module ) ; console . log ( 'Loaded module: ' + module . name + ' v' + module . version ) ; config = config . loadConfiguration ( sock_modules ) ;", "commit_type": "make"}
{"commit_tokens": ["Fixed", "a", "bug", "that", "caused", "an", "erroneous", "HTTP", "413", "error", "when", "Content", "-", "Length", "is", "zero"], "add_tokens": "// NOTE: Even a zero-byte file attachment will have a Content-Length > 0 if ( length > 0 ) {", "del_tokens": "// NOTE: A Content-Length of zero is NOT the same as having no body // (e.g. a zero-byte file attachment, an empty string, etc.) if ( ! isNaN ( length ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Make", "sure", "Array#insert", "inserts", "the", "values", "at", "the", "wanted", "index"], "add_tokens": "* @ return { Array } The same array if ( this . length < ( index - 1 ) ) { this . length = index - 1 ; }", "del_tokens": "* @ return { Array } Thesame array", "commit_type": "make"}
{"commit_tokens": ["Fix", "to", "var", "reference", "internal", "tidying", "."], "add_tokens": "u . log ( this . chord , \"BSTRAP: SENDING\" ) ; let obj = { id : this . initialID , data } ; obj . type = \"bstrap-offer\" ; obj . type = \"bstrap-ice\" ; safeSend ( this . ws , obj ) ;", "del_tokens": "u . log ( this . chord , \"BSTRAP: SENDING \" ) ; safeSend ( this . ws , { type : \"bstrap-offer\" , id : this . initialID , data } ) ; safeSend ( this . ws , { type : \"bstrap-ice\" , id : initialID , data } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "requirement", "of", "atime", "in", "the", "stats", "object"], "add_tokens": "* Copyright ( c ) 2014 - 2015 Douglas Christopher Wilson", "del_tokens": "* Copyright ( c ) 2014 Douglas Christopher Wilson && 'atime' in obj && toString . call ( obj . atime ) === '[object Date]'", "commit_type": "remove"}
{"commit_tokens": ["Make", "it", "possible", "to", "explicitly", "require", "a", "specific", "implementation", "+", "do", "not", "ignore", "distanceFunction", "if", "minDistance", "=", "maxDistance"], "add_tokens": "* @ param { float } [ options . maxDistance ] Maximum distance between each points , defaults to minDistance * 2 * @ param { int } [ options . tries ] Number of times the algorithm will try to place a point in the neighbourhood of another points , defaults to 30 * @ param { function | null } [ rng ] RNG function , defaults to Math . random if ( typeof options . distanceFunction === 'function' ) { throw new Error ( 'PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction' ) ; } this . maxDistance = options . maxDistance || options . minDistance * 2 ; this . maxTries = Math . ceil ( Math . max ( 1 , options . tries || 30 ) ) ; this . rng = rng || Math . random ;", "del_tokens": "* @ param { float } options . maxDistance Maximum distance between each points * @ param { int } options . tries Number of times the algorithm will try to place a point in the neighbourhood of another points * @ param { function } rng RNG function this . maxDistance = options . maxDistance ; this . maxTries = options . tries ; this . rng = rng ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "component", "event", "declarations", "in", "parent", "components"], "add_tokens": "* @ suppress { strictMissingProperties } * if ( originalPrototype . events ) {", "del_tokens": "if ( 'events' in originalPrototype && originalPrototype . events ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "test", "for", "numbers", "in", "bem", "class", "mods"], "add_tokens": "import { isString , isPObject , hyphenate , isNumber } from '../src/utils' ; test ( 'Expected false for bool' , ( ) => { expect ( isNumber ( false ) ) . not . toBeTruthy ( ) ; } ) ; describe ( 'isNumber' , ( ) => { test ( 'Expected false for NaN' , ( ) => { expect ( isNumber ( NaN ) ) . not . toBeTruthy ( ) ; } ) ; test ( 'Expected false for undefined' , ( ) => { expect ( isString ( undefined ) ) . not . toBeTruthy ( ) ; } ) ; test ( 'Expected false for string' , ( ) => { expect ( isNumber ( 'qwerty' ) ) . not . toBeTruthy ( ) ; } ) ; test ( 'Expected false for Object' , ( ) => { expect ( isString ( { } ) ) . not . toBeTruthy ( ) ; } ) ; test ( 'Expected false for bool' , ( ) => { expect ( isNumber ( false ) ) . not . toBeTruthy ( ) ; } ) ; test ( 'Expected true for number' , ( ) => { expect ( isNumber ( 123 ) ) . toBeTruthy ( ) ; } ) ; } ) ;", "del_tokens": "import { isString , isPObject , hyphenate } from '../src/utils' ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "Consumer", ".", "destroy", "."], "add_tokens": "var loop = async ( function ( ) { var value = this . shift ( ) if ( value != null || this . endOfStream ) { return [ loop . break , value ] } this . _wait = this . _procession . pushed . enter ( async ( ) ) } ) ( ) console . log ( this . _procession . pushed . _waiting [ 0 ] , this . _wait . derp = 1 ) this . _procession . pushed . leave ( this . _wait ) ( ) this . _procession = NullProcession", "del_tokens": "this . _pushed = procession . pushed async ( function ( ) { var loop = async ( function ( ) { var value = this . shift ( ) if ( value != null || this . endOfStream ) { return [ loop . break , value ] } this . _wait = this . _pushed . enter ( async ( ) ) } ) ( ) } , function ( value ) { } ) this . _procession = NullProcession this . _procession . shifted . leave ( this . _wait ) ( )", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "decrypt", "script", "for", "modified", "model"], "add_tokens": "if ( process . argv . length < 7 ) { ' <receiver-private> <receiver-public> <sender-public> <salt> <message>' ) ; // node crypto is finicky about accessing the public key // 1. it can't generate the public key from the private key // 2. it barfs when you try to access the public key, even after you set it // This hack squelches the complaints at the cost of a few wasted cycles receiver . generateKeys ( ) ; receiver . setPublicKey ( base64 . decode ( process . argv [ 3 ] ) ) ; ece . saveKey ( 'keyid' , receiver , \"P-256\" ) ; var result = ece . decrypt ( base64 . decode ( process . argv [ 6 ] ) , { dh : process . argv [ 4 ] , salt : process . argv [ 5 ]", "del_tokens": "if ( process . argv . length < 6 ) { ' <receiver-private> <sender-public> <salt> <message>' ) ; ece . saveKey ( 'keyid' , receiver ) ; var result = ece . decrypt ( base64 . decode ( process . argv [ 5 ] ) , { dh : process . argv [ 3 ] , salt : process . argv [ 4 ]", "commit_type": "fix"}
{"commit_tokens": ["add", "some", "unit", "tests", "for", "cross", "origin", "checks"], "add_tokens": "this . crossOrigin = this . _determineCrossOrigin ( this . url ) ; * @ param url { string } The url to test . * @ param [ location = window . location ] { object } The location object to test against . Resource . prototype . _determineCrossOrigin = function ( url , loc ) { if ( url . indexOf ( 'data:' ) === 0 ) { // default is window.location loc = loc || window . location ; tempAnchor . href = url ; url = _url . parse ( tempAnchor . href ) ; var samePort = ( ! url . port && loc . port === '' ) || ( url . port === loc . port ) ;", "del_tokens": "this . crossOrigin = this . _determineCrossOrigin ( ) ; Resource . prototype . _determineCrossOrigin = function ( ) { if ( this . url . indexOf ( 'data:' ) === 0 ) { tempAnchor . href = this . url ; var url = _url . parse ( tempAnchor . href ) , loc = window . location , samePort = ( ! url . port && loc . port === '' ) || url . port === loc . port ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "users", "to", "pass", "in", "auditConfiguration", "objects"], "add_tokens": "_ = require ( 'lodash' ) , data = data + ' var configuration = new axs.AuditConfiguration(' + JSON . stringify ( context . config . chromeA11YDevTools . auditConfiguration ) + '); return axs.Audit.run(configuration);' ;", "del_tokens": "_ = require ( 'lodash' ) ; data = data + ' return axs.Audit.run();' ;", "commit_type": "allow"}
{"commit_tokens": ["Move", "babel", "development", "config", "to", "webpack", "/", "dev", ".", "config", ".", "js"], "add_tokens": "loader : 'babel' , exclude : / node_modules / , query : { plugins : [ 'react-transform' ] , extra : { 'react-transform' : { transforms : [ { transform : 'react-transform-hmr' , imports : [ 'react' ] , locals : [ 'module' ] } , { transform : 'react-transform-catch-errors' , imports : [ 'react' , 'redbox-react' ] } ] } } }", "del_tokens": "loaders : [ 'babel' ] , exclude : / node_modules /", "commit_type": "move"}
{"commit_tokens": ["fix", "bug", "options", "for", "spray"], "add_tokens": "this . options . spray = new Spray ( this . defaultOptions ) ;", "del_tokens": "this . options . spray = new Spray ( { protocol : this . options . protocol , webrtc : this . options . webrtc } ) ;", "commit_type": "fix"}
{"commit_tokens": ["removing", "seal", "option", "because", "it", "s", "silly", ".", "Making", "initialize", "optional", "for", "easier", "use", "when", "being", "used", "as", "a", "base", "for", "something", "else", "."], "add_tokens": "if ( options . init !== false ) this . initialize . apply ( this , arguments ) ;", "del_tokens": "this . initialize . apply ( this , arguments ) ; if ( this . seal ) Object . seal ( this ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "jshint", "errors", "allow", "==", "null", "option"], "add_tokens": "} ) ; fail ( ) { return this ; var type = window . INLINE_CACHE [ this . name ] ;", "del_tokens": "} ) fail ( fn ) { return this var type = INLINE_CACHE [ this . name ] ; window . cache2 = INLINE_CACHE ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "the", "upgrade", "build", "task"], "add_tokens": "return _exec ( 'npm' , [ 'update' , '--dev' ] ) ;", "del_tokens": "await _exec ( 'npm' , [ 'install' , '--ignore-scripts' ] ) ; return _exec ( 'npm' , [ 'update' ] ) ;", "commit_type": "update"}
{"commit_tokens": ["fix", "stupid", "bug", "with", "default", "bib"], "add_tokens": "const defaultBib = 'bibliography.bib' ; if ( fs . existsSync ( path . resolve ( sourceDir , defaultBib ) ) ) { pandocCmd += ` ${ path . resolve ( sourceDir , bibFile ) } ` ;", "del_tokens": "const defaultBib = path . resolve ( sourceDir , 'bibliography.bib' ) ; if ( fs . existsSync ( defaultBib ) ) { pandocCmd += ` ${ path . join ( sourceDir , bibFile ) } ` ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "that", "caused", "HTML", "comments", "to", "halt", "all", "additional", "parsing"], "add_tokens": "if ( doc . name . startsWith ( COMMENT_TAG ) ) { return [ ... buffer , ... children ] } const tag = options . mappings [ doc . name ] || DEFAULT_TAG", "del_tokens": "if ( doc . name . startsWith ( COMMENT_TAG ) ) { return buffer } const tag = options . mappings [ doc . name ] || DEFAULT_TAG", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "repeat", "-", "style", "values", "."], "add_tokens": "const validatorPath = '../../validators/' ; if ( opts . candidates . length === 1 && opts . candidates [ 0 ] . value === 'repeat-style' ) { const identifier = 'isRepeatStyle' ; return generateProgram ( [ requireModules ( { identifier , module : ` ${ validatorPath } ${ identifier } ` , } ) , template ( ` ${ identifier } ` ) ( ) , properties , ] ) ; } module : ` ${ validatorPath } ${ camel } ` , module : ` ${ validatorPath } ` ,", "del_tokens": "module : ` ${ camel } ` , module : ` ` ,", "commit_type": "add"}
{"commit_tokens": ["added", "support", "for", "passing", "a", "selector", "to", "appendElement"], "add_tokens": "// We should be able to find the element that has been created in the custom dom element it ( 'should add the template html to the custom selector' , ( ) => { $httpBackend . expectGET ( 'some/template1.html' ) ; // create fake element let fakeDomElement = document . createElement ( 'div' ) ; fakeDomElement . id = 'fake-dom-element' ; // insert fakeDomElement into the document to test against document . body . insertBefore ( fakeDomElement , null ) ; ModalService . showModal ( { controller : \"DomController\" , templateUrl : \"some/template1.html\" , appendElement : '#fake-dom-element' } ) . then ( ( modal ) => { // We should be able to find the element that has been created in the custom dom element expect ( angular . element ( document . querySelector ( '#fake-dom-element' ) ) . find ( 'div' ) ) . not . to . equal ( null ) ; } ) ; $httpBackend . flush ( ) ; } ) ; // We should be able to find the element that has been created in the custom dom element", "del_tokens": "// We should be able to find the lement that has been created in the custom dom element // We should be able to find the lement that has been created in the custom dom element", "commit_type": "add"}
{"commit_tokens": ["Move", "SVG", "path", "generation", "to", "render", "phase"], "add_tokens": "var points = e . attrs . points . split ( \" \" ) ; if ( e . attrs . type === \"line\" ) { path . setAttribute ( \"d\" , \"M \" + points [ 0 ] + \" L \" + points . slice ( 1 ) . join ( \" \" ) ) ; } else if ( e . attrs . type === \"curve\" ) { path . setAttribute ( \"d\" , \"M \" + points [ 0 ] + \" C \" + points . slice ( 1 ) . join ( \" \" ) ) ; }", "del_tokens": "path . setAttribute ( \"d\" , e . attrs . path ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "support", "of", "indent", "and", "indent_size"], "add_tokens": "indent_size : 2 , // If user has used alias for indent_size if ( ! _ . isUndefined ( options . indent ) ) { options . indent_size = options . indent ; }", "del_tokens": "indent : 2 , // alias for indent_size options . indent_size = options . indent ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "generateCaller", "()", "from", "src", "/", "index", ".", "js", "a", "Runtime", ".", "Helper"], "add_tokens": "var History = require ( './src/history' ) var Store = require ( './src/store' ) var Constraint = require ( './src/constraint' ) History : History , Store : Store , Constraint : Constraint , allDifferent : allDifferent , dynamicCaller : dynamicCaller function dynamicCaller ( name ) { return function ( ) { var self = this var args = Array . prototype . slice . call ( arguments ) var arity = arguments . length var functor = name + '/' + arity if ( ! self . Constraints [ functor ] ) { throw new Error ( 'Constraint ' + name + '/' + arity + ' not defined.' ) } var constraint = new Constraint ( name , arity , args ) self . Store . add ( constraint ) self . Constraints [ functor ] . forEach ( function ( occurence ) { occurence . call ( self , constraint ) } ) } }", "del_tokens": "History : require ( './src/history' ) , Store : require ( './src/store' ) , Constraint : require ( './src/constraint' ) , allDifferent : allDifferent", "commit_type": "make"}
{"commit_tokens": ["Added", "support", "for", "clearing", "version", "images", "from", "image", "sets"], "add_tokens": "delete this . _baseTransforms [ version ] delete this . _previewURIs [ version ] 'clear' : ( event ) => { this . clearAsset ( this . _viewer . version ) // Update the viewer with the new preview URI and own // image flag. this . _viewer . setImageURL ( this . _viewer . version , this . getPreview ( this . _viewer . version ) ) this . _viewer . setOwnImage ( this . _viewer . version , false ) } ,", "del_tokens": "console . log ( )", "commit_type": "add"}
{"commit_tokens": ["allow", "helpers", "to", "be", "executed", "outside", "of", "arrays"], "add_tokens": "launchCallback ( loaded , obj , block , callback ) ; launchCallback ( templates . cache [ template ] , obj , block , callback ) ; launchCallback ( template , obj , block , callback ) ; return parseTemplate ( block , template , obj ) ; function launchCallback ( template , obj , block , callback ) { callback ( parseTemplate ( block , template , obj ) ) ; function parseTemplate ( block , template , obj ) { block = ! block ? template : templates . getBlock ( template , block ) ; template = parse ( block , obj ) ; return parseFunctions ( template , template , { data : obj } ) ; }", "del_tokens": "parseTemplate ( loaded , obj , block , callback ) ; parseTemplate ( templates . cache [ template ] , obj , block , callback ) ; parseTemplate ( template , obj , block , callback ) ; return parse ( ! block ? template : templates . getBlock ( template , block ) , obj ) ; function parseTemplate ( template , obj , block , callback ) { callback ( parse ( ! block ? template : templates . getBlock ( template , block ) , obj ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["fixing", "up", "test", "and", "refactoring", "status", "."], "add_tokens": "var proto = require ( './proto' ) ; status : { get : getStatus , decode : decodeStatus } , function decodeStatus ( data ) { return proto . krpc . schema . Status . decode ( data ) ; }", "del_tokens": "getStatus : getStatus ,", "commit_type": "fix"}
{"commit_tokens": ["removing", "connect", "()", "option", "connectTimeout"], "add_tokens": "options . imap = options . imap || { } ; if ( options . hasOwnProperty ( 'connectTimeout' ) ) { console . warn ( '[imap-simple] connect: options.connectTimeout is deprecated. ' + 'Please use options.imap.authTimeout instead.' ) ; options . imap . authTimeout = options . connectTimeout ; } options . imap . authTimeout = options . hasOwnProperty ( 'authTimeout' ) ? options . authTimeout : 2000 ; if ( err . src === 'timeout-auth' ) { err = new errors . ConnectionTimeoutError ( options . imap . authTimeout ) ; }", "del_tokens": "* @ param { number } options . connectTimeout Time in milliseconds to wait before giving up on a connection attempt clearTimeout ( timeout ) ; clearTimeout ( timeout ) ; var timeoutAfterMs = options . connectTimeout || 2000 ; timeout = setTimeout ( function ( ) { imap . removeListener ( 'ready' , imapOnReady ) ; imap . removeListener ( 'error' , imapOnError ) ; reject ( new errors . ConnectionTimeoutError ( timeoutAfterMs ) ) ; } , timeoutAfterMs ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "more", "tests", "change", "format", "to", "JSON", "for", "easier", "parsing"], "add_tokens": "console . log ( JSON . stringify ( logs , true , 2 ) ) ;", "del_tokens": "console . log ( logs ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "eslint", ".", "Fixed", "issue", "with", "FETCH_SUCCESS", "not", "updating", "lastUpdated", ":"], "add_tokens": "module . exports = function loadEntity ( dispatch ( actionCreators . fetchSuccess ( name ) ( data , Date . now ( ) ) ) ; } ) ; } ; BEFORE_SUCCESS : 'beforeSuccess' , AFTER_SUCCESS : 'afterSuccess' , BEFORE_FAILURE : 'beforeFailure' , AFTER_FAILURE : 'afterFailure' function _processStage ( processors , dispatch , type , data ) { }", "del_tokens": "module . exports = function loadEntity ( dispatch ( actionCreators . fetchSuccess ( name ) ( data ) , Date . now ( ) ) ; } ) } BEFORE_SUCCESS : 'beforeSuccess' , AFTER_SUCCESS : 'afterSuccess' , BEFORE_FAILURE : 'beforeFailure' , AFTER_FAILURE : 'afterFailure' function _processStage ( processors , dispatch , type , data ) { }", "commit_type": "add"}
{"commit_tokens": ["fixed", "issues", "5", "7", "8"], "add_tokens": "type = typeof ( value ) , currentview = CURRENTVIEW ; CURRENTVIEW = target ; CURRENTVIEW = currentview ; if ( aname === \"value\" ) target . value = value ; if ( result == null ) { const render = view . render || ( view . view ? view . view . render : null ) ; if ( view . parentElement && render ) render ( ) ; const scope = this || typeof ( globalThis ) !== \"undefined\" ? globalThis : typeof ( global ) !== \"undefined\" ? global : { } ; if ( options . eval && ! scope [ data ] ) { // allows reference to global names but not execution, see below \"t-if\" : ( bool , scope , actions , render , { element } = { } ) => bool ? render ( scope , actions ) : \"\" data => typeof ( data ) === \"string\" && data . match ( / (eval|alert|prompt|dialog|void|clean)\\s*\\(*\\) / ) ,", "del_tokens": "type = typeof ( value ) ; if ( ! result ) { if ( view . parentElement && view . render ) view . render ( ) ; if ( options . eval ) { \"t-if\" : ( bool , scope , actions , render ) => bool ? render ( scope , actions ) : undefined data => typeof ( data ) === \"string\" && data . match ( / eval|alert|prompt|dialog|void|clean\\s*\\( / ) ,", "commit_type": "fix"}
{"commit_tokens": ["Updating", "deps", "and", "correcting", "for", "new", "eslint", "config"], "add_tokens": "} ;", "del_tokens": "}", "commit_type": "update"}
{"commit_tokens": ["Added", "some", "input", "validation", "/", "feedback", "for", "createTable"], "add_tokens": "docket . title ( ` ` ) ;", "del_tokens": "docket . title ( ` ` ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "cmd_stmt", "to", "multiple", "statement", "remove", "semicolon", "in", "cmd_stmt"], "add_tokens": "return ` ${ clauses . join ( ' ' ) } ` return ` ${ type } ${ database } ` return ` ${ type } ${ storeProcessCall } `", "del_tokens": "function getSemiColon ( semicolon = '' ) { if ( semicolon === null ) semicolon = '' return semicolon } const semicolon = getSemiColon ( stmt . semicolon ) return ` ${ clauses . join ( ' ' ) } ${ semicolon } ` const semicolon = getSemiColon ( stmt . semicolon ) return ` ${ type } ${ database } ${ semicolon } ` const semicolon = getSemiColon ( stmt . semicolon ) return ` ${ type } ${ storeProcessCall } ${ semicolon } `", "commit_type": "add"}
{"commit_tokens": ["added", "more", "tests", "around", "feature", "transformer", "handled", "returning", "on", "last", "end", "in", "file"], "add_tokens": "if ( spec . description ) { current [ spec . description ] = spec . line ; }", "del_tokens": "current [ spec . description ] = spec . line ;", "commit_type": "add"}
{"commit_tokens": ["fixes", "path", "resolution", "bug", "from", "forgotten", "s3", "mock"], "add_tokens": "texturePromises [ textureCount ] = request . getTexture ( textureS3Key , { queue : queue } ) . catch ( onError ) texturePromises [ textureCount ] = request . getTexture ( textureS3Key , { queue : queue } ) . catch ( onError )", "del_tokens": "// dependencies var s3 = { getTexture : function ( path ) { return request . getTexture ( 'https://dnvf9esa6v418.cloudfront.net' + path ) } } texturePromises [ textureCount ] = s3 . getTexture ( textureS3Key , { queue : queue } ) . catch ( onError ) texturePromises [ textureCount ] = s3 . getTexture ( textureS3Key , { queue : queue } ) . catch ( onError )", "commit_type": "fix"}
{"commit_tokens": ["Removed", "if", "statement", "around", "useTypescript"], "add_tokens": "const useTypescript = Boolean ( conf . themeConfig . js . es2015 ) ;", "del_tokens": "let useTypescript = false ; if ( conf . themeConfig . js . hasOwnProperty ( 'es2015' ) ) { useTypescript = conf . themeConfig . js . es2015 ; }", "commit_type": "remove"}
{"commit_tokens": ["remove", "README", ".", "html", "creating"], "add_tokens": "grunt . registerTask ( 'default' , [ 'jshint' , 'clean' , 'copy' , 'stamp' ] ) ;", "del_tokens": "markdown : { options : { template : 'markdown.tpl' } , all : { files : [ { expand : true , src : '*.md' , dest : '.' , ext : '.html' } ] } } , grunt . registerTask ( 'default' , [ 'jshint' , 'clean' , 'copy' , 'stamp' , 'markdown' ] ) ;", "commit_type": "remove"}
{"commit_tokens": ["Removing", "confusion", "with", "tests", "using", "git"], "add_tokens": "var cli = helmsman ( { prefix : 'testcommand' , localFolder : './bin' } ) ; t . equal ( cli . prefix , 'testcommand-' , 'The prefix is properly set' ) ; t . equal ( cli . availableCommands . subcommand . description , 'A test' , 'A subcommand\\'s meta data is loaded' ) ;", "del_tokens": "var cli = helmsman ( { prefix : 'git' , localFolder : './bin' } ) ; t . equal ( cli . prefix , 'git-' , 'The prefix is properly set' ) ; t . equal ( cli . availableCommands . status . description , 'A test' , 'A subcommand\\'s meta data is loaded' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Removed", "trailing", "commas", "in", "object", "initializers", "(", "Google", "Closure", "does", "not", "like", "them", ")", "."], "add_tokens": "} reportMatchFailures : true", "del_tokens": "} , reportMatchFailures : true ,", "commit_type": "remove"}
{"commit_tokens": ["add", "zlib", "support", "to", "cql"], "add_tokens": "zlib = require ( 'zlib' ) , Connection . prototype . cql = function ( cmd , args , options , callback ) { if ( typeof options === 'function' ) { callback = options ; options = { } ; } var cql = new Buffer ( util . format . apply ( this , args ) ) , self = this ; if ( options . gzip === true ) { zlib . deflate ( cql , function ( err , cqlz ) { self . execute ( 'execute_cql_query' , cqlz , ttype . Compression . GZIP , onReturn ) ; } ) ; } else { self . execute ( 'execute_cql_query' , cql , ttype . Compression . NONE , onReturn ) ; }", "del_tokens": "Connection . prototype . cql = function ( cmd , args , callback ) { var cql = new Buffer ( util . format . apply ( this , args ) ) ; this . execute ( 'execute_cql_query' , cql , ttype . Compression . NONE , onReturn ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "TypeError", "when", "none", "of", "the", "commands", "have", "any", "examples", "."], "add_tokens": "} ) ; if ( hasExample . length > 0 ) { hasExample = hasExample . reduce ( function ( a , b ) { } ) ; } hasExample = hasExample . length > 0 ;", "del_tokens": "} ) . reduce ( function ( a , b ) { } ) . length > 0 ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "blueprints", "to", "make", "ember", "install", "ember", "-", "l10n", "work", "correctly"], "add_tokens": "name : '<%= name %>' ,", "del_tokens": "name : < %= name % > ,", "commit_type": "fix"}
{"commit_tokens": ["fixed", "bug", "in", "connection", "that", "was", "introduced", "in", "the", "last", "commit"], "add_tokens": "toURL = this . transport . remoteUrl . replace ( ':id' , to ) ;", "del_tokens": "toUrl = this . transport . remoteUrl . replace ( ':id' , to ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "class", "in", "popover", "test"], "add_tokens": "template : '<div class=\"popover foobar\"><div class=\"popover-arrow\"></div><div class=\"inner\"><h3 class=\"title\"/><div class=\"content\"><p/></div></div></div>'", "del_tokens": "template : '<div class=\"popover foobar\"><div class=\"arrow\"></div><div class=\"inner\"><h3 class=\"title\"/><div class=\"content\"><p/></div></div></div>'", "commit_type": "fix"}
{"commit_tokens": ["Fix", "Navigator#navigate", "not", "removing", "root", "from", "uri"], "add_tokens": "return this . _removeURIRoot ( location . pathname ) ; uri = this . _removeURIRoot ( uri ) ; / ** @ method _removeURIRoot @ param { String } uri '/partners/s/foo-bar' @ return { String } uri '/s/foo-bar' ** / _removeURIRoot : function ( uri ) { var rootRegex = new RegExp ( '^' + this . root ) ; return uri . replace ( rootRegex , '' ) ; } ,", "del_tokens": "return location . pathname . replace ( this . root , '' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "more", "documentation", "and", "cleaned", "up", "some", "tets", "."], "add_tokens": "console . log ( 'I am alive' ) ; // console.log(functionName + ' is not implemented by the installed version of LJM.');", "del_tokens": "console . log ( functionName + ' is not implemented by the installed version of LJM.' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "CSRF", "token", "to", "routes"], "add_tokens": "// '/*': { controller: 'App', action: 'serve', skipAssets: true, skipRegex: /^\\/api\\/.*$/ } <----old version of csrf '/*' : { controller : 'App' , action : 'serve' , skipAssets : true , skipRegex : / ^\\/(api\\/.*|__getcookie|csrfToken)$ / }", "del_tokens": "'/*' : { controller : 'App' , action : 'serve' , skipAssets : true , skipRegex : / ^\\/api\\/.*$ / }", "commit_type": "add"}
{"commit_tokens": ["add", "ZA", "-", "South", "Africa", "codes"], "add_tokens": "[ \"South Africa\" , \"ZA\" , \"Eastern Cape~EC|Free State~FS|Gauteng~GT|KwaZulu-Natal~NL|Limpopo~LP|Mpumalanga~MP|Northern~Cape~NC|North West~NW|Western Cape~WC\" ] ,", "del_tokens": "[ \"South Africa\" , \"ZA\" , \"Eastern Cape|Free State|Gauteng|KwaZulu-Natal|Mpumalanga|North-West|Northern Cape|Northern Province|Western Cape\" ] ,", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "updateSavedAttributes", "function", "."], "add_tokens": "self . updateSavedAttributes ( ) ; var innerUpdateSavedAttributes = function ( ) { } ; this . updateSavedAttributes = function ( ) { var defered = q . defer ( ) ; innerUpdateSavedAttributes ( ) . then ( function ( updatedAttributes ) { self . emit ( DEVICE_ATTRIBUTES_CHANGED , updatedAttributes ) ; defered . resolve ( updatedAttributes ) ; } ) ; return defered . promise ; } ;", "del_tokens": "var reloadDeviceSavedAttributes = function ( ) { updateSavedAttributes ( ) . then ( function ( updatedAttributes ) { self . emit ( DEVICE_ATTRIBUTES_CHANGED , updatedAttributes ) ; } ) ; } reloadDeviceSavedAttributes ( ) ; var updateSavedAttributes = function ( ) { }", "commit_type": "add"}
{"commit_tokens": ["update", "node", "modules", "and", "fix", "regression"], "add_tokens": "expiry : new Date ( Date . now ( ) + 3600000 * 24 ) created : new Date ( Date . now ( ) - 3600000 * 200 ) , updated : new Date ( Date . now ( ) - 3600000 * 200 ) , expiry : new Date ( 'Tue Nov 08 2017 23:59:00 GMT+0100 (CET)' ) created : new Date ( ) , updated : new Date ( ) ,", "del_tokens": "expiry : new Date ( 'Tue Nov 08 2016 23:59:00 GMT+0100 (CET)' ) created : new Date ( 'Mon Nov 09 2015 08:20:21 GMT+0100 (CET)' ) , updated : new Date ( 'Mon Nov 09 2015 08:20:21 GMT+0100 (CET)' ) , expiry : new Date ( 'Tue Nov 08 2016 23:59:00 GMT+0100 (CET)' ) created : new Date ( 'Mon Nov 09 2015 08:20:21 GMT+0100 (CET)' ) , updated : new Date ( 'Mon Nov 09 2015 08:20:21 GMT+0100 (CET)' ) ,", "commit_type": "update"}
{"commit_tokens": ["Fix", "test", "for", "profile", "=", "true"], "add_tokens": "/ * * / assert . equal ( result . value , 1 ) ;", "del_tokens": "assert . equal ( result , 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "a", "matrial", "-", "color", "applicator"], "add_tokens": "/** the emissive value of a node's material */ if ( node . material && node . material . emissive ) { node . material . emissive . setRGB ( ... parsedValue ) } } ) /** the duffuse color value of a node's material */ Applicators . set ( 'material-color' , ( node , styleInfo ) => { if ( ! node . material || ! node . material . emissive ) return const parsedValue = Evaluators . parse ( styleInfo . value , node ) if ( typeof parsedValue === 'undefined' ) return if ( node . material && node . material . color ) { node . material . color . setRGB ( ... parsedValue ) }", "del_tokens": "/** the emissive color of a node's material */ node . material . emissive . setRGB ( ... parsedValue )", "commit_type": "add"}
{"commit_tokens": ["Add", "check", "for", "undefined", "logAttributes", ".", "msg", "in", "lib", "/", "handler", "/", "console", ".", "js"], "add_tokens": "} else if ( typeof logAttributes . msg !== 'undefined' ) {", "del_tokens": "} else {", "commit_type": "add"}
{"commit_tokens": ["Fix", "debugging", "method", "in", "test", "command"], "add_tokens": "var document = new Document ( ) . setLanguage ( language ) ; if ( options . debug ) document . debugLex ( console . log ) . debugParse ( console . log ) ;", "del_tokens": "var document = new Document ( ) . setLanguage ( language ) . setDebug ( options . debug ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "the", "situation", "of", "setting", "the", "preferred", "countries", "&", "auto", "detection"], "add_tokens": "if ( countryCode === 'auto' ) { return 'auto' ; } if ( this . props . preferredCountries . length > 0 ) { countryData = utils . getCountryData ( this . props . preferredCountries [ 0 ] ) ; } else { countryData = AllCountries . getCountries ( ) [ 0 ] ; }", "del_tokens": "countryData = AllCountries . getCountries ( ) [ 0 ] ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "to", "latest", "repo", "layout", "+", "npm", "commands", "."], "add_tokens": "var useTranspiled = true ; // eslint-disable-line no-var try { require . resolve ( \"./lib\" ) ; } catch ( e ) { useTranspiled = false ; } if ( useTranspiled ) { // require(\"babel/polyfill\"); module . exports = require ( \"./lib\" ) ; } else { require ( \"babel/register\" ) ; module . exports = require ( \"./src\" ) ; }", "del_tokens": "module . exports = function ( opts = { } ) { var isJsonFile = opts . filter || / \\.json$ / ; return function ( override , transform , control ) { // https://github.com/interlockjs/interlock/blob/master/docs/extensibility.md#readsource transform ( \"readSource\" , function ( source , args ) { const asset = args [ 0 ] ; if ( isJsonFile . test ( asset . path ) ) { source = ` ${ source } ` ; } return source ; } ) ; } ; } ;", "commit_type": "update"}
{"commit_tokens": ["added", "the", "option", "to", "use", "parent", "scope", "variables", "in", "the", "label", "templates"], "add_tokens": "$scope . parentScopeOfTree = $scope . $parent ; // create a scope for the transclusion, whos parent is the parent of the tree control scope . transcludeScope = scope . parentScopeOfTree . $new ( ) ; scope . transcludeScope . node = scope . node ; scope . $on ( '$destroy' , function ( ) { scope . transcludeScope . $destroy ( ) ; } ) ; scope . $treeTransclude ( scope . transcludeScope , function ( clone ) {", "del_tokens": "scope . $treeTransclude ( scope , function ( clone ) {", "commit_type": "add"}
{"commit_tokens": ["Updating", "the", "run", "benchmarker", "to", "latest", "compiled", "code"], "add_tokens": "var template = function ( $$vmc ) { return function ( $$Lisplate , $data , $strings , $runtime ) { var $viewmodel = $$vmc ? new $$vmc ( $data ) : null ; var $helper = $$Lisplate . helpers ; var $_w = $runtime . $W ; var $i_each = $runtime . each , $i_escapeHtml = $runtime . escapeHtml , $i_if = $runtime . if ; $c . w ( $i_each ( $data . friends , ( function ( friend ) { $c . w ( $i_escapeHtml ( $data . getFullNameMve ( friend ) ) )", "del_tokens": "var template = function ( vmc ) { return function ( $L , $p , $i ) { var $v = vmc ? new vmc ( $p ) : null ; var $h = $L . helpers ; var $_w = $i . $W ; var $i_each = $i . each , $i_escapeHtml = $i . escapeHtml , $i_if = $i . if ; $c . w ( $i_each ( $p . friends , ( function ( friend ) { $c . w ( $i_escapeHtml ( $p . getFullNameMve ( friend ) ) )", "commit_type": "update"}
{"commit_tokens": ["Adding", "support", "for", "Service", "Workers", "."], "add_tokens": "// Service workers don't have XHR if ( global . XMLHttpRequest ) { var xhr = new global . XMLHttpRequest ( ) // If XDomainRequest is available (ie only, where xhr might not work // cross domain), use the page location. Otherwise use example.com xhr . open ( 'GET' , global . XDomainRequest ? '/' : 'https://example.com' ) } else { var xhr = null } if ( ! xhr ) return false exports . overrideMimeType = xhr ? isFunction ( xhr . overrideMimeType ) : false", "del_tokens": "var xhr = new global . XMLHttpRequest ( ) // If XDomainRequest is available (ie only, where xhr might not work // cross domain), use the page location. Otherwise use example.com xhr . open ( 'GET' , global . XDomainRequest ? '/' : 'https://example.com' ) exports . overrideMimeType = isFunction ( xhr . overrideMimeType )", "commit_type": "add"}
{"commit_tokens": ["remove", "https", "parameter", "not", "needed"], "add_tokens": "proxy : 'https://' + config . store", "del_tokens": "proxy : 'https://' + config . store , https : true", "commit_type": "remove"}
{"commit_tokens": ["Improve", "type", "of", "copy", "action"], "add_tokens": "export function copy < T > (state: Types.StoreState < T > ) { return { copied : PointSet . reduce ( ( acc , point ) => PointMap . set < T > ( point , Matrix . get < T > ( point . row , point . column , state . data ) , acc ) , state . selected , PointMap . from < T > ( [ ] ) ) , cut : false , hasPasted : false } ; }", "del_tokens": "export const copy = ( state : Types . StoreState < * > ) => ( { copied : PointSet . reduce ( ( acc , point ) => PointMap . set ( point , Matrix . get ( point . row , point . column , state . data ) , acc ) , state . selected , PointMap . from ( [ ] ) ) , cut : false , hasPasted : false } ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "bug", "causing", "incorrect", "uri", "()", "value", "in", "Wee", ".", "routes"], "add_tokens": "var search = a . search ; full : '/' + path + search + a . hash ,", "del_tokens": "var search = a . search . slice ( 1 ) ; full : '/' + path + a . search + a . hash ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "multiple", "emails", "and", "multiple", "phone", "numbers", "return", "name", "as", "well", "as", "firstName", "and", "lastName"], "add_tokens": "this . name = \"\" ; this . phones = { } ; this . emails = { } ; return this . name ;", "del_tokens": "this . phoneNumber = \"\" ; return this . firstName + \" \" + this . lastName ;", "commit_type": "add"}
{"commit_tokens": ["Add", "string", "to", "init", "function"], "add_tokens": "} , { type : 'string' , name : '_someString' } , [ '1' , '2' , '3' , \"SomeString\" ] ) ; console . log ( await dummySTO . someString ( ) ) ;", "del_tokens": "} , [ '1' , '2' , '3' ] ) ; // console.log(await dummySTO.someString());", "commit_type": "add"}
{"commit_tokens": ["fix", "v11", "circles", "not", "recognized"], "add_tokens": "if ( ! sixth || / ^(?:[0-9]+:)+? / . test ( sixth ) ) { this . beatmap . nbcircles ++ ; }", "del_tokens": "if ( ! sixth || / ^(?:[0-9]+:)+?$ / . test ( sixth ) ) { this . beatmap . nbcircles ++ ; }", "commit_type": "fix"}
{"commit_tokens": ["fixed", "a", "type", "in", "method"], "add_tokens": "this . getWebViewBridgeHandle ( ) , this . getWebViewBridgeHandle ( ) , this . getWebViewBridgeHandle ( ) , getWebViewBridgeHandle : function ( ) : any {", "del_tokens": "this . getWebViewHandle ( ) , this . getWebViewHandle ( ) , this . getWebViewHandle ( ) , getWebViewHandle : function ( ) : any {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "conditions", "for", "checking", "media", "-", "type", "when", "loading", "local", "RDF", "files", "."], "add_tokens": "if ( mediaType != null ) { if ( mediaType != null ) {", "del_tokens": "if ( mediaType == null ) { if ( mediaType == null ) {", "commit_type": "fix"}
{"commit_tokens": ["Update", "version", "in", "TypeScript", "declaration", "and", "externs", "file"], "add_tokens": "* @ fileoverview Externs for wavefile 8.1", "del_tokens": "* @ fileoverview Externs for wavefile 8.0", "commit_type": "update"}
{"commit_tokens": ["Removed", "false", "from", "before", "added", "this", ".", "exit", "()", "to", "exit", "immediately", "from", "before"], "add_tokens": "const ExitError = require ( './ExitError' ) ; yield controller . before . call ( context ) ; if ( e instanceof ExitError ) { // Lets Exit Immediately return ; } else if ( ! ( e instanceof SkipError ) ) {", "del_tokens": "if ( false === ( yield controller . before . call ( context ) ) ) { return ; } if ( ! ( e instanceof SkipError ) ) {", "commit_type": "remove"}
{"commit_tokens": ["update", "tests", "to", "cause", "uncaught", "error", "when", "adding", "task", "source"], "add_tokens": "hoodie . database . add ( 'user/foo' , function ( err ) { hoodie . task . addSource ( 'user/foo' ) ; var db = hoodie . database ( 'user/foo' ) ; hoodie . task . removeSource ( 'user/foo' ) ;", "del_tokens": "hoodie . database . add ( 'foo' , function ( err ) { hoodie . task . addSource ( 'foo' ) ; var db = hoodie . database ( 'foo' ) ; hoodie . task . removeSource ( 'foo' ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "response", "when", "timeout", "exceeds"], "add_tokens": "defer . reject ( new Response ( 405 , { } , 'timeout exceeded' ) ) ;", "del_tokens": "defer . reject ( 'Timeout exceeded' ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "WSS", "for", "remotedev", ".", "io"], "add_tokens": "secure : true , port : 443 ,", "del_tokens": "secure : false , port : 80 ,", "commit_type": "use"}
{"commit_tokens": ["allow", ">", "2", "arguments", "to", "subscribe"], "add_tokens": "if ( cb . length < 2 ) {", "del_tokens": "if ( cb . length !== 2 ) {", "commit_type": "allow"}
{"commit_tokens": ["Fix", "expr", "key", "to", "include", "."], "add_tokens": "var k = 'e:' + _ . $expr + '_' + _ . $name ;", "del_tokens": "var k = 'e:' + _ . $expr ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "TEST", "-", "prepend", "from", "the", "file", "name"], "add_tokens": "return str . replace ( / \\& / g , \"&amp;\" ) . replace ( / < / g , \"&lt;\" ) . replace ( / \\' / g , \"&apos;\" ) ; var fileName = this . getFullName ( suite , true ) + '.xml' ;", "del_tokens": "return str . replace ( / < / g , \"&lt;\" ) . replace ( / \\' / g , \"&apos;\" ) . replace ( / \\& / g , \"&amp;\" ) ; var fileName = 'TEST-' + this . getFullName ( suite , true ) + '.xml' ;", "commit_type": "remove"}
{"commit_tokens": ["added", "its", "own", "dev", ".", "server", "and", "livereload"], "add_tokens": "// Load Grunt tasks declared in the package.json file require ( 'matchdep' ) . filterDev ( 'grunt-*' ) . forEach ( grunt . loadNpmTasks ) ; } , connect : { all : { options : { port : 9000 , base : 'examples' } } } , watch : { all : { files : [ 'app/**/*' , 'examples/*' ] , options : { // `livereload : true` starts livereload server at port 35729 to broadcast file changes // Your browser needs to listen this broadcasting and update your page // Thus, install browser extension and click to enable/disable // . https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei livereload : true // starts livereload server at port 35729 } } grunt . registerTask ( 'server' , [ 'connect' , 'watch' ] ) ;", "del_tokens": "// load plugins grunt . loadNpmTasks ( 'grunt-contrib-clean' ) ; grunt . loadNpmTasks ( 'grunt-contrib-concat' ) ; grunt . loadNpmTasks ( 'grunt-contrib-copy' ) ; grunt . loadNpmTasks ( 'grunt-contrib-uglify' ) ; grunt . loadNpmTasks ( 'grunt-bump' ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "log", "with", "too", "many", "data"], "add_tokens": "* @ param error : the usual nodejs error * @ param result : the crawled resource *", "del_tokens": "* @ param error The usual nodejs error * @ param result : the result of the resource crawl * @ param the jquery like object for accessing to the HTML tags . Null is the resource * is not an HTML //console.log(error);", "commit_type": "remove"}
{"commit_tokens": ["fixed", "jshint", "error", "and", "updated", "test"], "add_tokens": "// Libs var async = require ( 'async' ) ; var exec = require ( 'child_process' ) . exec ; var path = require ( 'path' ) ; } ) ; } ;", "del_tokens": "var async = require ( 'async' ) ; var exec = require ( 'child_process' ) . exec ; var path = require ( 'path' ) ; } ) } ;", "commit_type": "fix"}
{"commit_tokens": ["Move", "ingress", "functions", "to", "its", "own", "helper", ".", "Fix", "info", "command"], "add_tokens": "const helpers = require ( './helpers' ) ; const ingressHelper = require ( './ingress' ) ; item . metadata . labels && _ . isEqual ( item . metadata . labels , ingressHelper . getIngressRuleLabels ( functions ) ) const rule = _ . find ( fIngress . spec . rules , r => _ . some ( r . http . paths , p => p . backend . serviceName === f ) ) ; const path = _ . find ( rule . http . paths , p => p . backend . serviceName === f ) . path ; url = ` ${ rule . host || 'API_URL' } ${ path } ` ;", "del_tokens": "const helpers = require ( '../lib/helpers' ) ; item . metadata . labels && item . metadata . labels . function === f url = ` ${ fIngress . spec . rules [ 0 ] . host || 'API_URL' } ` + ` ${ fIngress . spec . rules [ 0 ] . http . paths [ 0 ] . path } ` ;", "commit_type": "move"}
{"commit_tokens": ["removed", "transitionDuration", ";", "duration", "instead"], "add_tokens": "* AngularJS - nvD3 , v1 .0 .3 - dev ; MIT License ; 04 / 11 / 2015 20 : 22 scope . svg . datum ( data ) . call ( scope . chart ) ;", "del_tokens": "* AngularJS - nvD3 , v1 .0 .3 - dev ; MIT License ; 04 / 11 / 2015 17 : 22 // TODO this triggers one more refresh. Refactor it! scope . options . chart . transitionDuration = + scope . options . chart . transitionDuration || 250 ; scope . svg . datum ( data ) . transition ( ) . duration ( scope . options . chart . transitionDuration ) . call ( scope . chart ) ;", "commit_type": "remove"}
{"commit_tokens": ["update", "example", "with", "new", "api", "for", "message"], "add_tokens": "self . fsw . message ( { to : num + '@' + self . provider , from : self . from , profile : self . profile , body : msg } , function ( evt ) {", "del_tokens": "self . fsw . message ( num + '@' + self . provider , self . from , self . profile , msg , function ( evt ) {", "commit_type": "update"}
{"commit_tokens": ["added", "eslint", "and", "missing", "jsdoc", "entry"], "add_tokens": "* @ param { string } key", "del_tokens": "* @ param key", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "cas", "example", "."], "add_tokens": "'EXISTS' : function ( tokens , dataSet ) { return [ CONTINUE , false ] } , ( cas ? ' ' + cas : '' ) +", "del_tokens": "'EXISTS' : function ( tokens , dataSet ) { return [ CONTINUE , true ] } , ( cas ? cas : '' ) +", "commit_type": "add"}
{"commit_tokens": ["updating", "js", "-", "to", "-", "string"], "add_tokens": "this . jsToStringOptions = { execFuncs : [ \"data\" ] , } ; script : jsToString ( cleanBundle , this . jsToStringOptions ) , script : jsToString ( cleanBundle , this . jsToStringOptions ) ,", "del_tokens": "script : jsToString ( cleanBundle ) , script : jsToString ( cleanBundle ) ,", "commit_type": "update"}
{"commit_tokens": ["Added", "support", "for", "optional", "image", "file", "size", "limit", "restriction", "on", "inlineImages", "option"], "add_tokens": "// If inlineImages is not an object but evaluates to true // create object with default options if ( options . inlineImages && typeof options . inlineImages !== 'object' ) { options . inlineImages = { options : { limit : 0 } } ; } // Read the file in and convert it if its an image // If a size limit given skip if file larger than limit if ( options . inlineImages . options . limit > 0 ) { var stat = fs . statSync ( localImagePath ) ; if ( stat . size > options . inlineImages . options . limit ) { continue ; } }", "del_tokens": "// Read the file in and convert it if its an image", "commit_type": "add"}
{"commit_tokens": ["Fix", "bad", "property", "access", "in", "summary", "mapper", "."], "add_tokens": "value : getMedianRun ( result , 'SpeedIndex' , 'first' ) . requests", "del_tokens": "value : getMedianRun ( result , 'SpeedIndex' , 'first' ) . requests . length", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "A", "+", "bug", "."], "add_tokens": "this . resolve = MPromise . prototype . resolve . bind ( this ) ; this . fulfill = MPromise . prototype . fulfill . bind ( this ) ; this . reject = MPromise . prototype . reject . bind ( this ) ;", "del_tokens": "this . resolve = this . resolve . bind ( this ) ; this . fulfill = this . fulfill . bind ( this ) ; this . reject = this . reject . bind ( this ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "LESS", "by", "letting", "the", "possibility", "to", "choose", "the", "extension", "of", "branch", ".", "css", "files", "threw", "options", ".", "extension"], "add_tokens": "if ( name . indexOf ( 'branch' ) === - 1 ) { var generate = function ( tree , parent , options ) { var branchFile = 'branch' + options . extension ; content += '@import \"../' + branchFile + '\";\\n' ; fs . writeFileSync ( tree . path + '/' + branchFile , content , { generate ( child , tree , options ) ; generate : function ( tree , options ) { if ( ! options ) { options = { extension : '.css' } ; } if ( ! options . extension ) { options . extension = '.css' ; } generate ( tree , null , options ) ;", "del_tokens": "if ( name !== 'branch.css' ) { var generate = function ( tree , parent ) { content += '@import \"../branch.css\";\\n' ; fs . writeFileSync ( tree . path + '/branch.css' , content , { generate ( child , tree ) ; generate : function ( tree ) { generate ( tree , null ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "bug", "at", "copy"], "add_tokens": "if ( totalFiles === 0 ) { if ( callback ) { callback ( ) ; } } else { rootsArray . forEach ( function ( rootObject ) { rootObject . files . forEach ( function ( relativePath ) { fs . copy ( path . join ( rootObject . root , relativePath ) , path . join ( output , relativePath ) , function ( err ) { totalFiles -- ; if ( totalFiles == 0 ) { if ( callback ) { callback ( ) ; } } ) ; }", "del_tokens": "rootsArray . forEach ( function ( rootObject ) { rootObject . files . forEach ( function ( relativePath ) { fs . copy ( path . join ( rootObject . root , relativePath ) , path . join ( output , relativePath ) , function ( err ) { totalFiles -- ; if ( totalFiles == 0 ) { if ( callback ) { callback ( ) ; } } ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "ability", "to", "disable", "console", "logger"], "add_tokens": "var enabled = true ; if ( enabled ) { if ( arguments . length < 2 ) { message = tags ; tags = [ ] ; } if ( ! util . isArray ( tags ) ) tags = [ ] ; var text = new Date ( ) . getTime ( ) + ', ' ; if ( tags . length > 0 ) { text = text + tags [ 0 ] + ', ' ; } text = text + message ; console . log ( text ) ; Logger . enabled = function ( _enabled_ ) { enabled = _enabled_ ; } ;", "del_tokens": "if ( arguments . length < 2 ) { message = tags ; tags = [ ] ; } if ( ! util . isArray ( tags ) ) tags = [ ] ; var text = new Date ( ) . getTime ( ) + ', ' ; if ( tags . length > 0 ) { text = text + tags [ 0 ] + ', ' ; text = text + message ; console . log ( text ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "SVG", "path", "generation", "to", "render", "phase"], "add_tokens": "var points = e . attrs . points . split ( \" \" ) ; if ( e . attrs . type === \"line\" ) { path . setAttribute ( \"d\" , \"M \" + points [ 0 ] + \" L \" + points . slice ( 1 ) . join ( \" \" ) ) ; } else if ( e . attrs . type === \"curve\" ) { path . setAttribute ( \"d\" , \"M \" + points [ 0 ] + \" C \" + points . slice ( 1 ) . join ( \" \" ) ) ; }", "del_tokens": "path . setAttribute ( \"d\" , e . attrs . path ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "periodic", "invalid", "Unicode", "filename", "header"], "add_tokens": "/ ** * RegExp to match US - ASCII string * / var asciiStringRegExp = / ^[\\x00-\\x7f]*$ / if ( asciiStringRegExp . test ( name ) ) {", "del_tokens": "if ( ! nonAsciiRegExp . test ( name ) ) {", "commit_type": "fix"}
{"commit_tokens": ["use", "8086", "port", "fallback", "when", "running", "dev", "build"], "add_tokens": "} else if ( ! __DEBUG__ && / ^http(s)?:$ / . test ( window . location . protocol ) ) { // don't use served port when running webpack-dev-server", "del_tokens": "} else if ( / ^http(s)?:$ / . test ( window . location . protocol ) ) {", "commit_type": "use"}
{"commit_tokens": ["remove", "thirdparty", "libs", "from", "preload", "in", "gruntfile"], "add_tokens": "libraries : { 'nabi/m' : { src : [ 'nabi/m/**' , '!nabi/m/thirdparty/**' ] } }", "del_tokens": "libraries : true", "commit_type": "remove"}
{"commit_tokens": ["Fix", "bugs", "in", "implementation", "global", "Howler", "reference", "bad", "links"], "add_tokens": "var Howler = new HowlerGlobal ( ) ; return Howler ;", "del_tokens": "return new HowlerGlobal ( )", "commit_type": "fix"}
{"commit_tokens": ["Removed", "last", "check", "it", "was", "pointles"], "add_tokens": "{ regexp : / (MSIE) (\\d+)\\.(\\d+) / , family_replacement : 'Internet Explorer' }", "del_tokens": "{ regexp : / (MSIE) (\\d+)\\.(\\d+) / , family_replacement : 'Internet Explorer' } , { regexp : / (SymbianOS)\\/(\\d+) / , family_replacement : 'Symbian OS' }", "commit_type": "remove"}
{"commit_tokens": ["Update", "c", "-", "actions", ".", "js"], "add_tokens": "it ( 'should replace text in an element' , function ( ) {", "del_tokens": "it . only ( 'should replace text in an element' , function ( ) {", "commit_type": "update"}
{"commit_tokens": ["Fix", "in", "helper", "for", "contract", "interact"], "add_tokens": "return helper . sendTxAsyncFromAddr ( web3RpcProvider , currContractAddr , encodeABI , senderAddr , senderPassphrase , txOptions ) ; var tryReceipt = function ( ) { setTimeout ( function ( ) { web3RpcProvider . eth . getTransactionReceipt ( transactionHash ) . then ( handleResponse ) ; } , 5000 ) ; } ;", "del_tokens": "return sendTxAsyncFromAddr ( web3RpcProvider , currContractAddr , encodeABI , senderAddr , senderPassphrase , txOptions ) ; var tryReceipt = setTimeout ( function ( ) { web3RpcProvider . eth . getTransactionReceipt ( transactionHash ) . then ( handleResponse ) ; } , 5000 ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "end", "index", "check", "for", "eol", "issue", "(", "broken", "test", "added", "then", "change", "applied", "which", "fixed", "test", ")"], "add_tokens": "if ( start + 1 > max ) { return false ; }", "del_tokens": "if ( start + 3 >= max ) { return false ; }", "commit_type": "fix"}
{"commit_tokens": ["Move", "to", "linting", "lib", "instead", "of", "bin", "."], "add_tokens": "var runSequence = require ( 'run-sequence' ) ; var srcDir = 'lib' ; return gulp . src ( srcDir + '/**/*.js' ) . gulp . task ( 'lint' , function ( ) { return gulp . src ( srcDir + '/**/*.js' ) . pipe ( eslint . failAfterError ( ) ) ; // Run in serial to fail build if lint fails. gulp . task ( 'default' , function ( callback ) { return runSequence ( 'lint' , 'build' , callback ) ; } ) ;", "del_tokens": "var buildDir = 'bin' ; return gulp . src ( buildDir + '/**/*.js' ) . gulp . task ( 'eslint' , [ 'build' ] , function ( ) { return gulp . src ( buildDir + '/**/*.js' ) . pipe ( eslint . failOnError ( ) ) ; gulp . task ( 'default' , [ 'build' , 'eslint' ] ) ;", "commit_type": "move"}
{"commit_tokens": ["Update", "build", "order", "for", "outbound", "requests", "on", "async", "load"], "add_tokens": "\"src/visualize.js\" , \"src/async.js\" , \"src/outro.js\" , \"lib/chartstack/dist/chartstack.js\" , \"src/plugins/keen-chartstack.js\" \"src/async.js\" , \"src/async.js\" , \"src/async.js\" ,", "del_tokens": "\"src/async.js\" , \"src/outro.js\" //\"src/plugins/keen-pageviews.js\", //\"lib/chartstack/dist/chartstack.min.js\", //\"src/plugins/keen-chartstack.js\" \"src/async.js\" , \"src/async.js\" , \"src/async.js\" ,", "commit_type": "update"}
{"commit_tokens": ["Fixed", "up", "logic", "to", "consistently", "work", "in", "all", "cases"], "add_tokens": "function get ( key ) { return settings [ key ] ; if ( get ( 'imagemagick' ) || ! gmExists ) {", "del_tokens": "function get ( option ) { return settings . imagemagick ; if ( get ( 'imagemagick' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "use", "()", "function", "to", "register", "Express", "/", "Connect", "middleware"], "add_tokens": "var self = this ; this . _app . use ( function ( req , res , next ) { return self . handleRequest ( req , res , next ) ; } ) ; / ** * Use Connect / Express middleware . * * @ method use * @ param { function } callback * / BlueGate . prototype . use = function ( callback ) { if ( typeof this . server !== 'undefined' ) { throw Error ( 'Cannot register middleware after starting application.' ) ; } this . _app . use ( callback ) ; } ;", "del_tokens": "var self = this ; this . _app . use ( function ( req , res , next ) { return self . handleRequest ( req , res , next ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "the", "offset", "and", "source", "properties", "to", "the", "LcovError", "class"], "add_tokens": "* @ param { * } [ source ] The actual source input which caused the error . * @ param { number } [ offset ] message The offset in ` ` where the error was detected . constructor ( message , source = null , offset = - 1 ) { / ** * The offset in ` ` where the error was detected . * @ type { number } * / this . offset = offset ; / ** * The actual source input which caused the error . * @ type { * } * / this . source = source ; let values = [ ` ${ this . message } ` ] ; if ( this . offset >= 0 ) values . push ( ` ${ this . offset } ` ) ; return ` ${ this . name } ${ values . join ( ', ' ) } ` ; throw new LcovError ( 'The coverage data has an invalid LCOV format' , coverage ) ; if ( ! report . records . length ) throw new LcovError ( 'The coverage data is empty' , coverage ) ;", "del_tokens": "constructor ( message ) { return ` ${ this . name } ${ this . message } ` ; throw new LcovError ( 'The coverage data has an invalid LCOV format' ) ; if ( ! report . records . length ) throw new LcovError ( 'The coverage data is empty' ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "lock", "()", "unit", "tests"], "add_tokens": "it ( 'should call isScreenLocked and keyevent with correct args' , async ( ) => { mocks . adb . expects ( \"isScreenLocked\" ) . once ( ) . returns ( false ) ;", "del_tokens": "it ( 'should call keyevent with correct args' , async ( ) => {", "commit_type": "update"}
{"commit_tokens": ["Fix", "animate", "prop", "bug", "no", "more", "returning", "undefined", "by", "default"], "add_tokens": "const style = props . animate ? makePathTransitionStyle ( props . animationDuration , props . animationEasing ) : undefined ;", "del_tokens": "const style = props . animate && makePathTransitionStyle ( props . animationDuration , props . animationEasing ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "the", "concept", "of", "shake", "to", "the", "particle", "system"], "add_tokens": "/ * * Inspired in GameMaker Particle System by https : //www.yoyogames.com/ * / sprite : null , //TODO: Random sprite increase : 0 , x : 1 , y : 1 0 , 0 , 1 , 1 min : 2 , max : 5 , increase : 0.01 , amount : 0 , increase : 0 , increase : 0 , this . easing = PQ . Easing . linear ( ) ;", "del_tokens": "sprite : null , increase : - 0 , x : 6 , y : 0.5 0.5 , 1 , 0.1 , 1 , 0.2 min : 5 , max : 10 , increase : - 0.1 , amount : 9 , increase : 5 , increase : - 20 , this . easing = PQ . Easing . outSine ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "generating", "26", "char", "id"], "add_tokens": "var pid = typeof process === 'undefined' || ( typeof process . pid !== 'number' ? Math . floor ( Math . random ( ) * 100000 ) : process . pid ) % 0xFFFF ;", "del_tokens": "var pid = typeof process === 'undefined' || typeof process . pid !== 'number' ? Math . floor ( Math . random ( ) * 100000 ) : process . pid % 0xFFFF ;", "commit_type": "fix"}
{"commit_tokens": ["moved", "runner", "start", "/", "stop", "from", "npm", "pre", "/", "posttest", "hooks", "to", "mocha", "global", "hooks", "."], "add_tokens": "var runner = require ( 'mongodb-runner' ) ; var runnerOpts = { topology : 'replicaset' } ; before ( function ( done ) { this . timeout ( 20000 ) ; debug ( 'launching local replicaset.' ) ; runner ( runnerOpts , done ) ; } ) ; after ( function ( done ) { this . timeout ( 10000 ) ; debug ( 'stopping replicaset.' ) ; runner . stop ( runnerOpts , done ) ; } ) ; count ++ ;", "del_tokens": "count ++ ;", "commit_type": "move"}
{"commit_tokens": ["Allow", "only", "drilling", "into", "own", "properties"], "add_tokens": "* To prevent confusion , only own properties are drilled into . * var nextObject = ( object && object . hasOwnProperty ( key ) && object [ key ] || undefined ) ; return dd ( nextObject , object , key ) ;", "del_tokens": "return dd ( object && object [ key ] , object , key ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "test", "and", "docs", "for", "context", "passed", "to", "conditional"], "add_tokens": "} ) ; } ) ; describe ( 'conditional items that depend on context' , function ( ) { it ( 'passes the context to the conditional' , function ( ) { var context = { foo : 'my context' , bar : 'another field' } ; var res = null ; return Checkit ( { } ) . maybe ( { } , function ( item , context ) { res = context ; } ) . run ( { } , context ) . then ( function ( ) { deepEqual ( res , context ) ; } ) ; } ) ;", "del_tokens": "} )", "commit_type": "add"}
{"commit_tokens": ["Updated", "Readme", "to", "include", "CandleStick", "Patterns"], "add_tokens": "let GraveStoneDoji = require ( './lib/candlestick/GraveStoneDoji' ) ; let Harami = require ( './lib/candlestick/Harami' ) ; let HaramiCross = require ( './lib/candlestick/HaramiCross' ) ; DragonFlyDoji : new DragonFlyDoji ( ) , GraveStoneDoji : new GraveStoneDoji ( ) , Harami : new Harami ( ) , HaramiCross : new HaramiCross ( ) ,", "del_tokens": "DragonFlyDoji : new DragonFlyDoji ( )", "commit_type": "update"}
{"commit_tokens": ["Implemented", "SelectMany", "and", "Flatten", "methods"], "add_tokens": "return ( Symbol . iterator in Object ( obj ) )", "del_tokens": "return ( Symbol . iterator in obj )", "commit_type": "implement"}
{"commit_tokens": ["fix", "Prism", "from", "wrongfully", "populating", "config", "params"], "add_tokens": "if ( ! that . opts . prism . host ) that . opts . prism . host = that . opts . domain if ( ! that . opts . prism . port ) that . opts . prism . port = port || 5971", "del_tokens": "that . opts . prism . host = that . opts . domain that . opts . prism . port = port || 5971", "commit_type": "fix"}
{"commit_tokens": ["updates", "to", "revert", "now", "unneeded", "changes", "etc", "."], "add_tokens": "val = typeof val === 'string' ? { id : val } : val ; val = new TinCan . Activity ( val ) ;", "del_tokens": "val = new TinCan . Activity ( { id : val } ) ;", "commit_type": "update"}
{"commit_tokens": ["Fixing", "the", "tags", "required", "for", "jsdoc"], "add_tokens": "* @ constructor * @ param { Dispatcher } dispatcher The API dispatcher", "del_tokens": "* @ param { [ type ] } dispatcher [ description ]", "commit_type": "fix"}
{"commit_tokens": ["fix", "bug", "with", "no", "rollbar", "defined"], "add_tokens": "else if ( options . rollbar ) options . rollbar . error ( err ) . then ( exit , exit ) ; else exit ( ) ;", "del_tokens": "else options . rollbar . error ( err ) . then ( exit , exit ) ;", "commit_type": "fix"}
{"commit_tokens": ["Making", "polymer", "controls", "better", "."], "add_tokens": "if ( reason === 'execution' ) callback ( undefined , error ) ; else callback ( undefined , { 'reason' : reason , 'message' : error } ) ;", "del_tokens": "if ( error ) callback ( error ) ; else callback ( reason ) ;", "commit_type": "make"}
{"commit_tokens": ["allow", "nodes", "as", "column", "headers"], "add_tokens": "name : PropTypes . node . isRequired ,", "del_tokens": "name : PropTypes . string . isRequired ,", "commit_type": "allow"}
{"commit_tokens": ["Make", "short", "-", "circuiting", "redux", "store", "optional"], "add_tokens": "reducer ( action , location ) ; } else { reducer ( action ) ; // shortcircuit by default (don't pass to redux store), unless explicitly set // to false. if ( options . shortcircuit === false ) { return next ( action ) ; } return undefined ;", "del_tokens": "return reducer ( action , location ) ; return reducer ( action ) ;", "commit_type": "make"}
{"commit_tokens": ["Updated", "dependencies", "and", ".", "eshintrc"], "add_tokens": "'use strict' ;", "del_tokens": "'use strict' ;", "commit_type": "update"}
{"commit_tokens": ["Added", "callback", "to", "Drakov", ".", "run", "()"], "add_tokens": "exports . run = function ( argv , cb ) { if ( cb ) { seriesFunctions . push ( cb ) ; }", "del_tokens": "exports . run = function ( argv ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "v", "manually", "to", "getAthenaHeader", "s", "version", "number"], "add_tokens": "' * Athena Framework v<%= config.pkg.version %> (<%= config.pkg.homepage %>)' ,", "del_tokens": "' * Athena Framework <%= config.pkg.version %> (<%= config.pkg.homepage %>)' ,", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "opening", "Google", "Chrome", "under", "windows"], "add_tokens": "var isWin = / ^win / . test ( process . platform ) ; , app : isWin ? \"chrome\" : \"Google Chrome\"", "del_tokens": ", app : \"Google Chrome\"", "commit_type": "add"}
{"commit_tokens": ["Remove", "logic", "merely", "for", "the", "determining", "of", "log", "msgs"], "add_tokens": "var desc ; self . log ( \"...found.\" ) ; return desc . value ;", "del_tokens": "var result , proxied , desc , tvar ; result = desc . value ; if ( undefined === result || util . isPrimitive ( result ) ) { self . log ( \"...found and not object\" ) ; return result ; } if ( 'function' === typeof result ) { self . log ( \"...found and is a function\" ) ; return result ; } return result ;", "commit_type": "remove"}
{"commit_tokens": ["Move", "PATH", "mutation", "into", "example", "program"], "add_tokens": "} ) . cwd ( 'example' ) ;", "del_tokens": "/ ** * Appends ` ` to the world ' * / nixt . register ( 'path' , function ( dir ) { var path = require ( 'path' ) ; var PATH = this . world . env . PATH ; return this . env ( 'PATH' , path . join ( process . cwd ( ) , dir ) + path . delimiter + PATH ) ; } ) ; } ) . cwd ( 'examples' ) . path ( 'examples' ) ;", "commit_type": "move"}
{"commit_tokens": ["Remove", "invalid", "options", "in", "example", "code"], "add_tokens": "rules : { globals : [ '$' ] , envs : {", "del_tokens": "// gulp-eslint's config works much like .eslintrc with a dash of ESLint's CLI 'extends' : 'eslint:recommended' , 'ecmaFeatures' : { 'modules' : true } , 'rules' : { 'globals' : { '$' : false } , 'envs' : {", "commit_type": "remove"}
{"commit_tokens": ["Fix", "support", "for", "raw", "CoAP", "values"], "add_tokens": "const raw = this . _accessory instanceof accessory_1 . Accessory ? this . _accessory . options . skipValueSerializers : false ; const proxy = createRGBProxy ( raw ) ; function createRGBProxy ( raw = false ) { if ( raw ) { me . hue = definition . hue_raw ; me . saturation = definition . saturation_raw ; } else { me . hue = definition . hue ; me . saturation = definition . saturation ; } if ( raw ) { me . hue = Math . round ( h / 360 * predefined_colors_1 . MAX_COLOR ) ; me . saturation = Math . round ( s * predefined_colors_1 . MAX_COLOR ) ; } else { me . hue = h ; me . saturation = s * 100 ; }", "del_tokens": "const proxy = createRGBProxy ( ) ; function createRGBProxy ( ) { me . hue = definition . hue ; me . saturation = definition . saturation ; me . hue = h ; me . saturation = s * 100 ;", "commit_type": "fix"}
{"commit_tokens": ["Made", "a", "way", "to", "turn", "the", "debug", "and", "network", "messages", "on", "and", "off"], "add_tokens": "console . log ( \"Press 8 to show debug messages including network traffic\" ) ; console . log ( \"Press 9 to hide debug messages including network traffic\" ) ; //console.log(\"Press a to request an info update from the lights\"); case 0x38 : // 8 console . log ( \"Enabling debug\" ) ; gw . debug ( true ) ; break ; case 0x39 : // 9 console . log ( \"Disabling debug\" ) ; gw . debug ( false ) ; break ; console . log ( \"Requesting info\" ) ;", "del_tokens": "console . log ( \"gw \" + util . inspect ( gw ) ) ; console . log ( \"Press a to request an info update from the lights\" ) ; console . log ( \"Requesting info...\" ) ;", "commit_type": "make"}
{"commit_tokens": ["Improve", "checking", "of", "module", ".", "exports", "changes"], "add_tokens": "sandbox . exports = sandbox . module . exports = { } ; var moduleKeysCount = Object . keys ( sandbox . module ) . length ; var exportKeysCount = Object . keys ( sandbox . module . exports ) . length ; if ( Object . keys ( sandbox . module . exports ) . length === exportKeysCount && Object . keys ( sandbox . module ) . length === moduleKeysCount ) {", "del_tokens": "sandbox . exports = sandbox . module . exports = { '__42__' : '__42__' } ; if ( sandbox . module . exports [ '__42__' ] && Object . keys ( sandbox . module . exports ) . length === 1 ) { var needToClean ; if ( global . module ) { needToClean = global . module ; global . module = { } ; } else { global . module = { } ; } if ( needToClean ) { global . module = needToClean ; } else { global . module = undefined ; } delete sandbox . module . exports [ '__42__' ] ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "calling", "the", "teardown", "method", "after", "tests", "in", "a", "suite"], "add_tokens": "suite . _teardown . call ( t , t ) ;", "del_tokens": "suite . teardown . call ( t , t ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "callback", "support", "to", "MULTI", "so", "that", "return", "value", "of", "a", "async", "MULTI", "function", "can", "be", "processed", "without", "depending", "on", "the", "order", "of", "arguments", "in", "final", "step", "."], "add_tokens": "flowState . MULTI = function ( callback ) { if ( callback ) callback . apply ( this , arguments ) ;", "del_tokens": "flowState . MULTI = function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "display", "of", "circle", "timer", "text"], "add_tokens": "if ( this . countDownLabel ) { el . removeChild ( this . countDownLabel ) ; } var guiItem = el . getAttribute ( \"gui-item\" ) ; var canvas = this . canvas ; var countDownLabel = document . createElement ( \"a-entity\" ) ; countDownLabel . setAttribute ( 'geometry' , ` ${ guiItem . height / 1.5 } ${ guiItem . height / 1.5 } ` ) ; countDownLabel . setAttribute ( 'material' , ` ${ canvas . id } ` ) ; countDownLabel . setAttribute ( 'position' , '0 0 0.022' ) ; el . appendChild ( countDownLabel ) ; this . countDownLabel = countDownLabel ;", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["Added", "lodash", ".", "Switched", "to", "$log", "service", ".", "Improved", "test", "harness", "."], "add_tokens": "testUtil : [ 'test/testUtil.js' , 'bower_components/lodash/dist/lodash.js' ] ,", "del_tokens": "testUtil : [ 'test/testUtil.js' ] ,", "commit_type": "add"}
{"commit_tokens": ["Updated", "dist", "with", "arclength", "fix"], "add_tokens": "entity . angleLength = entity . endAngle - entity . startAngle ; // angleLength is deprecated", "del_tokens": "entity . angleLength = entity . startAngle - entity . endAngle ; // angleLength is deprecated", "commit_type": "update"}
{"commit_tokens": ["allow", "converting", "and", "parsing", "null", "island"], "add_tokens": "it ( \"should convert a GeoJSON Null Island to an ArcGIS Point\" , function ( ) { var input = { \"type\" : \"Point\" , \"coordinates\" : [ 0 , 0 ] } ; var output = Terraformer . ArcGIS . convert ( input ) ; expect ( output ) . toEqual ( { \"x\" : 0 , \"y\" : 0 , \"spatialReference\" : { \"wkid\" : 4326 } } ) ; } ) ; it ( \"should parse an ArcGIS Null Island in a Terraformer GeoJSON Point\" , function ( ) { var input = { \"x\" : 0 , \"y\" : 0 , \"spatialReference\" : { \"wkid\" : 4326 } } ; var output = Terraformer . ArcGIS . parse ( input ) ; expect ( output . coordinates ) . toEqual ( [ 0 , 0 ] ) ; expect ( output ) . toBeInstanceOfClass ( Terraformer . Point ) ; } ) ;", "del_tokens": "console . log ( output ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "issue", ":", "IE", "dispatches", "storage", "event", "twice"], "add_tokens": "var latestEventData 5. Edge doesn ' 7. IE 10 - 11 doesn ' event . origin = URL && event . url && new URL ( event . url ) . origin || locationOrigin //fix for some specific issues when 'storage' event is dispached across origins && latestEventData !== event . data && event . origin === locationOrigin latestEventData = event . data //fix previous IE double event handling", "del_tokens": "5. Old Firefox and IE may dispath event on the same context 7. IE 10 - 11 work very bad with iframes 8. IE 11 may dispatch event twice in an iframe var eventOrigin = URL && event . url && new URL ( event . url ) . origin || locationOrigin //fix for some specific issues when 'storage' event is dispached across origins && eventOrigin === locationOrigin", "commit_type": "fix"}
{"commit_tokens": ["use", "treo", "-", "websql", "for", "tests"], "add_tokens": "require ( 'treo-websql' ) . polyfill ( ) ;", "del_tokens": "require ( './support/indexeddb-shim' ) ;", "commit_type": "use"}
{"commit_tokens": ["move", ".", "/", "lib", "/", "index", ".", "js", "to", ".", "/", "index", ".", "js"], "add_tokens": "var exports = module . exports = require ( './lib/oauth2-sycle' ) ; exports . oauth2orize = require ( './lib/oauth2orize' ) ;", "del_tokens": "var exports = module . exports = require ( './oauth2-sycle' ) ; exports . oauth2orize = require ( './oauth2orize' ) ;", "commit_type": "move"}
{"commit_tokens": ["use", "json", "-", "stable", "-", "stringify"], "add_tokens": "var JSON_stringify = require ( 'json-stable-stringify' ) ; plated . files . write ( path . join ( opts . output , chunks . _output ) + \".json\" , JSON_stringify ( merged_chunks , null , 1 ) ) ; plated . files . write ( path . join ( opts . output , chunks . _output ) + \".json\" , JSON_stringify ( merged_chunks , null , 1 ) ) ;", "del_tokens": "plated . files . write ( path . join ( opts . output , chunks . _output ) + \".json\" , JSON . stringify ( merged_chunks , null , 1 ) ) ; plated . files . write ( path . join ( opts . output , chunks . _output ) + \".json\" , JSON . stringify ( merged_chunks , null , 1 ) ) ;", "commit_type": "use"}
{"commit_tokens": ["creating", "an", "initailize", "function", "also"], "add_tokens": "function buildWindowParams ( ) { if ( ! window ) return ; window . location . params = window . location . search . replace ( / ^\\? / , '' ) . toObject ( ) ; } buildAccentTable ( ) ; buildNormalizeTable ( ) ; buildWindowParams ( ) ;", "del_tokens": "buildAccentTable ( ) ; buildNormalizeTable ( ) ; if ( window ) { window . location . params = window . location . search . replace ( / ^\\? / , '' ) . toObject ( ) ; }", "commit_type": "create"}
{"commit_tokens": ["Fix", "typo", "in", "doc", "."], "add_tokens": "* & lt ; body key - handler = \"keyHandler\" >", "del_tokens": "* & lt ; body coa - key - handler = \"keyHandler\" >", "commit_type": "fix"}
{"commit_tokens": ["Fix", "cert", "scanner", "CA", "matching", "and", "add", "key", "matching"], "add_tokens": "scanner . getCertOrPem ( sslDir + 'unizeto-jira-e-instruments.com.pem' , function ( err , cert ) { assert . sameMembers ( cert . altNames , [ 'www.jira-e-instruments.com' , 'jira-e-instruments.com' ] ) ;", "del_tokens": "scanner . getDomainsFrom ( sslDir + 'unizeto-jira-e-instruments.com.pem' , function ( err , domains ) { assert . sameMembers ( domains , [ 'www.jira-e-instruments.com' , 'jira-e-instruments.com' ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "a", "bug", "with", "duplicated", "@media", "rules"], "add_tokens": "const merge = require ( 'lodash/merge' ) ; const mergedBreakpoints = merge ( [ ] , defaultBreakpoints , breakpointsOption ) ; return mergedBreakpoints . map ( processBreakpoint ) ; root . append ( breakpoints . map ( breakpoint => { return breakpoint . atRule ; } ) ) ;", "del_tokens": "const processedBreakpoints = defaultBreakpoints . concat ( breakpointsOption || [ ] ) . map ( breakpoint => processBreakpoint ( breakpoint ) ) ; return processedBreakpoints ; root . append ( breakpoints . map ( breakpoint => breakpoint . atRule ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "test", "for", "non", "-", "extensible", "objects", "."], "add_tokens": "test ( \"wrap a constructor\" , function ( t ) { function Cat ( ) { if ( ! ( this instanceof Cat ) ) return new Cat ( ) ; } var C = mstats . wrap ( \"Cat\" , Cat ) ; var c = C ( ) ; t . ok ( c instanceof Cat ) ; t . ok ( C . __concurix_wrapper_for__ === \"Cat\" ) ; t . end ( ) ; } ) test ( \"abort wraping a non-exensible Obj\" , function ( t ) { function Cat ( ) { if ( ! ( this instanceof Cat ) ) return new Cat ( ) ; } Object . preventExtensions ( Cat ) ; var C = mstats . wrap ( \"Cat\" , Cat ) ; var c = C ( ) ; t . ok ( c instanceof Cat ) ; t . notOk ( C . __concurix_wrapper_for__ === \"Cat\" ) ; t . end ( ) ; } ) } )", "del_tokens": "} )", "commit_type": "add"}
{"commit_tokens": ["add", "response", "ok", "parser", "and", "update", "defaultController"], "add_tokens": "res . locals . Model . findAndCountAll ( res . locals . query ) res . locals . Model . find ( { where : { id : id } , include : [ { all : true , attributes : [ 'id' ] } ] } ) if ( err ) return res . serverError ( err ) ; return res . ok ( record ) ;", "del_tokens": "res . locals . Model . findAndCountAll ( ) res . locals . Model . find ( id ) if ( err ) return res . status ( 500 ) . send ( err ) ; var response = { } ; response [ res . locals . model ] = record ; return res . status ( 200 ) . send ( response ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "store", ".", "clearListeners", "()"], "add_tokens": "this . clear ( ) ; // clears all listeners registered in this EventSource clear ( ) { this . listeners = [ ] ; }", "del_tokens": "this . listeners = [ ]", "commit_type": "add"}
{"commit_tokens": ["Adding", "error", "names", "to", "has", "snapshot"], "add_tokens": "socketWrapper . sendError ( C . TOPIC . RECORD , C . ACTIONS . HAS , [ recordName , error ] ) ; socketWrapper . sendError ( C . TOPIC . RECORD , C . ACTIONS . SNAPSHOT , [ recordName , C . EVENT . RECORD_NOT_FOUND ] ) ; socketWrapper . sendError ( C . TOPIC . RECORD , C . ACTIONS . SNAPSHOT , [ recordName , error ] ) ;", "del_tokens": "socketWrapper . sendError ( C . TOPIC . RECORD , C . ACTIONS . HAS , recordName ) ; socketWrapper . sendError ( C . TOPIC . RECORD , C . ACTIONS . SNAPSHOT , recordName ) ; socketWrapper . sendError ( C . TOPIC . RECORD , C . ACTIONS . SNAPSHOT , recordName ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "to", "exists", "-", "sync", "."], "add_tokens": "var existsSync = require ( 'exists-sync' ) ; var inputPathExists = existsSync ( inputPath ) ; // This is specifically looking for broken symlinks. var outputPathExists = existsSync ( this . outputPath ) ; if ( ! existsSync ( destDir ) ) {", "del_tokens": "var inputPathExists = fs . existsSync ( inputPath ) ; var outputPathExists = fs . existsSync ( this . outputPath ) ; if ( ! fs . existsSync ( destDir ) ) {", "commit_type": "move"}
{"commit_tokens": ["Added", "generator", "command", "option", "to", "generate", "step", "definitions", "from", "a", "feature", "file"], "add_tokens": ". command ( 'generate' ) . usage ( '[options] [path]' ) . description ( 'generate step definitions for a given feature' ) . option ( '--language <language>' , 'The localized language of the source feature [English]' , 'English' ) . action ( function ( file , options ) { cmd . action = 'generate' ; cmd . file = file ; cmd . options = options ;", "del_tokens": ". command ( 'web' ) . description ( 'launch the web interface' ) . action ( function ( ) { var args = Array . prototype . slice . call ( arguments , 0 , - 1 ) ; cmd . action = 'web' ; cmd . args = args ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "0x", "in", "makeTxHash", "()", "return", "value"], "add_tokens": "return sha3256 . update ( phraseToSign ) . hex ( ) ;", "del_tokens": "return add0xPrefix ( sha3256 . update ( phraseToSign ) . hex ( ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Changing", "err", "to", "Error", "in", "ajax", "failure"], "add_tokens": ". error ( function ( err , status , headers , conf ) { err = err || new Error ( 'Unknown ajax error' ) ; config : conf", "del_tokens": ". error ( function ( err , status , headers , config ) { err = err || 'Unknown ajax error' ; config : config", "commit_type": "change"}
{"commit_tokens": ["fixed", "escaping", "of", "minified", "content"], "add_tokens": "var content = grunt . file . read ( filepath ) ; content = minify ( content , htmlmin ) ; } return escapeContent ( content , quoteChar , indentString ) ;", "del_tokens": "var file = grunt . file . read ( filepath ) ; var content ; content = minify ( file , htmlmin ) ; } else { content = escapeContent ( file , quoteChar , indentString ) ; } return content ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "deep", "requiring", "of", "uuid"], "add_tokens": "const uuid = require ( 'uuid' ) . v4", "del_tokens": "const uuid = require ( 'uuid/v4' )", "commit_type": "remove"}
{"commit_tokens": ["Use", "babel", "-", "env", "|", "dynamic", "vendor", "loads"], "add_tokens": "function getVendorFileNames ( ) { const packageJson = require ( './package.json' ) ; return Object . keys ( packageJson . dependencies ) ; } vendor : getVendorFileNames ( )", "del_tokens": "vendor : [ 'babel-polyfill' , 'react' , 'react-dom' ]", "commit_type": "use"}
{"commit_tokens": ["fix", "typo", "in", "log", "domain", "property"], "add_tokens": "if ( extent [ 1 ] <= 0 ) {", "del_tokens": "if ( domain [ 1 ] <= 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "udhcpd", "to", "wireless_tools", ".", "js"], "add_tokens": "iwconfig : require ( './iwconfig' ) , udhcpd : require ( './udhcpd' )", "del_tokens": "iwconfig : require ( './iwconfig' )", "commit_type": "add"}
{"commit_tokens": ["Create", "a", "custom", "validator", "for", "enums", "so", "it", "s", "easier", "to", "represent"], "add_tokens": "this . expects = type ; Validator . prototype . toJSON = function ( ) { return { type : this . type } ; } ; function EnumValidator ( validValues ) { this . type = 'ENUM' ; this . validValues = validValues ; this . isValid = function ( val ) { return validValues . indexOf ( val ) > - 1 ; } ; this . expects = 'ENUM(' + validValues . map ( JSON . stringify ) . join ( ',' ) + ')' ; } EnumValidator . prototype . toJSON = function ( ) { return { type : this . type , valid_values : this . validValues } ; } ; return new EnumValidator ( args ) ; ' expects \"' + validator . expects + '\" type,' +", "del_tokens": "var expectedType = args . map ( JSON . stringify ) . join ( ',' ) ; return new Validator ( 'ENUM(' + expectedType + ')' , function ( val ) { return args . indexOf ( val ) > - 1 ; } ) ; ' expects \"' + validator . type + '\" type,' +", "commit_type": "create"}
{"commit_tokens": ["Fix", "incorrect", "event", "name", "in", "parser", "update", "data", "-", "streaming", "mask", "in", "example", "."], "add_tokens": "mask2 : 0x0D800000", "del_tokens": "mask2 : 0x01800000", "commit_type": "fix"}
{"commit_tokens": ["Use", "u8", "directly", "don", "t", "use", "deprecated", "API"], "add_tokens": "intpart = 256 * intpart + u8 [ offset + i ] ; fractpart = 256 * fractpart + u8 [ offset + i ] ;", "del_tokens": "var dat = new Buffer ( u8 ) ; intpart = 256 * intpart + dat [ offset + i ] ; fractpart = 256 * fractpart + dat [ offset + i ] ;", "commit_type": "use"}
{"commit_tokens": ["added", "pid", "in", "spmdb", "file", "name"], "add_tokens": "dbFileName = DB_DIR + '/' + 'metrics.db.' + ( cluster . worker . id || '0' ) + '.' + process . pid dbFileName = DB_DIR + '/' + 'metrics.db.0.' + process . pid", "del_tokens": "dbFileName = DB_DIR + '/' + 'metrics.db.' + ( cluster . worker . id || '0' ) dbFileName = DB_DIR + '/' + 'metrics.db.0'", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "console", "output", "on", "Windows"], "add_tokens": "const { normalize , resolve } = require ( 'path' ) ; if ( warning . code == 'CIRCULAR_DEPENDENCY' && warning . importer . includes ( normalize ( 'node_modules/chai' ) ) ) return ;", "del_tokens": "const { resolve } = require ( 'path' ) ; if ( warning . code == 'CIRCULAR_DEPENDENCY' && warning . importer . includes ( 'node_modules/chai' ) ) return ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "total", "value", "to", "100", "of", "cpu", "stats", "."], "add_tokens": "user : 0 , nice : 0 , system : 0 , iowait : 0 , idle : 0 , irq : 0 , softirq : 0 , steal : 0 , guest : 0 , total += obj [ name ] ; } obj . idle = 100 ; if ( total > 0 ) { for ( var name in obj ) { if ( name === 'idle' ) { continue ; } var value = obj [ name ] ; value = value > 0 ? Math . round ( value / total * 1000 ) / 10 : 0 ; obj [ name ] = value ; obj . idle -= value ; obj . idle = Math . round ( obj . idle * 10 ) / 10 ; }", "del_tokens": "user : 0 , nice : 0 , system : 0 , iowait : 0 , idle : 0 , irq : 0 , softirq : 0 , steal : 0 , guest : 0 , total += obj [ name ] ; } if ( total > 0 ) { for ( var name in obj ) { var value = obj [ name ] ; obj [ name ] = value > 0 ? Math . round ( value / total * 100 ) : 0 ; }", "commit_type": "fix"}
{"commit_tokens": ["Make", "username", "&", "email", "sparse", "-", "unique"], "add_tokens": "username : { type : String , index : true , sparse : true , unique : true } , email : { type : String , index : true , sparse : true , unique : true } ,", "del_tokens": "username : { type : String , index : true , sparse : true } , email : { type : String , index : true , sparse : true } ,", "commit_type": "make"}
{"commit_tokens": ["Fixing", "bug", "whereby", "parser", "would", "fail", "when", "array", "entry", "does", "not", "have", "a", "trailing", "comma"], "add_tokens": "function testProjectContents ( filename , test , expectedFilename ) { var myProj = new pbx ( filename ) ; var content ; if ( expectedFilename ) { content = fs . readFileSync ( expectedFilename , 'utf-8' ) ; } else { content = fs . readFileSync ( filename , 'utf-8' ) ; } // Special case in that the originating project does not have a trailing comma for all of its array entries. // This is definitely possibly. // But when we write/read it out again during testing, the trailing commas are introduced by our library. testProjectContents ( 'test/parser/projects/with_array.pbxproj' , test , 'test/parser/projects/expected/with_array_expected.pbxproj' ) ;", "del_tokens": "function testProjectContents ( filename , test ) { var myProj = new pbx ( filename ) , content = fs . readFileSync ( filename , 'utf-8' ) ; testProjectContents ( 'test/parser/projects/with_array.pbxproj' , test ) ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "standalone", "-", "html", ".", "js"], "add_tokens": ". option ( '-e, --escape \"[ regex ]\"' , 'ignore the given regular expression when minify' ) var escapeChar = ( commandLine . escape === undefined ) ? '' : commandLine . escape ; removeAttributeQuotes : false , removeComments : true , ignoreCustomFragments : eval ( escapeChar ) console . log ( 'Target file : ' + html ) ; standalone . cli ( inputPath , inputFile , outputPath , getOpt ) ; console . error ( 'error will processing file.' ) ;", "del_tokens": "removeAttributeQuotes : true , removeComments : true console . log ( 'Proceed file : ' + html ) ; standalone ( inputPath , inputFile , outputPath , getOpt ) ; console . log ( 'error will processing file.' ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "legend", "height", "in", "saved", "image"], "add_tokens": "legendHeight = this . heatmap . getColorScheme ( ) . getNames ( ) != null ? this . heatmap . getColorScheme ( ) . getNames ( ) . length * 14 : 40 ;", "del_tokens": "this . heatmap . getColorScheme ( ) . getNames ( ) != null ? this . heatmap . getColorScheme ( ) . getNames ( ) . length * 14 : 40 ;", "commit_type": "fix"}
{"commit_tokens": ["added", "support", "for", "using", "the", "bearer", "grant", "type", "for", "oauth", "against", "the", "ngin", "user", "service"], "add_tokens": "var payload = { client_id : options . clientID || config . clientID , client_secret : options . clientSecret || config . clientSecret , redirect_uri : options . redirectURI || config . redirectURI || undefined } if ( options . code ) { payload . grant_type = 'bearer' payload . code = options . code } else if ( options . username && options . password ) { payload . grant_type = 'password' payload . username = options . username payload . password = options . password } form : payload", "del_tokens": "form : { client_id : options . clientID || config . clientID , client_secret : options . clientSecret || config . clientSecret , grant_type : 'password' , username : options . username , password : options . password }", "commit_type": "add"}
{"commit_tokens": ["Add", "debug", "logging", "to", "coercion", "functions", "."], "add_tokens": "debug ( 'coercePromise: resolved to `%s`' , result ) ; var result = date . toJSON ( ) ; debug ( 'coerceDate: resolving to `%s`' , result ) ; return Promise . resolve ( result ) ; debug ( 'coerceMap: resolving to {}' ) ; debug ( 'coerceIterable: resolving to []' ) ;", "del_tokens": "debug ( 'coercePromise: resolved to %s' , result ) ; return Promise . resolve ( date . toJSON ( ) ) ; // TODO: coerce recursively // TODO: coerce recursively", "commit_type": "add"}
{"commit_tokens": ["added", "new", "method", "for", "forcing", "redraw"], "add_tokens": "//FIXME: clear mouse listener //Destroy objects //Clean up buffers accumBuffer . dispose ( ) for ( var i = 0 ; i < pickBuffers . length ; ++ i ) { pickBuffers [ i ] . dispose ( ) } //Clean up shaders accumShader . dispose ( ) //Release all references gl = null axes = null spikes = null objects = [ ] if ( stopped ) { return } function redraw ( ) { for ( var j = 0 ; j < 3 ; ++ j ) { gl . colorMask ( true , true , true , true ) //Draw the whole scene function render ( ) { if ( stopped ) { return } requestAnimationFrame ( render ) redraw ( ) } //Force redraw of whole scene scene . redraw = function ( ) { dirty = true redraw ( ) } }", "del_tokens": "//Draw the whole scene function render ( ) { if ( stopped ) { return } requestAnimationFrame ( render ) for ( var j = 0 ; j < 3 ; ++ j ) { gl . colorMask ( true , true , true , true ) }", "commit_type": "add"}
{"commit_tokens": ["Make", "physics", "support", "an", "option", "to", "enable", "not", "a", "separate", "component", "."], "add_tokens": "Intersector = require ( './helpers/intersector' ) , HandBody = require ( './helpers/hand-body' ) ; enablePhysics : { default : false } , this . handBody = /** @type {HandBody} */ null ; this . handMesh = new HandMesh ( ) ; update : function ( ) { var data = this . data ; if ( data . enablePhysics && ! this . handBody ) { this . handBody = new HandBody ( this . el , this ) ; } else if ( ! data . enablePhysics && this . handBody ) { this . handBody . remove ( ) ; this . handBody = null ; } } , this . handMesh = null ; } if ( this . handBody ) { this . handBody . remove ( ) ; this . handBody = null ; this . intersector = null ; body : this . handBody ? this . handBody . palmBody : null", "del_tokens": "Intersector = require ( './intersector' ) ; this . handMesh = /** @type {Leap.HandMesh} */ new HandMesh ( ) ; delete this . handMesh ; delete this . intersector ; body : this . el . components [ 'leap-hand-body' ] . palmBody", "commit_type": "make"}
{"commit_tokens": ["Made", "drain", "check", "interval", "configurable", "."], "add_tokens": "drainCheckInterval : opts . drainCheckIntervalMillis || 100 , * @ property { number } drainCheckIntervalMillis * Optional . How frequently the pool will check the status of waiting clients and unreturned * resources before destroying all the resources . Defaults to ` ` ( 1 / 10 th a second ) . * setTimeout ( check , self . _opts . drainCheckInterval ) ; setTimeout ( check , self . _opts . drainCheckInterval ) ;", "del_tokens": "setTimeout ( check , 100 ) ; setTimeout ( check , 100 ) ;", "commit_type": "make"}
{"commit_tokens": ["Adding", "more", "tests", "for", "self"], "add_tokens": "describe ( 'loading the value from memory' , function ( ) { storeUtils . get ( 'hello' ) ; it ( 'loads its value' , function ( ) { expect ( this . err ) . to . equal ( null ) ; expect ( this . val ) . to . deep . equal ( { moon : true } ) ; } ) ; } ) ; } ) ; } ) ; describe ( 'A deep object saved to memory' , function ( ) { describe ( 'when the source value is modified' , function ( ) { it ( 'does not effect the cached value' , function ( ) { } ) ; } ) ; describe ( 'when a cache-get value is modified' , function ( ) { it ( 'does not effect the cached value' , function ( ) { } ) ; } ) ; } ) ; // DEV: Previously, we tested loading from memory, now it is from disk describe . skip ( 'A non-existent value from disk' , function ( ) { describe ( 'when written' , function ( ) { describe ( 'and loaded from disk' , function ( ) {", "del_tokens": "describe . skip ( 'loading the value from memory' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Created", "draft", "for", "custom", "three", ".", "js", "shaderMaterial"], "add_tokens": "import fragmentShader from './data3d-view/fragment.glsl' import vertexShader from './data3d-view/vertex.glsl' console . log ( vertexShader ) / *material3d = new THREE.MeshPhongMaterial({ opacity: 0.5, transparent: true}) material3d . lightMapIntensity = - 1.0 * / material3d = new THREE . ShaderMaterial ( { uniforms : { value : 0.3 } , vertexShader : vertexShader , fragmentShader : fragmentShader } ) console . log ( self )", "del_tokens": "material3d = new THREE . MeshPhongMaterial ( { opacity : 0.5 , transparent : true } )", "commit_type": "create"}
{"commit_tokens": ["add", "thread", "refcount", "destroy", "threads", "with", "refcount", "0"], "add_tokens": "args . env . stdout ( 'test ok\\n' ) ; // setTimeout(function() { // console.log('timeout ok'); // }, 2000); // runtime.exit(0);", "del_tokens": "args . env . stdout ( 'test ok' ) ; runtime . exit ( 0 ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "type", "selector", "if", "no", "argument", "is", "given"], "add_tokens": "this . argument ( 'type' , { required : false } ) ; if ( this . args . length === 0 ) { return this . _promptForType ( ) . then ( this . _initializingImpl . bind ( this ) ) ; } this . type = this . args [ 0 ] ; return this . _initializingImpl ( ) ; } _promptForType ( ) { return this . prompt ( { type : 'list' , name : 'type' , message : 'Plugin Type' , choices : known . plugin . types , default : 'lib' } ) . then ( ( props ) => { this . type = props . type ; } ) ; } _initializingImpl ( ) { type : this . type , this . composeWith ( 'phovea:init-' + this . type , { local : require . resolve ( '../init-' + this . type )", "del_tokens": "this . argument ( 'type' ) ; type : this . args [ 0 ] , this . composeWith ( 'phovea:init-' + this . args [ 0 ] , { local : require . resolve ( '../init-' + this . args [ 0 ] )", "commit_type": "add"}
{"commit_tokens": ["Fix", "default", "service", "_id", "field"], "add_tokens": "const action = params . __action ; if ( ! action || action === 'find' ) { debug ( 'service %s find %j' , this . name , params . query ) ; return super . find ( params ) ; } if ( this [ action ] ) { delete params . __action ; return this . _action ( action , null , { } , params ) ; } throw new Error ( \"No such **get** action: \" + action ) ;", "del_tokens": "debug ( 'service %s find %j' , this . name , params . query ) ; return super . find ( params ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allowing", "preload", "deferment", "for", "testing", "."], "add_tokens": "if ( ! options . no_preload ) this . _authenticationPromise = API . getToken ( ) ;", "del_tokens": "this . _authenticationPromise = API . getToken ( ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "generic", "query", "resolvers", "."], "add_tokens": "var q = require ( \"q\" ) ; } ) ; asapi . addQueryHandler ( { name : \"test\" , type : \"user\" } , function ( userId ) { if ( userId . length == 5 ) { return q ( \"yep\" ) ; } return q . reject ( \"narp\" ) ; } ) ;", "del_tokens": "} )", "commit_type": "add"}
{"commit_tokens": ["remove", "last", "comma", "for", "IE7"], "add_tokens": "}", "del_tokens": "} ,", "commit_type": "remove"}
{"commit_tokens": ["Fix", "bug", "in", "command", "handling"], "add_tokens": "module . exports = function mysqlBackend ( opts , callback ) { process . nextTick ( callback ) ;", "del_tokens": "module . exports = function mysqlBackend ( opts ) {", "commit_type": "fix"}
{"commit_tokens": ["Improve", "shader", "library", "and", "texture", "util"], "add_tokens": "* @ param { object } [ option ] loadTexture : function ( path , option , onsuccess , onerror ) { if ( typeof ( option ) === 'function' ) { onsuccess = option ; onerror = onsuccess ; option = { } ; } else { option = option || { } ; } hdr . parseRGBE ( data , texture , option . exposure ) ; * @ param { object } [ option ] loadPanorama : function ( path , cubeMap , renderer , option , onsuccess , onerror ) { if ( typeof ( option ) === 'function' ) { onsuccess = option ; onerror = onsuccess ; option = { } ; } else { option = option || { } ; } textureUtil . loadTexture ( path , option , function ( texture ) {", "del_tokens": "loadTexture : function ( path , onsuccess , onerror ) { hdr . parseRGBE ( data , texture ) ; loadPanorama : function ( path , cubeMap , renderer , onsuccess , onerror ) { textureUtil . loadTexture ( path , function ( texture ) {", "commit_type": "improve"}
{"commit_tokens": ["Move", "to", "music", "-", "parser"], "add_tokens": "var parseMusic = require ( 'music-parser' ) this . sequence = parseMusic ( source , this . time )", "del_tokens": "var parseMeasures = require ( 'measure-parser' ) var parseMelody = require ( 'melody-parser' ) this . sequence = parseMeasures ( source , this . time ) || parseMelody ( source , this . time )", "commit_type": "move"}
{"commit_tokens": ["add", "tests", "for", "rotation", "etc", "."], "add_tokens": "\"rotate\" : [ - 45 , false ] , \"background\" : [ 0xFF000000 ] , var args = ( ( operations [ op ] . length > 0 ) ? \"-\" + operations [ op ] . join ( \"-\" ) : \"\" ) image . name = \"lenna-\" + op + args ; image . name = \"lenna-\" + op + args + \"-blit\" ; image . name = \"lenna-\" + op + args + \"-composite\" ; image . rgba ( false ) . write ( \"./output/\" + image . name + \"-noalpha.png\" ) ; image . write ( \"./output/\" + image . name + \".bmp\" ) ;", "del_tokens": "\"rotate\" : [ 90 ] , image . name = \"lenna-\" + op ; image . name = \"lenna-\" + op + \"-blit\" ; image . name = \"lenna-\" + op + \"-composite\" ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "the", "tests", "to", "correspond", "to", "the", "latest", "ubuntu", "zoneinfo", "files"], "add_tokens": "var us_timezones = [ \"America/Adak\" , \"America/Anchorage\" , \"America/Boise\" , \"America/Chicago\" , \"America/Denver\" , \"America/Detroit\" , \"America/Indiana/Indianapolis\" , \"America/Indiana/Knox\" , \"America/Indiana/Marengo\" , \"America/Indiana/Petersburg\" , \"America/Indiana/Tell_City\" , \"America/Indiana/Vevay\" , \"America/Indiana/Vincennes\" , \"America/Indiana/Winamac\" , \"America/Juneau\" , \"America/Kentucky/Louisville\" , \"America/Kentucky/Monticello\" , \"America/Los_Angeles\" , \"America/Menominee\" , \"America/Metlakatla\" , \"America/New_York\" , \"America/Nome\" , \"America/North_Dakota/Beulah\" , \"America/North_Dakota/Center\" , \"America/North_Dakota/New_Salem\" , \"America/Phoenix\" , \"America/Shiprock\" , \"America/Sitka\" , \"America/Yakutat\" , \"Pacific/Honolulu\" ] ; test . strictEqual ( zoneinfo . listTimezones ( ) . length , 519 , \"Full timezone list\" ) ;", "del_tokens": "var us_timezones = [ 'America/Adak' , 'America/Anchorage' , 'America/Boise' , 'America/Chicago' , 'America/Denver' , 'America/Detroit' , 'America/Indiana/Indianapolis' , 'America/Indiana/Knox' , 'America/Indiana/Marengo' , 'America/Indiana/Petersburg' , 'America/Indiana/Tell_City' , 'America/Indiana/Vevay' , 'America/Indiana/Vincennes' , 'America/Indiana/Winamac' , 'America/Juneau' , 'America/Kentucky/Louisville' , 'America/Kentucky/Monticello' , 'America/Los_Angeles' , 'America/Menominee' , 'America/New_York' , 'America/Nome' , 'America/North_Dakota/Center' , 'America/North_Dakota/New_Salem' , 'America/Phoenix' , 'America/Shiprock' , 'America/Yakutat' , 'Pacific/Honolulu' ] ; test . strictEqual ( zoneinfo . listTimezones ( ) . length , 516 , \"Full timezone list\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "yesterday", "and", "tomorrow", "labels", "for", "Russian", "localization"], "add_tokens": "\"previous\" : \"днём ранее\", \"next\" : \"через день\", \"previous\" : \"днём ранее\", \"next\" : \"через день\",", "del_tokens": "\"previous\" : \"вчера\", \"next\" : \"завтра\", \"previous\" : \"вчера\", \"next\" : \"завтра\", \"previous\" : \"вчера\", \"next\" : \"завтра\", \"previous\" : \"вчера\", \"next\" : \"завтра\",", "commit_type": "change"}
{"commit_tokens": ["Update", "scenegraph", "on", "component", "and", "dom", "changes"], "add_tokens": "// Create an observer to notify the changes in the scene var target = document . querySelector ( 'a-scene' ) ; var observer = new MutationObserver ( function ( mutations ) { mutations . forEach ( function ( mutation ) { Events . emit ( 'sceneModified' ) ; } ) ; } ) ; var config = { attributes : true , childList : true , characterData : true } observer . observe ( target , config ) ; < a href = \"#\" title = \"Delete selected entity\" onClick = { this . deleteEntity } className = \"button fa fa-trash-o\" > < / a >", "del_tokens": "< a href = \"#\" onClick = { this . deleteEntity } className = \"button fa fa-trash-o\" > < / a >", "commit_type": "update"}
{"commit_tokens": ["Added", "getParser", "to", "switch", "parsers", "fast"], "add_tokens": "readabilitySettings : settings", "del_tokens": "readabilitySettings : settings , slowParser : true console . log ( link ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "detect", "value", "from", "array", "if", "arrayItemIndex", "was", "specified", ".", "update", "readme", "about", "path", "attribute", "in", "validation", "error", ".", "fix", "examples", "tests"], "add_tokens": "arrayItemIndex = _ . isNumber ( arrayItemIndex ) && ! _ . isNaN ( arrayItemIndex ) ? arrayItemIndex : null ; if ( arrayItemIndex != null && _ . isArray ( value ) ) { value = value [ arrayItemIndex ] ; }", "del_tokens": "arrayItemIndex = _ . isNumber ( arrayItemIndex ) ? arrayItemIndex : null ;", "commit_type": "add"}
{"commit_tokens": ["add", "option", "for", "containsText", "and", "a", "couple", "of", "transforms"], "add_tokens": "import ieAlignFallback from './ieAlignFallback' import fallbackFor from './fallbackFor' export default { cssGroups , trueHide , convertProp , ieAlignFallback , fallbackFor , condition }", "del_tokens": "export default { cssGroups , trueHide , convertProp , condition }", "commit_type": "add"}
{"commit_tokens": ["Implemented", ".", "NET", "server", "for", "gnap", "-", "angular", "examples"], "add_tokens": "src : [ '*.*' , '**/*.*' , '!server/*.*' , '!server/**/*.*' ] , 'gnap-angular_server_to_build' : { expand : true , cwd : './custom/gnap-angular/server/release/' , src : [ '*.*' , '**/*.*' ] , dest : './build/gnap-angular/server/' } ,", "del_tokens": "src : [ '*.*' , '**/*.*' ] ,", "commit_type": "implement"}
{"commit_tokens": ["Make", "worker", "start", "the", "job"], "add_tokens": "let jobCounter = 1 ; jobCounter += 1 ; payload ,", "del_tokens": "const { send , } = require ( './worker/node' ) ; const log = require ( './utils/log' ) ; let jobCounter = 0 ; jobCounter += 1 ; const start = async ( w ) => { log ( ` ${ w . id } ${ id } ${ action } ` ) ; send ( w . worker , { workerId : w . id , jobId : id , action , payload , } ) ; } ; start ,", "commit_type": "make"}
{"commit_tokens": ["removing", "console", "logs", "and", "unnecessary", "lines"], "add_tokens": "this . webSocket . send ( JSON . stringify ( configJSON ) ) ; } ) if ( callback !== null ) { callback ( ) ; } else { that . waitForConn ( socket , callback ) ; } } , 1000 )", "del_tokens": "let config2 = dataConfig ; console . log ( 'subscribewidget' , dataConfig ) ; console . info ( 'sending' , configJSON ) ; this . webSocket . send ( JSON . stringify ( configJSON ) ) ; } ) console . info ( message ) ; console . info ( data ) ; console . info ( this . widgetMap ) ; console . info ( message ) ; console . info ( 'close' ) ; if ( callback !== null ) { callback ( ) ; } } else { that . waitForConn ( socket , callback ) ; } , 1000 )", "commit_type": "remove"}
{"commit_tokens": ["Added", "errback", "to", "build", "functions"], "add_tokens": "function findDeps ( options , config , callback , errback ) { buildAllModules ( options , config , entryModule , callback , errback ) ; function buildAllModules ( options , config , entryModule , callback , errback ) { if ( typeof ( errback ) === \"function\" ) errback ( \"find-deps\" , err , moduleName ) ; else console . log ( moduleName + \" - \" + err ) ;", "del_tokens": "function findDeps ( options , config , callback ) { buildAllModules ( options , config , entryModule , callback ) ; function buildAllModules ( options , config , entryModule , callback ) { console . log ( moduleName + \" - \" + err ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "HTTP", "get", "support", "for", "Android"], "add_tokens": "} , http : { get : function ( url , file ) { window . DroidGap . httpGet ( url , file ) ; } }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Remove", "unnecessary", "return", "statements", "."], "add_tokens": "process . exit ( 1 ) ; function say ( ) { console . log . apply ( console , __slice . call ( arguments , 0 ) ) }", "del_tokens": "return process . exit ( 1 ) ; function say ( ) { return console . log . apply ( console , __slice . call ( arguments , 0 ) ) }", "commit_type": "remove"}
{"commit_tokens": ["Add", "apps", "to", "our", "PICS", "cache", "when", "other", "users", "play", "them"], "add_tokens": "\"PackageContents\" : 3 , \"AddToCache\" : 4 SteamUser . prototype . _addAppToCache = function ( appid ) { if ( ! this . options . enablePicsCache ) { return ; } var apps = this . picsCache . apps || { } ; if ( apps [ appid ] ) { return ; } this . getProductInfo ( [ appid ] , [ ] , null , PICSRequestType . AddToCache ) ; } ;", "del_tokens": "\"PackageContents\" : 3", "commit_type": "add"}
{"commit_tokens": ["Update", "the", "license", "to", "MIT"], "add_tokens": "// get-log // Copyright 2014 Enrico Stara 'enrico.stara@gmail.com' // Released under the MIT License // https://github.com/enricostara/get-log } ;", "del_tokens": "// get-log // // Copyright 2014 Enrico Stara 'enrico.stara@gmail.com' // Released under the BSD-2-Clause license // https://github.com/enricostara/get-log }", "commit_type": "update"}
{"commit_tokens": ["Add", ".", "isGlobalMaster", ".", "Update", "README", "."], "add_tokens": "if ( typeof execPath === 'string' ) { var end = execPath . length - 9 ; if ( end >= 0 && execPath . indexOf ( '/bin/node' ) === end ) { globalNodeModulesPath = execPath . substring ( 0 , end ) + '/lib' ; }", "del_tokens": "var end = execPath . length - 9 ; if ( end < 0 ) { end = - 2 ; } if ( typeof execPath === 'string' && execPath . indexOf ( '/bin/node' ) === end ) { globalNodeModulesPath = execPath . substring ( 0 , end ) + '/lib' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "rule", "member", "of", "for", "string", "enum"], "add_tokens": "var memberOf = require ( './validators/member-of' ) ; 'minValue:$1' : minValue . validator , 'memberOf:$1' : memberOf . validator 'minLength:$1' : minLength . message , 'memberOf:$1' : memberOf . message ruleArray . forEach ( function ( rule ) { var ruleObj = { } ; if ( _ . isString ( rule ) ) { // First variant, everything is embedded as string var splitted = rule . split ( ':' ) ; ruleObj = { // full name is the generic full name of validation rule e.g range:1:3 -> range:$1:$2, required -> required fullName : splitted [ 0 ] , // get only the first part of full rule e.g if range:1:3 then we will get 'range' name : splitted [ 0 ] , // get the rule params if e.g range:1:3 -> [1, 3] params : splitted . slice ( 1 ) } ; } else { // Second variant, it is already parsed ruleObj . name = rule . name ; ruleObj . fullName = rule . name ; ruleObj . params = rule . params ; }", "del_tokens": "'minValue:$1' : minValue . validator 'minLength:$1' : minLength . message ruleArray . forEach ( function ( ruleName ) { var splitted = ruleName . split ( ':' ) ; var ruleObj = { // full name is the generic full name of validation rule e.g range:1:3 -> range:$1:$2, required -> required fullName : splitted [ 0 ] , // get only the first part of full rule e.g if range:1:3 then we will get 'range' name : splitted [ 0 ] , // get the rule params if e.g range:1:3 -> [1, 3] params : splitted . slice ( 1 ) } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "to", "properly", "add", "the", "tracked", "elements"], "add_tokens": "if ( ElementQueries . instance . withTracking && elements . indexOf ( element ) < 0 ) {", "del_tokens": "if ( this . withTracking ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "third", "-", "party", "library", "to", "serialize", "url", "params"], "add_tokens": "frameworks : [ 'jasmine-ajax' , 'jasmine' , 'sinon' ] ,", "del_tokens": "frameworks : [ 'jasmine-ajax' , 'jasmine' ] ,", "commit_type": "add"}
{"commit_tokens": ["Fixed", "one", "more", "issues", "with", "Attachment", "(", "x3", ")"], "add_tokens": "fs . open ( self . fullUrl , 'w' , function ( error , fd ) {", "del_tokens": "fs . open ( function ( error , fd ) {", "commit_type": "fix"}
{"commit_tokens": ["Move", "to", "Express", "+", "Node", "+", "reorg"], "add_tokens": "var mongoose = require ( 'mongoose' ) ; var Schema = mongoose . Schema ; var ObjectId = Schema . ObjectId ; var messageSchema = new Schema ( { owner : String , text : String , posted : { type : Date , default : Date . now } } ) ;", "del_tokens": "var mongoose = require ( 'mongoose' ) ; var Schema = mongoose . Schema ; var ObjectId = Schema . ObjectId ; var messageSchema = new Schema ( { owner : String , text : String , posted : { type : Date , default : Date . now } } ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "the", "default", "reporters", "for", "the", "CLI"], "add_tokens": "begin : function ( ) { } , info : function ( ) { } , results : function ( ) { }", "del_tokens": "info : function ( ) { }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "huge", "bug", "in", "nesting", "because", "undefined", "is", "apparently", "not", "falsey"], "add_tokens": "* v1 .8 .1 if ( ! currentPos [ pathPart ] ) { currentPos [ pathPart ] = [ ] ; } currentPos = currentPos [ pathPart ] ; var existingObj = null ; if ( ( arrayItem . constructor != Option ) && $ . isPlainObject ( arrayItem ) && arrayItem [ pathPart ] && ( typeof arrayItem [ pathPart ] !== 'undefined' ) ) { var newLength = currentPos . push ( { } ) ; currentPos = currentPos [ newLength - 1 ] ;", "del_tokens": "* v1 .8 .0 currentPos = currentPos [ pathPart ] = currentPos [ pathPart ] || [ ] ; var existingObj ; if ( ( typeof arrayItem === 'object' ) && arrayItem [ pathPart ] ) { currentPos . push ( { } ) ; currentPos = currentPos [ currentPos . length - 1 ] ;", "commit_type": "fix"}
{"commit_tokens": ["add", "an", "option", "to", "exclude", "files", "(", "correct", "indentation", ")"], "add_tokens": "//Files to exclude var filesToExclude = [ ] ;", "del_tokens": "//Files to exclude var filesToExclude = [ ] ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "bug", "with", "the", "regex", "open", "/", "close", "characters", "."], "add_tokens": "app . stack [ 0 ] . route . should . equal ( / ^\\/$ / ) app . stack [ 0 ] . route . should . equal ( / ^\\/0$ / ) app . stack [ 1 ] . route . should . equal ( / ^\\/1$ / )", "del_tokens": "app . stack [ 0 ] . route . should . equal ( \\^ \\/ $ \\) app . stack [ 0 ] . route . should . equal ( \\^ \\/ 0 $ \\) app . stack [ 1 ] . route . should . equal ( \\^ \\/ 1 $ \\)", "commit_type": "fix"}
{"commit_tokens": ["add", "filter", "for", "channel", "broadcast"], "add_tokens": "var ChannelService = function ( app , opts ) { opts = opts || { } ; this . broadcastFilter = opts . broadcastFilter ; var latch = countDownLatch . createCountDownLatch ( count , function ( ) { var genCB = function ( id ) { return function ( err , fails ) { if ( err ) { logger . error ( '[broadcast] fail to push message to %j, err:' + err . stack , id ) ; latch . done ( ) ; return ; } successFlag = true ; } ; method : method , args : [ route , msg , opts ] } , genCB ( ) ) ;", "del_tokens": "var ChannelService = function ( app ) { opts = opts || { } ; var latch = countDownLatch . createCountDownLatch ( count , function ( ) { var rpcCB = function ( err , fails ) { if ( err ) { logger . error ( '[pushMessage] fail to dispatch msg, err:' + err . stack ) ; return ; } if ( fails ) { failIds = failIds . concat ( fails ) ; } successFlag = true ; latch . done ( ) ; method : method , args : [ route , msg , opts . binded ] } , rpcCB ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "more", "options", "from", "options"], "add_tokens": "this . offset = options . offset ? options . offset : 0 ; this . interval = options . interval ? options . interval : 500 ; this . polling = false ; this . base_url = 'https://api.telegram.org/bot'", "del_tokens": "this . offset = 0 ;", "commit_type": "add"}
{"commit_tokens": ["Added", "tests", "to", "achive", "100%", "code", "coverage"], "add_tokens": "Abstract . prototype . set = undefined ; // abstact", "del_tokens": "Abstract . prototype . set = function ( ) { } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "version", "number", "not", "returning", "."], "add_tokens": "getVersion : function ( ) { return require ( packagePath ) . version ;", "del_tokens": "getVersion : function ( ) { require ( packagePath ) . version ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "city", "picker", "onchange", "bug"], "add_tokens": "return [ ] ; return [ ] ; return false ; // 因为数据未更新完，所以这里不进行后序的值的处理 return false ; // 因为数据未更新完，所以这里不进行后序的值的处理", "del_tokens": "return [ '' ] ; return [ \"\" ] ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "to", "customise", "the", "wormhole", "destination", "of", "the", "dropdown"], "add_tokens": "import config from 'ember-get-config' ; const destination = Ember . testing ? 'ember-testing' : ( config [ 'ember-basic-dropdown' ] && config [ 'ember-basic-dropdown' ] . destination || 'ember-basic-dropdown-wormhole' ) ; destination ,", "del_tokens": "_wormholeDestination : ( Ember . testing ? 'ember-testing' : 'ember-basic-dropdown-wormhole' ) ,", "commit_type": "allow"}
{"commit_tokens": ["Allow", "tooltip", "-", "menu", "to", "be", "used", "without", "tooltip"], "add_tokens": "openMenu ( node , this . menuItems , this . pm )", "del_tokens": "// FIXME change openMenu interface to not requires this kludge openMenu ( { close ( ) { } , show ( _id , dom ) { node . textContent = \"\" ; node . appendChild ( dom ) } } , this . menuItems , this . pm )", "commit_type": "allow"}
{"commit_tokens": ["made", "leading", "generated", "-", "by", "-", "coffeescript", "comment", "actually", "work"], "add_tokens": "program . leadingComments = [", "del_tokens": "program . comments = [", "commit_type": "make"}
{"commit_tokens": ["Make", "Babel", "presets", "/", "plugins", "configurable", "by", "block", "params"], "add_tokens": "test : / \\.(js|jsx)$ / , exclude : [ / \\/node_modules\\/ / ] , loaders : [ 'babel-loader?{\"cacheDirectory\":true}' ] } ) t . deepEqual ( webpackConfig . module . loaders [ 1 ] , { t . deepEqual ( webpackConfig . module . loaders [ 2 ] , {", "del_tokens": "t . deepEqual ( webpackConfig . module . loaders [ 1 ] , { t . deepEqual ( webpackConfig . module . loaders [ 2 ] , { test : / \\.(js|jsx)$ / , exclude : [ / \\/node_modules\\/ / ] , loaders : [ 'babel-loader?cacheDirectory' ] } )", "commit_type": "make"}
{"commit_tokens": ["add", "hard", "dependency", "for", "projectB"], "add_tokens": "var Condensation = require ( '../../../../lib/condensation' ) ; var sections = require ( '../../../../lib/condensation/template-helpers/sections' ) ; describe ( 'parameters' , function ( ) {", "del_tokens": "var Condensation = require ( '../../lib/condensation' ) ; var sections = require ( '../../lib/condensation/template-helpers/sections' ) ; describe ( 'particle-builds' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Update", "Backfire", "to", "latest", "callback", "signature", "(", "takes", "effect", "on", "Monday", ")"], "add_tokens": "this . _fbref . child ( model . id ) . set ( val , _ . bind ( function ( err ) { if ( ! err ) { this . _fbref . child ( model . id ) . update ( val , function ( err ) { if ( ! err ) { this . _fbref . child ( model . id ) . remove ( function ( err ) { if ( ! err ) {", "del_tokens": "this . _fbref . child ( model . id ) . set ( val , _ . bind ( function ( success ) { if ( success ) { this . _fbref . child ( model . id ) . update ( val , function ( success ) { if ( success ) { this . _fbref . child ( model . id ) . remove ( function ( success ) { if ( success ) {", "commit_type": "update"}
{"commit_tokens": ["add", "JSON", "Schema", "for", "parsed", "types", "and", "use", "it", "for", "validation"], "add_tokens": "var schema = require ( '../lib/schema' ) ; var tv4 = require ( 'tv4' ) ; var validate = tv4 . validateMultiple ; return parsed ; var parsedType ; var parsedTypes = [ ] ; var validationErrors = [ ] ; var validationResult ; parsedType = parseIt ( type , options ) ; validationResult = validate ( parsedType , schema , { banUnknownProperties : true } ) ; if ( validationResult . errors && validationResult . errors . length ) { validationErrors . push ( { expression : type . expression , errors : validationResult . errors } ) ; } validationErrors . should . eql ( [ ] ) ; // register schema with the validator tv4 . addSchema ( schema . id , schema ) ;", "del_tokens": "parseIt ( type , options ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "test", "file", "timeout", "handling", "."], "add_tokens": "if ( ! timedOut ) { clearTimeout ( timeoutId ) ; result = common . parseResult ( stderrJoined ) ; succeededResult = result [ 0 ] ; failedResult = result [ 1 ] ; // Print test results sys . puts ( fileName ) ; common . reportSucceeded ( succeededResult ) ; common . reportFailed ( failedResult ) ; successes += Object . keys ( succeededResult ) . length ; failures += Object . keys ( failedResult ) . length ; if ( failfast && failedResult ) { common . printTestsSummary ( dateStart , successes , failures , timeouts ) ; } } else { timeouts ++ ; timedOut = true ;", "del_tokens": "clearTimeout ( timeoutId ) ; result = common . parseResult ( stderrJoined ) ; succeededResult = result [ 0 ] ; failedResult = result [ 1 ] ; // Print test results sys . puts ( fileName ) ; common . reportSucceeded ( succeededResult ) ; common . reportFailed ( failedResult ) ; successes += Object . keys ( succeededResult ) . length ; failures += Object . keys ( failedResult ) . length ; if ( failfast && failedResult ) { common . printTestsSummary ( dateStart , successes , failures , timeouts ) ; timeouts ++ ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "omitting", "callback", "when", "requesting", "/", "removing", "friendships"], "add_tokens": "// Index the friends array with a multikey index on _id. Further indexing // on status is probably unnecessary, as all queries will hit _id and // this will already limit them to the friends on an individual user. cb || ( cb = noop ) ; cb || ( cb = noop ) ; // simple no op function for clarity function noop ( ) { }", "del_tokens": "// index the", "commit_type": "allow"}
{"commit_tokens": ["fixed", "problem", "with", "async", "tasks", "being", "sync"], "add_tokens": "if ( a . on ) { if ( ! a [ method ] || ! a [ method ] ( ) ) { next ( method ) ; if ( a . on ) a . on ( 'finish.chain' , null ) ; }", "del_tokens": "if ( ! a [ method ] || ! a [ method ] ( ) ) { next ( method ) ; } else {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "bug", "about", "session", "state"], "add_tokens": "self . state = STATE_CLOSED ;", "del_tokens": "this . state = STATE_CLOSED ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "stringification", "of", "toJML", "()"], "add_tokens": "return JSON . stringify ( ret [ 0 ] ) ;", "del_tokens": "return JSON . stringify ( ret ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "shortcut", "for", "the", "dataHook", "selectors"], "add_tokens": "var ElementFinder = $ ( '' ) . constructor ; var foundElement ; return this . each ( function ( element ) { element . getWebElement ( ) . getText ( ) . then ( function ( elementText ) { if ( elementText . trim ( ) === compareText ) { foundElement = element ; } } ) ; } ) . then ( function ( ) { return foundElement ; } ) ; } ; ElementArrayFinder . prototype . __ = ElementFinder . prototype . __ = function ( hook ) { return this . all ( by . dataHookAll ( hook ) ) ; } ; ElementFinder . prototype . _ = function ( hook ) { return this . element ( by . dataHook ( hook ) ) ; } ;", "del_tokens": "var foundElement ; return this . each ( function ( element ) { element . getWebElement ( ) . getText ( ) . then ( function ( elementText ) { if ( elementText . trim ( ) === compareText ) { foundElement = element ; } } ) ; } ) . then ( function ( ) { return foundElement ; } ) ; } ;", "commit_type": "add"}
{"commit_tokens": ["allow", "quick", "connect", "if", "peer", "s", "ip", ":", "port", "is", "known", "ahead", "of", "time"], "add_tokens": "Node . prototype . connect = function ( addr , expectedFingerprint ) { if ( expectedFingerprint && fingerprint !== expectedFingerprint ) { self . _debug ( 'peer at ' + addr + ' doesn\\'t have expected fingerprint, destroying them' ) peer . destroy ( ) return } * @ param { String } options . address - peer ' if ( options . address ) { this . connect ( options . address , fingerprint ) return }", "del_tokens": "Node . prototype . connect = function ( addr ) {", "commit_type": "allow"}
{"commit_tokens": ["fixed", "cls", "context", "for", "tunnel", "calls"], "add_tokens": "process . nextTick ( function ( ) { next ( ) ; } ) ;", "del_tokens": "next ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "before", ".", "read", "pipeline", "&", "plugin", "override"], "add_tokens": "next = map ( next ) || [ ] ;", "del_tokens": "next = map ( next ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "timers", "wrapper", "through", "web", "workers"], "add_tokens": "var Timer = require ( './timer' ) ; Timer . setInterval ( function ( ) { Timer . setInterval ( function ( ) {", "del_tokens": "setInterval ( function ( ) { setInterval ( function ( ) {", "commit_type": "add"}
{"commit_tokens": ["update", "the", "module", "to", "follow", "interactive", "spec", "-", "https", ":", "//", "github", ".", "com", "/", "ipfs", "/", "node", "-", "ipfs", "/", "issues", "/", "13#issuecomment", "-", "109802818", "next", "is", "doing", "silent", "-", "broadcast"], "add_tokens": "var Select = require ( '../src' ) . Select var ms = new Select ( ) ms . handle ( socket )", "del_tokens": "var MultiStream = require ( '../src' ) var ms = new MultiStream ( socket )", "commit_type": "update"}
{"commit_tokens": ["made", "all", "callbacks", "have", "a", "consistent", "signature"], "add_tokens": "result . push ( current . json ( ) ) ; result . push ( jdoc . get ( index ) . json ( ) ) ; jdoc . each ( function ( jdoc ) { result . push ( jdoc . json ( ) ) ; jdoc . each ( function ( jdoc ) { result . push ( jdoc . json ( ) ) ; union . each ( function ( jdoc ) { result . push ( jdoc . json ( ) ) ; var result = new jDoc ( library ) . deepMatch ( 'title' ) . select ( function ( jdoc ) { return jdoc . text ( ) . length ;", "del_tokens": "result . push ( current . json ) ; result . push ( jdoc . get ( index ) . json ) ; jdoc . each ( function ( json ) { result . push ( json ) ; jdoc . each ( function ( json ) { result . push ( json ) ; union . each ( function ( json ) { result . push ( json ) ; var result = new jDoc ( library ) . deepMatch ( 'title' ) . select ( function ( json ) { return json . length ;", "commit_type": "make"}
{"commit_tokens": ["remove", "copies", "of", "THREE", "ammo", "physijs", "from", "Incheon"], "add_tokens": "// TODO: // require of \"nodejs-physijs\" here is a disaster, because it adds ammojs and // THREEjs to Incheon - specifically to the browserified bundle which will run // on the client side. Thing is - the client typically does not use this // huge piece of baggage! const NodePhysijs = require ( 'nodejs-physijs' ) ; const PhysicsEngine = require ( './PhysicsEngine' ) ; const THREE = NodePhysijs . THREE ; const Ammo = NodePhysijs . Ammo ; const Physijs = NodePhysijs . Physijs ( THREE , Ammo ) ;", "del_tokens": "const PhysicsEngine = require ( './PhysicsEngine' ) ; const THREE = require ( './lib/three.js' ) ; const Ammo = require ( './lib/ammo.js' ) ; const Physijs = require ( './lib/physi.js' ) ( THREE , Ammo ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "type", "to", "display", "list", "in", "archive", "manager"], "add_tokens": "* @ property { String } type The type of archive connection status : archives [ archiveName ] . status , type : archives [ archiveName ] . type password : masterPassword , type : credentials . type let { content , type } = loadedData . archives [ archiveName ] ; credentials : content , type packet . archives [ archiveName ] = { content : archiveDetails . credentials , type : archiveDetails . type } ; packet . archives [ archiveName ] = { content , type : archiveDetails . type } ;", "del_tokens": "status : archives [ archiveName ] . status password : masterPassword credentials : loadedData . archives [ archiveName ] packet . archives [ archiveName ] = archiveDetails . credentials ; packet . archives [ archiveName ] = content ;", "commit_type": "add"}
{"commit_tokens": ["Added", "the", "ROT", ".", "Map", ".", "Rogue", ".", "prototype", ".", "_getRandomInt", "()", "function", "to", "ROT", ".", "RNG", "and", "added", "logic", "to", "ensure", "that", "the", "order", "of", "arguments", "doesn", "t", "matter", ".", "Recompiled", "rot", ".", "js", "and", "rot", ".", "min", ".", "js", "didn", "t", "touch", "documentation", "."], "add_tokens": "Version 0.5 ~ dev , generated on Fri Mar 28 13 : 20 : 07 EDT 2014. / ** * @ param { int } lowerBound The lower end of the range to return a value from * @ param { int } upperBound The upper end of the range to return a value from , inclusive * @ returns { int } Pseudorandom value [ lowerBound , upperBound ] , using ROT . RNG . getUniform ( ) to distribute the value * / getRandomInt : function ( lowerBound , upperBound ) { var max = Math . max ( lowerBound , upperBound ) ; var min = Math . min ( lowerBound , upperBound ) ; return Math . floor ( this . getUniform ( ) * ( max - min + 1 ) ) + min ; } ,", "del_tokens": "Version 0.5 ~ dev , generated on Tue Mar 4 10 : 16 : 09 CET 2014.", "commit_type": "add"}
{"commit_tokens": ["add", "record", "stream", "interface", "to", "allow", "streaming", "manipulation", "of", "record"], "add_tokens": "RecordStream = require ( '../lib/record-stream' ) , \"query big tables by piping randomly-waiting output record stream object\" : { var outStream = new RecordStream ( ) ; outStream . sendable = true ; outStream . send = function ( record ) { outStream . sendable = false ; outStream . sendable = true ; outStream . emit ( 'drain' ) ; return outStream . sendable ; outStream . end = function ( ) { query . pipe ( outStream ) ; query . on ( \"error\" , function ( err ) { self . callback ( err ) ; } ) ; \"should scan records via stream up to maxFetch num\" : function ( result ) {", "del_tokens": "\"query big tables by piping randomly-waiting send stream object\" : { var sendstream = new events . EventEmitter ( ) ; sendstream . sendable = true ; sendstream . send = function ( record ) { sendstream . sendable = false ; sendstream . sendable = true ; sendstream . emit ( 'drain' ) ; return sendstream . sendable ; sendstream . end = function ( ) { query . pipe ( sendstream ) ; \"should scan records up to maxFetch num\" : function ( result ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "vocab", "object", "to", "any", "vocab", "schemas", "to", "retain", "the", "original", "vocab", "source", "info", "(", "term", "module", "and", "registrationOrder", ")"], "add_tokens": "// Store original vocab source definition in the schema itself for reference later schema . vocab = { module : modulename , term , registrationOrder : _M . registrationOrder ++ , } ;", "del_tokens": "// Keep track of order of definition for oada-formats-viz: schema . registrationOrder = _M . _registrationOrder ++ ;", "commit_type": "add"}
{"commit_tokens": ["make", "log", "safe", "pre", "-", "handler"], "add_tokens": "var originalLog = console . log . bind ( console ) var contextLogger = contextLogMapper && contextLogMapper [ severity ] ? contextLogMapper [ severity ] : originalLog", "del_tokens": "var originalLog var contextLogger = contextLogMapper [ severity ] || originalLog", "commit_type": "make"}
{"commit_tokens": ["Add", "executable", "runner", "basic", "logging"], "add_tokens": "BrowserStack . post ( '/_progress' , data , function ( ) { } ) ; BrowserStack . post ( \"/_report\" , results , function ( ) { } ) ;", "del_tokens": "// Tiny Ajax Post var post = function ( url , json , cb ) { var req ; if ( window . ActiveXObject ) req = new ActiveXObject ( 'Microsoft.XMLHTTP' ) ; else if ( window . XMLHttpRequest ) req = new XMLHttpRequest ( ) ; else throw \"Strider: No ajax\" req . onreadystatechange = function ( ) { if ( req . readyState == 4 ) cb ( req . responseText ) ; } ; var data = \"data=\" + JSON . stringify ( json ) req . open ( \"POST\" , url , true ) ; req . setRequestHeader ( 'X-Requested-With' , 'XMLHttpRequest' ) ; req . setRequestHeader ( 'Content-type' , 'application/x-www-form-urlencoded' ) ; req . setRequestHeader ( 'Content-length' , data . length ) ; req . setRequestHeader ( 'Connection' , 'close' ) ; req . send ( data ) ; } post ( '/strider-progress' , data , function ( ) { } ) ; post ( \"/strider-report\" , results , function ( ) { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "broken", "dummy", "scope", "when", "buffers", "are", "full", "."], "add_tokens": "this . dummyScope = /** @type {!wtf.trace.Scope} */ ( { leave : function ( result ) { return result ; } } ) ;", "del_tokens": "this . dummyScope = /** @type {!wtf.trace.Scope} */ ( { } ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixes", "name", "problem", "for", "test", "txt", "file"], "add_tokens": "var test = new testutil . Testlog ( \"test/test_rpc_caller_disclose_me.txt\" ) ;", "del_tokens": "var test = new testutil . Testlog ( \"test/test_pubsub_caller_disclose_me.txt\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["adding", "support", "for", "left", "joins"], "add_tokens": "query : user . select ( user . name , post . content ) . from ( user . leftJoin ( post ) . on ( user . id . equals ( post . userId ) ) ) , pg : 'SELECT \"user\".\"name\", \"post\".\"content\" FROM \"user\" LEFT JOIN \"post\" ON (\"user\".\"id\" = \"post\".\"userId\")' } ) ; test ( { query : user . select ( user . name . as ( 'user name' ) , user . id . as ( 'user id' ) ) . from ( user ) , pg : 'SELECT \"user\".\"name\" as \"user name\", \"user\".\"id\" as \"user id\" FROM \"user\"'", "del_tokens": "query : user . select ( user . name , post . content ) . from ( user . join ( post ) . on ( user . id . equals ( post . userId ) ) ) , pg : 'SELECT \"user\".\"name\", \"post\".\"content\" FROM \"user\" INNER JOIN \"post\" ON (\"user\".\"id\" = \"post\".\"userId\")'", "commit_type": "add"}
{"commit_tokens": ["Add", "notes", "about", "createShader", "using", "regl"], "add_tokens": "// Create the shader and return it. It will be rendered by regl.", "del_tokens": "// Create the shader and return it", "commit_type": "add"}
{"commit_tokens": ["Added", "prefix", "(", "+", "-", ")", "support", "for", "tag", "queries"], "add_tokens": "// supports the prefixes: '-' (exclusionary tags) or '+' (inclusionary tags) // e.g.: ?path=vacations&tags=mountains,beach,+horses // will show routes with OPTIONAL('mountains') OR OPTIONAL('beach') REQUIRED 'horses' // e.g.: ?path=vacations&tags=mountains,+beach,-horses // will show routes with OPTIONAL('mountains'), REQUIRED 'beach', REQUIRED NO 'horses' var exit ; for ( var i = 0 ; i < tags . length ; i ++ ) { switch ( tags [ i ] . substring ( 0 , 1 ) ) { case ' - ' var tag = tags [ i ] . substring ( 1 , tags [ i ] . length ) ; if ( Hoek . intersect ( route . settings . tags , [ tag ] ) . length > 0 ) { exit = true ; } break ; case ' ' : // (+) filter out tagged paths that do not have this tag! var tag = tags [ i ] . substring ( 1 , tags [ i ] . length ) ; if ( Hoek . intersect ( route . settings . tags , [ tag ] ) . length == 0 ) { exit = true ; } break ; } } // if we have reason to exit, then do so! if ( exit == true ) { return false ; } // default behavior for tags is additive if ( Hoek . intersect ( route . settings . tags , tags ) . length > 0 ) { // fallback or no tag defined", "del_tokens": "if ( ! route . settings . tags || Hoek . intersect ( route . settings . tags , tags ) . length > 0 ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "the", "mac", "-", "address", "module", "to", "handle", "MAC", "serialization", "logic", "."], "add_tokens": "var mac = require ( 'mac-address' ) ; try { mac . toBuffer ( record . nbstat . unitId , buf , offset + bytes ) ; bytes += 6 ; } catch ( error ) { return { error : error } ;", "del_tokens": "var u = record . nbstat . unitId ; var lastIndex = 0 ; var colonIndex = 0 ; for ( var i = 0 ; i < 5 ; ++ i ) { colonIndex = u . indexOf ( ':' , lastIndex ) ; if ( colonIndex <= lastIndex ) { return { error : new Error ( 'Invalid unit ID [' + u + ']; should follow pattern [##:##:##:##:##:##]' ) } ; } var tmpStr = u . substr ( lastIndex , ( colonIndex - lastIndex ) ) ; var tmpByte = parseInt ( tmpStr , 16 ) ; buf . writeUInt8 ( tmpByte , offset + bytes ) ; bytes += 1 ; lastIndex = colonIndex + 1 ; var tmpStr = u . substr ( lastIndex , ( u . length - lastIndex ) ) ; var tmpByte = parseInt ( tmpStr , 16 ) ; buf . writeUInt8 ( tmpByte , offset + bytes ) ; bytes += 1 ;", "commit_type": "use"}
{"commit_tokens": ["make", "unproject", "calls", "explicitly", "in", "return", "statement"], "add_tokens": "return [ map . unproject ( p . rotated ( angle , r ) ) , map . unproject ( midPoint ) , map . unproject ( midPoint . add ( [ ( angle > Math . PI * 0.9 ) ? - length : length , 0 ] ) )", "del_tokens": "var points = [ p . rotated ( angle , r ) , midPoint , midPoint . add ( [ ( angle > Math . PI * 0.9 ) ? - length : length , 0 ] ) return points . map ( function ( x ) { return map . unproject ( x ) ; } ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "running", "from", "other", "working", "directories", "."], "add_tokens": "const libui = require ( './index.js' ) ;", "del_tokens": "const libui = require ( '.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "JS", "brotli", "implementation", "on", "Node", "<", "8"], "add_tokens": "utils . brotli ( buffer ) . then ( function ( compressed ) {", "del_tokens": "var brotli = require ( 'wasm-brotli' ) brotli . compress ( buffer ) . then ( function ( compressed ) {", "commit_type": "use"}
{"commit_tokens": ["use", "@feross", "s", "is", "-", "buffer", "code"], "add_tokens": "/ ** * Determine if an object is Buffer * * Author : Feross Aboukhadijeh < feross @ feross . org > < http : //feross.org> * License : MIT * * / var isBuffer = function ( obj ) { return ! ! ( obj != null && obj . constructor && typeof obj . constructor . isBuffer === 'function' && obj . constructor . isBuffer ( obj ) ) } ;", "del_tokens": "var isBuffer = typeof Buffer !== \"undefined\" ? Buffer . isBuffer : function ( ) { } ;", "commit_type": "use"}
{"commit_tokens": ["fix", "bug", "74", ":", "partial", "missing", "from", "C#", "keyword", "list"], "add_tokens": "\"object out override orderby params partial readonly ref sbyte sealed \" +", "del_tokens": "\"object out override orderby params readonly ref sbyte sealed \" +", "commit_type": "fix"}
{"commit_tokens": ["Added", "final", "error", "message", "for", "proc", "exit"], "add_tokens": "try { fs . unlinkSync ( path ) ; if ( bundleName != undefined ) { fs . unlinkSync ( _ ( getPath ( 'mountPath' ) + '/' + bundleName ) ) ; } } catch ( err ) { console . log ( 'Final : ' , err . stack ) //Means that it does not exists anymore.", "del_tokens": "fs . unlinkSync ( path ) ; if ( bundleName != undefined ) { fs . unlinkSync ( _ ( getPath ( 'mountPath' ) + '/' + bundleName ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "documentation", "of", "digest", "to", "be", "service", "oriented", "(", "not", "provider", ")", "."], "add_tokens": "var getService = function ( service ) { return this . container [ service ] ; * Immediately instantiates the provided list of services and returns them . * @ param array services var digest = function digest ( services ) { return ( services || [ ] ) . map ( getService , this ) ;", "del_tokens": "var getProvider = function ( provider ) { return this . container [ provider ] ; * Immediately instantiates the provided list of providers and returns them . * @ param array providers var digest = function digest ( providers ) { return ( providers || [ ] ) . map ( getProvider , this ) ;", "commit_type": "update"}
{"commit_tokens": ["Implement", "a", "method", "to", "determine", "locale", "given", "a", "language"], "add_tokens": "} ) ) ;", "del_tokens": "} ) )", "commit_type": "implement"}
{"commit_tokens": ["Change", "default", "output", "directory", "to", "dist", "."], "add_tokens": "this . set ( 'output' , process . cwd ( ) + '/dist' ) ;", "del_tokens": "this . set ( 'output' , process . cwd ( ) + '/output' ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "error", "for", "unused", "element"], "add_tokens": "throw this . errorWithNode ( \"Unused JSX Elements aren't supported.\" ) ;", "del_tokens": "this . dangerouslyRemove ( ) ; return ;", "commit_type": "add"}
{"commit_tokens": ["moved", "css", "and", "html", "headers"], "add_tokens": ". then ( css => new Promise ( ( resolve , reject ) => { css = \"// THIS IS AN AUTOGENERATED FILE, BUILD USING ./tools/buildCss.js\\n\\n\" + css ; css ,", "del_tokens": ". then ( js => new Promise ( ( resolve , reject ) => { js ,", "commit_type": "move"}
{"commit_tokens": ["Adding", "exclude", "for", "xmldom", "in", "browserify", "builds"], "add_tokens": "// node.js version if ( typeof window === \"undefined\" ) { parseXml = function parseXml ( xmlStr ) { // requires xmldom module var DOMParser = require ( 'xmldom' ) . DOMParser ; return new DOMParser ( ) . parseFromString ( xmlStr , \"text/xml\" ) ; } ; } else if ( typeof window . DOMParser !== \"undefined\" ) { } , { \"xmldom\" : \"xmldom\" } ] , 9 : [ function ( require , module , exports ) {", "del_tokens": "// TODO: same for node.js if ( typeof window . DOMParser !== \"undefined\" ) { } , { } ] , 9 : [ function ( require , module , exports ) {", "commit_type": "add"}
{"commit_tokens": ["add", "initial", "(", "none", ")", "category", ".", "reset", "user", "/", "role", "elements", "on", "category", "dropdown", "change"], "add_tokens": "categoryOptions . unshift ( < option > (none) < / option > ) ;", "del_tokens": "console . log ( 'sending ' + this . state . actions [ category ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "body", "parser", "+", "tests", "for", "various", "data", "type"], "add_tokens": "this . body . split ( \"&\" ) . forEach ( function ( item ) { key = decodeURIComponent ( item . shift ( ) . replace ( '+' , ' ' ) ) ; val = decodeURIComponent ( item . shift ( ) . replace ( '+' , ' ' ) ) ; this . parsedBody [ key ] = val ; } . bind ( this ) ) ; this . body . split ( \"\\n\" ) . forEach ( function ( item ) { val = decodeURIComponent ( item . join ( '=' ) ) ; this . parsedBody [ key ] = val ; } . bind ( this ) ) ;", "del_tokens": "this . parsedBody = this . body . split ( \"&\" ) . forEach ( function ( item ) { key = decodeURIComponent ( item . shift ( ) ) ; val = decodeURIComponent ( item . shift ( ) ) ; data [ key ] = val ; } ) ; this . parsedBody = this . body . split ( \"\\r\\n\" ) . forEach ( function ( item ) { val = decodeURIComponent ( item . shift ( ) ) ; data [ key ] = val ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "sbot", ".", "hook", ".", "feed", "add", "message", ".", "obs", ".", "likes", "and", "plug", "into", "message", ".", "html", ".", "actions"], "add_tokens": "'sbot.obs.connectionStatus' : 'first' , 'sbot.hook.feed' : 'map' api . sbot . hook . feed ( msg )", "del_tokens": "'sbot.obs.connectionStatus' : 'first'", "commit_type": "add"}
{"commit_tokens": ["Fix", "headers", "ordering", "bug", ".", "Add", "testing", "demoing", "bug", "."], "add_tokens": "stream . push ( new Buffer ( stream . formatter ( stream . headers , true ) , \"utf8\" ) ) ; exports . defaultTransform = defaultTransform ;", "del_tokens": "stream . push ( new Buffer ( stream . formatter ( headers , true ) , \"utf8\" ) ) ; exports . defaultTransform = defaultTransform ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "scope", "loss", "causing", "error", "in", "express", "."], "add_tokens": "return ( res . sendStatus || res . send ) . call ( res , 304 ) ;", "del_tokens": "return ( res . sendStatus || res . send ) ( 304 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "paths", "starting", "with", ".", "/"], "add_tokens": ". pipe ( recursiveBundle ( bundleExt , variables ) ) ; if ( ! variables || typeof ( variables [ varName ] ) === 'undefined' ) if ( line === '' ) return null ; var negative = line [ 0 ] === '!' ; if ( negative ) line = line . substr ( 1 ) ; // get file path var filePath ; if ( line . indexOf ( './' ) === 0 ) filePath = line . substr ( 2 ) ; else filePath = path . join ( dir , line ) ; // return path if ( negative ) return '!' + filePath ;", "del_tokens": ". pipe ( recursiveBundle ( bundleExt ) ) ; if ( ! variables || typeof ( variables [ varName ] ) == 'undefined' ) var filePath = line [ 0 ] === '!' ? '!' + path . join ( dir , line . substr ( 1 ) ) : path . join ( dir , line ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "docs", "for", "classifier", "persistence"], "add_tokens": "this . docCount = ( this . docCount ? this . docCount : 0 ) + data . length ;", "del_tokens": "this . docCount = data . length ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "utils", ".", "js", "for", "supporting", "IE"], "add_tokens": "return ( Array . isArray ) ? Array . isArray ( obj ) : toString . call ( obj ) === '[object Array]' ;", "del_tokens": "return toString . call ( obj ) === '[object Array]' ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "v", "-", "tooltip", "restarting", "logic"], "add_tokens": "this . _init ( ) this . _init ( ) _init ( ) { // get events list const events = typeof this . options . trigger === 'string' ? this . options . trigger . split ( ' ' ) . filter ( trigger => [ 'click' , 'hover' , 'focus' ] . indexOf ( trigger ) !== - 1 ) : [ ] this . _isDisposed = false // set event listeners this . _setEventListeners ( this . reference , events , this . options ) }", "del_tokens": "// get events list const events = typeof options . trigger === 'string' ? options . trigger . split ( ' ' ) . filter ( trigger => [ 'click' , 'hover' , 'focus' ] . indexOf ( trigger ) !== - 1 ) : [ ] this . _isDisposed = false // set event listeners this . _setEventListeners ( reference , events , options ) const events = typeof this . options . trigger === 'string' ? options . trigger . split ( ' ' ) . filter ( trigger => [ 'click' , 'hover' , 'focus' ] . indexOf ( trigger ) !== - 1 ) : [ ] this . _setEventListeners ( this . reference , events , this . options )", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "Property", "Mismatch", "for", "Sphere", "scale", "primativea"], "add_tokens": "diameterX , diameterY , diameterZ , diameter = { Math . sqrt ( diameterX ** 2 + diameterY ** 2 + diameterZ ** 2 ) }", "del_tokens": "diameter = 2 , diameter = { diameter }", "commit_type": "fix"}
{"commit_tokens": ["Add", "invalid", "multiple", "value", "tests", "."], "add_tokens": ") , createTest ( ` ${ candidate . value } ${ candidate . value } ` , false ) ) ;", "del_tokens": ") ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "tail", "attachment", "in", "(", "...", ")", "groups", "and", "misc", ".", "adjustments"], "add_tokens": "expect ( 't (b/c)' ) . toGenerate ( '<t><b></b></t><t><c></c></t>' ) ; expect ( 't (b>a/c)' ) . toGenerate ( '<t><b><a></a></b></t><t><c></c></t>' ) ; expect ( 't (a.klass/a#id) + j' ) . toGenerate ( '<t><a class=\"klass\"></a><j></j></t><t><a id=\"id\"></a><j></j></t>' ) ; expect ( 't{ b (x/z)>p }' ) . toGenerate ( '<t><b><x><p></p></x></b><b><z><p></p></z></b></t>' ) ; expect ( 'body (b/a b) \"txt\"' ) . toGenerate ( '<body><b>txt</b></body><body><a><b>txt</b></a></body>' ) ; expect ( 'a (b, (c/d)) \"eggs\"' ) . toGenerate ( '<a><b>eggs</b><c>eggs</c></a><a><b>eggs</b><d>eggs</d></a>' ) ; expect ( '(a, (b/c) x) t' ) . toGenerate ( '<a><t></t></a><b><x><t></t></x></b><c><x><t></t></x></c>' ) ; expect ( '(a{id:blah;}/b[id=foo]).same' ) . toGenerate ( '<a class=\"same\" id=\"blah\"></a><b class=\"same\" id=\"foo\"></b>' ) ; expect ( '((a/b)/(c/d))x' ) . toGenerate ( '<a><x></x></a><b><x></x></b><c><x></x></c><d><x></x></d>' ) ; expect ( '(a/B)\"foo\"' ) . toGenerate ( '<a>foo</a><B>foo</B>' ) ;", "del_tokens": "expect ( 't (b,c)' ) . toGenerate ( '<t><b></b><c></c></t>' ) ; expect ( 't (b>a,c)' ) . toGenerate ( '<t><b><a></a></b><c></c></t>' ) ; expect ( 't (a.klass,a#id) + j' ) . toGenerate ( '<t><a class=\"klass\"></a><a id=\"id\"></a><j></j></t>' ) ; expect ( 't{ b (x,z)>p }' ) . toGenerate ( '<t><b><x><p></p></x><z><p></p></z></b></t>' ) ; expect ( 'body (b,a b) \"txt\"' ) . toGenerate ( '<body><b>txt</b><a><b>txt</b></a></body>' ) ; expect ( 'a (b, (c,d)) \"eggs\"' ) . toGenerate ( '<a><b>eggs</b><c>eggs</c><d>eggs</d></a>' ) ; expect ( '(a, (b,c) x) t' ) . toGenerate ( '<a><t></t></a><b><x><t></t></x></b><c><x><t></t></x></c>' ) ; expect ( '(a{id:blah;},b[id=foo]).same' ) . toGenerate ( '<a class=\"same\" id=\"blah\"></a><b class=\"same\" id=\"foo\"></b>' ) ; expect ( '((a,b),(c,d))x' ) . toGenerate ( '<a><x></x></a><b><x></x></b><c><x></x></c><d><x></x></d>' ) ; expect ( '(a,B)\"foo\"' ) . toGenerate ( '<a>foo</a><B>foo</B>' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "coloring", "and", "Error", ".", "stackTraceLimit", "=", "Inifinity"], "add_tokens": "var colors = require ( 'colors' ) ; // findToken fails for stack traces deeper Error.stackTraceLimit => Error.stackTraceLimit = Infinity // Make configurable? Error . stackTraceLimit = Infinity ; for ( var fn , i = 0 , l = structuredStackTrace . length ; i < l ; i ++ ) { fn = structuredStackTrace [ i ] . fun ; if ( fn . name === '_TOKEN_' ) { token : fn , stack : filterInternalFrames ( FormatStackTrace ( error , structuredStackTrace ) ) function filterInternalFrames ( frames ) { var ret = [ ] ; } ) . map ( function ( frame , k ) { if ( frame . indexOf ( '/node_modules/' ) >= 0 ) { frame = colors . cyan ( frame ) ; } else if ( frame . indexOf ( '/' ) >= 0 ) { frame = colors . red ( frame ) ; } return frame ;", "del_tokens": "for ( var i = 0 , l = structuredStackTrace . length ; i < l ; i ++ ) { var callSite = structuredStackTrace [ i ] ; if ( callSite . fun . name === '_TOKEN_' ) { var token = callSite . fun ; var stack = filterInternalFrames ( FormatStackTrace ( error , structuredStackTrace ) ) ; token : token , stack : stack function filterInternalFrames ( frames , filename ) {", "commit_type": "add"}
{"commit_tokens": ["Make", "tiny", "-", "lr", "s", "output", "less", "confusing"], "add_tokens": "livereloadServer . changed ( { body : { files : [ 'LiveReload files' ] } } )", "del_tokens": "livereloadServer . changed ( { body : { files : 'all' } } )", "commit_type": "make"}
{"commit_tokens": ["Remove", "mixin", "node", "if", "mixin", "evaluates", "to", "false"], "add_tokens": "// Remove mixin from CSS // Accounting for conditional mixin logic if ( results === false ) { return node . remove ( ) ; } node . replaceWith ( createNode ( results , node ) ) ;", "del_tokens": "} else if ( results !== false ) { node . replaceWith ( createNode ( results , node ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["update", "static", "tree", "resetting", "comments"], "add_tokens": "// pre 2.5, all static trees are cahced together on the instance // post 2.5.4: only v-once trees. Pure static trees are cached on the // staticRenderFns array (replaced above) } // 2.5.0~2.5.1 if ( record . Ctor . options . _staticTree ) {", "del_tokens": "// pre 2.5 staticTrees are cached per-instance } else { // post 2.5 staticTrees are cached on shared options", "commit_type": "update"}
{"commit_tokens": ["Fix", "for", "crop", "ratio", "issue"], "add_tokens": "matrix [ 1 ] [ 1 ] = - ratio / 2.0 matrix [ 1 ] [ 3 ] = ratio / 2.0 matrix [ 0 ] [ 0 ] = ( - 1 / ratio ) / 2.0 matrix [ 0 ] [ 2 ] = ( 1 / ratio ) / 2.0 matrix [ 1 ] [ 1 ] = ratio / 2.0 matrix [ 1 ] [ 3 ] = - ratio / 2.0 matrix [ 0 ] [ 0 ] = ( 1 / ratio ) / 2.0 matrix [ 0 ] [ 2 ] = ( - 1 / ratio ) / 2.0", "del_tokens": "matrix [ 1 ] [ 1 ] = - ratio / 2.0 matrix [ 1 ] [ 3 ] = ratio / 2.0 matrix [ 0 ] [ 0 ] = ( - 1 / ratio ) / 2.0 matrix [ 0 ] [ 2 ] = ( 1 / ratio ) / 2.0 // @@ Why does vert work but not horz matrix [ 1 ] [ 1 ] = ratio / 2.0 matrix [ 1 ] [ 3 ] = - ratio / 2.0 matrix [ 0 ] [ 0 ] = ( 1 / ratio ) / 2.0 matrix [ 0 ] [ 2 ] = ( - 1 / ratio ) / 2.0", "commit_type": "fix"}
{"commit_tokens": ["Updated", "to", "work", "better", "with", "the", "lastest", "version", "of", "roc", "-", "internal", "-", "dev"], "add_tokens": "packages : [ join ( __dirname , 'lib' , 'index.js' ) ]", "del_tokens": "packages : [ 'roc' , join ( __dirname , 'lib' , 'index.js' ) ]", "commit_type": "update"}
{"commit_tokens": ["fixed", "issue", "with", "destructuring", "this", ".", "props", "in", "to", "-", "stateless"], "add_tokens": "// Replace this.props.x with x } , // Remove destructuring assignment from this.props VariableDeclaration ( path ) { const declarator = path . get ( 'declarations' ) [ 0 ] ; if ( declarator . get ( 'init' ) . isMemberExpression ( ) ) { const expression = declarator . get ( 'init' ) ; if ( expression . get ( 'object' ) . isThisExpression ( ) && expression . get ( 'property' ) . isIdentifier ( { name : 'props' } ) ) { path . remove ( ) ; } } if ( defaultProps ) { path . insertAfter ( t . assignmentExpression ( '=' , t . memberExpression ( t . identifier ( pascalComponentName ) , t . identifier ( 'defaultProps' ) ) , defaultProps ) ) ; } t . identifier ( 'propTypes' ) propTypes", "del_tokens": "// Replace this.props.x with x } if ( defaultProps ) { t . identifier ( 'defaultProps' ) defaultProps path . insertAfter ( t . assignmentExpression ( '=' , t . memberExpression ( t . identifier ( pascalComponentName ) , t . identifier ( 'propTypes' ) ) , propTypes ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "to", "increase", "coverage"], "add_tokens": "it ( 'should load helpers and data from a function' , function ( ) { var hb2 = hb . merge ( { handlebars : { helpers : function ( ) { return { helper1 : function ( value ) { return ` ${ value } ` } } } , data : function ( ) { return [ 'eins' , 'zwei' , 'drei' , 'view' ] . reduce ( ( result , key ) => { result [ key ] = key . split ( '' ) . reverse ( ) . join ( '' ) return result } , { } ) } } } ) return expect ( hb2 . run ( ) ) . to . eventually . deep . equal ( { handlebars : { 'a.md' : 'a.md testPartials1/eins ->snie<-' , 'b.md' : 'b.md testPartials1/zwei ->iewz<- helper1[->iewz<-]' } } ) } ) it ( 'should throw an exception if loading an existing helpers-module fails' , function ( ) { it ( 'should throw no exception if a helper- or preprocessor-module does not exist' , function ( ) { return expect ( hb . merge ( { handlebars : { helpers : 'test/fixtures/non-existing-helper.js' , preprocessor : 'test/fixtures/non-existing-preprocessor.js' } } ) . run ( ) ) . not . to . be . rejected } )", "del_tokens": "it ( 'should throw an exception if loading an existing helpers module fails' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["add", "WhileStatement", "support", "add", "util", "/", "ast", "improve", "identation", "logic", "and", "refactor", "line", "break", "insertion", "around", "special", "nodes"], "add_tokens": "exports . aroundNodeIfNeeded = aroundNodeIfNeeded ; if ( needsLineBreakBefore ( nodeType ) && prevToken ) { function aroundNodeIfNeeded ( node ) { var type = node . type ; brBeforeIfNeeded ( node . startToken , type ) ; if ( node . endToken . value !== ';' && node . endToken . next && node . endToken . next . value === ';' ) { brAfterIfNeeded ( node . endToken . next , type ) ; } else { brAfterIfNeeded ( node . endToken , type ) ; } }", "del_tokens": "if ( needsLineBreakBefore ( nodeType ) && prevToken ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "messaging", "for", "adding", "a", "route"], "add_tokens": "return 'SERVERASSIST_LOCAL_WORKSTATION' in process . env ;", "del_tokens": "return ( myIp ( ) === '127.0.0.1' ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "EXPECTED_DATA_COMPANY_NAME", "with", "uriBeacon", "&", "fixed", "mistake", "in", "i", "/", "o", "for", "test", "2", ".", "TO", "DO", ":", "companyName", "error"], "add_tokens": "var INPUT_DATA = '09164c001204eb150000' ; serviceData : { uuid : \"004c\" , data : \"1204eb150000\" , } serviceData : { uuid : \"fed8\" , data : \"00f2027265656c7961637469766507\" , companyName : \"Google\" , uriBeacon : { invisibleHint : false , txPower : \"-14dBm\" , url : \"http://reelyactive.com\" } } } ; assert . deepEqual ( ADVERTISER_DATA , EXPECTED_DATA ) ; servicedata . process ( INPUT_DATA_COMPANY_NAME , CURSOR , ADVERTISER_DATA ) ; assert . deepEqual ( ADVERTISER_DATA , EXPECTED_DATA_COMPANY_NAME ) ;", "del_tokens": "var INPUT_DATA = '09160a181204eb150000' ; uuid : \"180a\" , data : \"1204eb150000\" , uuid : \"fed8\" , data : \"00f2027265656c7961637469766507\" , companyName : \"Google\" } assert . deepEqual ( ADVERTISER_DATA . serviceData , EXPECTED_DATA ) ; servicedata . process ( INPUT_DATA , CURSOR , ADVERTISER_DATA ) ; assert . deepEqual ( ADVERTISER_DATA . serviceData , EXPECTED_DATA ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "useragent_parser", "to", "the", "test", "it", "s", "so", "slow", "that", "it", "only", "does", "6", "runs", ".", "_", "."], "add_tokens": ", uaparser = require ( 'ua-parser' ) , useragent_parser = require ( 'useragent_parser' ) ; . add ( 'useragent_parser' , function ( ) { for ( var i = 0 ; i < length ; i ++ ) { useragent_parser . parse ( testcases [ i ] ) ; } } )", "del_tokens": ", uaparser = require ( 'ua-parser' ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "import", "-", "fresh", "in", "tests", "too"], "add_tokens": "var requireFresh = require ( 'import-fresh' ) ; var pkjson = requireFresh ( path . join ( project , 'package.json' ) ) ; var pkgJson = requireFresh ( path . join ( project , 'package.json' ) ) ; var pkgJson = requireFresh ( templatePkgJsonPath ) ; var pkgJson = requireFresh ( templatePkgJsonPath ) ; var pkjson = requireFresh ( path . join ( project , 'package.json' ) ) ;", "del_tokens": "delete require . cache [ require . resolve ( path . join ( project , 'package.json' ) ) ] ; var pkjson = require ( path . join ( project , 'package.json' ) ) ; delete require . cache [ require . resolve ( path . join ( project , 'package.json' ) ) ] ; var pkgJson = require ( path . join ( project , 'package.json' ) ) ; delete require . cache [ require . resolve ( templatePkgJsonPath ) ] ; var pkgJson = require ( templatePkgJsonPath ) ; delete require . cache [ require . resolve ( templatePkgJsonPath ) ] ; var pkgJson = require ( templatePkgJsonPath ) ; delete require . cache [ require . resolve ( path . join ( project , 'package.json' ) ) ] ; var pkjson = require ( path . join ( project , 'package.json' ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "config", "option", "for", "using", "last", "modified", "time", "of", "a", "physical", "file"], "add_tokens": "} exports . getTimestampFromDate = function ( dt , bRealtime ) { var timestamp = [ dt . getFullYear ( ) , exports . lpad ( dt . getMonth ( ) + 1 , 2 ) , exports . lpad ( dt . getDate ( ) , 2 ) ] . join ( '-' ) ; // Indicate that lastmod should include minutes and seconds (and timezone) if ( bRealtime && bRealtime === true ) { timestamp += 'T' ; timestamp += [ exports . lpad ( dt . getHours ( ) , 2 ) , exports . lpad ( dt . getMinutes ( ) , 2 ) , exports . lpad ( dt . getSeconds ( ) , 2 ) ] . join ( ':' ) ; timestamp += ( dt . getTimezoneOffset ( ) >= 0 ? '+' : '' ) ; timestamp += [ exports . lpad ( parseInt ( dt . getTimezoneOffset ( ) / 60 , 10 ) , 2 ) , exports . lpad ( dt . getTimezoneOffset ( ) % 60 , 2 ) ] . join ( ':' ) ; } return timestamp ; }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Fix", "null", "text", "in", "Twitter"], "add_tokens": "let { url , title , text , via } = encodeParams ( params ) let textParam = ( text === 'null' && title ) ? title : text return ` ${ url } ${ textParam } ${ viaParam } `", "del_tokens": "let { url , text , via } = encodeParams ( params ) return ` ${ url } ${ text } ${ viaParam } `", "commit_type": "fix"}
{"commit_tokens": ["use", "regex", "-", "not", "lint"], "add_tokens": "var define = require ( 'define-property' ) ; var regex = require ( 'regex-not' ) ; var cache ; var not = cache || ( cache = regex ( '(?:\\\\[:|:\\\\]|\\\\]|\\\\[)+' , { contains : true , strictClose : false } ) ) ; define ( node , 'rest' , this . input ) ; define ( node , 'parsed' , parsed ) ; define ( node , 'rest' , this . input ) ; define ( node , 'parsed' , parsed ) ;", "del_tokens": "var utils = require ( './utils' ) ; var not = new RegExp ( utils . not ( '(?:\\\\[:|:\\\\]|\\\\]|\\\\[)+' ) ) ; utils . define ( node , 'rest' , this . input ) ; utils . define ( node , 'parsed' , parsed ) ; utils . define ( node , 'rest' , this . input ) ; utils . define ( node , 'parsed' , parsed ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "events", "to", "the", "freeboard", "singleton"], "add_tokens": "( function ( jQuery ) { jQuery . eventEmitter = { _JQInit : function ( ) { this . _JQ = jQuery ( this ) ; } , emit : function ( evt , data ) { ! this . _JQ && this . _JQInit ( ) ; this . _JQ . trigger ( evt , data ) ; } , once : function ( evt , handler ) { ! this . _JQ && this . _JQInit ( ) ; this . _JQ . one ( evt , handler ) ; } , on : function ( evt , handler ) { ! this . _JQ && this . _JQInit ( ) ; this . _JQ . bind ( evt , handler ) ; } , off : function ( evt , handler ) { ! this . _JQ && this . _JQInit ( ) ; this . _JQ . unbind ( evt , handler ) ; } } ; } ( jQuery ) ) ; freeboard . emit ( \"dashboard_loaded\" ) ; freeboard . emit ( \"initialized\" ) ; } ( ) ) ; $ . extend ( freeboard , jQuery . eventEmitter ) ;", "del_tokens": "} ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["removing", "extra", "console", ".", "log"], "add_tokens": "console . error ( update . result . error ) ;", "del_tokens": "console . error ( update . result . error )", "commit_type": "remove"}
{"commit_tokens": ["Use", "can", "-", "assign", "instead", "of", "assign", "from", "can", "-", "util", ";", "use", "CIDSet", "instead", "of", "Array", ".", "indexOf"], "add_tokens": "var assign = require ( \"can-assign\" ) ;", "del_tokens": "var assign = require ( \"can-util/js/assign/assign\" ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "Russian", "docs", "for", "timepicker"], "add_tokens": "minMinutes : 0 ,", "del_tokens": "minMinutes : 0 ,", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "flag", "for", "public", "ip", "to", "seed", "the", "inline", "frame", "."], "add_tokens": ". describe ( \"public\" , \"The public hostname/ip address of the server\" ) if ( ! options . public ) options . public = argv . public ; var devClient = [ require . resolve ( \"../client/\" ) + \"?\" + protocol + \"://\" + ( options . public || ( options . host + \":\" + options . port ) ) ] ;", "del_tokens": "var devClient = [ require . resolve ( \"../client/\" ) + \"?\" + protocol + \"://\" + options . host + \":\" + options . port ] ;", "commit_type": "add"}
{"commit_tokens": ["Add", "backwards", "compatible", "syntax", "for", "setting", "JSON", "editor", "defaults", "."], "add_tokens": "* This is a small wrapper for using JSON Editor like a typical jQuery plugin . window . $ = window . $ || { } ; $ . jsoneditor = JSONEditor . defaults ;", "del_tokens": "* Turn an element into a schema editor * @ param options Options ( must contain at least a ` ` property )", "commit_type": "add"}
{"commit_tokens": ["Adds", "pattern", "matching", "to", "new", "grammar"], "add_tokens": "var es = require ( \"./es\" ) ; var fileWrapper = require ( \"./file-wrapper\" ) ; var esAst = transformAst ( ast ) ; var expr = fileWrapper ( esAst ) ; var js = compile ( expr ) ;", "del_tokens": "var es = transformAst ( ast ) ; var js = compile ( es ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "github", "api", "as", "example", "because", "openweathermap", "now", "requires", "an", "access", "token", "."], "add_tokens": "Handlebars . registerHelper ( 'github-user' , function ( value , options ) { var url = 'https://api.github.com/users/' + value return httpGet ( url , { headers : { 'User-Agent' : 'Node' } } ) . then ( function ( data ) { return options . fn ( data ) var template = Handlebars . compile ( '{{username}}: {{#github-user username}}{{{name}}}{{/github-user}}' ) username : 'nknapp'", "del_tokens": "Handlebars . registerHelper ( 'weather' , function ( value , options ) { var url = 'http://api.openweathermap.org/data/2.5/weather?q=' + value + '&units=metric' return httpGet ( url ) . then ( function ( weather ) { return options . fn ( weather ) var template = Handlebars . compile ( '{{city}}: {{#weather city}}{{{main.temp}}}°C{{/weather}}') city : 'Darmstadt'", "commit_type": "use"}
{"commit_tokens": ["move", "smoke", "tests", "to", "directory"], "add_tokens": "var cv = require ( '../lib/opencv' )", "del_tokens": "var cv = require ( './lib/opencv' )", "commit_type": "move"}
{"commit_tokens": ["moved", "sql", "API", "to", "sql", "folder"], "add_tokens": "var dataFrame = sqlContext . read ( ) . json ( file ) ;", "del_tokens": "var dataFrame = sqlContext . read . json ( file ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "env", "var", "overloading", "of", "using", "firefox", "binary"], "add_tokens": "// check to see if the env variable JPM_FIREFOX_BINARY is set if ( process . env . JPM_FIREFOX_BINARY ) binaryPath = process . env . JPM_FIREFOX_BINARY ; else if ( / darwin / i . test ( platform ) )", "del_tokens": "if ( / darwin / i . test ( platform ) )", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "vendor", "prefixes", "and", "hacks"], "add_tokens": "var names = require ( '../utils/names' ) ; if ( ! node || node . data . type !== 'Identifier' ) { break mismatch ; } var keyword = names . keyword ( node . data . name ) ; if ( syntaxNode . name !== keyword . vendor + keyword . name && syntaxNode . name !== keyword . name ) { var property = names . property ( propertyName ) ; var propertySyntax = property . vendor ? this . getProperty ( property . vendor + property . name ) || this . getProperty ( property . name ) : this . getProperty ( property . name ) ;", "del_tokens": "if ( ! node || node . data . type !== 'Identifier' || node . data . name !== syntaxNode . name ) { var propertySyntax = this . getProperty ( propertyName ) ;", "commit_type": "add"}
{"commit_tokens": ["changed", "design", "for", "tabs", "component"], "add_tokens": "{ title }", "del_tokens": "renderTabContent ( ) { const { active , title , } = this . props ; const contentClasses = classnames ( { 'ui-tab__content' : true , 'ui-tab__content_active' : active , 'ui-tab__content-paddings' : typeof title === 'string' , } ) ; return ( < div className = { contentClasses } > { title } < / div > ) ; } < div className = \"ui-tab__shadow-wrapper\" > { this . renderTabContent ( ) } < / div >", "commit_type": "change"}
{"commit_tokens": ["Fix", "lintRules", "were", "not", "even", "empty"], "add_tokens": "if ( config . lintRules || config . lintRules !== \"\" ) { // TODO: Throw easy-to-understand error message // incorrect path? (ex. \"lintRules\": \"aaa\") // typo? (ex. \"lintRules\": \"stylelint-config-suitcs\") const lintRules = require ( config . lintRules ) ; if ( lintRules . rules ) { plugins . push ( stylelint ( lintRules ) ) ; } else { throw new Error ( \"Illegal lint rule: \\\"rules\\\" property is not found.\" ) ; }", "del_tokens": "const lintRules = require ( config . lintRules ) ; if ( lintRules . rules ) { plugins . push ( stylelint ( lintRules ) ) ; } else { throw new Error ( \"Illegal lint rule: \\\"rules\\\" property is not found.\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["adding", "coffee", "-", "haml", "-", "filter", "to", "the", "resources", "section"], "add_tokens": "var __a ; __a = $ ( '.shopping_cart' ) . bind ( 'click' , ( function ( __this ) { var __func = function ( event ) { var __b ; __b = this . customer . purchase ( this . cart ) ; return Account === this . constructor ? this : __b ; return __func . apply ( __this , arguments ) ; } ) ( this ) ) ;", "del_tokens": "var __a , __b ; var __this = this ; __a = $ ( '.shopping_cart' ) . bind ( 'click' , ( function ( ) { __b = function ( event ) { var __c ; __c = this . customer . purchase ( this . cart ) ; return Account === this . constructor ? this : __c ; return __b . apply ( __this , arguments ) ; } ) ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["removed", "on", "handlers", "since", "we", "do", "not", "need", "them", "because", "auto", "propagation", "is", "turned", "on"], "add_tokens": "if ( message . content ( ) . length && message . content ( ) . length > 128 ) {", "del_tokens": "if ( message . content ( ) . length && message . content ( ) [ 0 ] . length > 128 ) { / * * When the Bus finnaly gets the \"post\" message just deliver to the target . We * are handling this message on the Bus . * / bus . on ( 'post' , function ( message ) { message . deliver ( ) ; } ) ; / * * When the Bus finally gets the \"set name\" message just deliver to the target . * We are handling this message on the Bus . * / bus . on ( 'set name' , function ( message ) { message . deliver ( ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "opt", ".", "forceQuery", "for", "crudify", "actions"], "add_tokens": "* - forceQuery - > if set to true , we will not use data ( modelObj . code ) * if ( tmpObj && ! opt . forceQuery ) { * - forceQuery - > if set to true , we will not use data ( modelObj . code ) * if ( tmpObj && ! opt . forceQuery ) { * - forceQuery - > if set to true , we will not use data ( modelObj . code ) * if ( tmpObj && ! opt . forceQuery ) {", "del_tokens": "if ( tmpObj ) { * if ( tmpObj ) { if ( tmpObj ) {", "commit_type": "add"}
{"commit_tokens": ["add", "canary", "back", "to", "contextTypes"], "add_tokens": "canary : ReactObj , format : ReactObj , forms : ReactObj , router : ReactObj , store : ReactObj . isRequired , translate : ReactObj ,", "del_tokens": "store : ReactObj . isRequired , forms : ReactObj , translate : ReactObj , format : ReactObj , router : ReactObj", "commit_type": "add"}
{"commit_tokens": ["Fix", "replace", "sideeffects", "too", "."], "add_tokens": "attributes . replace ( / \\.(\\w+)|\\[([^\\]]*)\\] / g , function ( match , m1 , m2 ) {", "del_tokens": "attributes . replace ( / \\.(\\w+)|\\[([^\\]]+)\\] / g , function ( match , m1 , m2 ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "more", "accurate", "test", "logging"], "add_tokens": "console . log ( 'Testing fake typed arrays' , method ) ;", "del_tokens": "console . log ( 'Testing' , method ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "bug", "which", "added", "an", "extra", "shadow", "to", "shapes", "that", "are", "both", "filled", "and", "stroked"], "add_tokens": "// Prevent extra shadow created by stroke (but only when fill is present) if ( params . fillStyle !== 'transparent' ) { ctx . shadowColor = 'transparent' ; }", "del_tokens": "// Ensure width/height of shapes (other than images) can be animated without specifying those properties initially if ( layer . method !== $ . fn . drawImage ) { layer . width = layer . width || 0 ; layer . height = layer . height || 0 ; }", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "in", "auto", ".", "Results", "wern", "t", "being", "passed", "to", "functions", "that", "were", "immediately", "ready", "to", "run", "."], "add_tokens": "task [ task . length - 1 ] ( taskCallback , results ) ;", "del_tokens": "task [ task . length - 1 ] ( taskCallback ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "an", "externals", "build", "issue"], "add_tokens": "'next-core-object' : { 'next-core-utilities' : { 'next-core-validation' : {", "del_tokens": "'core-next-object' : { 'core-next-utilities' : { 'core-next-validation' : {", "commit_type": "fix"}
{"commit_tokens": ["Use", "local", "index", ".", "html", "for", "start", "and", "build", "commands"], "add_tokens": "document . querySelector ( 'main' ) . appendChild ( el )", "del_tokens": "document . body . appendChild ( el )", "commit_type": "use"}
{"commit_tokens": ["Use", "a", "real", "Error", "in", "tests", "."], "add_tokens": "var error = new Error ( 'error' ) ; sample . mocks . topic . get . callsArgWith ( 1 , error ) ; var error = new Error ( 'error' ) ; sample . mocks . topic . delete . callsArgWith ( 0 , error ) ; var error = new Error ( 'error' ) ; sample . mocks . topic . publish . callsArgWith ( 1 , error ) ; var error = new Error ( 'error' ) ; sample . mocks . pubsub . getTopics . callsArgWith ( 0 , error ) ;", "del_tokens": "var error = 'error' ; sample . mocks . topic . get . callsArgWith ( 1 , new Error ( error ) ) ; var error = 'error' ; sample . mocks . topic . delete . callsArgWith ( 0 , new Error ( error ) ) ; var error = 'error' ; sample . mocks . topic . publish . callsArgWith ( 1 , new Error ( error ) ) ; var error = 'error' ; sample . mocks . pubsub . getTopics . callsArgWith ( 0 , new Error ( error ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "selector", "property", "for", "MenuItem", "which", "automatically", "calls", "first", "reponder", "s", "selector", "."], "add_tokens": "selector : 'orderFrontStandardAboutPanel:' selector : 'hide:' selector : 'hideOtherApplications:' selector : 'performMiniaturize:' selector : 'performClose:' selector : 'arrangeInFront:'", "del_tokens": "click : function ( ) { Menu . sendActionToFirstResponder ( 'orderFrontStandardAboutPanel:' ) ; } click : function ( ) { Menu . sendActionToFirstResponder ( 'hide:' ) ; } click : function ( ) { Menu . sendActionToFirstResponder ( 'hideOtherApplications:' ) ; } click : function ( ) { Menu . sendActionToFirstResponder ( 'performMiniaturize:' ) ; } click : function ( ) { Menu . sendActionToFirstResponder ( 'performClose:' ) ; } click : function ( ) { Menu . sendActionToFirstResponder ( 'arrangeInFront:' ) ; }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "problem", "with", "dynamically", "changing", "select", "values"], "add_tokens": "node . bindster . forceRefresh = true ; if ( ! bind_error && ( node . bindster . forceRefresh ? true : last_value !== bind_data ) ) { node . bindster . forceRefresh = false ;", "del_tokens": "if ( ! bind_error && last_value !== bind_data ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "removeApp", "()", "test", "case"], "add_tokens": "it ( 'should have deleted the app from config' , function ( ) { var config = pod . getConfig ( ) assert . ok ( ! ( 'test' in config . apps ) , 'test should no longer be in apps' ) } ) it ( 'should have removed all the app files' , function ( ) {", "del_tokens": "it ( 'should remove all the app files' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Allow", "nested", "property", "names", "in", "uiScopeContext", "using", "dot", "notation", "in", "Strings"], "add_tokens": "context [ alias ] = key . split ( '.' ) . reduce ( function ( scope , nextKey ) { return scope [ nextKey ] ; } , scope ) ;", "del_tokens": "context [ alias ] = scope [ key ] ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "services", "and", "updated", "the", "blueprint", "loading", "process", "so", "that", "it", "cleans", "the", "loaded", "blueprint", "of", "missing", "service", "methods", "and", "/", "or", "adds", "missing", "actions", "."], "add_tokens": "description : 'The base controller blueprint provides a simple shell from which other blueprints can extend' ,", "del_tokens": "description : 'The base controller blueprint provides a simple shell to extend from.' ,", "commit_type": "add"}
{"commit_tokens": ["fix", "a", "few", "corner", "cases"], "add_tokens": "listener = function ( event ) { _ . handle ( event , listener . s [ event . type ] || [ ] ) ; } ; if ( handler . after ) { handler . after ( ) ; }", "del_tokens": "listener = function ( event ) { return _ . handle ( event , listener . s [ event . type ] ) ; } ; return ! event . defaultPrevented ; if ( handler . after ) { handler . after ( ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Removing", "dependency", "to", "pandoc", "-", "bin", "and", "make", "pandoc", "an", "external", "dependency"], "add_tokens": "// use system installed pandoc which ( 'pandoc' , function ( err , cmd ) { if ( ! err ) pdc . path = cmd ; else { console . err ( 'metalsmith-pandoc: Cannot find pandoc on the system. Please install it!' ) ; process . exit ( 1 )", "del_tokens": "var pdcPath = require ( 'pandoc-bin' ) . path ; // use pandoc-bin pdc . path = pdcPath ; // check if installation of pandoc-bin is ok fs . stat ( pdcPath , function ( err , stats ) { if ( err || i sExecutable( s tats. m ode) ) console . log ( 'metalsmith-pandoc: trouble with pandoc-bin installation' ) ; console . log ( 'metalsmith-pandoc: trying to use system installed pandoc' ) ; // try to use system installed pandoc which ( 'pandoc' , function ( err , cmd ) { if ( ! err ) pdc . path = cmd ; else console . log ( 'metalsmith-pandoc: ERROR pandoc not found' ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Updating", "test", "to", "test", "for", "non", "-", "style", "code", "ignoring", "."], "add_tokens": "// console.log(state.intensity, state.foreground, state.background, state.xterm_background); test . equal ( state . code , '\\033[' + legacy_codes . join ( ';' ) + ( ( legacy_codes . length > 0 ) ? ';' : '' ) + code + 'm' ) ; exports [ 'Ignore Non-Style Codes' ] = function ( test ) { test . expect ( 1 ) ; var state = new ANSIState ( [ '\\033[32;22m' , '\\033[' , '\\033I' , '\\0331' , '\\033[34C' , '\\033[37C' , '\\033[1K' , '\\033[2;1y' , '\\0337' , '\\033[31m' , ] ) ; test . equal ( state . code , '\\033[22;31m' ) ; test . done ( ) ; } ;", "del_tokens": "test . equal ( state . code , '\\033[' + legacy_codes . join ( ';' ) + ( ( legacy_codes . length > 0 ) ? ';' : '' ) + code + 'm' )", "commit_type": "update"}
{"commit_tokens": ["added", "forwardRef", "prop", "to", "created", "component"], "add_tokens": "// Simple Example // Outside Component Example const MyComponent = props => < div { ... props } > My component < / div > // Multiple Styled Components Example < Section css = { { padding : 32 } } className = \"page-section\" > forwardRef", "del_tokens": "const MyComponent = ( { innerRef , ... props } ) => ( < div ref = { innerRef } { ... props } > My component < / div > ) < Section css = { { padding : 32 } } >", "commit_type": "add"}
{"commit_tokens": ["added", "event", "created", "-", "by", "group", "-", "id", "to", "Java", "client"], "add_tokens": "* Version : 0.0 .19 , build : 911", "del_tokens": "* Version : 0.0 .18 , build : 909", "commit_type": "add"}
{"commit_tokens": ["Added", "example", "with", "leaflet", "."], "add_tokens": "var leafletFile = __dirname + '/leaflet-tracksymbol.js' ; app . get ( '/leaflet-tracksymbol.js' , function ( req , res ) { res . sendFile ( leafletFile ) ; } ) ;", "del_tokens": "// this will make Express serve your static files", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "for", "documents", "/", "batch", "API"], "add_tokens": "var database = config . database || new nroonga . Database ( config . databasePath ) ;", "del_tokens": "var database = new nroonga . Database ( config . databasePath ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "option", "cacheMaxSize", "and", "added", "test", "for", "thatg"], "add_tokens": "if ( ! options . cacheMaxSize ) { options . cacheMaxSize = 10000 ; } if ( that . cache . size >= that . options . cacheMaxSize ) {", "del_tokens": "if ( that . cache . size > 10000 ) {", "commit_type": "add"}
{"commit_tokens": ["upgrade", "dependencies", "and", "bump", "version"], "add_tokens": "if ( typeof process !== 'undefined' && process && process . once ) {", "del_tokens": "if ( process && process . once ) {", "commit_type": "upgrade"}
{"commit_tokens": ["Removed", "the", "weird", "unexpected", "slow", "and", "almost", "undocumented", "feature", "that", "allowed", "to", "interact", "with", "the", "tooltips", "inside", "a", "container"], "add_tokens": "var v = null ; this . each ( function ( ) {", "del_tokens": "var $elList = this , v = null ; // if we're calling a container to interact with API's of tooltips inside it - select all those tooltip origins first if ( ! $elList . data ( 'tooltipster' ) ) { var query = $elList . find ( '*' ) ; $elList = $ ( ) ; query . each ( function ( ) { if ( $ ( this ) . data ( 'tooltipster' ) ) { $elList . push ( $ ( this ) ) ; } } ) ; } $elList . each ( function ( ) {", "commit_type": "remove"}
{"commit_tokens": ["fix", "har", "size", "raw", "file", "report"], "add_tokens": "var total = harvested . rawFileDataSummary . total ; assert . isObject ( total ) ; assert . equals ( total . redirects , 6 ) ; assert . equals ( total . rawRequests , 5 ) ; assert . equals ( total . requests , 11 ) ; assert . isNumber ( total . size , 'size should be a number' ) ; assert . isNumber ( total . fullSize , 'fullSize should be a number' ) ; var tips = harvested . rawFileDataSummary . tips ; assert . isNumber ( tips . possibleCompressTarget , 'possibleCompressTarget should be a number' ) ; assert . isNumber ( tips . possibleCompressImprovement , 'possibleCompressImprovement should be a number' ) ; assert . isNumber ( tips . possibleCompressWithOnlyScriptGzip , 'possibleCompressWithOnlyScriptGzip should be a number' ) ;", "del_tokens": "assert . equals ( harvested . rawFileDataSummary . total . redirects , 6 ) ; assert . equals ( harvested . rawFileDataSummary . total . rawRequests , 5 ) ; assert . equals ( harvested . rawFileDataSummary . total . requests , 11 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changing", "the", "name", "of", "container", "to", "columns", "since", "it", "is", "more", "descriptive", "."], "add_tokens": "formioComponentsProvider . register ( 'columns' , { fbtemplate : 'formio/formbuilder/columns.html' $templateCache . put ( 'formio/formbuilder/columns.html' ,", "del_tokens": "formioComponentsProvider . register ( 'container' , { fbtemplate : 'formio/formbuilder/container.html' $templateCache . put ( 'formio/formbuilder/container.html' ,", "commit_type": "change"}
{"commit_tokens": ["add", "support", "for", "request", "json", "bodies"], "add_tokens": "* If given , the body will be included * as a JSON string . * * @ params { Object } [ body ] Optional request body . Message . prototype . bind = function ( options , body ) { if ( body ) { req . write ( JSON . stringify ( body ) ) ; }", "del_tokens": "Message . prototype . bind = function ( options ) {", "commit_type": "add"}
{"commit_tokens": ["Changed", "default", "api", "-", "docs", "to", "swagger", ".", "json"], "add_tokens": "default : 'swagger.json'", "del_tokens": "default : 'resources.json'", "commit_type": "change"}
{"commit_tokens": ["Fix", "output", "order", "of", "Sheet", "Properties"], "add_tokens": "this . _writeSheetProperties ( xml , this . properties , this . pageSetup ) ;", "del_tokens": "this . _writeSheetProperties ( xml , this . properties , this . pageSetup ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "http", "status", "code", "to", "the", "thrown", "exception", "."], "add_tokens": "var err = new Error ( \"Invalid response: \" + status + \" \" + response . statusText ) ; err . status = status ; throw err ;", "del_tokens": "throw new Error ( \"Invalid response: \" + status + \" \" + response . statusText ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "to", "support", "new", "input", "params", "and", "allow", "users", "t", "specify", "the", "domain", "for", "a", "guid", ".", "Use", "a", "new", "/", "box", "hosts", "path", ".", "Update", "README"], "add_tokens": "function genHost ( host ) { if ( host . indexOf ( 'feedhenry.com' ) === - 1 ) { return host . concat ( '.feedhenry.com' ) ; } return host ; } module . exports = function getUrl ( opts , callback ) { } else if ( res . statusCode !== 200 ) { var body , url , hostingDomain ; // Allow user specify the host (local dev for example) if ( typeof opts !== 'string' ) { hostingDomain = ( opts . domain ) ? genHost ( opts . domain ) : MILLICORE_HOST ; } else { hostingDomain = MILLICORE_HOST ; } url += path . join ( hostingDomain , HOSTS_PATH ) ; guid : ( typeof opts . guid !== 'undefined' ) ? opts . guid : opts 'Content-Type' : 'application/json'", "del_tokens": "module . exports = function getUrl ( guid , callback ) { } else if ( res . status !== 200 ) { var body , url ; url += path . join ( MILLICORE_HOST , HOSTS_PATH ) ; instance : process . env [ 'FH_INSTANCE' ] , widget : process . env [ 'FH_WIDGET' ] , payload : { guid : guid , calling_guid : process . env [ 'FH_WIDGET' ] , env : ENV } 'content-type' : 'application/json; charset=utf-8'", "commit_type": "update"}
{"commit_tokens": ["use", "sha256", "to", "generate", "copayerId", "from", "xPub"], "add_tokens": "//return (new Bitcore.HDPublicKey(xpub)).derive(HDPath.IdBranch).publicKey.toString(); return crypto . Hash . sha256 ( new Buffer ( xpub ) ) . toString ( 'hex' ) ;", "del_tokens": "return ( new Bitcore . HDPublicKey ( xpub ) ) . derive ( HDPath . IdBranch ) . publicKey . toString ( ) ; //key = sjcl.bitArray.clamp(key, 128); //key = sjcl.bitArray.clamp(key, 128);", "commit_type": "use"}
{"commit_tokens": ["Use", "up", "-", "to", "-", "date", "transitionend", "names"], "add_tokens": "var book2 = new Heidelberg ( $ ( '#Heidelberg-example-2' ) , { } ) ; $ ( '#first' ) . on ( 'click' , function ( ) { book2 . turnPage ( 1 ) ; } ) ; $ ( '#last' ) . on ( 'click' , function ( ) { book2 . turnPage ( 14 ) ;", "del_tokens": "new Heidelberg ( $ ( '#Heidelberg-example-2' ) , {", "commit_type": "use"}
{"commit_tokens": ["changed", "to", "mocha", ":", "mjs", "from", "mocha", ":", "src"], "add_tokens": "if ( api . env ( 'mocha:mjs' ) ) {", "del_tokens": "if ( api . env ( 'mocha:src' ) ) {", "commit_type": "change"}
{"commit_tokens": ["fix", "many", "to", "one", "(", "again", ")"], "add_tokens": "! linkedIsArray && if ( partialRecord [ inverseField ] === update . id ) return", "del_tokens": "! Array . isArray ( linked [ field ] [ inverseField ] ) &&", "commit_type": "fix"}
{"commit_tokens": ["Fix", "issue", "where", "folded", "signals", "weren", "t", "unmounted", "properly"], "add_tokens": "const subscription = s . subscribe ( { ... emit , next , complete } ) return ( ) => subscription . unsubscribe ( )", "del_tokens": "return s . subscribe ( { ... emit , next , complete } )", "commit_type": "fix"}
{"commit_tokens": ["allow", "key", "modifiers", "in", "simulate", "method"], "add_tokens": "const modifiers = { enter : 13 , tab : 9 , delete : 46 , esc : 27 , space : 32 , up : 38 , down : 40 , left : 37 , right : 39 , } ; const event = type . split ( '.' ) ; const eventObject = new window . Event ( event [ 0 ] ) ; if ( event . length === 2 ) { eventObject . keyCode = modifiers [ event [ 1 ] ] ; }", "del_tokens": "const eventObject = new window . Event ( type ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "hooks", "system", "moved", "entity", "tooltips", "to", "the", "Markup", "language", "as", "a", "plugin"], "add_tokens": "} // Plugin to make entity title show the real entity Prism . hooks . add ( 'wrap' , function ( env ) { if ( env . token === 'entity' ) { env . attributes [ 'title' ] = env . content . replace ( / &amp; / , '&' ) ; } } ) ;", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["fixed", "ref", "resolution", "using", "wrong", "root", "when", "compiling", "resolved", "schema"], "add_tokens": "var currentRoot = util . copy ( root ) ; var v ; if ( typeof schema == 'function' ) v = this . _refs [ ref ] = schema ; else if ( schema ) v = this . _refs [ ref ] = compile . call ( this , schema , root ) ; util . copy ( currentRoot , root ) ; return v ; if ( typeof refVal == 'function' ) util . copy ( refVal , root ) ; util . copy ( refVal , root ) ;", "del_tokens": "if ( typeof schema == 'function' ) return this . _refs [ ref ] = schema ; if ( schema ) return this . _refs [ ref ] = compile . call ( this , schema , root ) ; if ( typeof refVal == 'function' ) root = refVal ; root = refVal ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "failing", "test", "added", "by", "e86e361", ".", "Beautiful", "."], "add_tokens": "if ( start === end && __EMPTY_RANGE ) { return __EMPTY_RANGE ; } if ( wholeSlice ( begin , end , this . length ) ) { return this ; } begin = resolveBegin ( begin , this . length ) ; end = resolveEnd ( end , this . length ) ; if ( end <= begin ) { return __EMPTY_RANGE ; } var __EMPTY_RANGE = Range ( 0 , 0 ) ;", "del_tokens": "begin = begin < 0 ? Math . max ( 0 , this . length + begin ) : Math . min ( this . length , begin ) ; end = end == null ? this . length : end > 0 ? Math . min ( this . length , end ) : Math . max ( 0 , this . length + end ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "module", ".", "exports", "=", "to", "output", "for", "the", "main", "module"], "add_tokens": "var moduleExportsName = row . exportsName = '__module_' + row . id for ( var i = 0 ; i < rows . length ; i ++ ) { if ( rows [ i ] . entry ) { modules . push ( 'module.exports = ' + rows [ i ] . exportsName ) } }", "del_tokens": "var moduleExportsName = '__module_' + row . id", "commit_type": "add"}
{"commit_tokens": ["Remove", "^", "power", "op", "from", "string", "outputs"], "add_tokens": "qty . toBase ( ) . units ( ) . should . be \"m2/s2\" result . units ( ) . should . be \"m2\" result . units ( ) . should . be \"m2\" result . units ( ) . should . be \"cm2\" result . units ( ) . should . be \"m2\" result . units ( ) . should . be \"kg/m2\" qty . units ( ) . should . be \"cm2\" qty . units ( ) . should . be \"cm2/s2\" qty . units ( ) . should . be \"cm2*J3/s2*A2\" qty . toString ( ) . should . be \"254 kg/m2\"", "del_tokens": "qty . toBase ( ) . units ( ) . should . be \"m^2/s^2\" result . units ( ) . should . be \"m^2\" result . units ( ) . should . be \"m^2\" result . units ( ) . should . be \"cm^2\" result . units ( ) . should . be \"m^2\" result . units ( ) . should . be \"kg/m^2\" qty . units ( ) . should . be \"cm^2\" qty . units ( ) . should . be \"cm^2/s^2\" qty . units ( ) . should . be \"cm^2*J^3/s^2*A^2\" qty . toString ( ) . should . be \"254 kg/m^2\"", "commit_type": "remove"}
{"commit_tokens": ["Improved", "the", "documentation", "for", "the", "client"], "add_tokens": "/** @module client */ * Constructs a Client with instances of all the resources using the dispatcher . * It also keeps a reference to the dispatcher so that way the end user can have * access to it . * @ classdesc A wrapper for the Asana API which is authenticated for one user * Creates a Client for a user using that user ' * through HTTP Basic Authentication . This is probably the easier method for * command line scripts or bot like integrations . Handling \"real\" users should * be preferably done with OAuth . * @ param { String } apiKey The Asana Api Key of the user * Creates a Client for the user using that user ' * to the application . This library does not support handling the OAuth flow but * libraries like passport - asana or others than handle that flow are excellent * options . * @ param { String } token The Asana OAuth token of the user", "del_tokens": "* Creates an Asana API Client * Create a client for basic auth * @ param { String } apiKey The Asana Api Key for the user * Create a client for OAuth access * @ param { String } token The Asana OAuth token for the user", "commit_type": "improve"}
{"commit_tokens": ["Fix", "bone", "where", "arm", "width", "would", "not", "scale", "correctly"], "add_tokens": "boneXOffset = ( hand . arm . width / 2 ) * 0.85 ;", "del_tokens": "boneXOffset = ( hand . arm . width / 2 ) - ( boneRadius / 2 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "error", "fetching", "source", "version"], "add_tokens": "return process . env . SOURCE_VERSION || '' ;", "del_tokens": "return process . SOURCE_VERSION || '' ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "option", "to", "increment", "field", "on", "updates", "rather", "than", "just", "on", "insert", "."], "add_tokens": "incrementBy : 1 , incrementOnUpdate : false if ( typeof ( doc [ settings . field ] ) !== 'number' || settings . incrementOnUpdate )", "del_tokens": "incrementBy : 1 if ( typeof ( doc [ settings . field ] ) !== 'number' )", "commit_type": "add"}
{"commit_tokens": ["Fix", "undefined", "appearing", "in", "the", "type", "output", "for", "simple", "types"], "add_tokens": "var sTypes = m [ 2 ] || m [ 3 ] || '' ;", "del_tokens": "var sTypes = m [ 2 ] || m [ 3 ] ;", "commit_type": "fix"}
{"commit_tokens": ["changing", "context", "menu", "options", "to", "disable", "renaming", "on", "symbols", "and", "relocs"], "add_tokens": "if ( ui . target . hasClass ( 'insaddr' ) ) { $ ( document ) . contextmenu ( \"showEntry\" , \"define\" , true ) ; $ ( document ) . contextmenu ( \"showEntry\" , \"undefine\" , true ) ; $ ( document ) . contextmenu ( \"showEntry\" , \"comment\" , true ) ; $ ( document ) . contextmenu ( \"showEntry\" , \"rename\" , true ) ; } else { $ ( document ) . contextmenu ( \"showEntry\" , \"define\" , false ) ; $ ( document ) . contextmenu ( \"showEntry\" , \"undefine\" , false ) ; $ ( document ) . contextmenu ( \"showEntry\" , \"comment\" , false ) ; $ ( document ) . contextmenu ( \"showEntry\" , \"rename\" , true ) ; } if ( ui . target . hasClass ( 'reloc' ) || ui . target . hasClass ( 'symbol' ) ) { $ ( document ) . contextmenu ( \"showEntry\" , \"comment\" , false ) ; $ ( document ) . contextmenu ( \"showEntry\" , \"rename\" , false ) ;", "del_tokens": "// $(\"#command\")[0].setSelectionRange(inEvent.target.value.length, inEvent.target.value.length); // console.log(inEvent.target.value.length); // $(\"#command\")[0].focus(); // console.log(inEvent.target.value.length); // $(\"#command\")[0].setSelectionRange(inEvent.target.value.length, inEvent.target.value.length); // $(\"#command\")[0].focus(); var target = ui . target [ 0 ] ; if ( target . className . indexOf ( \"insaddr\" ) !== 0 ) {", "commit_type": "change"}
{"commit_tokens": ["add", "test", "for", "error", "with", "new", "line"], "add_tokens": "// test utils.reStack() method. expect ( 'no newline' ) . toEqual ( 'line with\\nnew line' ) ;", "del_tokens": "expect ( true ) . toEqual ( true ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "hasbody", "to", "be", "true", "for", "content", "-", "length", ":", "0"], "add_tokens": "return ! isNaN ( headers [ 'content-length' ] ) ;", "del_tokens": "var length = headers [ 'content-length' ] ; if ( ! length ) return false ; // no idea when this would happen, but `isNaN(null) === false` if ( isNaN ( length ) ) return false ; return ! ! parseInt ( length , 10 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "showTip", "calls", "to", "run", "from", "jQuery", "queue", "."], "add_tokens": "tipElement . queue ( function ( ) { showTip ( element ) ; } ) ; tipElement . queue ( function ( ) { } ) ; tipElement . stop ( true , true ) . fadeOut ( options . fadeOutTime , function ( ) {", "del_tokens": "showTip ( element ) ; setTimeout ( function ( ) { } , options . closeDelay ) ; tipElement . fadeOut ( options . fadeOutTime , function ( ) {", "commit_type": "change"}
{"commit_tokens": ["Allow", "an", "Autolinker", ".", "HtmlTag", "instance", "to", "be", "returned", "from", "the", "replaceFn", "and", "provide", "an", "easy", "API", "to", "generate", "one", "."], "add_tokens": "* @ protected * Generates the actual anchor ( & lt ; a & gt ; ) tag to use in place of the matched URL / email / Twitter text , * via its ` ` object . build : function ( match ) {", "del_tokens": "* @ private * Generates the actual anchor ( & lt ; a & gt ; ) tag to use in place of a source url / email / twitter link . createAnchorTag : function ( match ) {", "commit_type": "allow"}
{"commit_tokens": ["Move", "contents", "of", "/", "basic", "-", "shared", "/", "basic", "-", "helpers", "up", "to", "/", "basic", "-", "shared", "."], "add_tokens": "* Basic helpers related the tracking of changes in content , and flattening a * content tree ( including distributed content ) . var host = Basic . ContentHelpers . getHost ( node ) ; window . Basic = window . Basic || { } ; window . Basic . ContentHelpers = { window . Basic . ContentChanged = { Basic . ContentHelpers . observeContentChanges ( this ) ; Basic . ContentHelpers . observeContentChanges ( this , false ) ; return Basic . ContentHelpers . flattenChildren ( this ) ; return Basic . ContentHelpers . flattenChildNodes ( this ) ; return Basic . ContentHelpers . flattenTextContent ( this ) ;", "del_tokens": "* Basic helpers related to managing component content . * * These helpers generally deal with the tracking of changes in content , and * flattening a content tree ( including distributed content ) . var host = BasicContentHelpers . getHost ( node ) ; window . BasicContentHelpers = { window . BasicContentBehavior = { BasicContentHelpers . observeContentChanges ( this ) ; BasicContentHelpers . observeContentChanges ( this , false ) ; return BasicContentHelpers . flattenChildren ( this ) ; return BasicContentHelpers . flattenChildNodes ( this ) ; return BasicContentHelpers . flattenTextContent ( this ) ;", "commit_type": "move"}
{"commit_tokens": ["add", "option", "to", "allow", "inconsistency", "in", "request", "proxy"], "add_tokens": "retrySchedule : options . requestProxyRetrySchedule , enforceConsistency : options . enforceConsistency === undefined ? true : options . enforceConsistency", "del_tokens": "retrySchedule : options . requestProxyRetrySchedule", "commit_type": "add"}
{"commit_tokens": ["uses", "global", "Redis", "keyspace", "rather", "than", "a", "hashmap"], "add_tokens": "{ REDIS_URL } = require ( '../services/constants' ) , return module . exports . client . setAsync ( key , value ) ; return module . exports . client . getAsync ( key ) return module . exports . client . msetAsync ( batch ) ; return module . exports . client . delAsync ( key ) ;", "del_tokens": "{ REDIS_URL , REDIS_HASH } = require ( '../services/constants' ) , return module . exports . client . hsetAsync ( REDIS_HASH , key , value ) ; return module . exports . client . hgetAsync ( REDIS_HASH , key ) return module . exports . client . hmsetAsync ( REDIS_HASH , batch ) ; return module . exports . client . hdelAsync ( REDIS_HASH , key ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "option", "to", "omit", "transpiler"], "add_tokens": "// Adds dependencies to start of config.files: es6-module-loader, and system.js // Default to use Traceur as transpiler, but make it possible to avoid using // a transpiler by setting the transpiler option to null. var useTranspiler = systemjsConfig . config . transpiler !== null ; if ( useTranspiler ) { var transpilerPath = systemjsConfig . config . transpiler === 'babel' ? getDependencyPath ( 'babel' , '/../../../browser.js' ) : getDependencyPath ( 'traceur' , '/../../bin/traceur.js' ) ; // Don't watch, since this file should never change config . files . unshift ( createIncludePattern ( transpilerPath ) ) ; } } ;", "del_tokens": "var transpilerPath = systemjsConfig . config . transpiler === 'babel' ? getDependencyPath ( 'babel' , '/../../../browser.js' ) : getDependencyPath ( 'traceur' , '/../../bin/traceur.js' ) ; // Adds dependencies to start of config.files: traceur, es6-module-loader, and system.js createIncludePattern ( transpilerPath ) , } ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "incorrect", "env", "when", "build"], "add_tokens": "process . env . NODE_ENV = 'production' ;", "del_tokens": "process . env . NODE_ENV = 'development' ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "!", "character", "patch", "version", "bump"], "add_tokens": "expression += ` \\\\ ` ;", "del_tokens": "expression += path ? WILDCARD_PATH : WILDCARD ;", "commit_type": "fix"}
{"commit_tokens": ["add", "an", "entity", "for", "adding", "a", "class", "to", "an", "element", "(", "by", "uid", ")"], "add_tokens": "var select = require ( 'quantum-core' ) . select transforms . classed = function ( entity , page , transform ) { var element = page . get ( entity . params [ 0 ] ) if ( element ) { element . classed ( entity . params [ 1 ] , entity . params [ 2 ] ) } return }", "del_tokens": "var select = require ( 'quantum' ) . select", "commit_type": "add"}
{"commit_tokens": ["Remove", "API", "to", "clear", "stored", "modules"], "add_tokens": "// Move the module key", "del_tokens": "// Remove the module key } ; / ** * Removes a module * from the module store . * * If no module key is passed * the entire store is cleared . * * @ param { String | undefined } module * @ api public * / module . exports . clear = function ( module ) { if ( module ) delete store . modules [ module ] ; else store . modules = { } ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "perms", "listings", "and", "..", "links", "to", "dir", "listings"], "add_tokens": "opts . root = dir ; showDir ( opts , stat ) ( req , res ) ; return showDir ( opts , stat ) ( req , res ) ;", "del_tokens": "showDir ( pathname , file , stat , cache ) ( req , res ) ; return showDir ( pathname , file , stat , cache ) ( req , res ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "for", "subfile", "loading"], "add_tokens": "it ( 'loads each subfile' , function ( ) { var loadSpy = sinon . spy ( ) ; var hub = getHub ( { './get-subfiles' : function ( ) { return [ { relativePath : 'rel-path-1' } , { relativePath : 'rel-path-2' } ] } , './load-subfile' : loadSpy } ) ; hub ( 'test-pattern' ) ; loadSpy . calledTwice . should . be . true ; loadSpy . calledWith ( { relativePath : 'rel-path-1' } , { } ) . should . be . true ; loadSpy . calledWith ( { relativePath : 'rel-path-2' } , { } ) . should . be . true ; } ) ;", "del_tokens": "it ( 'loads each subfile' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "recursion", "issue", ".", "Resolves", "gh", "-", "2"], "add_tokens": "generateAnysort = function ( priCriteria ) { if ( priCriteria == null ) { priCriteria = returnFalse ; priMatcher = anymatch . matcher ( priCriteria ) ; return sorter = function ( a , b , criteria ) { var hasA , hasB , indexOfA , indexOfB , matcher , _ref ; if ( criteria ) { matcher = anymatch . matcher ( criteria ) ; } else { criteria = priCriteria ; return sorter ( a , b , criteria . slice ( indexOfA + 1 ) ) ;", "del_tokens": "generateAnysort = function ( criteria ) { if ( criteria == null ) { criteria = returnFalse ; priMatcher = anymatch . matcher ( criteria ) ; return sorter = function ( a , b , matcher ) { var hasA , hasB , indexOfA , indexOfB , _ref ; if ( matcher == null ) { return sorter ( a , b , anymatch . matcher ( criteria . slice ( indexOfA + 1 ) ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "stroke", "to", "scatter", "plot"], "add_tokens": ". heatmap ( 'h1' , { innerRadius : 220 , outerRadius : 240 , logScale : true } , heatmap ) . histogram ( 'hist1' , { innerRadius : 200 , outerRadius : 220 } , heatmap ) . scatter ( 'c1' , { innerRadius : 150 , outerRadius : 200 , glyph : { shape : 'cross' , size : 50 , fill : true } } , scatter )", "del_tokens": ". heatmap ( 'h1' , { outerRadius : 240 , logScale : true } , heatmap ) . histogram ( 'hist1' , { } , heatmap ) // .heatmap('h2', {innerRadius: 150, outerRadius: 200, colorPalette: 'BuGn'}, heatmap)", "commit_type": "add"}
{"commit_tokens": ["Add", "animation", "loading", "to", "splat", "."], "add_tokens": "this . animations = new splat . AnimationLoader ( this . images , manifest . animations ) ; return this . images . allLoaded ( ) && this . sounds . allLoaded ( ) && this . fonts . allLoaded ( ) && this . animations . allLoaded ( ) ;", "del_tokens": "return this . images . allLoaded ( ) && this . sounds . allLoaded ( ) && this . fonts . allLoaded ( ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "a", "test", "on", "nested", "folders"], "add_tokens": "} , 0 ) ; it ( 'should detect a new file in nested new folders if recursive is true @8' , function ( done ) { var d = __dirname + '/data/lol4/lol5' ; var f = __dirname + '/data/lol4/lol5/newfile' ; var w = new INotifyWait ( __dirname + '/data' , { recursive : true } ) ; w . on ( 'add' , function ( name ) { //console.log(name); w . close ( ) ; done ( ) ; } ) ; w . on ( 'ready' , function ( ) { mkdirp . sync ( d ) ; // wait few milliseconds before writing a file // so inotifywait can scan the new folder setTimeout ( function ( ) { fs . writeFileSync ( f , '...' ) ; } , 0 ) ; } ) ; } ) ;", "del_tokens": "} , 10 ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "a", "race", "condition", "issue", "on", "swagger", "startup"], "add_tokens": "if ( this . apis ( ) ) { var schemaUrl = this . _schemaUrl = this . _options . credentials . url + '/rest/swagger.json' ; var swaggerClient = new SwaggerClient ( { if ( swaggerClient . ready === true ) { that . swaggerClient = swaggerClient ; cb ( null , arg , that . apis ( ) ) ; if ( debugREST ) { console . log ( 'RestCall - onReady: ' + fn + ', err: ' + err + ', apis:' + apis ) ; }", "del_tokens": "this . _schema = null ; if ( this . swaggerClient ) { var schemaUrl = this . _options . credentials . url + '/rest/swagger.json' ; this . swaggerClient = new SwaggerClient ( { if ( that . swaggerClient . ready === true ) { cb ( null , arg , that . swaggerClient . apis ) ; if ( debugREST ) { console . log ( 'RestCall - onReady: ' + fn + ', err: ' + err ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "readme", "update", "samples", "and", "bug", "-", "fixes"], "add_tokens": "session . privateConversationData . qnaFeedbackUserQuestion = session . message . text ; if ( selectedResponse && selectedResponse . answer && selectedResponse . questions && selectedResponse . questions . length > 0 ) { var feedbackPostBody = '{\"feedbackRecords\": [{\"userId\": \"' + session . message . user . id + '\",\"userQuestion\": \"' + session . privateConversationData . qnaFeedbackUserQuestion + '\",\"kbQuestion\": \"' + selectedResponse . questions [ 0 ] + '\",\"kbAnswer\": \"' + selectedResponse . answer + '\"}]}' ; this . recordQnAFeedback ( feedbackPostBody ) ; } this . defaultWaitNextMessage ( session , { answers : [ selectedResponse ] } ) ;", "del_tokens": "session . privateConversationData . qnaFeedbackUserQuestion = session . message . text ; var feedbackPostBody = '{\"feedbackRecords\": [{\"userId\": \"' + session . message . user . id + '\",\"userQuestion\": \"' + session . privateConversationData . qnaFeedbackUserQuestion + '\",\"kbQuestion\": \"' + selectedResponse . questions [ 0 ] + '\",\"kbAnswer\": \"' + selectedResponse . answer + '\"}]}' ; this . recordQnAFeedback ( feedbackPostBody ) ; session . endDialog ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Moving", "things", "around", "for", "sturdier", "testability"], "add_tokens": "return ( / ^#[0-9a-f]{3}([0-9a-f]{3})?$ / i ) . test ( color ) ; return color . replace ( \")\" , \",1)\" ) . replace ( 'rgb(' , 'rgba(' ) . replace ( / \\s / g , '' ) ; return color . replace ( / \\s / g , '' ) ; return hslaToRgba ( color ) . replace ( / \\s / g , '' ) ; return hexToRgba ( color , 100 ) . replace ( / \\s / g , '' ) ; var normalizeString = function ( value ) { return value . replace ( / \\s / g , '' ) ; } ; toRgba : toRgba , normalizeString : normalizeString } ( ) ) ;", "del_tokens": "return ( / ^#[0-9a-f]{3}([0-9a-f]{3})?$ / ) . test ( color ) ; return color . replace ( \")\" , \", 1)\" ) . replace ( 'rgb(' , 'rgba(' ) ; return color ; return hslaToRgba ( color ) ; return hexToRgba ( color , 100 ) ; toRgba : toRgba } ( ) ) ;", "commit_type": "move"}
{"commit_tokens": ["Removed", "logout", "button", "and", "added", "Change", "Server", "button", "with", "modal", "window"], "add_tokens": "plugins : [ \"themes\" , \"json_data\" , \"types\" , \"ui\" , \"contextmenu\" ] function changeServer ( ) { $ ( '#addServerForm' ) . submit ( ) ; } setupAddKeyButton ( ) ;", "del_tokens": "plugins : [ \"themes\" , \"json_data\" , \"types\" , \"ui\" ] setupAddKeyButton ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Move", "trees", "to", "lib", "/", ";", "index", "to", "bin", "/", ";", "change", "main", "and", "bin", "in", "package", ".", "json"], "add_tokens": "var parseConfig = require ( './config' ) ; var parseVariations = require ( './variations' ) ; var MendelVariationWalker = require ( './tree-variation-walker' ) ; var MendelHashWalker = require ( './tree-hash-walker' ) ;", "del_tokens": "var parseConfig = require ( './lib/config' ) ; var parseVariations = require ( './lib/variations' ) ; var MendelVariationWalker = require ( './lib/tree-variation-walker' ) ; var MendelHashWalker = require ( './lib/tree-hash-walker' ) ;", "commit_type": "move"}
{"commit_tokens": ["Use", "external", "URL", "as", "the", "service", "parameter", "if", "the", "application", "is", "behind", "a", "proxy", "."], "add_tokens": "protocol : req . headers [ 'x-proxied-protocol' ] || req . protocol || 'http' , host : req . headers [ 'x-forwarded-host' ] || req . headers . host || reqURL . host , pathname : req . headers [ 'x-proxied-request-uri' ] || reqURL . pathname , self . error ( err ) ;", "del_tokens": "protocol : req . protocol || 'http' , host : req . headers [ 'host' ] , pathname : reqURL . pathname , self . fail ( err . message ) ;", "commit_type": "use"}
{"commit_tokens": ["Move", "vector", "functions", "into", "the", "nomnoml", "namespace"], "add_tokens": "var vm = nomnoml . vectorMath mouseDownPoint = vm . diff ( { x : e . pageX , y : e . pageY } , offset ) offset = vm . diff ( { x : e . pageX , y : e . pageY } , mouseDownPoint )", "del_tokens": "mouseDownPoint = diff ( { x : e . pageX , y : e . pageY } , offset ) offset = diff ( { x : e . pageX , y : e . pageY } , mouseDownPoint )", "commit_type": "move"}
{"commit_tokens": ["added", "a", "test", "to", "ensure", "compat", "with", "deprecated", "proxy", "argument", "api"], "add_tokens": "ok ( $ ( data ) . length ) asyncTest ( \"Same as previous test, but run with deprecated proxy argument API.\" , 3 , function ( ) { $ ( \"#proxy-d\" ) . live ( \"ajaxInclude\" , function ( e , data ) { ok ( $ ( \"#proxy-c\" ) . children ( ) . length === 1 ) ; ok ( $ ( \"#proxy-d\" ) . children ( ) . length === 1 ) ; ok ( $ ( data ) . filter ( \"entry\" ) . length === 2 ) ; start ( ) ; } ) ; $ ( \"#proxy-c, #proxy-d\" ) . ajaxInclude ( \"functional/quickconcat.php?wrap&files=\" ) ; } ) ;", "del_tokens": "ok ( $ ( data ) . length ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "empty", "window", "object", "when", "creating", "UAParser"], "add_tokens": "//Somehow, the UAParser constructor gets an empty window object. //We need to pass the user agent string in order to get information var ua = ( ( window && window . navigator && window . navigator . userAgent ) ? window . navigator . userAgent : '' ) ; var parser = new UAParser ( ua ) ;", "del_tokens": "var parser = new UAParser ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "failing", "test", "for", "inverse"], "add_tokens": "compilesTo ( '{{#testing}}test{{else}}not shown{{/testing}}' , 'test' ) ;", "del_tokens": "compilesTo ( '{{#testing}}test{{/testing}}' , 'test' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "reading", "only", "specified", "properties", "from", "Resource", "."], "add_tokens": "var query = req . query || { } ; var projection = { } ; if ( query . fields ) { projection . onlyFields = query . fields . split ( ',' ) . map ( function ( field ) { return field . trim ( ) ; } ) ; } var json = res . locals . resource . toJSON ( { projection : projection } ) ;", "del_tokens": "var json = res . locals . resource . toJSON ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "unit", "testing", "for", "the", "utility", "suite"], "add_tokens": "Utils . cleanForExecuting = R . compose ( replace ( / data\\['.*'\\] (===|>|<|>=|<=) ('?(.+)(?='|\\)| &&)) / g , 'true' ) , replace ( / data\\['mapnik::geometry_type'\\] === (\\d) / g , 'true' ) ) ; Utils . cleanForExecuting ,", "del_tokens": "R . compose ( replace ( / data\\['.*'\\] (===|>|<|>=|<=) ('?(.+)(?='|\\)| &&)) / g , 'true' ) , replace ( / data\\['mapnik::geometry_type'\\] === (\\d) / g , 'true' ) ) ,", "commit_type": "add"}
{"commit_tokens": ["allows", "expanding", "hashes", "on", "object", "keys", "not", "just", "the", "value", "of", "name", ".", "adds", "test", "cases"], "add_tokens": "// If dothash:true is still in the options, that means an // object's keys should be expanded, instead of the value // of `name`. if ( 'dothash' in options ) { data = expandHash ( data ) ; delete data . dothash ; } result = expander . process ( obj , obj , options || { } ) ; } ;", "del_tokens": "Object . keys ( obj ) . forEach ( function ( key ) { result [ key ] = expander . process ( obj , obj [ key ] , options || { } ) ; } ) ; } ;", "commit_type": "allow"}
{"commit_tokens": ["Removed", ".", "bind", "usage", "and", "es5", "-", "shim"], "add_tokens": "window . addEventListener ( 'beforeunload' , function ( ) { self . __destroy__ ( ) ; } ) ; window . addEventListener ( 'unload' , function ( ) { self . __destroy__ ( ) ; } ) ; setInterval ( function ( ) { self . __check_master__ ( ) ; } , UPDATE_INTERVAL ) ;", "del_tokens": "window . addEventListener ( 'beforeunload' , this . __destroy__ . bind ( this ) ) ; window . addEventListener ( 'unload' , this . __destroy__ . bind ( this ) ) ; setInterval ( this . __check_master__ . bind ( this ) , UPDATE_INTERVAL ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "unit", "tests", "for", "DataFrame"], "add_tokens": "function FakeKernelExecuteHandle ( execution ) { var msg = execution ? { msg_type : 'execute_result' , content : { data : { \"text/plain\" : \"{}\" } } } : { msg_type : 'status' , content : { execution_state : 'idle' } } ; // TODO: registerTempTable is an exception here, need a better way if ( msg . code . indexOf ( \"var \" ) == 0 || msg . code . indexOf ( \"registerTempTable\" ) >= 0 ) { return new FakeKernelExecuteHandle ( ) ; } else { return new FakeKernelExecuteHandle ( true ) ; }", "del_tokens": "function FakeKernelExecuteHandle ( ) { var msg = { msg_type : 'status' , content : { execution_state : 'idle' } } ; return new FakeKernelExecuteHandle ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "(", "very", "very", "basic", ")", "tunnel", "detection", "to", "Net", "module"], "add_tokens": "detectTunnels : true , // Add `tunneled: 'possible'` to all interfaces if we find a tunnel device if ( _ . get ( self . settings , 'net.detectTunnels' ) ) { var hasTunnel = this . adapters . some ( a => / ^tun / . test ( a . interface ) ) ; this . adapters . forEach ( adapter => adapter . tunneled = hasTunnel ? 'possible' : false ) ; } next ( null , this . adapters ) ;", "del_tokens": "return next ( null , this . adapters ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "wasm", "-", "pack", "compiled", "js"], "add_tokens": "const lTextEncoder = typeof TextEncoder === 'undefined' ? ( 0 , module . require ) ( 'util' ) . TextEncoder : TextEncoder ; let cachedTextEncoder = new lTextEncoder ( 'utf-8' ) ; const lTextDecoder = typeof TextDecoder === 'undefined' ? ( 0 , module . require ) ( 'util' ) . TextDecoder : TextDecoder ; let cachedTextDecoder = new lTextDecoder ( 'utf-8' , { ignoreBOM : true , fatal : true } ) ; wasm . invoke ( 8 , ptr0 , len0 , ptr1 , len1 , ptr2 , len2 , ptr3 , len3 ) ; var r0 = getInt32Memory0 ( wasm ) [ 8 / 4 + 0 ] ; var r1 = getInt32Memory0 ( wasm ) [ 8 / 4 + 1 ] ;", "del_tokens": "let cachedTextEncoder = new TextEncoder ( 'utf-8' ) ; let cachedTextDecoder = new TextDecoder ( 'utf-8' , { ignoreBOM : true , fatal : true } ) ; const retptr = wasm . __wbindgen_export_0 . value - 16 ; wasm . __wbindgen_export_0 . value = retptr ; wasm . invoke ( retptr , ptr0 , len0 , ptr1 , len1 , ptr2 , len2 , ptr3 , len3 ) ; var r0 = getInt32Memory0 ( wasm ) [ retptr / 4 + 0 ] ; var r1 = getInt32Memory0 ( wasm ) [ retptr / 4 + 1 ] ; wasm . __wbindgen_export_0 . value += 16 ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "issue", "where", "default", "and", "rest", "params", "where", "dropped", "on", "the", "floor", "by", "the", "ClassTransformer", "."], "add_tokens": "var createParameterList = ParseTreeFactory . createParameterList ; createParameterList ( set . tree . parameter ) , method . tree . formalParameterList , * @ param { FormalParameterList } formalParameters methodTree . formalParameterList ,", "del_tokens": "var createParameters = ParseTreeFactory . createParameters ; createParameters ( set . tree . parameter ) , createParameters ( method . tree . formalParameterList ) , * @ param { Array . < string > } formalParameters createParameters ( methodTree . formalParameterList ) ,", "commit_type": "fix"}
{"commit_tokens": ["add", "argument", "to", "validator", "validate", "function", "to", "validate", "only", "values", "passed", "in"], "add_tokens": "* @ param { Boolean } presentOnly only validate present values Validator . prototype . validate = function ( values , presentOnly , cb ) { errors = { } , validations = Object . keys ( this . validations ) ; // Handle optional second arg if ( typeof presentOnly === 'function' ) { cb = presentOnly ; presentOnly = false ; } // Use present values only or all validations if ( presentOnly ) { validations = _ . intersection ( validations , Object . keys ( values ) ) ; } async . each ( validations , validate , function ( ) {", "del_tokens": "Validator . prototype . validate = function ( values , cb ) { errors = { } ; async . each ( Object . keys ( this . validations ) , validate , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "sliders", "-", "get", "-", "wider", "bug"], "add_tokens": "else if ( key == 'addxyslider' ) self . addSlider ( { x : self . menux , y : self . menuy , subtype : 'xy' , w : 96 , h : 96 } ) ; else if ( key == 'addhslider' ) self . addSlider ( { x : self . menux , y : self . menuy , subtype : 'x' , w : 192 , h : 72 } ) ; //this.w += this.slidew;", "del_tokens": "else if ( key == 'addxyslider' ) self . addSlider ( { x : self . menux , y : self . menuy , subtype : 'xy' , w : 100 , h : 100 } ) ; else if ( key == 'addhslider' ) self . addSlider ( { x : self . menux , y : self . menuy , subtype : 'x' , w : 200 , h : 80 } ) ; this . w += this . slidew ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "the", "templates", ".", "w"], "add_tokens": "{ type : 'confirm' , name : 'kitchenSink' , message : 'Include the KitchenSink demo?' , default : false } , choices : [ { name : 'ios' , checked : true } , { name : 'android' , checked : true } , this . kitchenSink = props . kitchenSink ; if ( this . useCordova ) { this . copy ( '_cordova.js' , 'app/cordova.js' ) ; }", "del_tokens": "choices : [ { name : 'ios' , checked : true } , { name : 'android' , checked : true } , { name : 'wp7' } ,", "commit_type": "update"}
{"commit_tokens": ["fixed", "context", "and", "SQL", "uprade", "support", "for", "table", "still", "one", "more", "glitch", "to"], "add_tokens": "// - first argument is the object to clone // - second argument can be an object that acts as a filter to skip properties by name, // - _skip_null - to skip all null properties // - _empty_to_null - convert empty strings into null objects // - _skip_cb - a callback that returns true to skip a property, argumnets are property name and value // if the second arg is not an object then it is assumed that filter is not given and the argument is treated as additional property // - all additional arguments are treated as name value pairs and added to the cloned object as additional properties // Example: core.cloneObj({ 1: 2 }, { 1: 1 }, \"3\", 3, \"4\", 4) // core.cloneObj({1 : 2 }, \"3\", 3, \"4\", 4) core . cloneObj = function ( ) { var obj = arguments [ 0 ] ; var filter = { } , idx = 1 ; if ( this . typeName ( arguments [ 1 ] ) == \"object\" ) { idx = 2 ; filter = arguments [ 1 ] ; } for ( var i = idx ; i < arguments . length - 1 ; i += 2 ) rc [ arguments [ i ] ] = arguments [ i + 1 ] ;", "del_tokens": "// - filter is an object to skip properties that defined in it by name, // - _skip_null - to skip all null properties // - _empty_to_null - convert empty strings into null objects // - _skip_cb - a callback that returns true to skip a property, argumnets are property name and value // - props can be used to add additional properties to the new object core . cloneObj = function ( obj , filter , props ) { if ( ! filter ) filter = { } ; for ( var p in props ) rc [ p ] = props [ p ] ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "it", "work", "in", "IE8", "."], "add_tokens": "// This hackery is required for IE8, where `console.log` doesn't have 'apply' window . console && console . log && Function . prototype . apply . call ( console . log , console , arguments ) ;", "del_tokens": "console . log . apply ( console , arguments ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "in", "the", "bean", "definition", "of", "macro", "library", "configuration"], "add_tokens": "} , \"$res\" : { $type : \"json:Map\" , $description : \"Resource class to be accessible through the res variable in the library.\" , $contentType : { $type : \"json:PackageName\" , $description : \"Any resource class that the library is dependent of\" , $sample : \"aria.widgets.WidgetsRes\" } $type : \"coreBeans:Callback\" ,", "del_tokens": "$type : \"json:ObjectRef\" / * * TODO : when it is possible to put $beans in an Aria . classDefinition , * replace with a ref to aria . core . JsObject . Callback * / ,", "commit_type": "add"}
{"commit_tokens": ["Fixed", "some", "bugs", "with", "menus"], "add_tokens": "// Prevent clicking on the container from hiding the menu this . addListener ( this . $container , 'mousedown' , function ( ev ) { ev . stopPropagation ( ) ; } ) ; // Listen for option clicks this . addListener ( this . $options , 'click' , 'selectOption' ) ; this . hide ( ) ;", "del_tokens": "this . addListener ( this . $options , 'mousedown' , 'selectOption' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "the", "logs", "when", "reduce", "()"], "add_tokens": "// console.log(arguments);", "del_tokens": "console . log ( arguments ) ;", "commit_type": "remove"}
{"commit_tokens": ["Changed", "setting", "pixel", "colour", "to", "use", "firmata", "protocol", "not", "string", ".", "Improved", "FPS", "to", "150", "fps", "on", "test", "setup"], "add_tokens": "var fps = 35 ; // how many frames per second do you want to try? var pos2 = 1 ; var pos3 = 2 ; var current_color2 = 1 ; var current_color3 = 2 ; if ( ++ pos2 >= strip . stripLength ( ) ) { pos2 = 0 ; if ( ++ current_color2 >= colors . length ) current_color2 = 0 ; } strip . pixel ( pos2 ) . color ( colors [ current_color2 ] ) ; if ( ++ pos3 >= strip . stripLength ( ) ) { pos3 = 0 ; if ( ++ current_color3 >= colors . length ) current_color3 = 0 ; } strip . pixel ( pos3 ) . color ( colors [ current_color3 ] ) ;", "del_tokens": "var fps = 25 ; // how many frames per second do you want to try?", "commit_type": "change"}
{"commit_tokens": ["Add", "async", "mode", "for", "raw", "()"], "add_tokens": "function raw ( cb ) { return _parseProcMeminfo ( cb ) ; function _parseProcMeminfo ( cb ) { if ( cb ) { return fs . readFile ( '/proc/meminfo' , function ( err , meminfo ) { if ( err ) return cb ( err ) ; return cb ( null , _formatParsedProcMeminfo ( meminfo ) ) ; } ) ; } return _formatParsedProcMeminfo ( meminfo ) ; } function _formatParsedProcMeminfo ( meminfo ) {", "del_tokens": "function raw ( ) { return _parseProcMeminfo ( ) ; function _parseProcMeminfo ( ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "webpack", "config", "for", "demo"], "add_tokens": "entry : { './dist' : './lib/index.js' , './docs' : './demo/index.js' } , path : path . join ( __dirname , './' ) , filename : '[name]/bundle.js'", "del_tokens": "entry : './lib/index.js' , path : path . join ( __dirname , './dist' ) , filename : 'bundle.js'", "commit_type": "add"}
{"commit_tokens": ["use", "indexOf", "rather", "than", "includes", "for", "Node", "4"], "add_tokens": "if ( [ 'imperial' , 'metric' ] . indexOf ( unitSystem ) < 0 ) { if ( [ 'imperial' , 'metric' ] . indexOf ( unitSystem ) < 0 ) {", "del_tokens": "if ( ! ( [ 'imperial' , 'metric' ] . includes ( unitSystem ) ) ) { if ( ! ( [ 'imperial' , 'metric' ] . includes ( unitSystem ) ) ) {", "commit_type": "use"}
{"commit_tokens": ["Fix", "errors", "when", "using", "service", "utility", "functions", "caused", "by", "wrong", "variable", "access", "."], "add_tokens": "return this . _manager . characteristicsForDevice ( this . deviceUUID , this . uuid ) return this . _manager . readCharacteristic ( this . deviceUUID , this . uuid , characteristicUUID , transactionId ) return this . _manager . writeCharacteristicWithResponseForDevice ( this . deviceUUID , this . uuid , characteristicUUID , valueBase64 , transactionId ) return this . _manager . writeCharacteristicWithoutResponseForDevice ( this . deviceUUID , this . uuid , characteristicUUID , valueBase64 , transactionId ) return this . _manager . monitorCharacteristicForDevice ( this . deviceUUID , this . uuid , characteristicUUID , listener , transactionId )", "del_tokens": "return manager . characteristicsForDevice ( this . deviceUUID , this . uuid ) return manager . readCharacteristic ( this . deviceUUID , this . uuid , characteristicUUID , transactionId ) return manager . writeCharacteristicWithResponseForDevice ( this . deviceUUID , this . uuid , characteristicUUID , valueBase64 , transactionId ) return manager . writeCharacteristicWithoutResponseForDevice ( this . deviceUUID , this . uuid , characteristicUUID , valueBase64 , transactionId ) return manager . monitorCharacteristicForDevice ( this . deviceUUID , this . uuid , characteristicUUID , listener , transactionId )", "commit_type": "fix"}
{"commit_tokens": ["updated", "Gruntfile", "in", "grid", "example", "with", "proper", "banner", "and", "templates", "for", "paths"], "add_tokens": "* Assemble Example : Grid * http : //github.com/assemble/assemble * Copyright ( c ) 2013 Assemble * MIT License pkg : grunt . file . readJSON ( 'package.json' ) , helpers : '<%= build.helpers %>' , preprocessors : '<%= build.preprocessors %>' , production : false , flatten : true ,", "del_tokens": "* Gruntfile . js for projects . pkg : grunt . file . readJSON ( 'package.json' ) , helpers : '../../lib/engines/handlebars/helpers/defaultHelpers' , preprocessors : '../../lib/engines/handlebars/preprocessors/handlebarsPreprocessors' , flatten : true , production : false ,", "commit_type": "update"}
{"commit_tokens": ["fix", "url", "generation", "if", "secure", "is", "false", "in", "a", "secure", "page"], "add_tokens": "var prefix = secure ? 'https://' : ( window . location . protocol === 'file:' ? \"file://\" : 'http://' ) ;", "del_tokens": "var prefix = secure ? 'https://' : window . location . protocol + '//' ;", "commit_type": "fix"}
{"commit_tokens": ["change", "default", "view", "doc", ".", "js", "to", "display", "package", "names", "when", "available"], "add_tokens": "doc . addDiv ( content , doc . itemDisplayName ( item ) , 'contentTitle' ) ; doc . itemDisplayName = function ( item ) { return item . package ? item . package . name : item . name ; } ; var a = $ ( '<a href=\"#\">' + doc . itemDisplayName ( item ) + '</a>' ) ;", "del_tokens": "doc . addDiv ( content , item . name , 'contentTitle' ) ; //var a = $('<a href=\"javascript:void(0)\">' + item.name + '</a>'); var a = $ ( '<a href=\"#\">' + item . name + '</a>' ) ;", "commit_type": "change"}
{"commit_tokens": ["Added", "ability", "to", "insert", "middleware", "at", "beginning", "of", "stack"], "add_tokens": "if ( this . _first ) fn . _first = true ; delete this . _first ; if ( handle . _first ) { // remove handle from current position stack . splice ( i , 1 ) ; // insert it at begining of stack stack . unshift ( handle ) ; // remove property so we don't order it again later delete handle . _first ; // for debugging handle [ '_moved_first' ] = true ; // Continue ordering for remaining handles return order_stack ( stack ) ; } else if ( handle . _before || handle . _after ) { / ** * Adds a middleware at the beginning of the stack * / Connectr . prototype . first = function ( ) { this . _first = true ; }", "del_tokens": "if ( handle . _before || handle . _after ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "select", "option", "value", "instead", "of", "label", "+", "val"], "add_tokens": "React . createElement ( ReactSelect , { options : options , value : value , onChange : function ( v ) { return onChange ( v . value ) ; } , onBlur : function ( ) { return onBlur ( value ) ; } , onFocus : onFocus } ) ) ;", "del_tokens": "React . createElement ( ReactSelect , { options : options , value : value , onChange : onChange , onBlur : function ( ) { return onBlur ( value ) ; } , onFocus : onFocus } ) ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "tests", "to", "translate", "function"], "add_tokens": "stop : 3000 P . streamTranslate ( params , function ( data , err ) { console . log ( data ) } ) ;", "del_tokens": "// P.streamTranslate(params, function(data, err){ // console.log(data) // });", "commit_type": "add"}
{"commit_tokens": ["moves", "objectid", "creations", "to", "core"], "add_tokens": "var objectid = require ( '../core/objectid' ) ; model . set ( model . idAttribute , objectid . makeObjectID ( ) ) ;", "del_tokens": "var objectid_1 = require ( './objectid' ) ; model . set ( model . idAttribute , new objectid_1 . ObjectID ( ) . toHexString ( ) ) ;", "commit_type": "move"}
{"commit_tokens": ["allow", "non", "-", "ts", "tests", "to", "be", "written", "in", "harmony"], "add_tokens": "var react = require ( 'react-tools' ) ; // This is gross, but jest doesn't provide an asynchronous way to if ( path . match ( / \\.js$ / ) ) { return react . transform ( src , { harmony : true } ) ; }", "del_tokens": "// This is gross, but jest doesn't provide an asyncronous way to", "commit_type": "allow"}
{"commit_tokens": ["Use", "connect", "-", "flash", "to", "display", "errors", "from", "passport", "."], "add_tokens": "failureRedirect : '/signin' , } ;", "del_tokens": "failureRedirect : '/error' , } ;", "commit_type": "use"}
{"commit_tokens": ["Add", "test", "for", "document", "containing", "just", "the", "trailing", "block"], "add_tokens": "opts . type = opts . type || 'paragraph' ;", "del_tokens": "opts . type = opts . type || 'paragraph' ;", "commit_type": "add"}
{"commit_tokens": ["Improve", "performance", "of", ".", "reduce", "when", "initialValue", "is", "not", "a", "promise"], "add_tokens": "function unpackReducer ( fulfilleds ) { var fn = this . fn ; var initialValue = this . initialValue ; return reducer . call ( fn , fulfilleds , initialValue ) ; function slowReduce ( promises , fn , initialValue ) { return initialValue . then ( function ( initialValue ) { return Promise . reduce ( promises , fn , initialValue ) ; } ) ; } if ( isPromise ( initialValue ) ) { return slowReduce ( promises , fn , initialValue ) ; } return Promise . all ( promises ) . _then ( unpackReducer , void 0 , void 0 , { fn : fn , initialValue : initialValue } , void 0 , Promise . all ) ;", "del_tokens": "function slowReduce ( promises , fn , initialValue ) { return Promise . _all ( promises , PromiseArray , slowReduce ) . promise ( ) . then ( function ( fulfilleds ) { return reducer . call ( fn , fulfilleds , initialValue ) ; } ) ; return slowReduce ( promises , fn , initialValue ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fixed", "all", "examples", "to", "use", "mumble", "of", "parent", "folder", "and", "use", "MUMBLE_URL", "instead", "of", "example", ".", "org"], "add_tokens": "var mumble = require ( '../' ) ; mumble . connect ( process . env . MUMBLE_URL , options , function ( error , connection ) {", "del_tokens": "var mumble = require ( 'mumble' ) ; mumble . connect ( 'mumble://example.org' , options , function ( error , connection ) {", "commit_type": "fix"}
{"commit_tokens": ["Adding", "proper", "contruct", "of", "Middleware", "Provider", "for", "better", "type", "checking"], "add_tokens": "console . error ( error ) ;", "del_tokens": "console . error ( \"===> error\" , error ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "tokens", "from", "the", "grammar", "in", "favor", "of", "optimising", "during", "compilation", "."], "add_tokens": "function hasRest ( node ) { for ( var i = 0 , child ; ( child = node . children [ i ] ) ; i ++ ) { if ( child . type === \"rest\" || child . type === \"restIdentifier\" ) return true ; } return false ; } return hasRest ( node ) ? compileArrayRest ( argName , node ) : compileArrayStrict ( argName , node ) ; } function compileArrayStrict ( argName , node ) { return hasRest ( node ) ? compileObjectRest ( argName , node ) : compileObjectStrict ( argName , node ) ; } function compileObjectStrict ( argName , node ) {", "del_tokens": "\"arrayRest\" : compileArrayRest , \"objectRest\" : compileObjectRest ,", "commit_type": "remove"}
{"commit_tokens": ["fix", "string", "id", "bug", "converting", "to", "integer"], "add_tokens": "* Export lib / gstore - node", "del_tokens": "* Export lib / datastools", "commit_type": "fix"}
{"commit_tokens": ["Add", "chord", "config", ":", "clockWise", "startAngle"], "add_tokens": "innerRadius : 140 , outerRadius : 160 , startAngle : 90 , clockWise : false ,", "del_tokens": "innerRadius : 160 , outerRadius : 180 ,", "commit_type": "add"}
{"commit_tokens": ["Updated", "url", "-", "regex", "to", "accomodate", "space", "delimited", "list", "of", "URLs"], "add_tokens": "return ` ${ url } ${ windowTarget } ${ sharedAttributes } ${ displayText } ` ;", "del_tokens": "return ` ${ url } ${ windowTarget } ${ sharedAttributes } ${ displayText } ` ;", "commit_type": "update"}
{"commit_tokens": ["added", "error", "if", "command", "does", "not", "exist"], "add_tokens": "if ( ! self . emit ( command . join ( ' ' ) , data ) ) { console . error ( 'command %s does not exist' , command . join ( ' ' ) . bold ) ; self . emit ( 'help' ) ; }", "del_tokens": "self . emit ( command . join ( ' ' ) , data ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "empty", "conjunctions", "in", "scopesets"], "add_tokens": "test ( \"empty conjunction in scopesets\" , mktest ( [ \"foo:bar\" ] , [ [ ] ] , true ) ) ;", "del_tokens": "test ( \"empty conjunction in scopesets\" , mktest ( [ \"foo:bar\" ] , [ [ ] ] , 'exception' ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["Made", "comments", "work", "without", "a", "space"], "add_tokens": "version : '0.1.11' , if ( tag . indexOf ( '//' ) === 0 ) { tag = '//' ;", "del_tokens": "version : '0.1.10' , if ( tag == '//' ) {", "commit_type": "make"}
{"commit_tokens": ["Fix", "not", "return", "from", "catch", "and", "cleanup", "one", "branch", "in", "compiler"], "add_tokens": "var params = v [ 1 ] ;", "del_tokens": "var params = v [ 1 ] || null ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "write", "function", "cope", "with", "more", "value", "input", "types"], "add_tokens": "value = ( ! ! value && value !== '0' ) ? '1' : '0' ;", "del_tokens": "value = ( ! ! value ) ? '1' : '0' ;", "commit_type": "make"}
{"commit_tokens": ["make", "it", "work", "under", "linux", "again"], "add_tokens": "if ( process . platform !== 'win32' || process . argv [ 1 ] . startsWith ( Path . resolve ( '/snapshot/' ) ) ) { // in pkg packed apps and linux the console writes directly to fd 1 and 2 (or the original stdout/stderr)", "del_tokens": "if ( process . argv [ 1 ] . startsWith ( Path . resolve ( '/snapshot/' ) ) ) { // for some weird reason, in pkg packed apps, the console writes directly to fd 1 and 2", "commit_type": "make"}
{"commit_tokens": ["Use", "npm", "Registry", "Filter", "Header"], "add_tokens": "expect ( call ) . toMatchSnapshot ( ) ; expect ( call ) . toMatchSnapshot ( ) ;", "del_tokens": "expect ( call ) . toMatchObject ( [ 'https://npm.mycustomregistry.com/foobar' , { json : true , headers : { } } , ] ) ; expect ( call ) . toMatchObject ( [ 'https://npm.mycustomregistry.com/foobar' , { json : true , headers : { authorization : 'Basic 1234' , } , } , ] ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "some", "basic", "tests", "to", "improve", "coverage"], "add_tokens": "try { eval ( htmlString ) ; } catch ( e ) { return [ ] ; }", "del_tokens": "eval ( parsedTrends ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "globalTrafficGraph", "orbit", "size", "be", "a", "function", "of", "the", "graphWidth", "and", "graphHeight", "instead", "of", "a", "constant"], "add_tokens": "function updatePosition ( node , nodeCount , nodeIndex , orbitSize ) { function positionNodes ( nodes , orbitSize ) { updatePosition ( node , nodeCount , nodeIndex , orbitSize ) ; this . orbitSize = Math . min ( graphWidth , graphHeight ) ; positionNodes ( this . state . nodes , this . orbitSize ) ;", "del_tokens": "const orbitSize = 1100 ; function updatePosition ( node , nodeCount , nodeIndex ) { function positionNodes ( nodes ) { updatePosition ( node , nodeCount , nodeIndex ) ; positionNodes ( this . state . nodes ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "_", ".", "str", "dependency", "error"], "add_tokens": "var parts = criteria . sort . split ( ' ' ) ;", "del_tokens": "var parts = _ . str . words ( criteria . sort ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implement", "the", "github", "pages", "deployment", "service", "."], "add_tokens": "const ACCEPTED_COMMANDS = [ 'version' , 'include' , 'render' , 'init' , 'build' , 'serve' , 'deploy' ] ; program . command ( 'deploy' ) . description ( 'deploy the site to the repo\\'s Github pages.' ) . action ( ( option ) => { const rootFolder = path . resolve ( process . cwd ( ) ) ; const outputRoot = path . join ( rootFolder , '_site' ) ; new Site ( rootFolder , outputRoot ) . deploy ( ) . then ( ( success ) => { logger . info ( 'Deployed!' ) } ) . catch ( ( err ) => { logger . error ( err . message ) ; } ) ; logger . logo ( ) ; } ) ;", "del_tokens": "const ACCEPTED_COMMANDS = [ 'version' , 'include' , 'render' , 'init' , 'build' , 'serve' ] ;", "commit_type": "implement"}
{"commit_tokens": ["added", "fertilise", "and", "fixed", "bug", "for", "setOnBlock"], "add_tokens": "myTerminal . nu = \"esto es UPDATED\" ; audrey . updateAll ( myTerminal ) ; audrey . fertilise ( \"??nuevico\" , \"infooOooo\" , \"green\" , \"footer\" ) ; var obj = { name : \">>otro nuevo\" , value : \"aaaagh\" , color : 'blue' } ; audrey . fertilize ( obj , \"body\" ) ;", "del_tokens": "myTerminal . nu = \"esto es nu\" ; audrey . update ( myTerminal ) ; console . log ( myTerminal ) ; audrey . fertilize ( { name : \">>otro nuevo\" , value : \"aaaagh\" , color : 'blue' } , \"body\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "up", "nearly", "all", "functions"], "add_tokens": "return JSON . stringify ( data , null , 2 ) ; var dat = encodeURIComponent ( this . body ) . trim ( ) ; data += 'Content-Length: ' + dat . length + '\\n\\n' ; data += dat ; } return data . trim ( ) ; data += '</event>' ;", "del_tokens": "return JSON . stringify ( data ) ; data += 'Content-Length: ' + this . body . length + '\\n\\n' ; data += encodeURIComponent ( this . body ) ; } data += '\\n' ; return data ; data += '</event>\\n' ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "alert", "-", "dismissable", "class", "and", "fix", "typo"], "add_tokens": "'<div class=\"alert alert-danger avatar-alert alert-dismissable\">' ,", "del_tokens": "'<div class=\"alert alert-danger avater-alert\">' ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "this", "binding", "error", "in", "bailout", "."], "add_tokens": "if ( process . stdout . write ( message ) ) bailout . call ( this ) ; else process . stdout . once ( \"drain\" , bailout . bind ( this ) ) ; function exit ( ) { process . exit ( 1 ) }", "del_tokens": "if ( process . stdout . write ( message ) ) bailout ( ) else process . stdout . once ( \"drain\" , bailout . bind ( this ) ) function exit ( ) { process . exit ( 1 ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Removed", "setPrototypeOf", "solved", "bugs", "when", "multi", "router", "layer", "solved", "koa", "compose", "version", "bug"], "add_tokens": "Object . assign ( router , proto ) ; proto . routes = function routes ( ) { return this ; } ;", "del_tokens": "Reflect . setPrototypeOf ( router , proto ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "withCredentials", "and", "responseType", "headers"], "add_tokens": "path : httpPath , withCredentials : false method : ( this . _writeOffset === 0 ? 'GET' : 'POST' ) , responseType : 'arraybuffer'", "del_tokens": "path : httpPath method : ( this . _writeOffset === 0 ? 'GET' : 'POST' )", "commit_type": "add"}
{"commit_tokens": ["Improve", "block", "quote", "conversion", "test", "coverage"], "add_tokens": "var deepest = / <blockquote\\b[^>]*>((?:(?!<blockquote)[\\s\\S])*?)<\\/blockquote> / gi ; while ( string . match ( deepest ) ) { string = string . replace ( deepest , function ( str ) { return replaceBlockquotes ( str ) ; } ) ; } function replaceBlockquotes ( html ) { html = html . replace ( / <blockquote\\b[^>]*>([\\s\\S]*?)<\\/blockquote> / gi , function ( str , inner ) { inner = inner . replace ( / ^\\s+|\\s+$ / g , '' ) ; inner = cleanUp ( inner ) ; inner = inner . replace ( / ^ / gm , '> ' ) ; inner = inner . replace ( / ^(>([ \\t]{2,}>)+) / gm , '> >' ) ; return inner ; } ) ; return html ; }", "del_tokens": "string = string . replace ( / <blockquote\\b[^>]*>((?:(?!<blockquotel)[\\s\\S])*?)<\\/blockquote> / gi , function ( str , inner ) { inner = inner . replace ( / ^\\s+|\\s+$ / g , '' ) ; inner = cleanUp ( inner ) ; return inner . replace ( / ^ / gm , '> ' ) ; } ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "issue", "with", "replacing", "/", "with", ".", "in", "partial", "names", "."], "add_tokens": "name = name . replace ( '/' , '.' ) ;", "del_tokens": "name . replace ( '/' , '.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "div", "and", "added", "test", "cases"], "add_tokens": "( x1 * w2 - w1 * x2 - y1 * z2 + z1 * y2 ) * normSq , ( y1 * w2 - w1 * y2 - z1 * x2 + x1 * z2 ) * normSq , ( z1 * w2 - w1 * z2 - x1 * y2 + y1 * x2 ) * normSq ) ;", "del_tokens": "( x1 * w2 - w1 * x2 + y1 * z2 - z1 * y2 ) * normSq , ( y1 * w2 - w1 * y2 + z1 * x2 - x1 * z2 ) * normSq , ( z1 * w2 - w1 * z2 + x1 * y2 - y1 * x2 ) * normSq ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "own", "ship", "AIS", "signals"], "add_tokens": "// AIVDM for standard messages, AIVDO for messages from own ship AIS if ( nmea [ 0 ] !== '!AIVDM' || nmea [ 0 ] !== '!AIVDO' ) return ;", "del_tokens": "if ( nmea [ 0 ] !== '!AIVDM' ) return ;", "commit_type": "allow"}
{"commit_tokens": ["Fixed", "the", "create", "-", "project", "command"], "add_tokens": "* of the tartempion module . * * The only thing to dynamically create is the package . json file . console . log ( '\\nCreating the package.json file...' ) ; // Open the package.json file and fill it in // with the correct datas. var packagePath = path . join ( current , project , 'package.json' ) ; // First, get the datas var pack = JSON . parse ( fs . readFileSync ( packagePath ) ) ; // Add the properties in the object pack . name = project ; pack . version = '0.0.1' ; pack . dependencies = { 'tartempion' : '0.0.x' } ; // And write the object to the package.json file // by overriding everything in it. fs . writeFileSync ( packagePath , JSON . stringify ( pack , null , 4 ) ) ;", "del_tokens": "* of the tartempion module . The only thing to dynamically create * is the package . json file .", "commit_type": "fix"}
{"commit_tokens": ["added", "support", "for", "swapping", "texture", "spherical", "images", "(", "cubical", "projection", "not", "yet", "supported", ")"], "add_tokens": "map : this . loadImages ( this . config . sphere ) , console . log ( \"loader_onDone\" ) ; /*-------------------------------------------------------------------------*/ / ** * Fetches the images from server and assignes them to a texture * * @ param { Array } images array containg image URLs * @ return { Texture } Three . js texture on which the images will be painted * / proto . loadImages = function ( images ) { if ( ! this . imgLoader ) { this . imgLoader = new ProgressiveImgLoader ( ) ; this . loader_onDone = this . loader_onDone . bind ( this ) ; this . imgLoader . addEventListener ( 'done' , this . loader_onDone ) ; } this . showLoader ( ) ; return ( this . imgLoader . load ( images ) ) ; } ; // proto.loadImages = function(images) {...}", "del_tokens": "this . imgLoader = new ProgressiveImgLoader ( ) ; this . loader_onDone = this . loader_onDone . bind ( this ) ; this . imgLoader . addEventListener ( 'done' , this . loader_onDone ) ; map : this . imgLoader . load ( this . config . sphere ) , this . showLoader ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "last", "const", "from", "NesNes"], "add_tokens": "var cpu = this . cpu , ppu = this . ppu , apu = this . apu ;", "del_tokens": "const cpu = this . cpu , ppu = this . ppu , apu = this . apu ;", "commit_type": "remove"}
{"commit_tokens": ["added", "support", "for", "_return", "_throw", "and", "endExpression", "API", "calls", "in", "analysis", ".", "js", "."], "add_tokens": "\"instrumentCodePre\" , \"instrumentCode\" , \"_return\" , \"_throw\" , \"endExpression\" , \"endExecution\" ] ; this . globals = { } ;", "del_tokens": "\"instrumentCodePre\" , \"instrumentCode\" , \"endExecution\" ] ;", "commit_type": "add"}
{"commit_tokens": ["use", "only", "one", "physical", "connection"], "add_tokens": "// Max connections per shard (max concurrent transactions per shard) var DEFAULT_MAX_CONNECTION = 32 ; var DEFAULT_MAX_PENDING_TASK = 2048 ;", "del_tokens": "// Max connections per shard var DEFAULT_MAX_CONNECTION = 64 ; var DEFAULT_MAX_PENDING_TASK = 1024 ;", "commit_type": "use"}
{"commit_tokens": ["FIXED", "don", "t", "process", "responses", "to", "aborted", "XHR", "requests"], "add_tokens": "await browser . visit ( '/window/alert' ) ;", "del_tokens": "browser . visit ( '/window/alert' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "support", "for", "sparse", "bundles"], "add_tokens": "[ 's' , 'sparse' , 'Create a sparse bundle rather than a solid one' ] , console . error ( \"You need to specify an output file (ex. -o bundle)\" ) ; // Check for base dir var baseDir = path . dirname ( bundlePath ) ; if ( opt . options [ 'basedir' ] !== undefined ) { baseDir = opt . options [ 'basedir' ] ; if ( bundlePath . substr ( 0 , 1 ) != \"/\" ) bundlePath = baseDir + '/' + bundlePath ; } 'sparse' : opt . options [ 'sparse' ] || false", "del_tokens": "console . error ( \"You need to specify an output file (ex. -o bundle.jbb)\" ) ; // Check for base dir var baseDir = \".\" ; if ( opt . options [ 'basedir' ] !== undefined ) baseDir = opt . options [ 'basedir' ] ; if ( bundlePath . substr ( 0 , 1 ) != \"/\" ) bundlePath = baseDir + '/' + bundlePath ;", "commit_type": "add"}
{"commit_tokens": ["add", "a", "new", "line", "sign", "to", "the", "file", "appender", "message", "."], "add_tokens": "message , '\\n'", "del_tokens": "message", "commit_type": "add"}
{"commit_tokens": ["Changed", "track24", "to", "always", "update", "the", "info"], "add_tokens": "lng : 'en' , type : 'update'", "del_tokens": "lng : 'en'", "commit_type": "change"}
{"commit_tokens": ["Use", "a", "retry", "decider", "function", "rather", "than", "a", "number", "of", "retries"], "add_tokens": "let retryDecider = ( ) => false // Set a custom decider function that decides to retry // based on the number of tries and the previous error function retry ( decider ) { retryDecider = decider while ( tries === 0 || retryDecider ( tries , err ) ) { tries += 1 module . exports = { retry , single , many }", "del_tokens": "let maxTries = 3 // Set the maximum number of retries (default: 2) function retries ( tries ) { maxTries = tries + 1 while ( tries < maxTries ) { tries += 1 module . exports = { retries , single , many }", "commit_type": "use"}
{"commit_tokens": ["Updated", ".", "style", "()", "to", "allow", "getting", "style", "information"], "add_tokens": "var style = window . getComputedStyle ( element ) ; var style = window . getComputedStyle ( element ) ;", "del_tokens": "var style = element . currentStyle || window . getComputedStyle ( element ) ; var style = element . currentStyle || window . getComputedStyle ( element ) ;", "commit_type": "update"}
{"commit_tokens": ["using", "memwatch", "to", "monitor", "heap", "usage"], "add_tokens": "var memwatch = require ( 'memwatch' ) ; memwatch . on ( 'leak' , function ( info ) { console . log ( info ) ; } ) ; memwatch . on ( 'stats' , function ( stats ) { process . stdout . write ( '#' ) ; } ) ; var hd = new memwatch . HeapDiff ( ) ; var diff = hd . end ( ) ; console . log ( JSON . stringify ( diff , null , 4 ) ) ; var options = { recurse : false , preview : true } ;", "del_tokens": "var options = { recurse : true , preview : true } ;", "commit_type": "use"}
{"commit_tokens": ["Add", "support", "for", "new", "share", "dialog"], "add_tokens": "let hiddenServices = params . hiddenServices if ( hiddenServices . length === 10 ) hiddenServices = '' return ` ${ url } ${ title } ${ text } ${ hiddenServices } `", "del_tokens": "return ` ${ url } ${ title } ${ text } `", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "to", "properly", "handle", "trimming", "of", "header", "values"], "add_tokens": "parts . push ( headers [ key ] [ 0 ] . toLowerCase ( ) + ':' + this . canonicalHeaderValues ( headers [ key ] [ 1 ] . toString ( ) ) ) ; return parts . join ( \"\\n\" ) ; return values . replace ( / \\s+ / g , ' ' ) . replace ( / ^\\s+|\\s+$ / g , '' ) ;", "del_tokens": "parts . push ( headers [ key ] [ 0 ] . toLowerCase ( ) + ':' + this . canonicalHeaderValues ( headers [ key ] [ 1 ] ) ) ; return parts . join ( \"\\n\" ) . replace ( / [ \\t]+ / g , ' ' ) . replace ( / ^[ \\t]+|[ \\t]+$ / g , '' ) ; return values ;", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "jwt", "flag", "for", "loginsuccess", "to", "return", "the", "token", "without", "the", "need", "of", "a", "redirect", "."], "add_tokens": "var token = waterlock . _utils . createJwt ( req , res ) ;", "del_tokens": "var moment = require ( 'moment' ) ; var uuid = require ( 'node-uuid' ) ; var jwt = require ( 'jwt-simple' ) ; var jsonWebTokens = waterlock . config . jsonWebTokens || { } ; var expiryUnit = ( jsonWebTokens . expiry && jsonWebTokens . expiry . unit ) || 'days' ; var expiryLength = ( jsonWebTokens . expiry && jsonWebTokens . expiry . length ) || 7 ; var expires = moment ( ) . add ( expiryLength , expiryUnit ) . valueOf ( ) ; var issued = Date . now ( ) ; var user = req . session . user ; var token = jwt . encode ( { iss : user . id + '|' + req . remoteAddress , sub : jsonWebTokens . subject , aud : jsonWebTokens . audience , exp : expires , nbf : issued , iat : issued , jti : uuid . v1 ( ) } , jsonWebTokens . secret ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "items", "to", "the", "list", "component", "after", "they", "are", "put", "into", "the", "DOM", "such", "that", "the", "itemFocus", "finds", "the", "dom", "correctly", "when", "positioning", "itself"], "add_tokens": "this . _listComponent . addItem ( item ) ;", "del_tokens": "this . _listComponent . addItem ( item ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "bower", "to", "load", "external", "dependencies"], "add_tokens": "bower = require ( 'gulp-bower' ) , mainBowerFiles = require ( 'main-bower-files' ) , gulp . task ( 'js:vendor' , [ 'bower' ] , function ( ) { return gulp . src ( [ 'lib/app/js/vendor/**/*.js' ] . concat ( mainBowerFiles ( { filter : / \\.js / } ) ) ) gulp . task ( 'bower' , function ( ) { return bower ( ) ; } ) ;", "del_tokens": "gulp . task ( 'js:vendor' , function ( ) { return gulp . src ( 'lib/app/js/vendor/**/*.js' )", "commit_type": "use"}
{"commit_tokens": ["Upgrade", "to", "express", "3", ".", "x", "and", "enable", "compression"], "add_tokens": "CassandraRevisionStore = require ( './CassandraRevisionStore' ) ; var app = express ( ) ; app . use ( express . compress ( ) ) ; app . use ( express . urlencoded ( { limit : 25 * 1024 * 1024 } ) ) ; app . disable ( 'x-powered-by' ) ; res . writeHead ( 200 , { 'Content-type' : 'text/plain' } ) ;", "del_tokens": "CassandraRevisionStore = require ( './CassandraRevisionStore' ) , uuid = require ( 'node-uuid' ) ; var app = express . createServer ( ) ; app . use ( express . bodyParser ( { maxFieldsSize : 25 * 1024 * 1024 } ) ) ; app . use ( express . limit ( '25mb' ) ) ;", "commit_type": "upgrade"}
{"commit_tokens": ["Updated", "documentation", "on", "WebSocketSyncServer", ".", "js"], "add_tokens": "Functional WebSocket server that can be used as a template for how to implement a sync server that interchange changes between a Dexie . Syncable client and a database of any kind . The code is only dependant on nodejs - websocket . For simplicity reasons , it uses a non - persistent RAM database . It handles conflicts according to the Dexie . Syncable specification ; The rules of thumb for conflict handling is that : In this code , the resolveConflicts ( ) function handles changes on the server AS IF the server changes where applied after client changes .", "del_tokens": "A template for how to implement a sync server that interchange changes between a Dexie . Syncable client and a database of any kind . This code is an independant functional example but it uses a non - persistent RAM database for simplicity reasons . It handles conflicts according to the Dexie . Syncable specification . The rules of thumb for conflict handling is that The resolveConflicts ( ) function handles changes on the server AS IF the server changes where applied after client changes . This code may be used as a template for implementing your own sync with the database of your preference .", "commit_type": "update"}
{"commit_tokens": ["removed", "before", "in", "test", "and", "addedd", "compiling", "and", "starting", "as", "seperate", "tests"], "add_tokens": "describe ( 'Java Server' , function ( ) { it ( 'shoudl compile' , function ( done ) { runner . recompile ( function ( compiled ) { expect ( compiled ) . to . be . true ; done ( ) ; } ) ; } ) ; it ( 'should start server' , function ( done ) { runner . runServer ( 3678 , function ( p ) { expect ( p ) . to . equal ( 3678 ) ; } , i * 100 ) ;", "del_tokens": "before ( function ( done ) { runner . recompile ( function ( compiled ) { expect ( compiled ) . to . be . true ; runner . runServer ( function ( p ) { } ) ; describe ( 'Java Server' , function ( ) { i -- ; } , i * 100 ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "support", "for", "script", "data", "attrs"], "add_tokens": "function getDataAttribs ( attrs ) { var matches , reg = / (data-[\\a-z-]+=\"[\\w-]+\") / gm , dataAttribs = [ ] ; matches = attrs . match ( reg ) ; if ( matches && matches . length ) { dataAttribs . push . apply ( dataAttribs , matches ) ; } return matches ; } } ) . replace ( / <script.+?src=[\"']([^\"']+?)[\"'](.*?)>\\s*<\\/script> / g , function ( matchedWord , src , attrs ) { var ret = matchedWord , dataAttribs = getDataAttribs ( attrs ) ; ret = '<script ' + inlineTagAttributes + ' ' + dataAttribs . join ( ' ' ) + ' >\\n' + c + '\\n</script>' ;", "del_tokens": "} ) . replace ( / <script.+?src=[\"']([^\"']+?)[\"'].*?>\\s*<\\/script> / g , function ( matchedWord , src ) { var ret = matchedWord ; ret = '<script ' + inlineTagAttributes + '>\\n' + c + '\\n</script>' ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "dependency", "on", "pandoc", "-", "bin", "and", "clean", "up", "of", "postinstall", "check"], "add_tokens": "} ) ;", "del_tokens": "} ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "gulpfile", ".", "js", "tagging", "code"], "add_tokens": ". pipe ( tagVersion ( { prefix : '' } ) ) ;", "del_tokens": ". pipe ( tagVersion ( ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "missing", "depsolver", ".", "js"], "add_tokens": "const depSolver = require ( './depsolver' ) ;", "del_tokens": "const depSolver = require ( './depsolver' )", "commit_type": "add"}
{"commit_tokens": ["Add", "ability", "to", "parametrize", "symbol", "id", "pattern"], "add_tokens": "var defaultConfig = require ( './config' ) ; /** @type {SVGSpriteLoaderConfig} */ // Calculate sprite symbol id var id = loaderUtils . interpolateName ( this , config . name , { context : this . options . context , content : content } ) ; if ( config . name . indexOf ( '[pathhash]' ) !== - 1 ) id = utils . generateHashFromPath ( resourcePath ) ; if ( config . prefixize ) procs . prefixize ( doc , id + '_' ) ; // Check raster image pixel ratio from file name (e.g. image@2x.png)", "del_tokens": "/ ** * Default loader config * * @ typedef { { name : String , svgo : Boolean | SVGOConfig , spriteModule : String , * } } loaderConfig * / var defaultConfig = { // Sprite image naming pattern. Supported patterns: `[name]`, `[pathhash]`. name : '[name]' , // Use SVGO for optimization. Boolean or SVGO config supported. // See https://github.com/svg/svgo/blob/master/docs/how-it-works/en.md#1-config. svgo : true , // Sprite module name. You can define your own sprite module (based on `./lib/web/sprite` or not). spriteModule : path . resolve ( __dirname , 'lib/web/global-sprite' ) } ; /** @type {loaderConfig} */ var id = utils . generateIdFromFilepath ( resourcePath , config . name ) ; procs . prefixize ( doc , id + '_' ) ; // Check raster image pixel ratio based on file name (e.g. image@2x.png)", "commit_type": "add"}
{"commit_tokens": ["Adds", "specific", "onMouseOverIcon", "/", "onMouseOutIcon", "props", "to", "IconWithTooltip"], "add_tokens": "import SimpleComponentDriver from '../Testing/CommonDrivers/simpleComponentDriver' ; super ( wrapper , ` ${ wrapper . prop ( 'cssMap' ) . default } ` ) ; this . tooltip = wrapper . find ( 'IconWithTooltip > Tooltip' ) . first ( ) ; return this . tooltip . driver ( ) . getMessage ( ) ;", "del_tokens": "// eslint-disable-next-line max-len import SimpleComponentDriver from '../Testing/CommonDrivers/simpleComponentDriver' ; super ( wrapper , 'IconWithTooltip > Tooltip' ) ; return this . control . driver ( ) . getMessage ( ) ; } mouseOver ( ) { this . control . driver ( ) . mouseOver ( ) ; return this ; } mouseOut ( ) { this . control . driver ( ) . mouseOut ( ) ; return this ;", "commit_type": "add"}
{"commit_tokens": ["Added", "Windows", "autoconnect", "logic", ".", "Function", "expects", "callback", "."], "add_tokens": "exports . auto_connect = function ( callback ) { cmd . on ( 'exit' , function ( ) { // console.log(output); callback ( ) ;", "del_tokens": "exports . auto_connect = function ( ) { cmd . on ( 'return' , function ( output ) { console . log ( output ) ;", "commit_type": "add"}
{"commit_tokens": ["removed", "indentation", "for", "last", "wrap"], "add_tokens": "} ) ( ) ) . join ( ';\\n' ) ) + \";\\n\" + contents + \"\\n}).call(this);\" ;", "del_tokens": "} ) ( ) ) . join ( ';\\n' ) ) + \";\\n\" + ( contents . replace ( file . JSFile . prototype . RE_LINE_BEGIN , ' ' ) ) + \"\\n}).call(this);\" ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "a", "test", "for", "Jasmine", "adaptor"], "add_tokens": "test ( 'jasmine - phantom' , function ( done ) { ui : 'jasmine' , prj_dir : __dirname + '/jasmine' , files : [ __dirname + '/jasmine/test.js' ] test ( 'mocha-qunit - phantom' , function ( ) { var config = { ui : 'mocha-qunit' , prj_dir : __dirname + '/mocha-qunit' , phantom : true , concurrency : 1 , files : [ __dirname + '/mocha-qunit/test.js' ] } ; var zuul = Zuul ( config ) ; zuul . on ( 'browser' , function ( browser ) { browser . on ( 'done' , function ( results ) { assert . equal ( results . passed , 1 ) ; assert . equal ( results . failed , 1 ) ; } ) ; } ) ; zuul . run ( function ( passed ) { assert . ok ( ! passed ) ; } ) ; } ) ;", "del_tokens": "test ( 'mocha-qunit - phantom' , function ( done ) { ui : 'mocha-qunit' , prj_dir : __dirname + '/mocha-qunit' , files : [ __dirname + '/mocha-qunit/test.js' ]", "commit_type": "add"}
{"commit_tokens": ["fixed", "afterScroll", "callback", "function", "and", "using", "$", ".", "smoothScroll", "()", "--", "as", "opposed", "to", "$", "(", "selector", ")", ".", "smoothScroll", "()", "--", "with", "options", "and", "px", "."], "add_tokens": "opts . link = link ; scrollTargetOffset = px || $ ( opts . scrollTarget ) . offset ( ) . top ; opts = $ . extend ( { link : null } , opts ) ; easing : opts . easing , complete : function ( ) { if ( opts . afterScroll && $ . isFunction ( opts . afterScroll ) ) { opts . afterScroll . call ( opts . link , opts ) ; } }", "del_tokens": "scrollTargetOffset = $ ( opts . scrollTarget ) . offset ( ) . top ; easing : opts . easing } , function ( ) { opts . afterScroll . call ( link ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "logging", "function", "pr", "s", "line", "number", "reporting"], "add_tokens": "this . dispatch = function dispatch ( req , res , route , dispatchController ) { } ; this . parse = function parse ( req , res , route , next ) { if ( typeof this . cache [ req . url ] === 'undefined' ) { } ;", "del_tokens": "this . dispatch = function dispatch ( req , res , route , dispatchController ) { } this . parse = function parse ( req , res , route , next ) { if ( typeof this . cache [ req . url ] == 'undefined' ) { }", "commit_type": "fix"}
{"commit_tokens": ["added", "test", "and", "realized", "--", "source", "-", "map", "is", "not", "boolean"], "add_tokens": "describe : 'Emit source map'", "del_tokens": "describe : 'Emit source map' , type : 'boolean'", "commit_type": "add"}
{"commit_tokens": ["Move", "InvalidValueError", "into", "validate", "module", "and", "mv", "utils", "-", ">", "convert"], "add_tokens": "function InvalidValueError ( message ) { this . name = 'InvalidValueError' ; this . message = message ; this . stack = ( new Error ) . stack ; } InvalidValueError . prototype = Object . create ( Error . prototype ) ; InvalidValueError . prototype . constructor = InvalidValueError ; InvalidValueError . prepend = function ( message , error ) { if ( error instanceof InvalidValueError ) { error . message = message + ': ' + error . message ; } return error ; } ; Validate . InvalidValueError = InvalidValueError ;", "del_tokens": "var InvalidValueError = require ( './invalid-value-error' ) ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "an", "issue", "with", "the", "default", "provider", "path"], "add_tokens": "var providerPath = __dirname + \"/\" + ( configuration . providersPath || \"provider\" ) + \"/\" + config . type", "del_tokens": "var providerPath = __dirname + \"/\" + ( configuration . providersPath || \".\" ) + \"/\" + config . type", "commit_type": "fix"}
{"commit_tokens": ["Add", "demo", "case", "3", "that", "shows", "regexp", "matching"], "add_tokens": "Case 6. It is suposed that this will come before ( \\\\ d + )", "del_tokens": "Case 6. It ' \\\\", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "second", "test", "for", "case", "3"], "add_tokens": "_hash = _hash . split ( matcher ) [ 1 ] ; if ( _hash . length > 0 ) { matchHash ( container , _hash ) ; }", "del_tokens": "matchHash ( container , _hash . split ( matcher ) [ 1 ] ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "method", "to", "activate", "spectate", "mode"], "add_tokens": "'17' : function ( ) { //i don't know what this is, it keeps showing up in \"spectate\" mode } , //i dont know what this is //activate spectate mode spectate : function ( ) { var buf = new Buffer ( [ 1 ] ) ; buf . writeUInt8 ( 1 , 0 ) ; this . send ( buf ) ; } ,", "del_tokens": "//i dont know what is this", "commit_type": "add"}
{"commit_tokens": ["use", "github", "user", "name", "detection"], "add_tokens": "githubAccount : this . github ? this . github . username ( ) || 'phovea'", "del_tokens": "githubAccount : 'phovea'", "commit_type": "use"}
{"commit_tokens": ["update", "scroll", "example", "and", "layout"], "add_tokens": "< div className = { ` ${ this . props . className || '' } ` } { ... this . props } > { this . props . children } < / div >", "del_tokens": "< div / >", "commit_type": "update"}
{"commit_tokens": ["fix", "getUnion", "returning", "duplicate", "items", "from", "both", "sets"], "add_tokens": "var getProps = require ( \"can-util/js/get/get\" ) ; // concatUnique // concat all items in bItems onto aItems that do not already exist in aItems. // same-object and ID collisions are both looked at when deciding whether // an item matches another. function concatUnique ( aItems , bItems , algebra ) { var keyTree = { } ; aItems . forEach ( function ( item ) { var keyNode = keyTree ; each ( algebra . clauses . id , function ( prop ) { keyNode = keyNode [ getProps ( item , prop ) ] = keyNode [ getProps ( item , prop ) ] || { } ; } ) ; } ) ; return aItems . concat ( bItems . filter ( function ( item ) { var keyNode = keyTree ; if ( aItems . indexOf ( item ) > - 1 ) { return false ; } each ( algebra . clauses . id , function ( prop ) { keyNode = keyNode && keyNode [ getProps ( item , prop ) ] ; } ) ; return keyNode === keyTree || ! keyNode ; } ) ) ; } combined = concatUnique ( aItems , bItems , this ) ; combined = concatUnique ( aItems , bItems , this ) ;", "del_tokens": "combined = aItems . concat ( bItems ) ; combined = aItems . concat ( bItems ) ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "dev", "installation", "check", "for", "init"], "add_tokens": "if ( ! npmArgs || ! npmArgs . some ( arg => / ^publish-please(@\\d+\\.\\d+.\\d+)?$ / . test ( arg ) ) )", "del_tokens": "if ( ! npmArgs || npmArgs . indexOf ( 'publish-please' ) < 0 )", "commit_type": "improve"}
{"commit_tokens": ["Updating", "deps", "except", "Gulp", "who", "seems", "to", "break", "tests"], "add_tokens": "VarStream . stringify ( b ) . split ( / \\r?\\n / ) . sort ( ) . join ( '\\n' ) ) ;", "del_tokens": "VarStream . stringify ( b ) . split ( / \\r?\\n / ) . sort ( ) . join ( '\\n' ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "update", "functionality", "to", "Entity", "change", "remove", "to", "callback", "with", "nothing", "and", "add", "some", "tests"], "add_tokens": "this . update = utils . bind ( this , this . update ) ; callback = callback || function ( ) { } ; var that = this ; this . del ( \"\" , { } , function ( ) { callback ( ) ; } ) ; } , update : function ( props , callback ) { callback = callback || function ( ) { } ; var that = this ; this . post ( \"\" , props , function ( err ) { callback ( err , that ) ; } ) ; this . _invalidate ( ) ;", "del_tokens": "this . del ( \"\" , { } , callback ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "top", "song", "not", "being", "added", "to", "array"], "add_tokens": "songs . push ( { \"rank\" : 1 , \"title\" : $ ( '.chart-number-one__details' ) . children ( '.chart-number-one__title' ) . text ( ) . trim ( ) , \"artist\" : $ ( '.chart-number-one__details' ) . children ( '.chart-number-one__artist' ) . text ( ) . trim ( ) , \"cover\" : \"\" } ) ; }", "del_tokens": "}", "commit_type": "fix"}
{"commit_tokens": ["improved", "error", "reporting", "for", "xhr", "and", "websocket", "transports"], "add_tokens": "syncHandle . _openViewWithSnapshots ( baseTypeCode , snapshot . version , snaps , viewName , mainViewParams , function ( err , root ) { if ( err ) _ . errout ( 'Error: ' + err )", "del_tokens": "syncHandle . _openViewWithSnapshots ( baseTypeCode , snapshot . version , snaps , viewName , mainViewParams , function ( root ) {", "commit_type": "improve"}
{"commit_tokens": ["Add", "timestamp", "in", "stats", "filename"], "add_tokens": "import moment from \"moment\" ; const statsFileName = path . basename ( filePath , path . extname ( filePath ) ) ; const statsTimeStamp = moment ( ) . format ( \"YYYYMMDDHHmmss\" ) ; const statsPath = ` ${ statsFileName } ${ statsTimeStamp } ${ extension } ` ; const outputDir = ` ${ process . cwd ( ) } ${ statsConf . outputDir } ` ; try { fs . accessSync ( outputDir ) ; } catch ( err ) { fs . mkdirSync ( outputDir ) ; }", "del_tokens": "const statsPath = ` ${ path . basename ( file . path , path . extname ( file . path ) ) } ${ extension } ` ; const outputDir = ` ${ process . cwd ( ) } ${ statsConf . outputDir } ` fs . mkdirSync ( outputDir ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "action", "callback", "param", "type", "test", "."], "add_tokens": "assert . equals ( typeof cb , 'function' ) ; assert . equals ( typeof cb , 'function' ) ; assert . equals ( typeof cb , 'function' ) ; assert . equals ( typeof cb , 'function' ) ; assert . equals ( typeof cb , 'function' ) ; } ) ;", "del_tokens": "assert . equals ( typeof bag . cli . exit , 'function' ) ; assert . equals ( typeof bag . cli . exit , 'function' ) ; assert . equals ( typeof bag . cli . exit , 'function' ) ; assert . equals ( typeof bag . cli . exit , 'function' ) ; assert . equals ( typeof bag . cli . exit , 'function' ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "EJS", "caching", "and", "error", "catching"], "add_tokens": "} , // EJS options cache : true , filename : templatename var renderHtml = '' ; // Try to render using ejs try { renderHtml = ejs . render ( templateSource , ejsPayload ) ; } catch ( err ) { renderHtml = '<hawkejs data-hawkejs=\"error\">Error rendering template</hawkejs>' ; log ( 'The EJS engine encountered an error rendering element ' + templatename , false , 'error' ) ; log ( err , false , 'error' ) ; }", "del_tokens": "} // Render using ejs var renderHtml = ejs . render ( templateSource , ejsPayload ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "bug", "forgot", "to", "concat", "data", ":", "$", "that", "s", "what", "you", "get", "if", "you", "don", "t", "finish", "your", "unit", "tests", ":", "*", "("], "add_tokens": "if ( ! spec . meta . compile ) { concat . push ( data ) ; return next ( ) ; }", "del_tokens": "if ( ! spec . meta . compile ) return next ( null , data ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "placement", "of", "server_knowledge", "on", "on", "category", "/", "month", "endpoints"], "add_tokens": "const USER_AGENT = \"api_client/js/1.13.3\" ;", "del_tokens": "const USER_AGENT = \"api_client/js/1.13.2\" ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "occurences", "of", "khr_materials_common", "for", "code", "(", "not", "tests", "yet", ")"], "add_tokens": "describe : 'Bypass the gltf-pipeline for debugging purposes. This option overrides many of the options above.' ,", "del_tokens": "kmc : { describe : 'Output glTF with the KHR_materials_common extension.' , type : 'boolean' , default : defaults . kmc } , describe : 'Bypass the gltf-pipeline for debugging purposes. This option overrides many of the options above and will save the glTF with the KHR_materials_common extension.' , kmc : argv . kmc ,", "commit_type": "remove"}
{"commit_tokens": ["use", "rollup", "&", "reduce", "code", "size"], "add_tokens": "import jsonParse from '../../util/json-parse' result = jsonParse ( data )", "del_tokens": "result = JSON . parse ( data )", "commit_type": "use"}
{"commit_tokens": ["Use", "forEach", "()", "to", "force", "a", "closure", "."], "add_tokens": "types . forEach ( function ( type , i ) { var pptr = new FFI . Pointer ( FFI . sizeOf ( type ) ) ; if ( type == \"string\" ) { this . _argputf [ i ] = putterFunction ( type , pptr , this . _strParamPtrs [ i ] ) ; } , this ) ;", "del_tokens": "for ( var i = 0 , len = types . length ; i < len ; i ++ ) { var pptr = new FFI . Pointer ( FFI . sizeOf ( types [ i ] ) ) ; if ( types [ i ] == \"string\" ) { this . _argputf [ i ] = putterFunction ( types [ i ] , pptr , this . _strParamPtrs [ i ] ) ; }", "commit_type": "use"}
{"commit_tokens": ["Fix", "reference", "to", "incorrect", "argument"], "add_tokens": "throw new Error ( 'Invalid source; file does not exit: ' + curr ) ;", "del_tokens": "throw new Error ( 'Invalid source; file does not exit: ' + file ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "reverse", "button", "and", "limit", "slider", "to", "example", "3"], "add_tokens": "timeSteps : 1 , playReverseButton : true , limitSliders : true , updateTimeDimension : true } ) ; $ ( \"#btn_limitrange\" ) . click ( function ( ) { var startTime = new Date ( $ ( '#dtp_start' ) . val ( ) ) ; var endTime = new Date ( $ ( '#dtp_end' ) . val ( ) ) ; map . timeDimension . setLowerLimit ( startTime ) ; map . timeDimension . setUpperLimit ( endTime ) ; map . timeDimension . setCurrentTime ( startTime ) ;", "del_tokens": "updateTimeDimension : true ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "search", "for", "version", "in", "plug", "-", "in", "header"], "add_tokens": "matches = plugin . match ( new RegExp ( \"^[\\* ]*Version:\\\\s*(\\\\S+)\" , \"im\" ) ) ;", "del_tokens": "matches = plugin . match ( new RegExp ( \"^Version:\\\\s*(\\\\S+)\" , \"im\" ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "event", "in", "ui", "/", "Editor"], "add_tokens": "on ( this , 'change' , function ( ) {", "del_tokens": "on ( this . domNode , 'change' , function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "log", "to", "redis", "cacher"], "add_tokens": "this . logger . debug ( ` ${ match } ` ) ; if ( micromatch . isMatch ( key , match ) ) {", "del_tokens": "this . logger . debug ( ` ${ this . prefix } ${ match } ` ) ; if ( micromatch . isMatch ( key , this . prefix + match ) ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "list", "of", "files", "to", "build", "()", "callback"], "add_tokens": ", function ( err , files ) { console . log ( 'done' , files )", "del_tokens": ", function ( err ) { console . log ( 'done' )", "commit_type": "add"}
{"commit_tokens": ["use", "rewire", "fork", "w", "/", "o", "enumerated", "methods"], "add_tokens": "var testUtils = require ( \"./util\" ) // a copy of API we can safely iterate (w/o rewire methods); Object . keys ( api ) . forEach ( function ( key ) { console . log ( key ) ;", "del_tokens": "// a copy of API we can safely iterate (w/o rewire methods); var iterableApi = Object . keys ( api ) . reduce ( function ( obj , key ) { if ( key !== \"__set__\" && key !== \"__get__\" && key !== \"__with__\" ) { obj [ key ] = api [ key ] ; } return obj ; } , { } ) ; Object . keys ( iterableApi ) . forEach ( function ( key ) {", "commit_type": "use"}
{"commit_tokens": ["Adding", "$log", "into", "the", "controller", "declaration"], "add_tokens": "angular . module ( 'myApp' ) . controller ( 'sampleCtrl' , [ '$scope' , '$log' , function ( $scope , $log ) {", "del_tokens": "angular . module ( 'myApp' ) . controller ( 'sampleCtrl' , [ '$scope' , function ( $scope , $log ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "global", "installation"], "add_tokens": "#!/usr/bin/env node console . log ( 'Usage: $ ttl <path-to-file>' ) ;", "del_tokens": "console . log ( 'Usage: $ node N3Validator.js <path-to-file>' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "automatic", "block", "size", "detection", "on", "open", "()"], "add_tokens": "if ( error != null ) return callback . call ( self , error , fd ) // Set file descriptor // If no blockSize has been set, attempt to // detect it after opening the device if ( self . blockSize == null || self . blockSize <= 0 ) { self . detectBlockSize ( 0 , 0 , 0 , function ( error , blockSize ) { self . blockSize = blockSize || - 1 callback . call ( self , error , self . fd ) } ) } * @ param { Function } callback ( err , blockSize )", "del_tokens": "callback . call ( self , error , fd ) * @ param { Function } callback", "commit_type": "add"}
{"commit_tokens": ["added", "support", "for", "getting", "pool", "standings"], "add_tokens": "var route = '' if ( options . subseason_id || this . subseason_id ) { var subseasonID = options . subseason_id || this . subseason_id delete options . subseason_id route = 'subseasons/' + subseasonID } else if ( options . pool_id || this . pool_id ) { var poolID = options . pool_id || this . pool_id delete options . pool_id route = 'pools/' + poolID } return Url . resolve ( base , route + scope + '/standings' ) if ( ! options . subseason_id && ! options . pool_id ) return callback ( new Error ( 'subseason_id or pool_id required' ) )", "del_tokens": "var subseasonID = options . subseason_id || this . subseason_id delete options . subseason_id return Url . resolve ( base , 'subseasons/' + subseasonID + scope + '/standings' ) if ( ! options . subseason_id ) return callback ( new Error ( 'subseason_id is required' ) )", "commit_type": "add"}
{"commit_tokens": ["Adding", "validation", "capabilities", "to", "types", "and", "forms", "."], "add_tokens": "var validationResponseCallback = function ( callback ) { return function ( error , item , errors ) { if ( error ) { // Application error. return callback ( error ) ; } if ( errors && errors . length > 0 ) { // Validation errors. return callback ( null , errors , 400 ) ; } // Validation passed. callback ( null , item ) ; } ; } ; return typeModel . validateAndSave ( request . body , validationResponseCallback ( callback ) ) ; return typeModel . validateAndSave ( request . body , validationResponseCallback ( callback ) ) ; typeModel . validateAndSave ( request . body , validationResponseCallback ( callback ) ) ;", "del_tokens": "return typeModel . save ( request . body , callback ) ; return typeModel . save ( request . body , callback ) ; typeModel . save ( request . body , callback ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "ability", "to", "set", "range", "for", "rants", "(", "top", ")"], "add_tokens": "function rants ( sort , limit , skip , prev_set , token , range ) { if ( range == undefined ) { range = '' } sort , limit , skip , prev_set , range", "del_tokens": "function rants ( sort , limit , skip , prev_set , token ) { sort , limit , skip , prev_set", "commit_type": "add"}
{"commit_tokens": ["Updating", "html", "tag", "stripping", "pattern"], "add_tokens": "var t = new Tokenizer ( { cleanPattern : / (<([^>]+)>) / ig } ) ; expect ( t . clean ( '<div><a href=\"http://www.google.com\" data-prop=\"bleh\">data here to clean</a></div>' ) ) . toEqual ( 'data here to clean' ) ; var t = new Tokenizer ( { cleanPattern : / (<([^>]+)>) / ig , cleanTriggerChar : '<' } ) ;", "del_tokens": "var t = new Tokenizer ( { cleanPattern : / <\\/?[A-Za-z]*> / g } ) ; expect ( t . clean ( '<text>data here to clean</text>' ) ) . toEqual ( 'data here to clean' ) ; var t = new Tokenizer ( { cleanPattern : / <\\?[A-Za-z]*> / g , cleanTriggerChar : '<' } ) ;", "commit_type": "update"}
{"commit_tokens": ["use", "the", "pre", "-", "configured", "post", "-", "robot", "instance", "which", "comes", "with", "xcomponent", "instead", "of", "the", "one", "from", "dev", "dependencies"], "add_tokens": "import { postRobot } from 'xcomponent/src' ; export const CONSTANTS = postRobot . CONSTANTS ; export const CONFIG = postRobot . CONFIG ; export const disable = postRobot . disable ; export const disableMockMode = postRobot . disableMockMode ; export const enableMockMode = postRobot . enableMockMode ; export const linkUrl = postRobot . linkUrl ; export const listen = postRobot . listen ; export const on = postRobot . on ; export const once = postRobot . once ; export const openBridge = postRobot . openBridge ; export const parent = postRobot . parent ; export const Promise = postRobot . Promise ; export const request = postRobot . request ; export const reset = postRobot . reset ; export const send = postRobot . send ; export const sendToParent = postRobot . sendToParent ; export const util = postRobot . sendToParent ;", "del_tokens": "export { CONSTANTS , CONFIG , disable , disableMockMode , enableMockMode , linkUrl , listen , on , once , openBridge , parent , Promise , request , reset , send , sendToParent , util } from 'post-robot/src' ;", "commit_type": "use"}
{"commit_tokens": ["created", "file", "for", "global", "settings", "like", "redis", "initiation"], "add_tokens": "client = redis . createClient ( ) ; // client = redis.createClient(12000, process.env.REDIS_HOST); // client.auth(process.env.REDIS_AUTH, function (err) { // if (err) { throw err; } // // You are now connected to your redis. // }); client . flushdb ( ) ; // client.on('ready', function(){ // });", "del_tokens": "var config ; client = redis . createClient ( 6379 , 'nodejitsudb1343585590.redis.irstack.com' ) ; client . auth ( 'nodejitsudb1343585590.redis.irstack.com:f327cfe980c971946e80b8e975fbebb4' , function ( err ) { if ( err ) { throw err ; } // You are now connected to your redis. } ) ; // client.flushdb();", "commit_type": "create"}
{"commit_tokens": ["Make", "sure", "we", "are", "using", "utilx", ".", "anyToString", "and", "not", "String"], "add_tokens": "stringifiedValue = function ( ) { return 1 ; } ; stringifiedValue . toJSON = stringifiedValue ( ) . toString ( ) ; return utilx . anyToString ( value ) ; return utilx . anyToString ( value ) ;", "del_tokens": "( function ( ) { stringifiedValue = function ( ) { return 1 ; } ; } ( ) ) ; stringifiedValue . toJSON = stringifiedValue ; return String ( value ) ; return String ( value ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "the", "ability", "to", "train", "and", "classify", "files"], "add_tokens": "assert . equal ( \"GROUP-B\" , group ) ; } ; // Test training from files exports [ 'test classify#fromFiles' ] = function ( beforeExit , assert ) { var classifier = new Classifier ( ) ; classifier . trainFromFile ( \"GROUP-A\" , \"test/sample/sample1.txt\" ) ; classifier . trainFromFile ( \"GROUP-A\" , \"test/sample/sample2.txt\" ) ; classifier . trainFromFile ( \"GROUP-A\" , \"test/sample/sample3.txt\" ) ; classifier . trainFromFile ( \"GROUP-B\" , \"test/sample/sample4.txt\" ) ; classifier . trainFromFile ( \"GROUP-B\" , \"test/sample/sample5.txt\" ) ; var group = classifier . classify ( \"Something that should be GROUP-B\" ) ; assert . equal ( \"GROUP-B\" , group ) ;", "del_tokens": "assert . equal ( \"GROUP-B\" , group ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "setup", "cope", "more", "sensible", "with", "missing", "arguments"], "add_tokens": "gpio . setup ( 1 ) ; describe ( 'and callback is specified' , function ( ) { beforeEach ( function ( ) { spyOn ( ( fs . exists ? fs : path ) , 'exists' ) . andCallFake ( function ( path , cb ) { cb ( false ) ; } ) ; spyOn ( fs , 'watchFile' ) . andCallFake ( function ( path , cb ) { } ) ; } ) ; it ( 'should execute the callback when direction is missing' , function ( ) { var callback = jasmine . createSpy ( ) ; gpio . setup ( 1 , callback ) ; expect ( callback ) . toHaveBeenCalled ( ) ; } ) ; } ) ;", "del_tokens": "var callback = jasmine . createSpy ( ) ; gpio . setup ( 1 , null , callback ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "grunt", "-", "dox", "and", "generated", "documentation", ".", "Add", "myself", "to", "collaborators", "list", "."], "add_tokens": "} , dox : { options : { title : \"PhysicsJS Documentation\" } , files : { src : [ 'src/**/*.js' ] , dest : 'docs' } } , grunt . loadNpmTasks ( 'grunt-dox' ) ; grunt . registerTask ( 'docs' , [ 'dox' ] ) ;", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["added", "callback", "for", "connect", "and", "fixed", "another", "bug"], "add_tokens": "var i = 0 ; while ( IDX [ i ] ) { // Request Fresh device status on connect. self . request ( IDX [ i ] ) ; i ++ ; } self . emit ( 'connect' ) ; if ( ( cmd === 'Set Level' ) || ( cmd === 'On' ) ) { state [ 'level' ] = lvl } ;", "del_tokens": "if ( cmd === 'Set Level' ) { state [ 'level' ] = lvl } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "arg", "and", "return", "parsing", ";", "add", "forgotten", "src", "dir"], "add_tokens": "$$ [ $0 ] = $$ [ $0 ] . split ( \"\\n\" ) . map ( function ( element , idx ) { return element . replace ( / ^\\s{1,4} / g , '' ) ; } ) ; description : $$ [ $0 ] . join ( \"\\n\" )", "del_tokens": "description : $$ [ $0 ] . replace ( / (?:\\s*\\*\\s*|\\s+) / g , ' ' ) . replace ( / (^\\s*|\\s*$) / g , '' )", "commit_type": "fix"}
{"commit_tokens": ["Add", "hidden", "option", "to", "all", "editors", "that", "stops", "it", "from", "being", "displayed", "in", "the", "UI", "."], "add_tokens": "var th = self . theme . getTableHeaderCell ( editor . getTitle ( ) ) ; if ( editor . options . hidden ) th . style . display = 'none' ; self . header_row . appendChild ( th ) ;", "del_tokens": "self . header_row . appendChild ( self . theme . getTableHeaderCell ( editor . getTitle ( ) ) ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "/", "case", "in", "the", "end", "of", "destPath"], "add_tokens": "destPath = fileObject . dest ? correctedDestination + fileObject . dest + ( tempPath . charAt ( 0 ) === \"/\" ? tempPath . slice ( 1 ) : tempPath ) : tempDestPath ;", "del_tokens": "destPath = fileObject . dest ? correctedDestination + fileObject . dest : tempDestPath ;", "commit_type": "add"}
{"commit_tokens": ["Add", "new", "message", "notifications", "for", "individual", "tabs"], "add_tokens": "// We only trigger this event for new single messages self . notifications . trigger ( 'addmessage' , data ) ;", "del_tokens": "self . notifications . trigger ( 'addmessage' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "chunk", "buffering", "based", "on", "passed", "highWaterMark"], "add_tokens": "processor . getProcessor ( ) ( ) ;", "del_tokens": "processor . process ( awaitingPromise : false , ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "way", "to", "retrieve", "associated", "data"], "add_tokens": "Object . defineProperties ( o , { __meta__ : { value : elementMeta ( jsmfElement ) } , conformsTo : { value : function ( ) { return conformsTo ( o ) ; } } , getAssociated : { value : getAssociated , enumerable : false } } ) ; function getAssociated ( name ) { if ( name === undefined ) { return _ . get ( this , [ '__meta__' , 'associated' ] ) ; } else { return _ . get ( this , [ '__meta__' , 'associated' , name ] ) ; } }", "del_tokens": "Object . defineProperty ( o , '__meta__' , { value : elementMeta ( jsmfElement ) } ) ; Object . defineProperty ( o , 'conformsTo' , { value : function ( ) { return conformsTo ( o ) ; } } ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "server", "mode", "to", "the", "monkey"], "add_tokens": "if ( ! process . env [ 'monkey.watch' ] && ! process . env [ 'monkey.server' ] ) { SessionManager . prototype . _getWebdriverSessions = function ( ) {", "del_tokens": "if ( ! process . env [ 'monkey.watch' ] ) { SessionManager . prototype . _getWebdriverSessions = function ( callback ) {", "commit_type": "add"}
{"commit_tokens": ["Changing", "error", "message", "on", "invalid", "syntax"], "add_tokens": "throw new Error ( 'Error parsing code while looking for \"npm:\" imports: ' + ( result . stack || result ) + ' in file: ' + fullPath ) ;", "del_tokens": "throw new Error ( 'Error parsing code while looking for \"npm:\" imports: ' + result . stack || result + ' in file: ' + fullPath ) ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "for", "model", "factory", "loading", "resources"], "add_tokens": "resources : true var resourcesDir = this . injector . rootDir + '/' + this . injector . servicesDir + '/resources' ; if ( ! fs . existsSync ( resourcesDir ) ) { var resourceNames = fs . readdirSync ( resourcesDir ) ; // for resources we need to load them the first time they are referenced if ( objectName === 'resources' && this . internalObjects [ objectName ] === true ) { this . internalObjects [ objectName ] = this . loadResources ( ) ; }", "del_tokens": "resources : this . loadResources ( ) var resourceDir = this . injector . rootDir + '/' + this . injector . servicesDir + '/resources' ; if ( ! fs . existsSync ( resourceDir ) ) { var resourceNames = fs . readdirSync ( resourceDir ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "separate", "active", "-", "class", "for", "wrapper"], "add_tokens": "addClass ( that . wrapper , 'jslghtbx-wrapper-active' ) ; removeClass ( that . wrapper , 'jslghtbx-wrapper-active' ) ;", "del_tokens": "addClass ( that . wrapper , 'jslghtbx-active' ) ; removeClass ( that . wrapper , 'jslghtbx-active' ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "command", "to", "event", "converting", "API"], "add_tokens": "} ; module . exports . commandToEvent = function ( request , response ) { response . type = 'event' ; response . event = response . command ; response . body = request . arguments || { } ; delete response . command ; delete response . request_seq ; } ;", "del_tokens": "} ;", "commit_type": "add"}
{"commit_tokens": ["Added", "FrontController", "ViewFactory", "Routers", "etc", "."], "add_tokens": "this . trigger ( 'change' , { fromJson : true } ) ;", "del_tokens": "this . trigger ( 'change' ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "for", "salt", "and", "iv", "generation"], "add_tokens": "* @ returns { Promise . < String > } A promise that resolves with a salt ( hex )", "del_tokens": "* @ returns { Promise . < String > } A promise that resolves with a salt", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "last", "test", "pass", "green"], "add_tokens": "< $ { tagContent } hash = \"case8\" src = \"/test/case8/case8-external.html\" > //content.innerHTML = ` // <${tagSrc}><div>This is an external content</div></${tagSrc}> //`; assert_equals ( src . textContent , 'This is an external content\\n' ) ;", "del_tokens": "< $ { tagContent } hash = \"case8\" src = \"case8-external.html\" > content . innerHTML = ` < $ { tagSrc } > This is an external content < / $ { tagSrc } > ` ; assert_equals ( src . textContent , 'This is an external content' ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "custom", "webpack", "configuration", "for", "storybook", "to", "transpile", "svg", "-", "partial", "-", "circle", "package"], "add_tokens": "import { storiesOf } from '@storybook/react' ;", "del_tokens": "import { storiesOf , action } from '@storybook/react' ;", "commit_type": "add"}
{"commit_tokens": ["fix", "property", "test", "for", "phantomjs"], "add_tokens": "if ( window . navigator . userAgent . indexOf ( 'PhantomJS' ) === - 1 ) { expect ( el . prop1 ) . to . be . eq ( 'value' ) ; }", "del_tokens": "expect ( el . prop1 ) . to . be . eq ( 'value' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "mongo", "store", "session", "and", "remove", "a", "bug", "about", "res", ".", "red", "()", "+", "session", "on", "controllers"], "add_tokens": "MongoStore = require ( 'connect-mongo' ) ( express ) , graoExpress . use ( i18n . init ) ; graoExpress . use ( express . favicon ( ) ) ; graoExpress . use ( express . logger ( 'dev' ) ) ; graoExpress . use ( express . json ( ) ) ; graoExpress . use ( express . urlencoded ( ) ) ; graoExpress . use ( express . session ( { secret : 'FIXME AND RAND THIS' , store : new MongoStore ( { db : 'grao' } ) } ) ) ; // development only / *if ('development' == app.get('env')) { app . use ( express . errorHandler ( ) ) ; } * / if ( process . env . PORT != undefined ) { } else { }", "del_tokens": "graoExpress . use ( express . session ( { secret : 'FIXME CHANGE IT IN COMPILE TIME!' } ) ) ; graoExpress . use ( i18n . init ) ; if ( process . env . PORT != undefined ) { } else { }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "small", "bug", "in", "write", "test", "logging"], "add_tokens": "parent : { name : 'parent' , args : [ ] , returnType : 'RuleDataSnapshot' } ,", "del_tokens": "parent : { name : 'parent' , args : [ 'string' ] , returnType : 'RuleDataSnapshot' } ,", "commit_type": "fix"}
{"commit_tokens": ["add", "BOM", "signature", "to", "sk", ".", "js", "translation", "file"], "add_tokens": "EDITOR.p l ugins.s e tLang(' y outube', ' k', {", "del_tokens": "CKEDITOR . plugins . setLang ( 'youtube' , 'sk' , {", "commit_type": "add"}
{"commit_tokens": ["adds", "prismjs", "and", "tabs", "stuff", "(", "from", "demo", "-", "site", ")"], "add_tokens": "'./bower_components/components-font-awesome/css/font-awesome.min.css' , // ICONS './bower_components/roboto-fontface/css/roboto-fontface.css' , // FONT (Roboto) './node_modules/prismjs/themes/prism-coy.css' , // prismjs coy theme (syntax highlighting) './bower_components/jquery/dist/jquery.min.js' , './bower_components/a11y-tabs/a11y-tabs.js' , './node_modules/prismjs/prism.js' , './node_modules/prismjs/components/prism-jade.min.js' ,", "del_tokens": "'bower_components/components-font-awesome/css/font-awesome.min.css' , // ICONS 'bower_components/roboto-fontface/css/roboto-fontface.css' , // FONT (Roboto) 'bower_components/jquery/dist/jquery.min.js' ,", "commit_type": "add"}
{"commit_tokens": ["Remove", "json", "-", "stable", "-", "stringify", "sort", "options", "."], "add_tokens": "space : 2", "del_tokens": "// GraphSON requires its top level properties to be in the order mode, vertices, edges. space : 2 , cmp : function ( a , b ) { if ( a . key === 'edges' ) return 1 ; else if ( b . key === 'edges' ) return - 1 ; return a . key < b . key ? - 1 : 1 ; }", "commit_type": "remove"}
{"commit_tokens": ["Add", "type", "property", "for", "each", "subclass", "of", "Asset"], "add_tokens": "prop ( this , 'type' , 'static' ) ; // No caching to avoid memory bloating by default. // Caching might be implemented on the higher level (e.g. in [[Server]]) // by simply setting `__buffer__` property. return this . __buffer__ || fs . readFileSync ( this . pathname ) ;", "del_tokens": "// No caching to avoid memory bloating. // Caching might be implemented on the higher level (e.g. in [[Server]]). return fs . readFileSync ( this . pathname ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "too", "low", "field", "length", "in", "form"], "add_tokens": "if ( t [ 'http://www.w3.org/2005/01/wf/flow#Task' ] || kb . holds ( subject , UI . ns . wf ( 'tracker' ) ) ) return \"issue\" ; // in case ontology not available if ( t [ \"http://www.w3.org/2005/01/wf/flow#Task\" ] || kb . holds ( subject , UI . ns . wf ( 'tracker' ) ) ) {", "del_tokens": "if ( t [ 'http://www.w3.org/2005/01/wf/flow#Task' ] ) return \"issue\" ; if ( t [ \"http://www.w3.org/2005/01/wf/flow#Task\" ] ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "--", "global", "flag", "fixed", "getCliInstallCommand", "to", "capture", "and", "parse", "stdout", "in", "a", "platform", "-", "independent", "manner", "save", "Buffer", ".", "toString", "()", "of", "command", "in", "unit", "tests", "to", "be", "able", "to", "log", "it", "to", "console", "during", "troubleshooting"], "add_tokens": "global , let globalFlag = packageManager === C . yarn ? \"global\" : \"--global\" ; if ( ! global ) { globalFlag = \"\" ; } // global must preceed add in yarn; npm doesn't care args = args . concat ( globalFlag ) ; // and it's not a silent install and it's not a global install // make sure to save deps in package.json under \"dependencies\" if ( devFlag === \"\" && packageManager === C . npm && ! silent && ! global ) {", "del_tokens": "// and it's not a silent install make sure to save // deps in package.json under \"dependencies\" if ( devFlag === \"\" && packageManager === C . npm && ! silent ) {", "commit_type": "add"}
{"commit_tokens": ["use", "schemaless", "url", ".", "fix", "bug", "causing", "bad", "paylods", "when", "stacktrace", "could", "not", "be", "parsed", "."], "add_tokens": "this . endpoint = params . endpoint || '//submit.ratchet.io/api/1/' ; if ( ! trace . frames ) { // no frames - not useful as a trace. just report as a message. this . handleMessage ( { msg : className + ': ' + message , level : 'error' } , callback ) ; } else { this . _pushTrace ( trace , callback ) ; }", "del_tokens": "this . endpoint = params . endpoint || 'https://submit.ratchet.io/api/1/' ; this . _pushTrace ( trace , callback ) ;", "commit_type": "use"}
{"commit_tokens": ["Changed", "powerTip", "()", "methods", "to", "use", "property", "lookup", "."], "add_tokens": "// handle api method calls on the plugin, e.g. powerTip('hide') if ( typeof opts === 'string' && $ . powerTip [ opts ] ) { return $ . powerTip [ opts ] . call ( this , this , arg ) ; // API aliasing $ . powerTip . show = $ . powerTip . showTip ; $ . powerTip . hide = $ . powerTip . closeTip ;", "del_tokens": "// show tip for the first matching element if ( opts === 'show' ) { // arg, if provided, is an event return $ . powerTip . showTip ( this , arg ) ; } // hide tip for the first matching element if ( opts === 'hide' ) { // arg, if provided, indicates whether to close this immediately return $ . powerTip . closeTip ( this , arg ) ; } // reset tip position for the first matching element if ( opts === 'resetPosition' ) { return $ . powerTip . resetPosition ( this ) ; } // destroy associated powertips if ( opts === 'destroy' ) { return $ . powerTip . destroy ( this ) ;", "commit_type": "change"}
{"commit_tokens": ["Adds", "mapping", "for", "Nodes", "establishes", "Link", "component"], "add_tokens": "import React from \"react\" // eslint-disable-line const treeData = [ { \"name\" : \"Top Level\" , \"parent\" : \"null\" , \"children\" : [ { \"name\" : \"Level 2: A\" , \"parent\" : \"Top Level\" , \"children\" : [ { \"name\" : \"Son of A\" , \"parent\" : \"Level 2: A\" } , { \"name\" : \"Daughter of A\" , \"parent\" : \"Level 2: A\" } ] } , { \"name\" : \"Level 2: B\" , \"parent\" : \"Top Level\" } ] } ] < Tree rawData = { treeData } / >", "del_tokens": "import React from \"react\" < Tree / >", "commit_type": "add"}
{"commit_tokens": ["update", "export", "for", "global", "varialble"], "add_tokens": "win . jBone = win . $ = jBone ; } else if ( typeof win === \"object\" && typeof win . document === \"object\" ) {", "del_tokens": "} if ( typeof win === \"object\" && typeof win . document === \"object\" ) {", "commit_type": "update"}
{"commit_tokens": ["Fixed", "a", "bug", "that", "broke", "the", "tabs", "in", "IE7"], "add_tokens": "var panelSelector = $anchor . attr ( 'href' ) ; window . location . hash = clickedTab . selector ;", "del_tokens": "var panelSelector = $anchor [ 0 ] . getAttribute ( 'href' ) ; window . location . hash = clickedTab . selector", "commit_type": "fix"}
{"commit_tokens": ["Add", "iphone", "x", "to", "deviceSizes", ".", "js"], "add_tokens": "'iPhone 6' : { // 6s, 7, 8 'iPhone 6 Plus' : { // 6s+, 7+, 8+ 'iPhone X' : { // note: this won't have the bezel windowPhysicalPixels : { width : 1125 , height : 2436 , scale : 3 , fontScale : 3 , } , } ,", "del_tokens": "'iPhone 6' : { 'iPhone 6 Plus' : {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "an", "issue", "in", "directory", "creation"], "add_tokens": "try { fs . mkdirSync ( current_output_dir ) ; console . log ( \"Created \" + current_output_dir + \" directory\" ) ; } catch ( e ) { if ( e . code === \"EEXIST\" ) { } ; } } proceedToNextOrCallback ( ) ; } ;", "del_tokens": "fs . mkdir ( current_output_dir , function ( err ) { if ( ! err ) { console . log ( \"Created \" + current_output_dir + \" directory\" ) ; } } ) ; } else { proceedToNextOrCallback ( ) ; } }", "commit_type": "fix"}
{"commit_tokens": ["fixing", "lint", "errors", "(", "JSDoc", "quotes", ")"], "add_tokens": "* @ param { Function } callback ( err , data ) to be triggered with response && opts . device === \"bb8\" ) {", "del_tokens": "* @ param { Function } callback ( err , data ) to be triggered with response && opts . device === 'bb8' ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "for", "line", "numbers", "in", "events"], "add_tokens": "var beforeLexCounter = 0 ; var afterLexCounter = 0 ; beforeLexCounter ++ ; t . equal ( e . detail . lineNum , beforeLexCounter - 1 ) ; afterLexCounter ++ ; t . equal ( e . detail . lineNum , afterLexCounter - 1 ) ; // lexer should have been called twice by now t . equal ( beforeLexCounter , 2 , 'lexer was called twice' ) ; t . equal ( afterLexCounter , 2 , 'lexer was called twice' ) ; // alignment tests t . equal ( e . detail . firstLineNum , 0 , 'firstLineNum' ) ; t . equal ( e . detail . lastLineNum , 1 , 'lastLineNum' ) ; t . equal ( e . detail . firstLineNum , 0 , 'firstLineNum' ) ; t . equal ( e . detail . lastLineNum , 1 , 'lastLineNum' ) ; t . equal ( e . detail . firstLineNum , 0 , 'firstLineNum' ) ; t . equal ( e . detail . lastLineNum , 1 , 'lastLineNum' ) ; t . equal ( e . detail . firstLineNum , 0 , 'firstLineNum' ) ; t . equal ( e . detail . lastLineNum , 1 , 'lastLineNum' ) ;", "del_tokens": "// should be called twice // should be called twice", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "the", "logger", "always", "works", ";", "Fix", "config", "handling"], "add_tokens": "if ( ! conf . logging . name ) { conf . logging . name = 'restbase' ; } if ( ! conf . storage ) { conf . storage = { } ; } if ( ! conf . storage [ 'default' ] ) { conf . storage [ 'default' ] = { // module name \"type\" : \"restbase-cassandra\" , \"hosts\" : [ \"localhost\" ] , \"id\" : \" < uuid > \" \"keyspace\" : \"system\" , \"username\" : \"test\" , \"password\" : \"test\" , \"poolSize\" : 70 ,", "del_tokens": "if ( ! conf . logging . name ) { conf . logging . name = 'main' ; } if ( ! conf . storage ) { conf . storage = { \"default\" : { // module name \"type\" : \"restbase-cassandra\" , \"hosts\" : [ \"localhost\" ] , \"id\" : \" < uuid > \" \"keyspace\" : \"system\" , \"username\" : \"test\" , \"password\" : \"test\" , \"poolSize\" : 70 , }", "commit_type": "make"}
{"commit_tokens": ["Make", "RangeInput", "controlled", "when", "value", "is", "0", "or", "null"], "add_tokens": "if ( props . value === undefined ) { if ( value === undefined ) { return ( this . props . value === undefined ) ? this . state . value : this . props . value", "del_tokens": "if ( ! props . value ) { if ( ! value ) { return this . props . value || this . state . value", "commit_type": "make"}
{"commit_tokens": ["Add", "next", "/", "prev", "month", "touch", "events", "handlers"], "add_tokens": "onDayMouseLeave : React . PropTypes . func , onNextMonthTouchTap : React . PropTypes . func , onPrevMonthTouchTap : React . PropTypes . func this . setState ( { month : this . state . month . add ( 1 , 'month' ) } , ( ) => { this . props . onNextMonthTouchTap && this . props . onNextMonthTouchTap ( this . state . month ) ; } ) ; this . setState ( { month : this . state . month . subtract ( 1 , 'month' ) } , ( ) => { this . props . onPrevMonthTouchTap && this . props . onPrevMonthTouchTap ( this . state . month ) ; } ) ;", "del_tokens": "onDayMouseLeave : React . PropTypes . func this . setState ( { month : this . state . month . add ( 1 , 'month' ) } ) ; this . setState ( { month : this . state . month . subtract ( 1 , 'month' ) } ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "one", "template", "to", "many", "output", "support"], "add_tokens": "test . equal ( actual , expected , 'Globbed templates should append when output is a single file' ) ; test . done ( ) ; } , oneTemplateToManyOutputs : function ( test ) { test . expect ( 2 ) ; var actual1 = grunt . file . read ( 'tmp/oneTemplateToManyOutputs1.html' ) ; var expected1 = grunt . file . read ( 'test/expected/oneTemplateToManyOutputs1.html' ) ; var actual2 = grunt . file . read ( 'tmp/oneTemplateToManyOutputs2.html' ) ; var expected2 = grunt . file . read ( 'test/expected/oneTemplateToManyOutputs2.html' ) ; test . equal ( actual1 , expected1 , 'Output should use same template but different data when it is a single file' ) ; test . equal ( actual2 , expected2 , 'Output should use same template but different data when it is a single file' ) ;", "del_tokens": "test . equal ( actual , expected , 'Globbed templates should append when output is a singlefile' ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "a", "counter", "in", "test", "/", "extend", ".", "js"], "add_tokens": ", counter = 0 NRTest . addMethod ( 'description' , '@@:' , function ( id , sel ) { counter ++ console . log ( String ( instance ) ) //console.log(''+instance) // Either of these //console.log(instance+'') // segfault, WTF? assert . equal ( counter , 3 )", "del_tokens": "NRTest . addMethod ( 'description' , '@@:' , function ( ) { console . log ( instance . toString + '' ) console . log ( instance + '' ) // This segfaults, WTF?", "commit_type": "use"}
{"commit_tokens": ["changed", "how", "incoming", "notices", "appear", ":", "-", "nick", "-", "msg"], "add_tokens": "return basicText ( 'activity_notice' , '-' + originNickOrName ( activity . origin ) + '- ' + activity . text ) ;", "del_tokens": "return basicText ( 'activity_notice' , '* Notice from ' + originNickOrName ( activity . origin ) + ': ' + activity . text ) ;", "commit_type": "change"}
{"commit_tokens": ["removed", "accidental", "$", "attribute", "in", "json", "from", "getZoneAttrs", "()", "and", "getZoneInfo", "()"], "add_tokens": "for ( var d in data [ 0 ] ) if ( data [ 0 ] . hasOwnProperty ( d ) && d !== '$' ) output [ d ] = data [ 0 ] [ d ] [ 0 ] ; for ( var d in data [ 0 ] ) if ( data [ 0 ] . hasOwnProperty ( d ) && d !== '$' ) output [ d ] = data [ 0 ] [ d ] [ 0 ] ;", "del_tokens": "for ( var d in data [ 0 ] ) if ( data [ 0 ] . hasOwnProperty ( d ) ) output [ d ] = data [ 0 ] [ d ] [ 0 ] ; for ( var d in data [ 0 ] ) if ( data [ 0 ] . hasOwnProperty ( d ) ) output [ d ] = data [ 0 ] [ d ] [ 0 ] ;", "commit_type": "remove"}
{"commit_tokens": ["Change", "the", "encoding", "of", "URI", "s", "to", "use", "encodeURIComponent", "to", "support", "copying", "filenames", "with", "special", "characters", "like", "+"], "add_tokens": "s3 . copyObject ( { Key : object . dest , CopySource : encodeURIComponent ( options . bucket + '/' + object . Key ) , Bucket : options . bucket } , function ( err , data ) {", "del_tokens": "s3 . copyObject ( { Key : object . dest , CopySource : encodeURI ( options . bucket + '/' + object . Key ) , Bucket : options . bucket } , function ( err , data ) {", "commit_type": "change"}
{"commit_tokens": ["Fix", "typos", "in", "security_credentials", ".", "js"], "add_tokens": "return SecurityCredentialsNative . acquire ( 'Kerberos' , username , password , domain , callback ) ;", "del_tokens": "return SecurityCredentialsNative . aquire ( 'Kerberos' , username , password , domain , callback ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "that", "causes", "premature", "end", "event"], "add_tokens": "todo += 3 endUtimes ( me , me . props , current , me . _path , next ( \"utimes\" ) )", "del_tokens": "endUtimes ( me , me . props , current , me . _path , next ( \"chown\" ) ) todo ++", "commit_type": "fix"}
{"commit_tokens": ["Use", "Bootstrap", "styling", "for", "DataTables"], "add_tokens": "$ ( 'head' ) . append ( '<link rel=\"stylesheet\" href=\"//cdn.datatables.net/plug-ins/1.10.7/integration/bootstrap/3/dataTables.bootstrap.css\" type=\"text/css\" />' ) ; $ ( this ) . html ( '<input type=\"text\" class=\"form-control\" placeholder=\"Search ' + title + '\" />' ) ;", "del_tokens": "$ ( 'head' ) . append ( '<link rel=\"stylesheet\" href=\"//cdn.datatables.net/1.10.5/css/jquery.dataTables.min.css\" type=\"text/css\" />' ) ; $ ( this ) . html ( '<input type=\"text\" placeholder=\"Search ' + title + '\" />' ) ;", "commit_type": "use"}
{"commit_tokens": ["fix", "callback", "they", "are", "also", "inside", "CallExpression", "but", "are", "not", "IIFE"], "add_tokens": "if ( isIIFE ( node ) ) { if ( ( node . type === 'FunctionExpression' || node . type === 'FunctionDeclaration' ) && ! isIIFE ( node . parent ) ) { function isIIFE ( node ) { return node . type === 'CallExpression' && node . callee . type === 'FunctionExpression' ; }", "del_tokens": "if ( node . type === 'CallExpression' && node . callee . type === 'FunctionExpression' ) { if ( node . parent . type !== 'CallExpression' && ( node . type === 'FunctionExpression' || node . type === 'FunctionDeclaration' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "errors", "in", "isFile", "&", "isDirectory", "method", "optimize", "codes"], "add_tokens": "var value = isBuffer ( Buffer . from ( 'test' ) ) ;", "del_tokens": "var value = isBuffer ( Buffer . alloc ( 'test' ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "auth", "setting", "for", "access", "to", "swagger", "assets"], "add_tokens": "config : { auth : settings . aut } , config : { auth : settings . aut } , } var responseClassName = route . responseSchema && route . responseSchema . _settings ? var responseProperty = internals . validatorToProperty ( responseClassName || op . nickname + '_response' , } params = params . _inner . children } // version >= 4.x of Joi var param = ( param . _inner . children ) ? param . _inner . children : param . _inner models ) ; return obj && ! ( obj . propertyIsEnumerable ( 'length' ) ) && typeof obj === 'object'", "del_tokens": "} var responseClassName = route . responseSchema && route . responseSchema . _settings ? var responseProperty = internals . validatorToProperty ( responseClassName || op . nickname + '_response' , } params = params . _inner . children } // version >= 4.x of Joi var param = ( param . _inner . children ) ? param . _inner . children : param . _inner models ) ; return obj && ! ( obj . propertyIsEnumerable ( 'length' ) ) && typeof obj === 'object'", "commit_type": "use"}
{"commit_tokens": ["Use", "https", "if", "pfx", "option", "is", "specified", "."], "add_tokens": "if ( ( this . options . key && this . options . cert ) || this . options . pfx ) {", "del_tokens": "if ( this . options . key && this . options . cert ) {", "commit_type": "use"}
{"commit_tokens": ["Fix", "parsing", "Accept", "parameters", "with", "quoted", "equals"], "add_tokens": "params = splitParameters ( match [ 3 ] ) . map ( splitKeyValuePair ) . reduce ( function ( set , p ) { / ** * Split a key value pair . * @ private * / function splitKeyValuePair ( str ) { var index = str . indexOf ( '=' ) ; var key ; var val ; if ( index === - 1 ) { key = str ; } else { key = str . substr ( 0 , index ) ; val = str . substr ( index + 1 ) ; } return [ key , val ] ; }", "del_tokens": "params = splitParameters ( match [ 3 ] ) . map ( function ( s ) { return s . trim ( ) . split ( '=' ) ; } ) . reduce ( function ( set , p ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "gulp", "-", "rename", "to", "renamve", "dev", ".", "scss", "to", "pattern", "-", "library", ".", "scss", "for", "dist"], "add_tokens": "var rename = require ( 'gulp-rename' ) ; logPrefix : \"Pattern Library\" . pipe ( rename ( 'pattern-library.scss' ) )", "del_tokens": "logPrefix : \"Pattern Library\" , browser : [ \"google chrome\" , \"firefox\" , \"safari\" ]", "commit_type": "add"}
{"commit_tokens": ["Remove", "reference", "to", "output", "file", "."], "add_tokens": "var featureParser = require ( './featureParser' ) ; function handleSpec ( spec , output , callback ) {", "del_tokens": "var featureParser = require ( './featureParser' ) , fs = require ( \"fs\" ) ; function handleSpec ( spec , output , callback , outputFile ) {", "commit_type": "remove"}
{"commit_tokens": ["removed", "prev", "/", "names", "globals"], "add_tokens": "var ms = curr - ( debug [ name ] || curr ) ; debug [ name ] = curr ; / ** * The currently active debug mode names . * / debug . names = [ ] ; debug . names . push ( new RegExp ( '^' + name + '$' ) ) ; for ( var i = 0 , len = debug . names . length ; i < len ; i ++ ) { if ( debug . names [ i ] . test ( name ) ) {", "del_tokens": "/ ** * The currently active debug mode names . * / var names = [ ] ; / ** * Previous debug ( ) call . * / var prev = { } ; var ms = curr - ( prev [ name ] || curr ) ; prev [ name ] = curr ; names . push ( new RegExp ( '^' + name + '$' ) ) ; for ( var i = 0 , len = names . length ; i < len ; i ++ ) { if ( names [ i ] . test ( name ) ) {", "commit_type": "remove"}
{"commit_tokens": ["Fix", "bald", "LHS", "for", "object", "names"], "add_tokens": "var binding = \"text: {object: 'string'}\" ; assert . deepEqual ( bindings . text ( ) , { object : \"string\" } )", "del_tokens": "var binding = \"text: { object: 'string' }\" ; assert . equal ( bindings . text ( ) , \"string\" )", "commit_type": "fix"}
{"commit_tokens": ["Remove", "handling", "of", "failed", "send", "error"], "add_tokens": "Mails . find ( { limit : 100 } , function ( e , recs ) { } // else{ // Mails.update({id:r.id, sent:'1'}, function(){ // run(); // }); // }", "del_tokens": "Mails . find ( { limit : 100 , sent : '0' } , function ( e , recs ) { } else { Mails . update ( { id : r . id , sent : '1' } , function ( ) { run ( ) ; } ) ; }", "commit_type": "remove"}
{"commit_tokens": ["improved", "undefined", "check", "and", "more", "documentation"], "add_tokens": "return this . obj !== void 0 ;", "del_tokens": "return typeof this . obj !== 'undefined' ;", "commit_type": "improve"}
{"commit_tokens": ["Use", "same", "verifier", "generation", "for", "both", "methods", "."], "add_tokens": "var verifier = base64url ( crypto . pseudoRandomBytes ( 32 ) ) , challenge ;", "del_tokens": "var verifier , challenge ; verifier = uid ( 43 ) ; verifier = base64url ( crypto . pseudoRandomBytes ( 32 ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Improve", "behavior", "with", "punctuations", "at", "the", "end", "of", "a", "url"], "add_tokens": "hyperlinksPlugin . pattern = / ([a-z-]+:\\/\\/)?[^\\s/]{2,256}\\.[a-z]{2,3}(\\/[^\\s]*[^\\s,.:;?!])? / g ;", "del_tokens": "hyperlinksPlugin . pattern = / ([a-z-]+:\\/\\/)?[^\\s/]{2,256}\\.[a-z]{2,3}(\\/[^\\s]*[^\\s,.:;])? / g ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "nba", ".", "players", "are", "not", "built", "after", "updated"], "add_tokens": "const buildPlayers = require ( \"./util/build-players\" ) ; const players = buildPlayers ( require ( \"../data/players.json\" ) ) ; nba . players = buildPlayers ( data ) ;", "del_tokens": "const players = require ( \"./util/build-players\" ) ( require ( \"../data/players.json\" ) ) ; nba . players = data ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "a", "bug", "with", "Map", "in", "serialize"], "add_tokens": "var replacer = opts . replacer return m ++", "del_tokens": "var replacer = opts . replacer return", "commit_type": "fix"}
{"commit_tokens": ["Added", ".", "gitignore", ".", "Minor", "cleanup", "."], "add_tokens": "response . setHeader ( 'Content-Type' , 'application/dart' ) ; urlRegex : / \\/base\\/__adapter_dart_unittest.dart / , path : '/base/__adapter_dart_unittest.dart' ,", "del_tokens": "var m = mime . lookup ( file , 'text/plain' ) ; if ( file . indexOf ( '.dart' , file . length - '.dart' . length ) !== - 1 ) { m = 'application/dart' ; } response . setHeader ( 'Content-Type' , m ) ; urlRegex : / \\/base\\/__adapter_dartacular.dart / , path : '/base/__adapter_dartacular.dart' ,", "commit_type": "add"}
{"commit_tokens": ["Add", "method", "to", "retrieve", "expect", "deserialized", "Case", "from", "config"], "add_tokens": "attributesSerializedCase : 'kebab-case' , // As it should be in the JSON structure attributesDeserializedCase : 'camelCase' // Ad it should be in Sails' model definitions", "del_tokens": "attributesSerializedCase : 'kebab-case'", "commit_type": "add"}
{"commit_tokens": ["Fixed", "an", "issue", "with", "how", "a", "disconnected", "curated", "device", "s", "name", "is", "read", "."], "add_tokens": "var info = modbus_map . getAddressInfo ( register , 0 ) ; // Try pulling data out of the savedAttributes object first var savedAttributes = device . curatedDevice . savedAttributes ; if ( savedAttributes [ register ] && register !== 'HARDWARE_INSTALLED' ) { // force HW-Installed reg to be c-read. debugCuratedDeviceReads ( 'Cached info for' , register , savedAttributes [ register ] ) ; var pRes = data_parser . parseResult ( info . address , savedAttributes [ register ] , savedAttributes . deviceType ) ; cb ( pRes ) ; } else { // If info wasn't in savedAttributes then try seeing if the value has been cached. device . curatedDevice . cRead ( register ) . then ( function ( result ) { debugCuratedDeviceReads ( 'Reading Register' , register ) ; cb ( result ) ; } , function ( err ) { console . error ( 'ljs-device_scanner ljm_utils: ERROR Cached READING' , register , err ) ; cb ( err ) ; } ) ; }", "del_tokens": "debugCuratedDeviceReads ( 'Reading Register' , register ) ; device . curatedDevice . cRead ( register ) . then ( function ( result ) { cb ( result ) ; } , function ( err ) { console . error ( 'ljs-device_scanner ljm_utils: ERROR Cached READING' , register , err ) ; cb ( err ) ; } ) ; var info = modbus_map . getAddressInfo ( register , 0 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "examples", "demo", "and", "homer", "to", "use", "new", "map", "-", "speed", "transition"], "add_tokens": "{ method : 'map-speed' , speed2 : 3000 } , // km/h", "del_tokens": "{ duration : 2000 } ,", "commit_type": "update"}
{"commit_tokens": ["Add", "more", "tests", "for", "errors"], "add_tokens": "- Otherwise the key should be a ` ` or binary - encoded string , length equal to [ get_key_size ( ) ] ( # cryptget_key_size ) . It will be used as a symmetric key for encryption or signing . / ** Get the size ( in bytes ) that [ Crypt . prototype . encrypt ] ( # cryptprototypeencryptdata - iv - cb ) expects ( optional ) initialisation vectors to be . @ return { Number } Initialisation vector size . * / Crypt . get_iv_size = function ( ) { return undefined ; } ; @ param { Buffer | String } [ iv ] Optional initialisation vector ( salt ) to use for AES encryption . If not supplied , a random one is created . Length must be equal to [ get_iv_size ( ) ] ( # cryptget_iv_size ) .", "del_tokens": "- Otherwise the key should be a ` ` or binary - encoded string , length equal to [ get_key_size ] ( # cryptget_key_size ) . It will be used as a symmetric key for encryption or signing . @ param { Buffer | String } [ iv ] Optional initialisation vector ( salt ) to use for AES encryption . If not supplied , a random one is created .", "commit_type": "add"}
{"commit_tokens": ["Added", "event", "bindings", "to", "wrap", "."], "add_tokens": "var key = 'CRISP_CACHE_KEY_' + keyIdCounter ; } ; cache = new CrispCache ( options ) ; //Bind to user supplied events if ( options . events ) { var eventNames = Object . keys ( options . events ) ; eventNames . map ( function ( eventName ) { cache . on ( eventName , options . events [ eventName ] ) ; } ) ; }", "del_tokens": "var key = 'CRISP_CACHE_KEY_' + keyIdCounter } cache = new CrispCache ( options )", "commit_type": "add"}
{"commit_tokens": ["added", "gui", "option", "to", "switch", "renderer"], "add_tokens": "frictionAir : 0.01 , renderer : 'canvas' // clear scene graph (if defined in controller) var renderController = engine . render . controller ; if ( renderController . clear ) renderController . clear ( engine . render ) ; render . add ( gui , 'renderer' , [ 'canvas' , 'webgl' ] ) . onFinishChange ( function ( value ) { var controller ; if ( value === 'canvas' ) controller = Render ; if ( value === 'webgl' ) controller = RenderPixi ; // remove old canvas engine . render . element . removeChild ( engine . render . canvas ) ; // create new renderer using the same options object var options = engine . render . options ; engine . render = controller . create ( { element : engine . render . element , options : options } ) ; engine . render . options = options ; // update mouse engine . input . mouse = Mouse . create ( engine . render . canvas ) ; engine . mouseConstraint . mouse = engine . input . mouse ; } ) ;", "del_tokens": "frictionAir : 0.01", "commit_type": "add"}
{"commit_tokens": ["Fix", "potential", "error", "in", "postprocessTree"], "add_tokens": "var options = this . app && this . app . options ; var assetLoaderOptions = options && options . assetLoader ;", "del_tokens": "var options = this . app && this . app . options && this . app . options ; var assetLoaderOptions = options . assetLoader ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "TChannel", "version", "Ringpop", "version", "timestamp", "and", "uptime", "stats", "to", "the", "/", "admin", "/", "stats", "endpoint"], "add_tokens": "var packageJSON = require ( './package.json' ) ; var getTChannelVersion = require ( './lib/util.js' ) . getTChannelVersion ; this . startTime = Date . now ( ) ; //used for calculating uptime this . tchannelVersion = getTChannelVersion ( ) ; this . ringpopVersion = packageJSON . version ; var timestamp = Date . now ( ) ; var uptime = timestamp - this . startTime ; var stats = { ring : Object . keys ( this . ring . servers ) , version : this . ringpopVersion , timestamp : timestamp , uptime : uptime if ( this . tchannelVersion !== null ) { stats . tchannelVersion = this . tchannelVersion ; } return stats ;", "del_tokens": "return { ring : Object . keys ( this . ring . servers )", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "individually", "disabling", "js", "or", "css", "inlining"], "add_tokens": "if ( options . inlineJS == null ) options . inlineJS = true ; if ( options . inlineCSS == null ) options . inlineCSS = true ; inline : ( type == 'js' ) ? options . inlineJS : options . inlineCSS , var clean = function ( source ) { return source . context . replace ( ' ' + options . attribute , '' ) ; } , type , content ; content = clean ( source ) ; // Disabled via options.inlineXX } else { // Remove 'inline' attribute content = clean ( source ) ; // Replace inlined content in html (PR #5) html = html . replace ( source . context , function ( ) { return content ; } ) ;", "del_tokens": "inline : true , var type , content ; content = source . context . replace ( ' ' + options . attribute , '' ) ; // Replace inlined content in html (PR #5) html = html . replace ( source . context , function ( ) { return content ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "short", "README", ".", "md", "file", "about", "Luigi", "Core"], "add_tokens": "exclude : [ 'package.json' , 'README.md' ] ,", "del_tokens": "exclude : [ 'package.json' ] ,", "commit_type": "add"}
{"commit_tokens": ["Move", "the", "beforeStart", "callback", "above", "doing", "anything", "to", "allow", "the", "client", "to", "return", "false", "from", "it"], "add_tokens": "if ( _this . options . beforeStart ( this . originalTable ) === false ) { return ; }", "del_tokens": "_this . options . beforeStart ( this . originalTable ) ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "browser", "configuration", "in", "karma", "config", "."], "add_tokens": "configFile : 'karma.conf.js'", "del_tokens": "configFile : 'karma.conf.js' , browsers : [ 'Chrome' ]", "commit_type": "fix"}
{"commit_tokens": ["fix", "grunt", "test", "(", "browser", "+", "node", ")", "task"], "add_tokens": "'mochaTest:ci'", "del_tokens": "'test:node'", "commit_type": "fix"}
{"commit_tokens": ["Move", "empty", "state", "&", "paginator", "logic", "into", "Menu"], "add_tokens": "const { defaultSelected } = this . props ; /* eslint-disable no-console */ console . warn ( /* eslint-enable no-console */", "del_tokens": "const { defaultSelected , paginateResults } = this . props ; console . error (", "commit_type": "move"}
{"commit_tokens": ["make", "grid", "spread", "props", "and", "inherit", "classes"], "add_tokens": "export default class Grid extends Component { this . props . className , < div { ... this . props } className = { classes } >", "del_tokens": "class Grid extends Component { divided : PropTypes . bool , padded : PropTypes . bool , stretched : PropTypes . bool , style : PropTypes . object , this . props . className , { padded : this . props . padded } , { 'equal width' : this . props . stretched } , { divided : this . props . divided } , < div className = { classes } style = { this . props . style } > export default Grid ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "perf", "tests", "in", "node", "env"], "add_tokens": "transparency_t . render ( data ) ; result . append ( \"Fastest is \" + this . filter ( \"fastest\" ) . pluck ( \"name\" ) + \"\\n\" ) ; return result . trigger ( \"complete\" ) ;", "del_tokens": "return result . append ( \"Fastest is \" + this . filter ( \"fastest\" ) . pluck ( \"name\" ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "sleep", "()", "and", "sleep", ".", "untilEvent", "()"], "add_tokens": "if ( arguments . length === 0 ) { // return anonymous channel that never closes; // useful for processes since every yield is combined // with an implicit close channel. return csp . chan ( ) ; } else { return csp . timeout ( ms ) ; } sleep . untilEvent = function ( obj , eventName ) { let chan = csp . chan ( ) ; Ember . addListener ( obj , eventName , null , event => { csp . putAsync ( chan , event ) ; // need to close chan? does it matter if it's anonymous? } , true ) ; return chan ; } ;", "del_tokens": "return csp . timeout ( ms ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "scratch", "stream", "test", "+", "clean"], "add_tokens": "// if (!result) console.log('READ FAILED:', node.toString('hex')) // creates a new trie backed by the same db // and starting at the same root this . _lookupNode ( root , function ( err , value ) { cb ( err , ! ! value )", "del_tokens": "if ( ! result ) console . log ( 'READ FAILED:' , node . toString ( 'hex' ) ) // creates a new trie with a shared cache this . _lookupNode ( root , function ( value ) { cb ( ! ! value )", "commit_type": "add"}
{"commit_tokens": ["Adding", "test", "for", "simple", "conf"], "add_tokens": "var goToStateAndFlush ; / ** * Due to templateUrl definitions in $state configuration , * httpBackend will try to load the view for each state asked . * / beforeEach ( module ( function ( ) { return function ( $httpBackend , $state ) { // httpBackend return something for each view (no status 404). $httpBackend . when ( 'GET' , 'views/home.html' ) . respond ( 'dummy home view' ) ; $httpBackend . when ( 'GET' , 'views/room_list.html' ) . respond ( 'dummy room_list view' ) ; $httpBackend . when ( 'GET' , 'views/room_detail.html' ) . respond ( 'dummy room_detail view' ) ; $httpBackend . when ( 'GET' , 'views/room_form.html' ) . respond ( 'dummy room_form view' ) ; // Helpful function for navigate within states. goToStateAndFlush = function ( state , stateParams ) { $state . transitionTo ( state , stateParams ) ; $httpBackend . flush ( ) ; } ; } ; } ) ) ; * ( we don ' // Order of arguments has importance here (overriding purpose). goToStateAndFlush ( 'room' ) ; goToStateAndFlush ( 'home' ) ; goToStateAndFlush ( 'room' ) ; goToStateAndFlush ( 'room.detail' , { roomId : 1 } ) ;", "del_tokens": "* ( we don ' // Order of arguments has importance here. goToState ( 'room' ) ; goToState ( 'home' ) ; goToState ( 'room' ) ; goToState ( 'room.detail' , { roomId : 1 } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "delay", "to", "<Spinner", ">"], "add_tokens": "/ ** * Delay after which spinner should be visible . * / delay : PropTypes . number , size : 40 , delay : 0 } constructor ( { delay } ) { super ( ) this . state = { isVisible : delay === 0 } if ( ! this . state . isVisible ) { return null } componentDidMount ( ) { const { delay } = this . props if ( delay > 0 ) { this . delayTimer = setTimeout ( ( ) => { this . setState ( { isVisible : true } ) } , delay ) } } componentWillUnmount ( ) { clearTimeout ( this . delayTimer ) }", "del_tokens": "size : 40", "commit_type": "add"}
{"commit_tokens": ["Remove", "stream", "-", "length", "package"], "add_tokens": "var jsDAV = require ( \"jsDAV/lib/jsdav\" ) ,", "del_tokens": "var streamLength = require ( \"stream-length\" ) , jsDAV = require ( \"jsDAV/lib/jsdav\" ) ,", "commit_type": "remove"}
{"commit_tokens": ["added", "ability", "to", "disable", "x", "-", "forwarded", "-", "for", "header", "for", "proxy"], "add_tokens": "xfwd : ( opts . xfwd != false ) ? true : false ,", "del_tokens": "xfwd : true ,", "commit_type": "add"}
{"commit_tokens": ["use", "__DEV__", "instead", "of", "DEBUG"], "add_tokens": "if ( __DEV__ ) {", "del_tokens": "// for now if ( typeof DEBUG !== 'undefined' && DEBUG ) {", "commit_type": "use"}
{"commit_tokens": ["use", "url", "instead", "of", "originalUrl"], "add_tokens": "res . pageLinks = _ . get ( pageLinks , req . url ) || _ . get ( pageLinks , matchPaths ( pageLinks , req . url ) ) || [ ] ;", "del_tokens": "res . pageLinks = _ . get ( pageLinks , req . originalUrl ) || _ . get ( pageLinks , matchPaths ( pageLinks , req . originalUrl ) ) || [ ] ;", "commit_type": "use"}
{"commit_tokens": ["added", "dynamic", "map", "service", "layer", "to", "layer", "events", "test", "/", "example", "pages"], "add_tokens": "title : 'Layer Events' , description : 'Shows how to listen for events raised by layer directives and get a direct reference to the layer object.' , url : urlPrefixes . templateHref + 'layer-events' path : urlPrefixes . routePath + 'layer-events' , templateUrl : urlPrefixes . routeTemplateUrl + 'layer-events.html' , controller : 'LayerEventsCtrl'", "del_tokens": "title : 'Feature Layer Events' , description : 'Shows how to listen for feature layer events raised by the feature layer directive and get a direct reference to the layer object.' , url : urlPrefixes . templateHref + 'feature-layer-events' path : urlPrefixes . routePath + 'feature-layer-events' , templateUrl : urlPrefixes . routeTemplateUrl + 'feature-layer-events.html' , controller : 'FeatureLayerEventsCtrl'", "commit_type": "add"}
{"commit_tokens": ["Use", "grunt", ".", "file", ".", "expand", "instead", "of", "expandFiles"], "add_tokens": "files = grunt . file . expand ( config . src ) , } ;", "del_tokens": "files = grunt . file . expandFiles ( config . src ) , } ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "for", "broken", "unit", "test"], "add_tokens": "remodelExists : undefined , remodelFn : null , remodelWatchers : 'null' , remodelEvents : 'null' , useRemodelOnWatch : undefined , useRemodelOnEvent : undefined ,", "del_tokens": "rebindExists : undefined , rebindFn : null , rebindWatchers : 'null' , rebindEvents : 'null' , useRebindOnWatch : undefined , useRebindOnEvent : undefined ,", "commit_type": "fix"}
{"commit_tokens": ["Added", ":", "tests", "for", "two", "promises"], "add_tokens": "off : function ( event , callback ) {", "del_tokens": "off : function ( event , callback ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "resources", "in", "link", "process", "."], "add_tokens": "source . tag ( \"innerJS\" , innerJS ) ; source . tag ( \"innerCSS\" , innerCSS ) ;", "del_tokens": "source . tag ( \"innerJS\" , \"\" ) ; source . tag ( \"innerCSS\" , \"\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "wrapper", "to", "handle", "the", "maximum", "width", "of", "the", "info", "window", ".", "Reworked", "the", "sizing", "of", "the", "pointer", "background", "."], "add_tokens": "content : '<div><h1>Snazzy Info Windows</h1><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque ex ipsum, porta ut felis sit amet, porttitor laoreet neque. Maecenas vel lacinia quam. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque ex ipsum, porta ut felis sit amet, porttitor laoreet neque. Maecenas vel lacinia quam. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque ex ipsum, porta ut felis sit amet, porttitor laoreet neque. Maecenas vel lacinia quam.</p></div>' , //content: '<div>Test Test</div>', // wrapperClass: 'multi-info-window', // backgroundColor: 'black', // //padding: '40px', // //borderRadius: '2px 20px', // fontColor: '#eee', // fontSize: '16px', // pointer: '30px', // border: { // width: '20px' // }, // shadow: { // h: '10px', // v: '10px', // opacity: 0.5, // color: 'black' // }", "del_tokens": "content : '<div><b>Testing</b></div><div>Snazzy Maps</div>' , wrapperClass : 'multi-info-window' , offset : { left : '20px' , top : '40px' } , backgroundColor : 'black' , padding : '40px' , borderRadius : '2px 20px' , fontColor : '#eee' , fontSize : '20px' , pointer : '30px' , border : { width : '20px' } , shadow : { h : '10px' , v : '10px' , opacity : 0.5 , color : 'black' }", "commit_type": "add"}
{"commit_tokens": ["Added", "move", "up", "/", "down", "capability", "for", "widgets"], "add_tokens": "this . widgetCanMoveUp = function ( widget ) { return ( self . widgets . indexOf ( widget ) >= 1 ) ; } this . widgetCanMoveDown = function ( widget ) return ( i < self . widgets ( ) . length - 1 ) ; } this . moveWidgetUp = function ( widget ) { if ( self . widgetCanMoveUp ( widget ) ) { var i = self . widgets . indexOf ( widget ) ; if ( self . widgetCanMoveDown ( widget ) ) { var i = self . widgets . indexOf ( widget ) ; var array = self . widgets ( ) ;", "del_tokens": "this . moveWidgetUp = function ( widget ) if ( i >= 1 ) { var i = self . widgets . indexOf ( widget ) ; var array = self . widgets ( ) ; if ( i < array . length - 1 ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "the", "travis", "ci", "build", "and", "adding", "the", "doc", "for", "tests"], "add_tokens": "'!bower_components/**' , '!test/helpers/ember-template-compiler.js'", "del_tokens": "'!bower_components/**'", "commit_type": "fix"}
{"commit_tokens": ["Fix", "displaying", "of", "progress", "bar", "value"], "add_tokens": "if ( props . value ) { meterProps . style = meterProps . style || { } ; meterProps . style . width = ` ${ props . value } ` ; } * Progress meter sub - component . * Progress meter with text sub - component . * Progress meter text sub - component . * Native progress component .", "del_tokens": "* ProgressMeter sub - component . * ProgressMeterWithText sub - component . * ProgressMeterText sub - component . * NativeProgress component .", "commit_type": "fix"}
{"commit_tokens": ["Fix", "view", "path", "for", "windows"], "add_tokens": "var Handlebars , fs , layoutTemplate , _ , path ; path = require ( 'path' ) ; basePath = path . join ( 'app' , 'views' ) ;", "del_tokens": "var Handlebars , fs , layoutTemplate , _ ; basePath = 'app/views' ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "localization", "to", "pt", "-", "BR"], "add_tokens": "* add it to your application module ' * * $translateProvider . translations ( 'pt-BR' , { DIALOGS_ERROR : \"Erro\" , DIALOGS_ERROR_MSG : \"Ocorreu um erro inesperado.\" , DIALOGS_CLOSE : \"Fechar\" , DIALOGS_PLEASE_WAIT : \"Por favor aguarde\" , DIALOGS_PLEASE_WAIT_ELIPS : \"Por favor aguarde...\" , DIALOGS_PLEASE_WAIT_MSG : \"Aguardando que a operação termine.\", DIALOGS_PERCENT_COMPLETE : \"% Completados\" , DIALOGS_NOTIFICATION : \"Notificação\", DIALOGS_NOTIFICATION_MSG : \"Notificação de aplicação desconhecida.\", DIALOGS_CONFIRMATION : \"Confirmação\", DIALOGS_CONFIRMATION_MSG : \"Confirmação requerida.\", DIALOGS_OK : \"OK\" , DIALOGS_YES : \"Sim\" , DIALOGS_NO : \"Não\" } ) ;", "del_tokens": "* add it to your application module ' * *", "commit_type": "add"}
{"commit_tokens": ["move", "some", "shared", "tests", "into", "a", "shared", "lib"], "add_tokens": "'use strict' ; var sharedExamplesFor = require ( '../shared/examplesFor' ) ; sharedExamplesFor ( require ( '../../lib/middleware/localfiles' ) ) ; it ( 'should load a local file' , function ( ) { //TODO: implement me expect ( true ) . to . be . true ;", "del_tokens": "describe ( 'The module' , function ( ) { var module = require ( '../../lib/middleware/localfiles' ) ; it ( 'should provide a create method' , function ( ) { expect ( module . create ) . to . be . a ( 'function' ) ; } ) ; it ( 'should create new local file handlers' , function ( ) { expect ( module . create ( { } ) ) . to . be . a ( 'function' ) ; } ) ;", "commit_type": "move"}
{"commit_tokens": ["added", "initial", "error", "parsing", "support", "for", "flow"], "add_tokens": "const { add } = require ( './test' ) ;", "del_tokens": "function add ( a : number , b : number ) { return a + b ; }", "commit_type": "add"}
{"commit_tokens": ["Fix", "negative", "indexes", "(", "i", ".", "e", ".", "make", "-", "0", "work", ")", "and", "get", "rid", "of", "an", "ifelse", "."], "add_tokens": "var num = ( isNaN ( + id ) || id === '' ) ? null : + id , negative = id . indexOf ( '-' ) === 0 ; value = first [ negative ? arrayLength + num : num ] ; value = args [ autoIndex + 1 ] ; // Indexed or automatic arguments value = args [ ( num !== null ? ( negative ? argsLength + num : num ) : autoIndex ) + 1 ] ;", "del_tokens": "var num = ( isNaN ( + id ) || id === '' ) ? null : + id ; value = first [ num >= 0 ? num : arrayLength + num ] ; value = args [ 1 + autoIndex ] ; // Handle given arguments indexes } else if ( num !== null ) { value = args [ 1 + ( num >= 0 ? num : argsLength + num ) ] ; // Handle automatic arguments indexes value = args [ 1 + autoIndex ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "svg", "icon", "docs", "to", "readme"], "add_tokens": "* SVG CLASSES", "del_tokens": "* SVG SPRITES", "commit_type": "add"}
{"commit_tokens": ["Use", "increment", "method", "in", "example"], "add_tokens": "b2 . increment ( ) ; if ( b2 . value >= b2 . getTotal ( ) ) {", "del_tokens": "// the bar value - will be linear incremented var value = 0 ; value ++ ; // update the bar value b2 . update ( value ) ; if ( value >= b2 . getTotal ( ) ) {", "commit_type": "use"}
{"commit_tokens": ["Changed", "default", "projection", "definition", "for", "map", "to", "900913"], "add_tokens": "var DEFAULT_PROJECTION = \"EPSG:900913\" ; //\"+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs\";", "del_tokens": "var DEFAULT_PROJECTION = \"EPSG:3857\" ; //\"+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs\";", "commit_type": "change"}
{"commit_tokens": ["fixes", "an", "issue", "about", "createSpy", "API", "."], "add_tokens": "global [ 'jasmine' ] . createSpy = function ( name , fn ) { var spy = originalCreateSpy ( name , fn ) ;", "del_tokens": "global [ 'jasmine' ] . createSpy = function ( name ) { var spy = originalCreateSpy ( name ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "memory", "leak", "on", "NodeJS", "while", "using", "WebSocketStream"], "add_tokens": "// according to https://github.com/baygeldin/ws-streamify/issues/1 // Nodejs WebSocketServer cause memory leak // Handlers like onerror, onclose, onmessage and onopen are accessible via setter/getter // And setter first of all fires removeAllListeners, that doesnt make inner array of clients on WebSocketServer cleared ever var eventListenerSupport = ( 'undefined' === typeof socket . addEventListener ) if ( eventListenerSupport ) { socket . addEventListener ( 'open' , onopen ) } else { socket . onopen = onopen } if ( eventListenerSupport ) { socket . addEventListener ( 'close' , onopen ) socket . addEventListener ( 'error' , onerror ) socket . addEventListener ( 'message' , onmessage ) } else { socket . onclose = onclose socket . onerror = onerror socket . onmessage = onmessage }", "del_tokens": "socket . onopen = onopen socket . onclose = onclose socket . onerror = onerror socket . onmessage = onmessage", "commit_type": "fix"}
{"commit_tokens": ["fixes", "a", "problem", "if", "npmIgnore", "does", "not", "exist"], "add_tokens": "if ( ! alwaysIgnore [ name ] && ( ! npmIgnore || ! npmIgnore [ name ] ) ) {", "del_tokens": "if ( ! alwaysIgnore [ name ] && ! npmIgnore || ! npmIgnore [ name ] ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "a", "tag", "to", "a", "config", "handler"], "add_tokens": "tags : [ 'modifyCommandConfig' , 'modifyOptionConfig' ] ,", "del_tokens": "tags : [ 'modifyCommandConfig' ] ,", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "unit", "test", "framework", "from", "nodeunit", "to", "mocha", "/", "chai", "and", "fixed", "audit", "security", "issues", "."], "add_tokens": "tasks : [ 'clean' , 'jshint' , 'mochaTest' , 'concat' , 'uglify' ] , test : 'mocha' , // grunt-mocha-test plugin configuration (unit testing) mochaTest : { test : { options : { reporter : 'spec' } , src : [ 'test/**/*.js' ] } grunt . loadNpmTasks ( 'grunt-mocha-test' ) ; grunt . registerTask ( 'build' , 'Build the library.' , [ 'clean:build' , 'jshint' , 'mochaTest' , 'concat' , 'uglify' ] ) ; grunt . registerTask ( 'default' , 'Default targets.' , [ 'generate' , 'build' ] ) ;", "del_tokens": "tasks : [ 'clean' , 'jshint' , 'nodeunit' , 'concat' , 'uglify' ] , // grunt-contrib-nodeunit plugin configuration (unit testing) nodeunit : { tests : 'test/**/*.js' grunt . loadNpmTasks ( 'grunt-contrib-nodeunit' ) ; grunt . registerTask ( 'build' , 'Build the library.' , [ 'clean:build' , 'jshint' , 'nodeunit' , 'concat' , 'uglify' ] ) ; grunt . registerTask ( 'default' , 'The default task.' , [ 'clean:build' , 'jshint' , 'nodeunit' , 'concat' , 'uglify' ] ) ;", "commit_type": "change"}
{"commit_tokens": ["Adds", "browser", "example", "and", "refactors", "."], "add_tokens": "context ( 'with some objects' , function ( ) { it ( 'should behave correct' , function ( ) { qt . debug ( true ) ; it ( 'should behave correct' , function ( ) { var qt = qtFactory ( new Vec2 ( 100 , 100 ) , 4 ) , o1 = oFactory ( null , new Vec2 ( 2 , 2 ) , 1 ) , o2 = oFactory ( null , new Vec2 ( 4 , 4 ) , 1 ) , o3 = oFactory ( null , new Vec2 ( 4 , 2 ) , 1 ) , o4 = oFactory ( null , new Vec2 ( 2 , 4 ) , 1 ) , o5 = oFactory ( null , new Vec2 ( 6 , 2 ) , 1 ) ; qt . debug ( true ) ; qt . addObjects ( [ o1 , o2 , o3 , o4 , o5 ] ) ; qt . getQuadrantCount ( ) . should . eql ( 21 ) ; qt . getLeafQuadrants ( ) . length . should . eql ( 16 ) ; } ) ;", "del_tokens": "context ( 'with two objects and one limit' , function ( ) { it ( 'should return five quadrants' , function ( ) { } ) ; context ( 'with some objects' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Implemented", "smaller", "background", "pixel", "buffer"], "add_tokens": "this . bgBuffer . set ( background , this . index ) ; this . spriteBuffer . set ( sprites . subarray ( 0 , 256 ) , this . index ) ; // TODO: shorten buffers", "del_tokens": "this . bgBuffer . set ( background . subarray ( 0 , 256 ) , this . index ) ; // TODO: shorten buffers this . spriteBuffer . set ( sprites . subarray ( 0 , 256 ) , this . index ) ;", "commit_type": "implement"}
{"commit_tokens": ["removed", "commented", "code", "and", "changed", "the", "waiting", "sentence"], "add_tokens": "grunt . log . write ( 'Simple Watch, Waiting...' ) ;", "del_tokens": "grunt . log . write ( 'Waiting for file updates on shared folder...' ) ; // Close watcher. // watchedFiles[filepath].close();", "commit_type": "remove"}
{"commit_tokens": ["Fixing", "an", "issue", "where", "the", "error", "handler", "was", "not", "called", "on", "nonexistent", "images"], "add_tokens": "fs . createReadStream ( filename ) . once ( 'error' , function ( err ) { fn ( err , undefined ) ; } ) . pipe ( image ) . once ( 'parsed' , function ( ) { } ) . pipe ( image ) ;", "del_tokens": "fs . createReadStream ( filename ) . pipe ( image ) . once ( 'parsed' , function ( ) { } ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "native", "object", "extension", "if", "available"], "add_tokens": "if ( / ^f / . test ( typeof Object . assign ) ) { Object . assign . apply ( Object , args ) ; } else { for ( i in args ) { if ( i > 0 ) { for ( prop in args [ i ] ) { if ( args [ i ] . hasOwnProperty ( prop ) ) { base [ prop ] = args [ i ] [ prop ] ; }", "del_tokens": "for ( i in args ) { if ( i > 0 ) { for ( prop in args [ i ] ) { if ( args [ i ] . hasOwnProperty ( prop ) ) { base [ prop ] = args [ i ] [ prop ] ;", "commit_type": "use"}
{"commit_tokens": ["Move", "openpgp", "code", "-", "signing", "script", "to", "build", "folder"], "add_tokens": "const child = fork ( 'build/openpgp.sign.js' , [ './dist/js/main.bundle.js' ] , opts ) // const child = spawn('node', ['build/openpgp.sign.js', './dist/js/main.bundle.js'])", "del_tokens": "const child = fork ( 'src/openpgp.sign.js' , [ './dist/js/main.bundle.js' ] , opts ) // const child = spawn('node', ['src/openpgp.sign.js', './dist/js/main.bundle.js'])", "commit_type": "move"}
{"commit_tokens": ["add", "feature", "to", "close", "popup", "when", "a", "tag", "is", "scanned", "update", "documentation"], "add_tokens": "start ( { onSessionClosedIOS } = { } ) { registerTagEvent ( listener , alertMessage = '' , invalidateAfterFirstRead = false ) { NativeNfcManager . registerTagEvent ( alertMessage , invalidateAfterFirstRead , ( ) => {", "del_tokens": "start ( { onSessionClosedIOS } = { } ) { registerTagEvent ( listener , alertMessage = '' ) { NativeNfcManager . registerTagEvent ( alertMessage , ( ) => {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "typo", "in", "setting", "name", "."], "add_tokens": "app . set ( 'stormpathSocial' , opts . social || JSON . parse ( process . env . STORMPATH_SOCIAL || '{}' ) || { } )", "del_tokens": "app . set ( 'stormpathSocial' , opts . stormpathSocial || JSON . parse ( process . env . STORMPATH_SOCIAL || '{}' ) || { } )", "commit_type": "fix"}
{"commit_tokens": ["Adds", "AVA", "and", "updates", "tests", "to", "use", "it", "."], "add_tokens": "import test from 'ava' import { take } from 'redux-saga/effects' import { watchStartup } from '../../App/Sagas/StartupSaga' import Types from '../../App/Actions/Types' test ( 'watches for the right action' , t => { const gen = watchStartup ( ) const next = ( mock ) => gen . next ( mock ) . value t . deepEqual ( next ( ) , take ( Types . STARTUP ) ) } )", "del_tokens": "// import test from 'ava' // import { describe, it } from 'mocha' // import { expect } from 'chai' // import { take } from 'redux-saga/effects' // import { watchStartup } from '../../App/Sagas/StartupSaga' // import Types from '../../App/Actions/Types' // describe('watchStartup', () => { // it('listens for the STARTUP action type', () => { // const gen = watchStartup() // const actual = gen.next().value // const expected = take(Types.STARTUP) // expect(actual).to.deep.equal(expected) // }) // })", "commit_type": "add"}
{"commit_tokens": ["Add", "back", "support", "for", "per", "test", "init", "file", "and", "remove", "global", "init", "file", "option", "."], "add_tokens": "var testObj ; function TestFile ( filePath , testInitFile , timeout , concurrency ) { this . _testInitFile = testInitFile ; // if test init file is present, run init function in it function ( callback ) { if ( ! self . _testInitFile ) { callback ( ) ; return ; } runInitFunction ( self . _testInitFile , callback ) ; } ,", "del_tokens": "function TestFile ( filePath , timeout , concurrency ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "for", "darken", "/", "lighten", "fix", "these", "functions"], "add_tokens": "var min = colorMode . min [ index ] ; var max = colorMode . max [ index ] ; var brightness = newColor . values [ index ] + amount * ( max - min ) / 2 ; newColor . values [ index ] = Math . min ( max , Math . max ( min , brightness ) ) ;", "del_tokens": "var brightness = newColor . values [ index ] + amount * ( colorMode . max [ index ] - colorMode . min [ index ] ) ; newColor . values [ index ] = Math . min ( colorMode . max [ index ] , Math . max ( colorMode . min [ index ] , brightness ) ) ; if ( amount === undefined ) { amount = 0.1 ; }", "commit_type": "add"}
{"commit_tokens": ["Use", "cssnano", "instead", "of", "csswring", "for", "tests"], "add_tokens": "require ( 'cssnano' )", "del_tokens": "require ( 'csswring' )", "commit_type": "use"}
{"commit_tokens": ["made", "modal", "add", "class", "modal", "hide", "for", "user", "if", "user", "didnt", "specify", "added", "test", "for", "it"], "add_tokens": "'<div ui-modal ng-model=\"modalShown\">' it ( 'should add \"modal hide\" class for you' , function ( ) { expect ( elm . hasClass ( \"modal hide\" ) ) . toBe ( true ) ; } ) ;", "del_tokens": "'<div class=\"modal hide\" ui-modal ng-model=\"modalShown\">'", "commit_type": "make"}
{"commit_tokens": ["Updated", "eslint", "and", "ran", "fix", "against", "the", "bootstrap", "js"], "add_tokens": "( function ( $ ) { } else if ( $bg . hasClass ( '.object-fit-fill' ) ) { } else if ( $bg . hasClass ( '.object-fit-none' ) ) { } else if ( $bg . hasClass ( '.object-fit-scale-down' ) ) { } else { $ . fn . mediaBackground = function ( ) { this . each ( function ( ) { const $bg = $ ( this ) ; } ; } ( jQuery ) ) ;", "del_tokens": "( function ( $ ) { } else if ( $bg . hasClass ( '.object-fit-fill' ) ) { } else if ( $bg . hasClass ( '.object-fit-none' ) ) { } else if ( $bg . hasClass ( '.object-fit-scale-down' ) ) { } else { $ . fn . mediaBackground = function ( ) { this . each ( function ( ) { var $bg = $ ( this ) ; } } ) ( jQuery ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "functionality", "for", "weighted", "postions", "in", "heatmap", "component"], "add_tokens": "return { location : new google . maps . LatLng ( pos . lat , pos . lng ) , weight : pos . weight }", "del_tokens": "return new google . maps . LatLng ( pos . lat , pos . lng ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "unused", "image", "state", "setting"], "add_tokens": "return [ ] . concat ( fullResults , partialResults ) const { id } = token ;", "del_tokens": "return [ ] . concat ( fullResults , partialResults ) const { id , image , address } = token ; // dispatch only the changed images if ( images [ address ] !== image ) { dispatch ( setAddressImage ( address , image , true ) ) ; }", "commit_type": "remove"}
{"commit_tokens": ["Fix", "bug", ":", "it", "is", "now", "possible", "to", "travel", "to", "initial", "state"], "add_tokens": "if ( ! run || ! event ) { if ( event . type === \"action\" ) { return event . stateAfter && event . stateAfter !== run . currentState ; } if ( event . type === \"init\" ) { return event . state !== run . currentState ; } return false ;", "del_tokens": "if ( ! run || ! event || event . type !== \"action\" ) { return event . stateAfter && event . stateAfter !== run . currentState ;", "commit_type": "fix"}
{"commit_tokens": ["Improved", ".", "race", "and", ".", "parallel"], "add_tokens": "needCtx = maxArgsLength > 3 || p . parallel || p . race , priority = o . priority , maxParallel = o . maxParallel , maxParallelIsNumber = typeof maxParallel === 'number' ; iFn += 'var fIsPromise, res;' ; res = f ; } else if ( f ) { res = baseCb ( $ { cbArgs } ) ; if ( p . parallel || p . race ) { const fn = p . parallel ? 'wait' : 'race' ; iFn += ws ` if ( maxParallelIsNumber ) { ctx [ $ { fn } ] ( maxParallel , new Promise ( ( r ) => r ( res ) ) ) ; } else { ctx [ $ { fn } ] ( new Promise ( ( r ) => r ( res ) ) ) ; } ` ; } else { iFn += 'return res;' ; }", "del_tokens": "needCtx = maxArgsLength > 3 , priority = o . priority ; iFn += 'var fIsPromise;' ; return f ; } if ( f ) { return baseCb ( $ { cbArgs } ) ;", "commit_type": "improve"}
{"commit_tokens": ["Use", "UTF8", "connect", "-", "busboy", "and", "convert", "error", "to", "string"], "add_tokens": "return next ( new restify . InternalError ( err . toString ( ) ) ) ;", "del_tokens": "return next ( new restify . InternalError ( err ) ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "getWrappedComponent", "method", "to", "provide", "and", "mergingProvide", "decorators"], "add_tokens": "* ProvidedDemo . getWrappedComponent ( ) === Demo ; // true * export const provide = ctx => Child => { const ProviderWrapper = props => h ( Provider , ctx , h ( Child , props ) ) ; ProviderWrapper . getWrappedComponent = Child && Child . getWrappedComponent || ( ( ) => Child ) ; return ProviderWrapper ; } ; * ProvidedDemo . getWrappedComponent ( ) === Demo ; // true * export const mergingProvide = ctx => Child => { const MergingProviderWrapper = props => h ( MergingProvider , ctx , h ( Child , props ) ) ; MergingProviderWrapper . getWrappedComponent = Child && Child . getWrappedComponent || ( ( ) => Child ) ; return MergingProviderWrapper ; } ;", "del_tokens": "export const provide = ctx => Child => props => h ( Provider , ctx , h ( Child , props ) ) ; export const mergingProvide = ctx => Child => props => h ( MergingProvider , ctx , h ( Child , props ) ) ;", "commit_type": "add"}
{"commit_tokens": ["change", "inputClassName", "syntax", "to", "wrapperClassName"], "add_tokens": "const combinedClassName = ` ${ ownProps . attribute } ${ ownProps . className } `", "del_tokens": "const combinedClassName = ` ${ ownProps . className } ${ ownProps . inputClassName } `", "commit_type": "change"}
{"commit_tokens": ["fixed", "title", "overlapping", "issue", "and", "metapositioning"], "add_tokens": "chart . setXScales ( ) . resize ( ) $ ( \"#chartContainer\" ) . css ( \"height\" , chart . g . series [ 0 ] . data . length * 22 + chart . g . padding . top + chart . g . padding . bottom ) chart . resize ( ) . setPadding ( ) ;", "del_tokens": "chart . resize ( ) $ ( \"#chartContainer\" ) . css ( \"height\" , chart . g . series [ 0 ] . data . length * 22 + chart . g . padding . top + chart . g . padding . bottom ) chart . setPadding ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "a", "bunch", "of", "ordering", "issues"], "add_tokens": "App . __container__ . lookup ( 'controller:mixinStack' ) . set ( 'model' , [ ] ) ;", "del_tokens": "App . __container__ . lookup ( 'controller:application' ) . set ( 'mixinDetails' , [ ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["change", "example", "to", "use", "symbol", "to", "make", "handler", "more", "private"], "add_tokens": "const changeHandlerKey = Symbol ( 'changeHandler' ) ; // change observer implementation example for a property this [ changeHandlerKey ] = ( p_NewValue , p_OldValue ) => { this . $ . output . textContent += ` ${ this . constructor . is } ${ p_OldValue } ${ p_NewValue } \\n ` ; } observer : changeHandlerKey , // (optional) the name or symbol of a function in the class to be called when the value of the property is changed", "del_tokens": "observer : '_myChangeHandler' , // (optional) the name of a function in the class to be called when the value of the property is changed // change observer implementation example for a property _myChangeHandler ( p_NewValue , p_OldValue ) { this . $ . output . textContent += ` ${ this . constructor . is } ${ p_OldValue } ${ p_NewValue } \\n ` ; }", "commit_type": "change"}
{"commit_tokens": ["Fix", "type", "and", "update", "comments", "."], "add_tokens": "// Revert child node to original element which may exist if modal is // consecutively opened without first being closed.", "del_tokens": "// Revert child node which may exist if modal is consequetively opened // without being closed.", "commit_type": "fix"}
{"commit_tokens": ["Changed", "ffi", "to", "_ffi", "in", "node", "tests"], "add_tokens": "assert . equal ( run . _ffi . cxs_init ( null ) , 0 ) ; assert . equal ( run . _ffi . cxs_init ( 'garbage' ) , 1004 ) ; assert . equal ( run . _ffi . cxs_connection_create ( \"dog, cat, man\" , intPtr ) , 0 ) assert . equal ( run . _ffi . cxs_connection_connect ( 2 , \"SMS\" ) , 1003 ) assert . equal ( run . _ffi . cxs_connection_get_data ( 2 ) , null ) assert . equal ( run . _ffi . cxs_connection_get_state ( 2 , intPtr ) , 0 ) assert . equal ( run . _ffi . cxs_connection_release ( 2 ) , 1003 )", "del_tokens": "assert . equal ( run . ffi . cxs_init ( null ) , 0 ) ; assert . equal ( run . ffi . cxs_init ( 'garbage' ) , 1004 ) ; assert . equal ( run . ffi . cxs_connection_create ( \"dog, cat, man\" , intPtr ) , 0 ) assert . equal ( run . ffi . cxs_connection_connect ( 2 , \"SMS\" ) , 1003 ) assert . equal ( run . ffi . cxs_connection_get_data ( 2 ) , null ) assert . equal ( run . ffi . cxs_connection_get_state ( 2 , intPtr ) , 0 ) assert . equal ( run . ffi . cxs_connection_release ( 2 ) , 1003 )", "commit_type": "change"}
{"commit_tokens": ["Allow", "string", "alias", "for", "HeaderCell", "class", "lookups", "in", "Column"], "add_tokens": "var headerCell = resolveNameToClass ( this . get ( \"headerCell\" ) , \"HeaderCell\" ) ; this . set ( { cell : cell , headerCell : headerCell } , { silent : true } ) ;", "del_tokens": "this . set ( { cell : cell } , { silent : true } ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "compatibility", "option", "to", "work", "with", "bluebird"], "add_tokens": "that . immediateInterceptor . intercept ( that . config ) ; ignoreProcessTimers : false , fakeOriginalSetImmediateMethods : false", "del_tokens": "that . immediateInterceptor . intercept ( ) ; ignoreProcessTimers : false", "commit_type": "add"}
{"commit_tokens": ["Fix", "bad", "require", "path", "."], "add_tokens": "JsonError = require ( './error' ) ;", "del_tokens": "JsonError = require ( 'JsonError' ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "a", "default", "user", "-", "secret", "on", "new", "localUser", "creation"], "add_tokens": "default : function ( ) { var token = new Buffer ( uuid . v4 ( ) ) . toString ( 'base64' ) ; return \"new-\" + token ; } , const whitelist = \"email,username,display_name,active,groups,local_auth_type\" +", "del_tokens": "const whitelist = \"email,username,display_name,active,groups\" +", "commit_type": "add"}
{"commit_tokens": ["Remove", "references", "to", "direct", "wrapper"], "add_tokens": "//Again can use a visitor:", "del_tokens": "//Again can use a visitor. Also possible to use lower overhead direct wrapper.", "commit_type": "remove"}
{"commit_tokens": ["Add", "command", "list", "-", "services"], "add_tokens": "var fs = require ( \"fs\" ) ; var _ = require ( \"lodash\" ) ; var debug = require ( \"debug\" ) ( \"github-todos\" ) ; module . exports = getService ; function getService ( service ) { } getService . list = listServices ; function listServices ( ) { var files = fs . readdirSync ( __dirname ) ; return _ . filter ( _ . map ( files , function ( file ) { if ( file === \"index.js\" ) { return null ; } try { var service = require ( \"./\" + file ) ; var name = file . replace ( / \\.[^\\.]+$ / , \"\" ) ; return _ . merge ( { \"desc\" : name } , service . meta || { } , { \"name\" : name } ) ; } catch ( e ) { debug ( \"failed loading issue service\" , file , e ) ; return null ; } } ) ) ; }", "del_tokens": "module . exports = function ( service ) { } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "dns", "delete", "commands", ";", "bug", "fixes", ";", "isPrivate", "option", "moved", "in", "example"], "add_tokens": "return this . Request . post ( '/dns/' + encodeURIComponent ( name ) ) . auth ( ) . execute ( ) ; } , deleteName : function ( name ) { return this . Request . delete ( '/dns/' + encodeURIComponent ( name ) ) . auth ( ) . execute ( ) ; return this . Request . post ( '/dns' ) . auth ( ) . body ( payload ) . execute ( ) ; return this . Request . put ( '/dns' ) . auth ( ) . body ( payload ) . execute ( ) ; } , deleteService : function ( serviceName , name ) { return this . Request . delete ( '/dns/' + encodeURIComponent ( serviceName ) + '/' + encodeURIComponent ( name ) ) . auth ( ) . execute ( ) ;", "del_tokens": "return this . Request . post ( '/dns/' + encodeURIComponent ( name ) ) . auth ( ) . execute ( ) return this . Request . post ( '/dns' ) . auth ( ) . body ( payload ) . execute ( ) return this . Request . put ( '/dns' ) . auth ( ) . body ( payload ) . execute ( )", "commit_type": "add"}
{"commit_tokens": ["Changed", "some", "names", "of", "the", "parameters", "for", "createTag"], "add_tokens": "if ( ! options . commit ) { mucc . cp ( branchUrl , tagUrl , { revision : options . revision } ) ; mucc . cp ( branchUrl , tagUrl , { revision : options . revision } ) ;", "del_tokens": "//export function createTag( dir, url, targetDesc, tagName, commitLocalChanges, mergeLocalChanges, mergeBowerJson, mergeOriginalBranchTargetDesc, taggedBowerJson, workingCopyRevision, commentPrefix ) { // commitLocalChanges, mergeLocalChanges, mergeBowerJson, mergeOriginalBranchTargetDesc, taggedBowerJson, workingCopyRevision, commentPrefix if ( ! options . commitLocalChanges ) { mucc . cp ( branchUrl , tagUrl , { revision : options . workingCopyRevision } ) ; mucc . cp ( branchUrl , tagUrl , { revision : options . workingCopyRevision } ) ;", "commit_type": "change"}
{"commit_tokens": ["make", "the", "extends", "field", "of", "a", "prototype", "a", "subentity", "rather", "than", "being", "part", "of", "the", "param", "string", ".", "this", "is", "so", "that", "prototypes", "refer", "to", "the", "same", "thing", "even", "when", "what", "they", "extend", "changes"], "add_tokens": "var extenddEntities = entity . selectAll ( 'extends' ) if ( extenddEntities . length > 0 ) { details = details . add ( page . create ( 'span' ) . class ( 'qm-api-prototype-extends' ) . text ( 'extends' ) ) extenddEntities . forEach ( function ( ent ) { var extender = page . create ( 'span' ) . class ( 'qm-api-prototype-extends-type' ) . add ( createType ( ent . ps ( ) , page ) ) details = details . add ( extender ) } )", "del_tokens": "if ( entity . params [ 1 ] ) { details = details . add ( page . create ( 'span' ) . class ( 'qm-api-prototype-extends' ) . add ( 'Extends: ' ) . add ( createType ( entity . params [ 1 ] , page ) ) )", "commit_type": "make"}
{"commit_tokens": ["Moved", "modules", "/", "_globals", ".", "html", "to", "globals", ".", "html"], "add_tokens": "this . project . url = 'globals.html' ; urls . push ( new TypeDoc . Models . UrlMapping ( 'globals.html' , this . project , 'reflection.hbs' ) ) ; new TypeDoc . Models . NavigationItem ( '<em>Globals</em>' , 'globals.html' , root ) ;", "del_tokens": "this . project . url = 'modules/_globals.html' ; urls . push ( new TypeDoc . Models . UrlMapping ( 'modules/_globals.html' , this . project , 'reflection.hbs' ) ) ; new TypeDoc . Models . NavigationItem ( '<em>Globals</em>' , 'modules/_globals.html' , root ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "support", "for", "string", "seeds"], "add_tokens": "// A string was passed as a seed } else if ( typeof options . seed === 'string' ) { seed = stringToInteger ( options . seed ) ; // Something was passed as a seed but it wasn't an integer or string function stringToInteger ( string ) { var total = 0 for ( var i = 0 ; i !== string . length ; i ++ ) { if ( total >= Number . MAX_SAFE_INTEGER ) break ; total += string . charCodeAt ( i ) } return total }", "del_tokens": "// Something was passed as a seed but it wasn't an integer", "commit_type": "add"}
{"commit_tokens": ["added", "api", "key", "test", "expectation", "to", "all", "providers"], "add_tokens": "'Google Analytics' : 'x' expect ( analytics . providers [ 0 ] . settings . trackingId ) . to . equal ( 'x' ) ;", "del_tokens": "'Google Analytics' : 'UA-XXXXXXX-X'", "commit_type": "add"}
{"commit_tokens": ["Added", "multi", "-", "argument", "support", "and", "fixed", "new", "line", "problems"], "add_tokens": "_ . forEach ( arguments , function ( argument , index , arguments ) { if ( _ . isString ( argument ) ) { argument = chalk [ options . color ] ( argument ) ; argument = argument . replace ( / \\n / g , '\\n' + group . render ( options . title , buffers . group . length ) ) ; } if ( _ . isObject ( argument ) ) argument = chalk [ options . color ] ( stringify ( argument , config . json ) ) ; arguments [ index ] = argument ; } ) ;", "del_tokens": "if ( _ . isString ( arguments [ 0 ] ) ) arguments [ 0 ] = chalk [ options . color ] ( arguments [ 0 ] ) ; if ( _ . isObject ( arguments [ 0 ] ) ) arguments [ 0 ] = chalk [ options . color ] ( stringify ( arguments [ 0 ] , config . json ) ) ; else if ( buffers . group . length ) arguments = [ group . render ( options . title , buffers . group . length ) , arguments ] ;", "commit_type": "add"}
{"commit_tokens": ["change", "CRS", "to", "proj4", "style"], "add_tokens": "'name' : name 'proj' : proj //some common CRS definitions Z . CRS . WGS84 = Z . CRS . createProj4 ( \"+proj=longlat +datum=WGS84 +no_defs\" ) ; Z . CRS . EPSG4326 = Z . CRS . WGS84 ; Z . CRS . EPSG3857 = Z . CRS . createProj4 ( \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs\" ) ; Z . CRS . IDENTITY = Z . CRS . createProj4 ( \"+proj=identity\" ) ; //official coordinate system in China, in most cases, it can be considered same with wgs84 //http://spatialreference.org/ref/sr-org/7408/ Z . CRS . CGCS2000 = Z . CRS . createProj4 ( \"+proj=longlat +datum=CGCS2000\" ) ; //crs usded in Chinese map services due to the coordinate encryption. //https://en.wikipedia.org/wiki/Restrictions_on_geographic_data_in_China Z . CRS . BD09LL = Z . CRS . createProj4 ( \"+proj=longlat +datum=BD09\" ) ; Z . CRS . GCJ02 = Z . CRS . createProj4 ( \"+proj=longlat +datum=GCJ02\" ) ;", "del_tokens": "name : name proj : proj Z . CRS . WGS84 = new Z . CRS ( \"cnCoordinateType\" , { \"name\" : \"wgs84\" } ) ; Z . CRS . CGCS2000 = new Z . CRS ( \"cnCoordinateType\" , { \"name\" : \"cgcs2000\" } ) ; Z . CRS . GCJ02 = new Z . CRS ( \"cnCoordinateType\" , { \"name\" : \"gcj02\" } ) ; Z . CRS . BD09LL = new Z . CRS ( \"cnCoordinateType\" , { \"name\" : \"bd09ll\" } ) ; Z . CRS . PIXEL = new Z . CRS ( \"cnCoordinateType\" , { \"name\" : \"pixel\" } ) ;", "commit_type": "change"}
{"commit_tokens": ["Adding", "ext", "option", "to", "assemble", "task", "."], "add_tokens": "assets : '.' , ext : '.html' destFile = path . join ( dest , relative , filename + options . ext ) ;", "del_tokens": "assets : '.' destFile = path . join ( dest , relative , filename + '.html' ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "second", "param", "of", "Tween", ".", "setPosition", "to", "actionsMode", ".", "Got", "looping", "working", "for", "Timeline", "."], "add_tokens": "if ( tween . _prevPosition >= tween . duration ) { completeCount ++ ; } else { completeCount += tween . setPosition ( pos ) ; }", "del_tokens": "var looped = pos < value ; completeCount += tween . setPosition ( pos ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "precision", "rule", "to", "number"], "add_tokens": "( { min , max , precision } = { } , value ) => { if ( precision && String ( value ) !== value . toFixed ( precision ) ) { throw new Error ( ` ` ) }", "del_tokens": "( { min , max } = { } , value ) => {", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "and", "handling", "of", "=", "regexp", "."], "add_tokens": "** * / } ) ) ; // Add a isRegExp function context . functions . push ( M ( function ( ) { / *** var isRegEx = function ( value ) { try { new RegExp ( value ) ; } catch ( err ) { return false ; } return true ; } ** * / } ) ) ;", "del_tokens": "** * / } ) )", "commit_type": "add"}
{"commit_tokens": ["Fix", "spawn", "module", "require", "in", "rear", "-", "server", "-", "scripts", "init"], "add_tokens": "const spawnSync = require ( 'child_process' ) . spawnSync ; const proc = spawnSync ( command , args , { stdio : 'inherit' } ) ;", "del_tokens": "const spawn = require ( 'child_process' ) . spawn ; const proc = spawn . sync ( command , args , { stdio : 'inherit' } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "regression", "with", "Mocha", "6"], "add_tokens": "gulp . task ( 'test' , ( ) => _exec ( 'nyc' , [ normalize ( 'node_modules/.bin/mocha' ) , 'test/**/*.ts' ] ) ) ;", "del_tokens": "gulp . task ( 'test' , ( ) => _exec ( 'nyc' , [ normalize ( 'node_modules/.bin/mocha' ) ] ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "empty", "strings", "being", "output", "around", "the", ".", "load", "()", "call"], "add_tokens": "var loadRegex = / ['\"](<%= settings\\.load %>)['\"];? / ; var lineRegex = / (<%= settings\\.load %>|<%= settings\\.page %>|}}\\(\\);) / g ; var snippet = template ( source . replace ( loadRegex , '$1' ) . replace ( pageRegex , '$1' ) , { variable : 'settings' } ) ; } ) . code . replace ( loadRegex , '$1' ) . replace ( pageRegex , '$1' ) . replace ( lineRegex , '\\n$1' ) , { variable : 'settings' } ) ;", "del_tokens": "var lineRegex = / (analytics.load\\(|<%= settings\\.page %>|}}\\(\\);) / g ; var snippet = template ( source . replace ( pageRegex , '$1' ) , { variable : 'settings' } ) ; } ) . code . replace ( pageRegex , '$1' ) . replace ( lineRegex , '\\n$1' ) , { variable : 'settings' } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "nth", "-", "of", "-", "type", "selector", "test"], "add_tokens": "+ ':nth-of-type(2n+1):container(width > 100px) { display: block }' assert . equal ( Object . keys ( queries ) [ 6 ] , ':nth-of-type(2n+1).\\\\:container\\\\(width\\\\>100px\\\\)' , 'Correct key' ) ; assert . equal ( queries [ Object . keys ( queries ) [ 6 ] ] . _selector , ':nth-of-type(2n+1)' , 'Preceding selector' ) ;", "del_tokens": "+ '.nth-selector:nth-of-type(2n+1):container(width > 100px) { display: block }' assert . equal ( Object . keys ( queries ) [ 6 ] , '.nth-selector:nth-of-type(2n+1).\\\\:container\\\\(width\\\\>100px\\\\)' , 'Correct key' ) ; assert . equal ( queries [ Object . keys ( queries ) [ 6 ] ] . _selector , '.nth-selector:nth-of-type(2n+1)' , 'Preceding selector' ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "MochiKit", ".", "Base", ".", "update"], "add_tokens": "Dygraph . update ( this . options , options ? options : { } ) ; Dygraph . update ( this . options , new_options ? new_options : { } ) ; Dygraph . update ( this . options , options ) ;", "del_tokens": "MochiKit . Base . update ( this . options , options ? options : { } ) ; MochiKit . Base . update ( this . options , new_options ? new_options : { } ) ; MochiKit . Base . update ( this . options , options ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "missing", "tests", "+", "fixed", "invalid", "use", "strict", "string"], "add_tokens": "'use strict' ;", "del_tokens": "'\"use strict' ;", "commit_type": "add"}
{"commit_tokens": ["Change", "directory", "test", "-", ">", "demo", "."], "add_tokens": "var watchFiles = [ 'index.js' , 'gulpfile.js' , 'demo/src/**/**' ] ; gulp . task ( 'demo' , function ( ) { return gulp . src ( 'demo/*.js' , { read : false } ) return gulp . src ( [ './demo/src/html/index.html' ] , { base : './demo/src/html/' } ) . pipe ( gulp . dest ( './demo/dist/html/' ) ) ; return gulp . src ( './demo/src/css/*.css' ) imagePath : './demo/src/slice' , stylesheetPath : './demo/dist/css' , spritePath : './demo/dist/sprites' , . pipe ( gulp . dest ( './demo/dist/css' ) ) ; // gulp.watch(watchFiles, ['css', 'demo', 'lint']);", "del_tokens": "var watchFiles = [ 'index.js' , 'gulpfile.js' , 'test/src/**/**' ] ; gulp . task ( 'test' , function ( ) { return gulp . src ( 'test/*.js' , { read : false } ) return gulp . src ( [ './test/src/html/index.html' ] , { base : './test/src/html/' } ) . pipe ( gulp . dest ( './test/dist/html/' ) ) ; return gulp . src ( './test/src/css/*.css' ) imagePath : './test/src/slice' , stylesheetPath : './test/dist/css' , spritePath : './test/dist/sprites' , . pipe ( gulp . dest ( './test/dist/css' ) ) ; // gulp.watch(watchFiles, ['css', 'test', 'lint']);", "commit_type": "change"}
{"commit_tokens": ["Moving", "back", "to", "using", "html", "in", "demo"], "add_tokens": "html ,", "del_tokens": "text : 'test' ,", "commit_type": "move"}
{"commit_tokens": ["Adds", "context", "to", "fragments", "to", "reduce", "the", "need", "for", "sync"], "add_tokens": "return value . slice ( ) . sort ( sortFunc . bind ( this ) ) ;", "del_tokens": "return value . slice ( ) . sort ( sortFunc ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "builder", "path", "for", "watcher", "."], "add_tokens": "var watcher = new Watcher ( builder ) ;", "del_tokens": "var watcher = new Watcher ( packagePath , builder ) ;", "commit_type": "use"}
{"commit_tokens": ["Implement", "{", "Promise", "Function", ".", "prototype", "}", ".", "asyncApply", "methods", "."], "add_tokens": "return Promise . asyncApply ( fn , this , arguments , allowReuseOfCurrentFiber ) ; Promise . asyncApply = function ( fn , context , args , allowReuseOfCurrentFiber ) { var fiber = Fiber . current ; if ( fiber && allowReuseOfCurrentFiber ) { return this . resolve ( fn . apply ( context , args ) ) ; } return fiberPool . run ( { callback : fn , context : context , args : args , dynamics : fiber && fiber . _meteorDynamics } , this ) ; } ; Function . prototype . asyncApply = function ( context , args , allowReuseOfCurrentFiber ) { return Promise . asyncApply ( this , context , args , allowReuseOfCurrentFiber ) ; } ;", "del_tokens": "var self = this ; var args = arguments ; var fiber = Fiber . current ; if ( allowReuseOfCurrentFiber && fiber ) { return Promise . resolve ( fn . apply ( self , args ) ) ; } return fiberPool . run ( { callback : fn , context : self , args : args , dynamics : fiber && fiber . _meteorDynamics } , Promise ) ;", "commit_type": "implement"}
{"commit_tokens": ["Add", "ability", "to", "mock", "response", "errors"], "add_tokens": "addResponseError , export function addResponse ( content ) { reqResponses . push ( content ) } export function addResponseError ( response , content ) { const responseError = new Error ( 'Status ' + response . status ) responseError . response = response responseError . content = content reqResponses . push ( responseError ) return new Promise ( ( resolve , reject ) => { let response = reqResponses . shift ( ) if ( response instanceof Error ) { return reject ( response ) } resolve ( response )", "del_tokens": "export function addResponse ( response ) { reqResponses . push ( response ) return new Promise ( ( resolve ) => { resolve ( reqResponses . shift ( ) )", "commit_type": "add"}
{"commit_tokens": ["added", "fallback", "implementation", "to", "wrap"], "add_tokens": "if ( ! oldCursor && opt . impl && typeof opt . impl === 'string' ) { try { / * Passing in fn as option instead of running page . evaluate if future versions of Phantom support implementation * / oldCursor = new Function ( 'return ' + opt . impl ) ( ) ; } catch ( e ) { console . log ( 'try catch failed on ' + opt . impl + '. Error:' + JSON . stringify ( e ) ) ; } } } return function wrap ( name , impl ) { name : name , impl : impl && impl . toString ( )", "del_tokens": "} ; return function wrap ( name ) { name : name", "commit_type": "add"}
{"commit_tokens": ["Add", "ability", "to", "tail", "*", "all", "*", "jobs", "."], "add_tokens": "'Only follow the specified job (job numbers start at 1)' console . log ( '== Travis build' , state . build . number + '.' + state . job_num , '==' ) ; if ( program . job !== undefined ) { // watch one particular job return watchJob ( ( + program . job ) ) ; } // watch all jobs return Promise . reduce ( state . build . job_ids , function ( _ , jid , index ) { return watchJob ( index + 1 ) ; } , null ) ; if ( program . job !== undefined ) { // return our job status return state . job . state ; } // return our build status return state . build . state ;", "del_tokens": "'Which job to follow [1]' , 1 return watchJob ( ( + program . job ) || 1 ) ; // return our job status return state . job . state ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "on_submit", "to", "use", "custom", "messages", "instead", "of", "stateful", "communcation"], "add_tokens": "this . model . last_modified_view = this ; // For callbacks. this . model . send ( { event : 'submit' } ) ;", "del_tokens": "this . model . set ( 'submits' , this . model . get ( 'submits' ) + 1 ) ; this . model . update_other_views ( this ) ;", "commit_type": "change"}
{"commit_tokens": ["changed", "function", "name", "to", "replaceAdjacentAt", "()"], "add_tokens": "function replaceAdjacentAt ( index , newValues , array ) { exports . replaceAdjacentAt = replaceAdjacentAt ;", "del_tokens": "function replaceAt ( index , newValues , array ) { exports . replaceAt = replaceAt ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "self", "loops", "in", "layout"], "add_tokens": "e . dagre = { points : [ ] , source : nodeMap [ source ] , target : nodeMap [ target ] , } ; edgeMap [ id ] = e . dagre ;", "del_tokens": "edgeMap [ id ] = e . dagre = { points : [ ] , source : nodeMap [ source ] , target : nodeMap [ target ] , } ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "definitions", "of", "changeDir", "jumpiness", "and", "rests", "values", "to", "make", "more", "sense"], "add_tokens": "if ( useRests && random . bool ( settings . rests ) ) return noteGroupObj . notes . push ( null ) ; if ( random . bool ( settings . jumpiness ) ) { if ( random . bool ( settings . changeDir ) ) dir = - dir ; changeDir : 0.25 , // Likelihood of changing chromatic direction, number (0 to 1) or range jumpiness : 0.25 , // Likelihood of jumping intervals, number (0 to 1) or range rests : [ 0.35 , 0 ] , // Likelihood of a note being a rest (previous note is sustained), number (0 to 1) or range", "del_tokens": "if ( useRests && random . bool ( settings . rests / 2 ) ) return noteGroupObj . notes . push ( null ) ; if ( random . bool ( settings . jumpiness / 2 ) ) { if ( random . bool ( settings . changeDir / 2 ) ) dir = - dir ; changeDir : 0.5 , // Likelihood of changing chromatic direction, number (0 to 1) or range jumpiness : 0.5 , // Likelihood of jumping intervals, number (0 to 1) or range rests : [ 0.75 , 0 ] , // Likelihood of a note being a rest (previous note is sustained), number (0 to 1) or range", "commit_type": "change"}
{"commit_tokens": ["Fix", "various", "incorrect", "code", "in", "the", "XHR", "auto", "-", "instrumentation"], "add_tokens": "// TODO: this should be only 'component_name'. A larger task to completely // replace group_name with component_name needs to be done. let groupName = dataset . component_name || dataset . group_name ; // NOTE: this is a little inelegant as this is hard-coding support for a // \"plug-in\" option. let xhrInstrumentation = dataset . xhr_instrumentation ; if ( typeof xhrInstrumentation === 'string' && xhrInstrumentation === 'true' ) { browserOpts . xhr_instrumentation = true ; }", "del_tokens": "let groupName = dataset . group_name ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "simulating", "FocusEvents", "in", "Firefox", "."], "add_tokens": "blur : 'UIEvent' , focus : 'UIEvent' , focusin : 'UIEvent' , focusout : 'UIEvent' ,", "del_tokens": "blur : 'FocusEvent' , focus : 'FocusEvent' , focusin : 'FocusEvent' , focusout : 'FocusEvent' ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "config", "parameter", "to", "make", "the", "pluralization", "of", "resourcename", "optional", "defaults", "to", "true"], "add_tokens": "config . resource = config . pluralize === true ? _i . pluralize ( collectionName ) : collectionName ; pluralize : true ,", "del_tokens": "config . resource = _i . pluralize ( collectionName ) ;", "commit_type": "add"}
{"commit_tokens": ["Adds", "React", "Native", "component", "tests", "."], "add_tokens": "import mockery from 'mockery' // inject __DEV__ as it is not available when running through the tests global . __DEV__ = true // We enable mockery and leave it on. This is a little different than what // I've seen setup. mockery . enable ( ) // Silence the warnings when *real* modules load... this is a change from // the norm. We want to opt-in instead of opt-out because not everything // will be mocked. mockery . warnOnUnregistered ( false ) // mock the images so the tests can load them mockery . registerMock ( '../Images/ir.png' , 0 ) mockery . registerMock ( '../Images/top_logo.png' , 0 ) mockery . registerMock ( '../Images/ignite_logo.png' , 0 ) mockery . registerMock ( '../Images/tile_bg.png' , 0 ) mockery . registerMock ( '../Images/BG.png' , 0 )", "del_tokens": "// import test from 'ava' // import chai from 'chai' // import chaiImmutable from 'chai-immutable' // chai.use(chaiImmutable) // global.expect = chai.expect // global.__DEV__ = true", "commit_type": "add"}
{"commit_tokens": ["Moved", "the", "default", "configs", "into", "their", "own", "folder", "for", "better", "organization"], "add_tokens": "this . reveal = require ( __dirname + '/../config/reveal.json' ) ;", "del_tokens": "this . reveal = require ( __dirname + '/../reveal.json' ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "TODO", "on", "store", "behaviour"], "add_tokens": "// TODO : review this one export const connect = ( entityPathArray , { mapStateToProps , mapDispatchToProps } ) => connectToReduxStore ( mapStateToProps || defaultMapStateToPropsBuilder ( entityPathArray ) , mapDispatchToProps ) ;", "del_tokens": "const defaultMapDispatchToProps = dispatch => ( { dispatch } ) ; export const connect = ( entityPathArray , { mapStateToProps , mapDispatchToProps = defaultMapDispatchToProps } ) => connectToReduxStore ( mapStateToProps || defaultMapStateToPropsBuilder ( entityPathArray ) , mapDispatchToProps ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "polygon", "invalid", "test", "when", "splitting"], "add_tokens": "// A polygon is valid if all it's vertices are valid Polygon3D . prototype . isValid = function ( ) { if ( this . vertices ) { return true ; } // Use the toVertices() function instead of // checking each vertex, since this will cache the vertices try { this . toVertices ( ) ; return true ; } catch ( e ) { return false ; } } var p = new Polygon3D ( this . s , frontOutputPlanes ) ; front = p . isValid ( ) ? p : undefined ; var p = new Polygon3D ( this . s , backOutputPlanes ) ; back = p . isValid ( ) ? p : undefined ;", "del_tokens": "try { front = new Polygon3D ( this . s , frontOutputPlanes ) ; } catch ( e ) { // invalid polygon } try { back = new Polygon3D ( this . s , backOutputPlanes ) ; } catch ( e ) { // invalid polygon }", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "to", "walk", "the", "whole", "tree", "when", "transforming", ";"], "add_tokens": "// walk the tree const walker = context . createWalker ( { enter ( node ) { const childTag = node . tagName ; // find the matching tag based on the child tag name of // the children matching the given tagName if ( node . type === 'HtmlElement' && node . tagName . indexOf ( ` ${ parentTag } ` ) === 0 ) { const outputTag = ` ${ parentTag } ${ childTag . slice ( parentTag . length + 1 ) } ` ; const nestedTag = context . createNodeForEl ( outputTag , node . getAttributes ( ) ) ; nestedTag . body = node . body ; node . replaceWith ( nestedTag ) ; walker . skip ( ) ; } } walker . walk ( el ) ;", "del_tokens": "el . body . forEach ( child => { const childTag = child . tagName ; // find the matching tag based on the child tag name of // the children matching the given tagName if ( childTag && childTag . indexOf ( ` ${ parentTag } ` ) === 0 ) { const outputTag = ` ${ parentTag } ${ childTag . slice ( parentTag . length + 1 ) } ` ; const nestedTag = context . createNodeForEl ( outputTag , child . getAttributes ( ) ) ; nestedTag . body = child . body ; child . replaceWith ( nestedTag ) ; } return child ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "this", ".", "isServer", "for", "model", "hooks"], "add_tokens": "if ( typeof properties !== 'object' ) properties = { }", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["remove", "deep", "option", "version", ":", "deep", "walk", "prop", "-", "value", "when", "changeed", "."], "add_tokens": "diff : function ( next , pre , _t ) { var that = this // defult max 4 level _t = _t == undefined ? 4 : _t if ( _t <= 0 ) return next !== pre if ( this . type ( next ) == 'array' && this . type ( pre ) == 'array' ) { if ( next . length !== pre . length ) return true return next . some ( function ( item , index ) { return that . diff ( item , pre [ index ] , _t - 1 ) } ) } else if ( this . type ( next ) == 'object' && this . type ( pre ) == 'object' ) { var nkeys = Object . keys ( next ) var pkeys = Object . keys ( pre ) if ( nkeys . length != pkeys . length ) return true var that = this return nkeys . some ( function ( k ) { return ( ! ~ pkeys . indexOf ( k ) ) || that . diff ( next [ k ] , pre [ k ] , _t - 1 ) } ) } return next !== pre", "del_tokens": "diff : function ( next , pre ) { return next !== pre || next instanceof Object", "commit_type": "remove"}
{"commit_tokens": ["Add", "noFail", "setting", "to", "spec", "."], "add_tokens": "/ ** * Runs JSLint over each item in the stream . * @ param { Object } spec The specification . * @ param { String } spec . jslint The file path to jslint . js . * @ param { Object } [ spec . options ] The options to pass to JSLint . * @ param { Array } [ spec . globals ] The list of known global variables to pass to JSLint . * @ param { Boolean } [ spec . noFail ] True to log all warnings without failing . * / if ( errors && ! spec . noFail ) {", "del_tokens": "if ( errors ) {", "commit_type": "add"}
{"commit_tokens": ["added", "Job", ".", "get", "(", "id", "fn", ")", "test"], "add_tokens": "var Queue = require ( '../' ) , queue = new Queue , Job = Queue . Job , redis = require ( 'redis' ) , client = redis . createClient ( ) , should = require ( 'should' ) ; setup : function ( done ) { client . flushdb ( done ) ; } , Queue . version . should . match ( / ^\\d+\\.\\d+\\.\\d+$ / ) ; } , 'Job.get()' : function ( done ) { queue . createJob ( 'email' , { to : 'tj@test.com' } ) . save ( function ( err , id ) { should . equal ( null , err ) ; Job . get ( id , function ( err , job ) { should . equal ( null , err ) ; job . type . should . equal ( 'email' ) ; job . data . should . eql ( { to : 'tj@test.com' } ) ; job . state . should . equal ( 'inactive' ) ; done ( ) ; } ) ; } ) ;", "del_tokens": "var q = require ( '../' ) ; q . version . should . match ( / ^\\d+\\.\\d+\\.\\d+$ / ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "SVG", "font", "size", "option"], "add_tokens": "svgAttrs : { id : 'view-svg' } , fontSize : ( MakerJsPlayground . windowZoom * MakerJsPlayground . svgFontSize ) + 'px' ,", "del_tokens": "svgAttrs : { id : 'view-svg' , \"font-size\" : ( MakerJsPlayground . windowZoom * MakerJsPlayground . svgFontSize ) + 'px' } ,", "commit_type": "add"}
{"commit_tokens": ["Use", "the", "block", "key", "not", "the", "entity", "key", "."], "add_tokens": "const key = block . getKey ( )", "del_tokens": "const key = block . getEntityAt ( 0 )", "commit_type": "use"}
{"commit_tokens": ["updated", "example", "tests", "to", "call", "done"], "add_tokens": "this . When ( / ^I search Google for \"([^\"]*)\"$ / , function ( searchQuery , done ) { done ( ) ; this . Then ( / ^I should see some results$ / , function ( done ) { driver . findElements ( by . css ( 'div.g' ) ) . then ( function ( elements ) { done ( ) ;", "del_tokens": "this . When ( / ^I search Google for \"([^\"]*)\"$ / , function ( searchQuery ) { this . Then ( / ^I should see some results$ / , function ( ) { return driver . findElements ( by . css ( 'div.g' ) ) . then ( function ( elements ) {", "commit_type": "update"}
{"commit_tokens": ["add", "accumulative", "tests", "w", "/", "bad", "fee", "skipping"], "add_tokens": "var utxoBytes = utils . inputBytes ( utxo ) var utxoFee = feeRate * utxoBytes var utxoValue = utils . uintOrNaN ( utxo . value ) // skip detrimental input if ( utxoFee > utxo . value ) continue bytesAccum += utxoBytes inAccum += utxoValue", "del_tokens": "bytesAccum += utils . inputBytes ( utxo ) inAccum += utils . uintOrNaN ( utxo . value )", "commit_type": "add"}
{"commit_tokens": ["Remove", "parse", "(", "req", ")", "and", "parse", "(", "res", ")", "signatures"], "add_tokens": "* Copyright ( c ) 2014 - 2015 Douglas Christopher Wilson", "del_tokens": "* Copyright ( c ) 2014 Douglas Christopher Wilson // support req/res-like objects as argument if ( typeof string === 'object' ) { string = getcontenttype ( string ) } / ** * Get content - type from req / res objects . * * @ param { object } * @ return { Object } * @ api private * / function getcontenttype ( obj ) { if ( typeof obj . getHeader === 'function' ) { // res-like return obj . getHeader ( 'content-type' ) } if ( typeof obj . headers === 'object' ) { // req-like return obj . headers && obj . headers [ 'content-type' ] } }", "commit_type": "remove"}
{"commit_tokens": ["Fixing", "issue", "preventing", "polygon", "from", "rendering"], "add_tokens": "if ( this . polygon ) { this . polygon . setMap ( null ) ; } this . renderPolygon ( ) ;", "del_tokens": "if ( this . polygon ) { this . polygon . setMap ( null ) ; this . renderPolygon ( ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Allow", "update", "requests", "to", "specify", "their", "desired", "filetype", "fallback", "to", "zip"], "add_tokens": "var filetype = req . query . filetype ? req . query . filetype : \"zip\" ; \"url\" : url . resolve ( fullUrl , \"/download/version/\" + latest . tag + \"/\" + platform + \"?filetype=\" + filetype ) ,", "del_tokens": "\"url\" : url . resolve ( fullUrl , \"/download/version/\" + latest . tag + \"/\" + platform + \"?filetype=zip\" ) ,", "commit_type": "allow"}
{"commit_tokens": ["fix", "bug", "with", "queryAST", "depth"], "add_tokens": "handleSelections ( children , selection . selectionSet . selections , gqlType , fragments , variables , namespace , depth , options ) handleSelections ( children , fragment . selectionSet . selections , gqlType , fragments , variables , namespace , depth , options )", "del_tokens": "handleSelections ( children , selection . selectionSet . selections , gqlType , fragments , variables , namespace , depth + 1 , options ) handleSelections ( children , fragment . selectionSet . selections , gqlType , fragments , variables , namespace , depth + 1 , options )", "commit_type": "fix"}
{"commit_tokens": ["allow", "to", "send", "multiple", "arguments", "with", "a", "dispatcher"], "add_tokens": "dispatch : function ( topic ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; config . handler . apply ( config . context , args ) ;", "del_tokens": "dispatch : function ( topic , message ) { config . handler . call ( config . context , message ) ;", "commit_type": "allow"}
{"commit_tokens": ["Make", "quad", "invisible", "if", "any", "point", "is", "NaN"], "add_tokens": "if ( showWireframe ) { barycentricAttr . init ( vertexCount ) ; } var farPoints = [ 1e7 , 1e7 , 1e7 ] ; var invisibleQuad = false ; if ( isPointsNaN ( pos ) ) { // Quad is invisible if any point is NaN invisibleQuad = true ; } } for ( var k = 0 ; k < 4 ; k ++ ) { if ( invisibleQuad ) { // Move point far away positionAttr . set ( vertexOffset + k , farPoints ) ; } else { getFromArray ( pointsArr , quadIndices [ k ] , pos ) ; positionAttr . set ( vertexOffset + k , pos ) ; } if ( showWireframe ) { barycentricAttr . set ( vertexOffset + k , quadBarycentric [ k ] ) ; } if ( needsNormal && ! invisibleQuad ) {", "del_tokens": "barycentricAttr . init ( vertexCount ) ; positionAttr . set ( vertexOffset + k , pos ) ; barycentricAttr . set ( vertexOffset + k , quadBarycentric [ k ] ) ; if ( needsNormal ) { // Ignore normal if any point is NaN. if ( isPointsNaN ( pts [ 0 ] ) || isPointsNaN ( pts [ 1 ] ) || isPointsNaN ( pts [ 2 ] ) ) { continue ; }", "commit_type": "make"}
{"commit_tokens": ["added", "private", "to", "public", "key", "conversion", "from", "ethereumjs", "-", "util", "library"], "add_tokens": "var privateToPublic = require ( \"ethereumjs-util\" ) . privateToPublic ; var publicKey = privateToPublic ( privateKey ) ; console . log ( \"public key: \" + publicKey . toString ( \"hex\" ) ) ; console . log ( \"Hash of message '\" + message + \"': \" + sha256 ( message , publicKey . toString ( ) ) ) ; // TODO: get the public key somehow and use it instead of the private key!", "del_tokens": "console . log ( \"Hash of message '\" + message + \"': \" + sha256 ( message , privateKey . toString ( ) ) ) ; // TODO: get the public key somehow and use it instead of the private key!", "commit_type": "add"}
{"commit_tokens": ["Fix", "import", "to", "require", "babel", "-", "core"], "add_tokens": "var t = require ( 'babel-core' ) . types ;", "del_tokens": "var t = require ( 'babel' ) . types ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "bug", "in", "intentation", "rules", "with", "scenario", "outlines"], "add_tokens": "if ( examples . tableHeader ) { test ( examples . tableHeader . location , 'example' ) ; examples . tableBody . forEach ( function ( row ) { test ( row . location , 'example' ) ; } ) ; }", "del_tokens": "test ( examples . tableHeader . location , 'example' ) ; examples . tableBody . forEach ( function ( row ) { test ( row . location , 'example' ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "expected", "file", "for", "Travis", "CI"], "add_tokens": "expectedDir + '/multiple3.png' , expectedDir + '/multiple4.png' // console.log(encodeURIComponent(actualImage));", "del_tokens": "expectedDir + '/multiple3.png' console . log ( encodeURIComponent ( actualImage ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "bootstrap", "dropdown", "-", "menu", "class"], "add_tokens": "list . classList . add ( 'fl-fb-ControlBar-dropdown-content' ) ;", "del_tokens": "const toggleMechanism = document . createElement ( 'input' ) ; toggleMechanism . type = 'checkbox' ; toggleMechanism . classList . add ( 'fl-fb-ControlBar-dropdown-checkbox-toggle' ) ; const randomNum = Date . now ( ) + parseInt ( Math . random ( ) * 1000 , 10 ) ; toggleMechanism . id = ` ${ randomNum } ` ; wrapper . appendChild ( toggleMechanism ) ; mainButton . setAttribute ( 'for' , toggleMechanism . id ) ; list . classList . add ( 'dropdown-menu' , 'fl-fb-ControlBar-dropdown-content' ) ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", "typo", "in", "connection_changed", "event", "name"], "add_tokens": "this . _state . on ( \"connection_changed\" , this . _onConnectionStateChange . bind ( this ) ) ;", "del_tokens": "this . _state . on ( \"connection_change\" , this . _onConnectionStateChange . bind ( this ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "executed", "and", "noop", "function"], "add_tokens": "* Check if the key exists / ** * Check if the command for the key was executed * @ this { Connection } * @ param { string } key * @ returns { boolean } true if the key exists * / Connection . prototype . executed = function ( key ) { var self = this ; return ( typeof self . _messages [ self . _messages_key_prefix [ key ] ] !== 'undefined' ) ; } Connection . prototype . noop = function ( key ) { //self._messages[prefix] = ; // not needed, will be set if messages was received", "del_tokens": "* check if the key exists Connection . prototype . starttls = function ( key ) { self . _messages [ prefix ] = '' ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "performance", "problem", "saving", "to", "hash"], "add_tokens": "var debounce = require ( './utils' ) . debounce ;", "del_tokens": "function debounce ( fn , t ) { var i ; return function ( ) { var args = arguments ; clearTimeout ( i ) ; i = setTimeout ( function ( ) { fn . apply ( window , args ) ; } , t ) ; } }", "commit_type": "fix"}
{"commit_tokens": ["Use", "UTF", "-", "8", "encoding", "by", "default"], "add_tokens": "hashFn . update ( key , 'utf8' ) ; return hashFn . update ( 'error:' + err . toString ( ) , 'utf8' ) ; return hashFn . update ( 'string:' + string , 'utf8' ) ; return hashFn . update ( 'fn:' + fn . toString ( ) , 'utf8' ) ; return hashFn . update ( 'xml:' + xml . toString ( ) , 'utf8' ) ; return hashFn . update ( 'regex:' + regex . toString ( ) , 'utf8' ) ;", "del_tokens": "hashFn . update ( key ) ; return hashFn . update ( 'error:' + err . toString ( ) ) ; return hashFn . update ( 'string:' + string ) ; return hashFn . update ( 'fn:' + fn . toString ( ) ) ; return hashFn . update ( 'xml:' + xml . toString ( ) ) ; return hashFn . update ( 'regex:' + regex . toString ( ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "basic", "projected", "tile", "loading"], "add_tokens": "// Create object to define tile provider settings and transformations. Supports // all Leaflet TileLayer options. // CRS Code for the tiles crs : \"EPSG:3573\" , crs : \"EPSG:3857\" , crs : \"EPSG:3857\" , crs : \"EPSG:32632\" , proj4def : '+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs' , zoom : 1 , continuousWorld : true , map = L . polarMap ( 'xmap' , { tileProjection : projectedTiles [ \"jotunheimen@EPSG:32632\" ] } ) ; // map = L.map('xmap', { // center: [51.080126, -114.13380900], // zoom: 15, // layers: [ // L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', { // attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' // }) // ] // });", "del_tokens": "// Create object to define tile provider settings and transformations. zoom : 0 , // map = L.polarMap('xmap', { // tileProjection: mapProviders[\"osm_tile_map@EPSG:3857\"] // }); map = L . map ( 'xmap' , { center : [ 51.080126 , - 114.13380900 ] , zoom : 15 , layers : [ L . tileLayer ( 'http://{s}.tile.osm.org/{z}/{x}/{y}.png' , { attribution : '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' } ) ] } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "an", "option", "to", "control", "how", "to", "sort", "operation", "parameters"], "add_tokens": "/* jshint -W014 */ var sortParams = options . sortParams || 'desc' ; switch ( sortParams ) { case 'asc' : return a . paramName > b . paramName ? 1 : a . paramName < b . paramName ? - 1 : 0 ; case 'desc' : return a . paramName > b . paramName ? - 1 : a . paramName < b . paramName ? 1 : 0 ; default : return 0 ; }", "del_tokens": "return a . paramName > b . paramName ? - 1 : a . paramName < b . paramName ? 1 : 0 ;", "commit_type": "add"}
{"commit_tokens": ["adding", "change", "detector", "mark", "on", "component", "view", "init"], "add_tokens": "this . changeDetectorRef . markForCheck ( ) ; S5lComponent . prototype . ngOnChanges = function ( ) {", "del_tokens": "S5lComponent . prototype . ngDoCheck = function ( ) {", "commit_type": "add"}
{"commit_tokens": ["added", "support", "for", "browser", "platform"], "add_tokens": "case 'ios' : case 'browser' : console . log ( 'this hook only supports android, ios, and browser currently' ) ;", "del_tokens": "case 'ios' : console . log ( 'this hook only supports android and ios currently' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "more", "error", "handling", "to", "writeJSON", "function"], "add_tokens": "var writeJSON = function writeJSON ( filename , obj ) { if ( ! Object . is ( obj ) ) resolve ( new Error ( 'writeJSON requires the second argument to be an object' ) ) ; _fs2 [ 'default' ] . writeFile ( filename , JSON . stringify ( obj ) , function ( err ) {", "del_tokens": "var writeJSON = function writeJSON ( filename , content ) { _fs2 [ 'default' ] . writeFile ( filename , JSON . stringify ( content ) , function ( err ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "key", "error", "in", "Toolbar", "s", "render", "method"], "add_tokens": "return TransformButtons . map ( function ( option , i ) { return < a href = '#' title = { option . value } key = { i }", "del_tokens": "return TransformButtons . map ( function ( option ) { return < a href = '#' title = { option . value }", "commit_type": "fix"}
{"commit_tokens": ["Remove", "grunt", ".", "file", ".", "watchFiles"], "add_tokens": "grunt . log . ok ( 'File \"' + filepath + '\" ' + changedFiles [ filepath ] + '.' ) ;", "del_tokens": "var status = changedFiles [ filepath ] ; grunt . log . ok ( 'File \"' + filepath + '\" ' + status + '.' ) ; // Add filepath to grunt.file.watchFiles for grunt.file.expand* methods. grunt . file . watchFiles [ status ] . push ( filepath ) ;", "commit_type": "remove"}
{"commit_tokens": ["make", "set", "compatible", "with", "non", "-", "strings", "still", "very", "slow"], "add_tokens": "for ( x in this . members ) if ( ! ( x in other . members ) ) d . push ( this . members [ x ] ) ; var ms = this . members ; return ownProps ( this . members ) . map ( function ( k ) { return ms [ k ] ; } ) ; var ms = this . members ; , u = ownProps ( this . members ) . map ( function ( k ) { return ms [ k ] ; } ) ; ms = other . members ; u = u . concat ( ownProps ( ms ) . map ( function ( k ) { return ms [ k ] ; } ) ) ; return new Set ( u ) ;", "del_tokens": "for ( x in this . members ) if ( ! ( x in other . members ) ) d . push ( x ) ; return Object . keys ( this . members ) ; return new Set ( ownProps ( this . members ) . concat ( ownProps ( other . members ) ) ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "msg", "method", "and", "deliver", "method"], "add_tokens": ", slice = Array . prototype . slice / ** * Gets a builder for the passed data * * @ api public * @ see Server . prototype . message ( ) * @ param { object } data * @ return Builder * / Server . prototype . msg = Server . prototype . message ; / ** * Sends the data to server in a message * * @ api public * @ param mixed * @ return Server * / Server . prototype . deliver = function ( ) { this . msg . apply ( this , slice . call ( arguments ) ) . deliver ( ) ; return this ; } ;", "del_tokens": "Server . prototype . socketReceiver = Server . prototype . incomming ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "check", "for", "open", "FDs"], "add_tokens": "if ( process . platform !== 'linux' ) {", "del_tokens": "if ( process !== 'linux' ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "Object", ".", "keys", "instead", "of", "Object", ".", "entries"], "add_tokens": "Object . keys ( handlers ) . forEach ( ( action ) => { const handler = handlers [ action ] Object . keys ( derivedState ) . forEach ( ( name ) => { const deriver = derivedState [ name ] \"color: black; font-weight: normal;\" ,", "del_tokens": "Object . entries ( handlers ) . forEach ( ( [ action , handler ] ) => { Object . entries ( derivedState ) . forEach ( ( [ name , deriver ] ) => { \"color: black; font-weight: bold;\" ,", "commit_type": "use"}
{"commit_tokens": ["Allow", "the", "administrator", "to", "enable", "additional", "plugins"], "add_tokens": "import additionalPlugins from \"../plugins.js\" ; let plugins = { for ( let name in additionalPlugins ) { plugins [ name ] = additionalPlugins [ name ] ; } export default plugins ;", "del_tokens": "export default {", "commit_type": "allow"}
{"commit_tokens": ["Updated", "tests", "for", "Play", "and", "Queue", "api", "changes"], "add_tokens": "} else {", "del_tokens": "} else {", "commit_type": "update"}
{"commit_tokens": ["updated", "Gruntfile", ".", "js", "min", ".", "js", "package", "name"], "add_tokens": "dest : \"dist/<%= pkg.name %>.min.js\"", "del_tokens": "dest : \"dist/file-compare.min.js\"", "commit_type": "update"}
{"commit_tokens": ["Updating", "from", "just", "a", "broccoli", "filter", "to", "an", "addon"], "add_tokens": "var mergeTrees = require ( 'broccoli-merge-trees' ) ; module . exports = { name : 'ember-browserify' , included : function ( app ) { app . import ( 'browserify/browserify.js' ) ; } , postprocessTree : function ( type , tree ) { if ( type === 'js' ) { var bundle = browserify ( StubGenerator ( tree ) , { entries : [ './browserify_stubs.js' ] , outputFile : './browserify/browserify.js' } ) ; return mergeTrees ( [ tree , bundle ] ) ; } else return tree ; }", "del_tokens": "module . exports = function emberBrowserify ( tree ) { return browserify ( StubGenerator ( tree ) , { entries : [ './browserify_stubs.js' ] } ) ;", "commit_type": "update"}
{"commit_tokens": ["Move", "gps", "heuristic", "function", "to", "tests", ".", "js"], "add_tokens": "// Heuristic function CityNode . prototype . GPS_distance = function ( city ) { var x = ( city . longRad - this . longRad ) * Math . cos ( ( this . latRad + city . latRad ) / 2 ) , y = city . latRad - this . latRad , res = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) * 6371 ; return res ; } ; // Real cost function CityNode . prototype . Real_distance = function ( city ) { // Re-use heuristic function for now // TODO: Determine the real distance between cities (from another data set) return this . GPS_distance ( city ) ; } ; // Override neighbors function for this specific graph graph . neighbors = function ( node ) { neighbor . cost = node . Real_distance ( neighbor ) ; // Compute real cost! var GPSheuristic = function ( node0 , node1 ) { return node0 . GPS_distance ( node1 ) ; } ;", "del_tokens": "var GPSheuristic = astar . heuristics . gps ; graph . neighbors = function ( node ) { // Override neighbors function for this specific graph neighbor . cost = GPSheuristic ( node , neighbor ) ; // Compute real cost!", "commit_type": "move"}
{"commit_tokens": ["Updated", "tests", "due", "to", "md5", "dependency", "update", "."], "add_tokens": "var md5 = require ( __dirname + '/../src/md5' ) ( { node : { fs : require ( 'fs' ) } } ) ;", "del_tokens": "var md5 = require ( __dirname + '/../src/md5' ) ( ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "issue", "where", "state", "machine", "signals", "weren", "t", "unmounted", "properly"], "add_tokens": "const subscription = s . subscribe ( { ... emit , next } ) return ( ) => subscription . unsubscribe ( )", "del_tokens": "return s . subscribe ( { ... emit , next } )", "commit_type": "fix"}
{"commit_tokens": ["Add", "ability", "to", "query", "a", "companies", "sites", "."], "add_tokens": "* @ property { CompanySites } CompanySites _CompanyTypeInfos = require ( './CompanyTypeInfos' ) , _CompanySites = require ( './CompanySites' ) ; CompanySites : new _CompanySites ( options ) ,", "del_tokens": "_CompanyTypeInfos = require ( './CompanyTypeInfos' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "more", "key", "codes", "for", "the", "Apple", "command", "key", "to", "catch", "firefox", "and", "right", "command", "on", "webkit"], "add_tokens": "case 91 : // Left Command in WebKit case 93 : // Right Command in WebKit case 224 : // Command in FireFox case 91 : // Left Command in WebKit case 93 : // Right Command in WebKit case 224 : // Command in FireFox", "del_tokens": "es . SurfaceView . prototype . hasSelection = function ( ) { return ! ! this . selection . getLength ( ) ; } case 91 : // Command case 91 : // Command", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "leaked", "common", "functions", "."], "add_tokens": "clone , propEq , get , matches , memoize , it ( 'propEq get matches' , function ( ) { ( matches ( { a : 1 } ) ( { a : 1 } ) ) . should . equal ( true ) ; ( matches ( { b : 1 } ) ( { a : 1 } ) ) . should . equal ( false ) ; ( get ( { b : 1 } ) ( 'b' ) ) . should . equal ( 1 ) ; var count = 0 ; const square = x => { count = count + 1 ; return x * x ; } ;", "del_tokens": "clone , propEq , it ( 'propEq' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["remove", "dangling", "screenshots", "from", "previous", "recording"], "add_tokens": "function _simulateScreenshot ( driver , event , taskPath , compareWithOld , next ) { // TODO: browser name var oldImagePath = taskPath + '/' + event . index + '.png' ; if ( compareWithOld ) { var compareWithOld = options . compareWithOld || false ; // the last action is always taking a screenshot. We trimmed the rest when // we saved the recording fn = _simulateScreenshot . bind ( null , driver , currentEvent , taskPath , compareWithOld , function ( ) { imageOperations . removeDanglingImages ( taskPath , currentEvent . index + 1 , done ) ; } null , driver , currentEvent , taskPath , compareWithOld , _next", "del_tokens": "function _simulateScreenshot ( driver , event , taskPath , compareWithOldOne , next ) { // TODO: shorter img name, and with browser name var oldImagePath = taskPath + '/screenshot' + event . index + '.png' ; // TODO: remove dir somewhere if ( compareWithOldOne ) { var compareWithOldImages = options . compareWithOldImages || false ; // the last action is always taking a screenshot. We trimmed it so when we // saved the recording fn = _simulateScreenshot . bind ( null , driver , currentEvent , taskPath , compareWithOldImages , done null , driver , currentEvent , taskPath , compareWithOldImages , _next", "commit_type": "remove"}
{"commit_tokens": ["updated", "readme", "with", "basic", "instructions", "and", "credits"], "add_tokens": "poster : true function getName ( name , width , separator ) { return separator + name ; return separator + width ; size . name = getName ( size . name , size . width , options . separator ) ;", "del_tokens": "poster : false function getName ( name , width , separator , suffix ) { // handle empty suffix as no suffix if ( typeof suffix === 'undefined' ) { suffix = '' ; } return separator + name + suffix ; return separator + width + suffix ; size . name = getName ( size . name , size . width , options . separator , size . suffix ) ;", "commit_type": "update"}
{"commit_tokens": ["add", "close", "button", "to", "show", "more", "popup"], "add_tokens": "var closeButton = document . createElement ( 'img' ) ; closeButton . classList . add ( 'md-event-calendar-show-more-close' ) ; closeButton . setAttribute ( 'src' , 'icons/ic_close_black_24px.svg' ) ; closeButton . setAttribute ( 'md-show-more-close' , 'true' ) ; container . appendChild ( closeButton ) ; cell . appendChild ( buildShowMoreLink ( validEvents . length - pos , date ) ) ; function buildShowMoreLink ( num , date ) { showMoreElement . classList . add ( 'md-event-calendar-cell-event-show-more-link' ) ;", "del_tokens": "cell . appendChild ( buildShowMore ( validEvents . length - pos , date ) ) ; function buildShowMore ( num , date ) { showMoreElement . classList . add ( 'md-event-calendar-cell-event-show-more' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "GET", "/", "statistics", "and", "updated", "integration", "with", "barnacles"], "add_tokens": "this . api = new barterer ( { httpPort : 3006 } ) ; // TODO: make configurable // ----- route: /statistics ------ this . router . route ( '/statistics' ) . get ( function ( req , res ) { self . notifications . getStatistics ( req , function ( response , status ) { res . status ( status ) . json ( response ) ; } ) ; } ) ;", "del_tokens": "this . api = new barterer ( { httpPort : 3005 } ) ; // TODO: make configurable", "commit_type": "add"}
{"commit_tokens": ["added", "an", "error", "response", "config", "option"], "add_tokens": "sand . http . config . sendErrorResponse . call ( this , err ) ;", "del_tokens": "let self = this ; this . res . format ( { 'application/json' : function ( ) { self . json ( { error : err } ) ; } , 'text/html' : function ( ) { let config = sand . http . config ; if ( 'string' === typeof config [ err . statusCode ] ) { self . render ( config [ err . statusCode ] , err ) ; } else if ( _ . isPlainObject ( config [ err . statusCode ] ) ) { self . render ( config [ err . statusCode ] . file , config [ err . statusCode ] . data ) ; } else { self . send ( message ) ; } } , 'text/plain' : function ( ) { self . send ( message ) ; } } ) ;", "commit_type": "add"}
{"commit_tokens": ["Improving", "redirect", "ui", "and", "fixing", "ordering"], "add_tokens": "} ) . sort ( function ( a , b ) { if ( a . order < b . order ) return - 1 ; if ( a . order > b . order ) return 1 ; return 0 ;", "del_tokens": "} ) . sort ( function ( a , b ) { if ( a . order < b . order ) return - 1 ; if ( a . order > b . order ) return 1 ; return 0 ;", "commit_type": "improve"}
{"commit_tokens": ["removed", "window", ".", "close", "()", "call", "from", "browser", "as", "it", "s", "causeing", "firefox", "to", "crash", "and", "behave", "strangely", "on", "the", "next", "run"], "add_tokens": "$ . post ( '/tests-complete' , JSON . stringify ( testResults ) ) ;", "del_tokens": "$ . post ( '/tests-complete' , JSON . stringify ( testResults ) , function ( ) { // alert('test complete'); window . close ( ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "CSS", "only", "reset", "button"], "add_tokens": "var html = '<button id=\"rateit-reset-{{index}}\" type=\"button\" data-role=\"none\" class=\"rateit-reset\" aria-label=\"' + $ . rateit . aria . resetLabel + '\" aria-controls=\"rateit-range-{{index}}\"><span></span></button><{{element}} id=\"rateit-range-{{index}}\" class=\"rateit-range\" tabindex=\"0\" role=\"slider\" aria-label=\"' + $ . rateit . aria . ratingLabel + '\" aria-owns=\"rateit-reset-{{index}}\" aria-valuemin=\"' + itemdata ( 'min' ) + '\" aria-valuemax=\"' + itemdata ( 'max' ) + '\" aria-valuenow=\"' + itemdata ( 'value' ) + '\"><{{element}} class=\"rateit-empty\"></{{element}}><{{element}} class=\"rateit-selected\"></{{element}}><{{element}} class=\"rateit-hover\"></{{element}}></{{element}}>' ;", "del_tokens": "var html = '<button id=\"rateit-reset-{{index}}\" type=\"button\" data-role=\"none\" class=\"rateit-reset\" aria-label=\"' + $ . rateit . aria . resetLabel + '\" aria-controls=\"rateit-range-{{index}}\"></button><{{element}} id=\"rateit-range-{{index}}\" class=\"rateit-range\" tabindex=\"0\" role=\"slider\" aria-label=\"' + $ . rateit . aria . ratingLabel + '\" aria-owns=\"rateit-reset-{{index}}\" aria-valuemin=\"' + itemdata ( 'min' ) + '\" aria-valuemax=\"' + itemdata ( 'max' ) + '\" aria-valuenow=\"' + itemdata ( 'value' ) + '\"><{{element}} class=\"rateit-empty\"></{{element}}><{{element}} class=\"rateit-selected\"></{{element}}><{{element}} class=\"rateit-hover\"></{{element}}></{{element}}>' ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "even", "more", "debug", "logging"], "add_tokens": "console . log ( ` ${ sha } ${ JSON . stringify ( json , null , 2 ) } ` ) if ( process . env . VERBOSE ) { console . log ( ` ${ sha } ${ JSON . stringify ( json , null , 2 ) } ` ) }", "del_tokens": "console . log ( ` ${ sha } ${ JSON . stringify ( __ . map ( json , 'merge_commit_sha' ) ) } ` ) if ( process . env . VERBOSE ) { console . log ( ` ${ pr . head . sha } ${ sha } ` ) }", "commit_type": "add"}
{"commit_tokens": ["Add", "user", "agent", "parsing", "."], "add_tokens": "metrics = require ( '../metrics' ) , useragent = require ( 'useragent' ) ; // Asynchronously update the user agent database. useragent ( true ) ; var browser = useragent . lookup ( userAgent ) . toJSON ( ) ; name : browser . family , version : browser . major", "del_tokens": "metrics = require ( '../metrics' ) ; // TODO name : '' , version : ''", "commit_type": "add"}
{"commit_tokens": ["move", "parser", "to", "new", "folder"], "add_tokens": "JDLParser = require ( '../parser/jdl_parser' ) ;", "del_tokens": "JDLParser = require ( '../dsl/jdl_parser' ) ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "_", "typo", "again", ".", "It", "double", "in", "volume", "this", "time", "...", "Weird"], "add_tokens": "delete self . _modified [ entity . _type ( ) ] [ entity . id ( ) ] ; self . _modified [ entity . _type ( ) ] [ entity . id ( ) ]", "del_tokens": "delete self . _modified [ entity . _type ( ) ] [ entity . _id ( ) ] ; self . _modified [ entity . _type ( ) ] [ entity . _id ( ) ]", "commit_type": "fix"}
{"commit_tokens": ["Update", "to", "latest", "Grunt", ".", "Fix", "lint", "errors"], "add_tokens": "grunt . loadNpmTasks ( 'grunt-benchmark' ) ; grunt . loadNpmTasks ( 'grunt-contrib-jshint' ) ; grunt . loadNpmTasks ( 'grunt-contrib-nodeunit' ) ;", "del_tokens": "grunt . loadNpmTasks ( 'grunt-benchmark' ) ;", "commit_type": "update"}
{"commit_tokens": ["Making", "more", "complex", "examples", "work"], "add_tokens": "\"use strict\" ; title : 'Selection of Selections' , placeholder : 'Select a make' placeholder : 'Select a model' props : { valueManager : true } , setup : function ( scope , props ) { props . valueManager = 'Subschema.ValueManager(' + JSON . stringify ( props . value , null , '\\t' ) + ')' ; delete props . value ; } , setupTxt : require ( '!!raw!./CarMake-setup.js' )", "del_tokens": "title : 'Selection of Selections' , placeholder : 'Select a make' placeholder : 'Select a model' setup : require ( './CarMake-setup.js' ) , setupTxt : require ( '!!raw!../sample-loader!./CarMake-setup.js' )", "commit_type": "make"}
{"commit_tokens": ["make", "it", "portable", "(", "no", "compilation", ")", "and", "added", "titleize"], "add_tokens": "return api . extend ( { } , t ) ; uppercase : function ( v ) { return v . toUpperCase ( ) ; } , titlelize : function ( value ) { return ( ( value || '' ) + '' ) . replace ( / ([A-Z]) / g , ' $1' ) . replace ( / ^. / , api . uppercase ) ; } ,", "del_tokens": "var { ... ret } = t ; return ret ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "https", ":", "//", "github", ".", "com", "/", "mWater", "/", "mwater", "-", "app", "/", "issues", "/", "413"], "add_tokens": "this . shownFirstTime ( ) ; } if ( ! this . visible && this . model . has ( this . id ) ) { return this . model . unset ( this . id ) ;", "del_tokens": "return this . shownFirstTime ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["changed", "and", "fixed", "few", "glitches", "in", "promise"], "add_tokens": "var ext = global , ts = ext . ToolStack ; if ( ! ts . extensionized ) { ts . extensionized = true ; delete ext . ToolChain ; delete ext . Env ; delete ext . Console ; delete ext . Matchers ; delete ext . Flux ; delete ext . ASColors ; delete ext . Class ; delete ext . Callbacks ; delete ext . Events ; delete ext . Promise ; delete ext . Logger ; delete ext . Jaz ; delete ext . Stalk ; delete ext . Structures ; delete ext . ExtInit ;", "del_tokens": "var ext = global , ts = ext . ToolStack , initalized = false ; if ( ! initalized ) { initalized = true ;", "commit_type": "change"}
{"commit_tokens": ["Fixing", "setting", "lang", "into", "web", "route", "handler", "correctly"], "add_tokens": "var routeInfo = webRouteHandler . getRouteInfo ( appName , request . url . pathname , request . query , request . app . lang ) ;", "del_tokens": "var routeInfo = webRouteHandler . getRouteInfo ( appName , request . url . pathname , request . query , request . lang ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "on", "-", "ready", "check"], "add_tokens": "if ( contains ( element , classObject . OPEN_DEFAULT ) ) { _baseTransition . applyClass ( classObject . EXPANDED ) ; element . style . maxHeight = element . scrollHeight + 'px' ; } else { previousHeight = element . scrollHeight ; _baseTransition . applyClass ( classObject . COLLAPSED ) ; }", "del_tokens": "const onReady = require ( 'cf-atomic-component/src/utilities//on-ready' ) . onReady ; onReady ( function ( ) { if ( contains ( element , classObject . OPEN_DEFAULT ) ) { _baseTransition . applyClass ( classObject . EXPANDED ) ; element . style . maxHeight = element . scrollHeight + 'px' ; } else { previousHeight = element . scrollHeight ; _baseTransition . applyClass ( classObject . COLLAPSED ) ; } } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Removed", "restRange", "and", "rhythmRange", "settings", "instead", "allowing", "ranges", "for", "rests", "and", "rhythmicVariety"], "add_tokens": "if ( settings . rests instanceof Array ) { restDelta = ( settings . rests [ 1 ] - settings . rests [ 0 ] ) / beats ; settings . rests = settings . rests [ 0 ] ; if ( settings . rhythmicVariety instanceof Array ) { rhythmDelta = ( settings . rhythmicVariety [ 1 ] - settings . rhythmicVariety [ 0 ] ) / beats ; settings . rhythmicVariety = settings . rhythmicVariety [ 0 ] ; changeDir : 0.5 , // Likelihood of changing chromatic direction, number (0 to 1) jumpiness : 0.5 , // Likelihood of jumping intervals, number (0 to 1) or range rests : 0.5 , // Likelihood of a note being a rest (previous note is sustained), number (0 to 1) rhythmicVariety : 0.5 , // Likelihood of rhythmic variety, number (0 to 1) or range range : [ 'C4' , 'C6' ] // Note range", "del_tokens": "if ( settings . restRange ) { settings . rests = settings . restRange [ 0 ] ; restDelta = ( settings . restRange [ 1 ] - settings . restRange [ 0 ] ) / beats ; if ( settings . rhythmRange ) { settings . rhythmicVariety = settings . rhythmRange [ 0 ] ; rhythmDelta = ( settings . rhythmRange [ 1 ] - settings . rhythmRange [ 0 ] ) / beats ; changeDir : 0.5 , // Likelihood of changing chromatic direction, range 0 to 1 jumpiness : 0.5 , // Likelihood of jumping intervals rests : 0.5 , // Likelihood of a note being a rest (previous note is sustained) rhythmicVariety : 0.5 , // Likelihood of rhythmic variety range : [ 'C4' , 'C6' ] , // Note range restRange : null , // Rests decrease as time goes on, within range specified rhythmRange : null // Rhythmic variety increases as time goes on, within range specified", "commit_type": "remove"}
{"commit_tokens": ["Add", "allowEmptyFormatting", "property", "that", "applies", "formatting", "to", "empty", "inputs"], "add_tokens": "allowEmptyFormatting : PropTypes . bool , allowEmptyFormatting : false , const { format , allowEmptyFormatting } = this . props ; if ( value === '' && ! allowEmptyFormatting ) { const { format , decimalScale , fixedDecimalScale , allowEmptyFormatting } = this . props ; if ( value === undefined && allowEmptyFormatting ) { value = '' ; } if ( value === undefined && ! allowEmptyFormatting ) return '' ;", "del_tokens": "const { format } = this . props ; if ( value === '' ) { const { format , decimalScale , fixedDecimalScale } = this . props ; if ( value === undefined ) return '' ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "setting", "highWaterMark", "for", "Dicer", "stream", "and", "for", "PartStream", "via", "partHwm", "property"], "add_tokens": "WritableStream . call ( this , cfg ) ; if ( ! cfg || ( ! cfg . headerFirst && typeof cfg . boundary !== 'string' ) ) this . _partOpts = ( typeof cfg . partHwm === 'number' ? { highWaterMark : cfg . partHwm } : { } ) ; this . _part = new PartStream ( this . _partOpts ) ; this . _part = new PartStream ( this . _partOpts ) ;", "del_tokens": "WritableStream . call ( this ) ; if ( ! cfg . headerFirst && typeof cfg . boundary !== 'string' ) this . _part = new PartStream ( ) ; this . _part = new PartStream ( ) ;", "commit_type": "allow"}
{"commit_tokens": ["made", "skip", "check", "case", "insensitvie"], "add_tokens": "const isSkipped = ( { raw } ) => ( / #\\s?(SKIP)+ / i ) . test ( raw )", "del_tokens": "const isSkipped = ( { raw } ) => ( / #\\s?(SKIP)+ / ) . test ( raw )", "commit_type": "make"}
{"commit_tokens": ["Update", "bootstrap", "-", "rating", ".", "js"], "add_tokens": ". append ( '<span class=\"' + this . options . filled + '\"></span>' )", "del_tokens": ". append ( '<span></span>' )", "commit_type": "update"}
{"commit_tokens": ["Allow", "mkdirRecursive", "to", "continue", "on", "EEXIST"], "add_tokens": "if ( err && err . code !== 'EEXIST' ) return callback ( err ) ;", "del_tokens": "if ( err ) { return callback ( err ) ; }", "commit_type": "allow"}
{"commit_tokens": ["improve", "readability", "a", "little", "bit", "update", "changelog"], "add_tokens": "// on touchend event, we have to use `e.changedTouches` return ( ( e . targetTouches && e . targetTouches . length && e . targetTouches [ 0 ] [ coord ] ) || ( e . changedTouches && e . changedTouches . length && e . changedTouches [ 0 ] [ coord ] ) || 0 ) ;", "del_tokens": "// on touchend event, we have to use e.changedTouches return ( e . targetTouches && e . targetTouches . length && e . targetTouches [ 0 ] [ coord ] ) || ( e . changedTouches && e . changedTouches . length && e . changedTouches [ 0 ] [ coord ] ) || 0 ;", "commit_type": "improve"}
{"commit_tokens": ["removed", "OpenSeadragon", ".", "format", "because", "it", "was", "only", "called", "once", "in", "the", "entire", "codebase", "and", "didnt", "actually", "format", "a", "string", ".", "Instead", "just", "be", "direct", "and", "return", "string", ".", "corrected", "treatment", "of", "prefixUrl", "at", "that", "location", "since", "it", "was", "ignored", "otherwise", "."], "add_tokens": "var prefix = this . _viewer . get_prefixUrl ( ) ; return prefix ? prefix + url : url ;", "del_tokens": "return $ . format ( \"{1}\" , this . _viewer . get_prefixUrl ( ) , url ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "option", "to", "flatten", "the", "folder", "structure"], "add_tokens": "if ( options . flatten ) { file . path = Path . join ( file . cwd , file . base , type , components . filename ) ; } else { file . path = Path . join ( file . cwd , file . base , components . packageName , type , components . filename ) ; }", "del_tokens": "file . path = Path . join ( file . cwd , file . base , components . packageName , type , components . filename ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "step", "callback", "for", "SFTP", ".", "fast", "(", "Get|Put", ")"], "add_tokens": "var concurrency = 25 , chunkSize = 32768 , step ; if ( typeof opts . step === 'function' ) step = opts . step ; var fsize , chunk , psrc = 0 , pdst = 0 , reads = 0 , total = 0 , srcfd , dstfd , total_done = 0 , function onstep ( chunk , total ) { total_done += chunk ; ! ! step && step ( total_done , chunk , total ) ; } onstep ( nb , fsize ) ; } else { }", "del_tokens": "var concurrency = 25 , chunkSize = 32768 ; var fsize , chunk , psrc = 0 , pdst = 0 , reads = 0 , total = 0 , srcfd , dstfd , } else", "commit_type": "add"}
{"commit_tokens": ["Add", "activity", "tab", "to", "profile"], "add_tokens": "src : [ '**/*.{png,jpg,gif,svg,jpeg}' ] ,", "del_tokens": "src : [ '**/*.{png,jpg,gif,svg}' ] ,", "commit_type": "add"}
{"commit_tokens": ["Changed", "db", ".", "init", "to", "db", ".", "setConnectionString"], "add_tokens": "* @ summary Sets DB connection string to be used by other methods . * @ function setConnectionString module . setConnectionString = function ( ) { return handleStepResult ( dispatcher . execute ( 'db' , 'setConnectionString' , Array . prototype . slice . call ( arguments ) ) , rs ) ; } ;", "del_tokens": "* @ summary Stores DB connection string to be used by other methods . * @ function init module . init = function ( ) { return handleStepResult ( dispatcher . execute ( 'db' , 'init' , Array . prototype . slice . call ( arguments ) ) , rs ) ; } ;", "commit_type": "change"}
{"commit_tokens": ["fix", "a", "bug", "in", "destroy", "that", "failed", "item", "found", "check"], "add_tokens": "return _ . result ( model , 'url' ) ; debug ( 'DESTROY: %o' , model . toJSON ( options ) ) ; var modelId = getKey ( model ) ; this . store ( ) . removeItem ( modelId , function ( ) { var itemFound = id === modelId ;", "del_tokens": "return _ . isFunction ( model . url ) ? model . url ( ) : model . url ; debug ( 'DESTROY: %o' + model . toJSON ( options ) ) ; this . store ( ) . removeItem ( getKey ( model ) , function ( ) { var itemFound = id === getKey ( model ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "event", "params", "to", "auth", "events"], "add_tokens": "self . emit ( 'esl::event::auth::success' , evt ) ; if ( cb && typeof cb === 'function' ) cb ( null , evt ) ; self . emit ( 'esl::event::auth::fail' , evt ) ; if ( cb && typeof cb === 'function' ) cb ( new Error ( 'Authentication Failed' ) , evt ) ;", "del_tokens": "self . emit ( 'esl::event::auth::success' ) ; if ( cb && typeof cb === 'function' ) cb ( ) ; self . emit ( 'esl::event::auth::fail' ) ; if ( cb && typeof cb === 'function' ) cb ( new Error ( 'Authentication Failed' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "assert", "style", "methods", "add", "additional", "keywords", "to", "package", ".", "json", "add", "additional", "tests", "for", "should", "/", "assert"], "add_tokens": "var Assertion = chai . Assertion ; var assert = chai . assert ; var v = ( version ) ? version : '' ; var regex = getRegEx ( v ) ; // should / expect methods for chai // assert methods for chai assert . uuid = function ( val , exp ) { new chai . Assertion ( val ) . to . be . a . uuid ( exp ) ; } ; assert . guid = assert . uuid ;", "del_tokens": "const Assertion = chai . Assertion ; const v = ( version ) ? version : '' ; const regex = getRegEx ( v ) ; // expose methods for chai", "commit_type": "add"}
{"commit_tokens": ["Remove", "go", "prefix", "for", "angular", "components", "defined", "in", "the", "examples"], "add_tokens": "module . filter ( 'reverse' , function ( ) { module . directive ( 'layerManager' , [ map : '=layerManager' ' | reverse track by layer.get(\\'id\\')\">' + '<label>' +", "del_tokens": "module . filter ( 'goReverse' , function ( ) { module . directive ( 'goLayermanager' , [ map : '=goLayermanager' ' | goReverse track by layer.get(\\'id\\')\">' + '<label class=\"ga-checkbox\">' +", "commit_type": "remove"}
{"commit_tokens": ["Add", "docs", "getters", "section", "and", "hooking", "up", "react"], "add_tokens": "function urlize ( uri ) { return BASE_URL + uri } < li > < a href = { urlize ( \"docs/01-getting-started.html\" ) } > Docs < / a > < / li > < li > < a href = { urlize ( \"examples/\" ) } > Examples < / a > < / li > < li > < a href = { urlize ( \"api/\" ) } > API < / a > < / li >", "del_tokens": "< li > < a href = \"docs/01-getting-started.html\" > Docs < / a > < / li > < li > < a href = \"examples/\" > Examples < / a > < / li > < li > < a href = \"api/\" > API < / a > < / li >", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "DB_PATH", "env", "var"], "add_tokens": "const db = flatfile . sync ( process . env . DB_NAME || 'views.db' )", "del_tokens": "const db = flatfile . sync ( 'views.db' )", "commit_type": "add"}
{"commit_tokens": ["update", "Configuration", "default", "schemas", "descriptions", "."], "add_tokens": "\"description\" : \"Glob or array of globs to read.\" , \"description\" : \"Options to pass to node-glob through glob-stream.\" , \"description\" : \"Used for relative pathing. Typically where a glob starts.\" \"description\" : \"Setting this to false will return file.contents as a stream and not buffer files. This is useful when working with large files.\" \"description\" : \"Setting this to false will return file.contents as null and not read the file at all.\" \"description\" : \"The path (output folder) to write files to.\" \"description\" : \"cwd for the output folder, only has an effect if provided output folder is relative.\" \"description\" : \"Octal permission string specifying mode for any folders that need to be created for output folder.\"", "del_tokens": "\"description\" : \"\" , \"description\" : \"\" , \"description\" : \"\" \"description\" : \"\" \"description\" : \"\" \"description\" : \"\" \"description\" : \"\" \"description\" : \"\"", "commit_type": "update"}
{"commit_tokens": ["improve", "CLJS", "-", ">", "JS", "-", ">", "CLJS", "interop"], "add_tokens": "moduleFn . call ( module , goog . global , shadow . js . require , module , module [ \"exports\" ] ) ;", "del_tokens": "moduleFn . call ( module , shadow . js . require , module , module [ \"exports\" ] ) ;", "commit_type": "improve"}
{"commit_tokens": ["Add", "more", "user", "actions", "and", "entities"], "add_tokens": "import { TeamTypes , UserTypes } from 'action_types' ; { type : UserTypes . RECEIVED_PROFILE_IN_TEAM , data : { user_id : userId } , id : teamId } , { type : UserTypes . RECEIVED_PROFILE_NOT_IN_TEAM , data : { user_id : userId } , id : teamId } ,", "del_tokens": "import { TeamTypes } from 'action_types' ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "manual", "response", "(", "does", "not", "return", "a", "400", "or", "401", "but", "passes", "it", "back", "to", "the", "application", "to", "handle", ")"], "add_tokens": "AuthExecutionScope . prototype . halt = function ( callback , errorResponse ) { this . pass ( callback , errorResponse ) ; AuthExecutionScope . prototype . pass = function ( callback , errorResponse ) { callback ( errorResponse ) ;", "del_tokens": "AuthExecutionScope . prototype . halt = function ( callback ) { this . pass ( callback ) ; AuthExecutionScope . prototype . pass = function ( callback ) { callback ( ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "tests", "work", "in", "browser"], "add_tokens": "pull . through ( console . log . bind ( console , 'A->B' ) ) , pull . through ( console . log . bind ( console , 'A<-B' ) ) ,", "del_tokens": "pull . through ( console . log . bind ( null , 'A->B' ) ) , pull . through ( console . log . bind ( null , 'A<-B' ) ) ,", "commit_type": "make"}
{"commit_tokens": ["Use", "chmod", "instead", "of", "lchmod", "if", "not", "a", "SymbolicLink"], "add_tokens": ", chmod = me . props . follow || me . type !== \"SymbolicLink\"", "del_tokens": ", chmod = me . props . follow || me . type === \"Directory\"", "commit_type": "use"}
{"commit_tokens": ["create", "fake", "boardgame", ".", "io", "package", "in", "node_modules", "so", "that", "examples", "can", "import", "boardgame", ".", "io", "instead", "of", "files", "in", "src"], "add_tokens": "import Game from 'boardgame.io/game' ;", "del_tokens": "import Game from '../packages/game' ;", "commit_type": "create"}
{"commit_tokens": ["Added", "backwards", "compatibility", "for", "previous", "export", "API"], "add_tokens": "var module = require ( test ) ; var run = getLitmusForModule ( module ) . createRun ( ) ; / ** * Find the litmus . Test or litmus . Suite for a module . * Previous versions of litmus expected this to be exposed under a 'test' key . * / function getLitmusForModule ( module ) { function isLitmus ( module ) { return ( module . constructor == litmus . Test || module . constructor == litmus . Suite ) } if ( isLitmus ( module ) ) { return module ; } if ( module . test && isLitmus ( module . test ) ) { return module . test ; } throw new Error ( 'litmus: expected module to export litmus.Test or litmus.Suite' ) ; }", "del_tokens": "var mod = require ( test ) ; var run = mod . createRun ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "first", "item", "if", "possible"], "add_tokens": "var first = $scope . page * oldPp ; var newPage = Math . floor ( first / newPp ) ;", "del_tokens": "var middle = $scope . page * oldPp ; middle += ( Math . min ( ( $scope . page + 1 ) * oldPp , $scope . numItems - 1 ) - middle ) / 2.01 ; var newPage = Math . floor ( middle / newPp ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "extensible", "sematics", "via", "transformer"], "add_tokens": "/ ** * A function that may transform the parsed tree before the compilation continues . * This should return a new array of tokens or ` ` to use the same ( in case * of in - place changes ) * @ callback TransformerFn * @ param { Array < Token > } tokens * @ returns { ? Array < Token > } * / * @ param { TransformerFn } [ options . transformer ] // Parse let tokens = parse ( source ) // Transform if ( options . transformer ) { tokens = options . transformer ( tokens ) || tokens } let reducedTokens = reduce ( tokens ) ,", "del_tokens": "let tokens = parse ( source ) , reducedTokens = reduce ( tokens ) ,", "commit_type": "add"}
{"commit_tokens": ["Removing", "transform", "questions", "from", "swagen", "init", ".", "The", "generator", "packages", "will", "not", "provide", "default", "values", "for", "the", "transforms", "."], "add_tokens": "serviceName : [ ] , operationName : [ ] , modelName : [ ] , propertyName : [ ] ,", "del_tokens": "function getTransformValue ( transform ) { switch ( transform ) { case 'cc' : return [ ` ` ] ; case 'pc' : return [ ` ` ] ; default : return [ ] ; } } serviceName : getTransformValue ( answers . transformServiceName ) , operationName : getTransformValue ( answers . transformOperationName ) , modelName : getTransformValue ( answers . transformModelName ) , propertyName : getTransformValue ( answers . transformPropertyName ) ,", "commit_type": "remove"}
{"commit_tokens": ["Added", "link", "to", "ghp", "docs", "minor", "fix", "for", "the", "events", "test", "."], "add_tokens": "expect ( infoSpy . calledWith ( 'Worker forked: ' + worker . id ) ) . to . be . true ( ) ;", "del_tokens": "expect ( infoSpy . calledWith ( 'Worker forked: ' + worker . id ) ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "unused", "-", "moz", "-", "and", "-", "ms", "-", "prefixes", "to", "reduce", "output", "payload"], "add_tokens": "line = '-webkit-' + build + build ; else if ( first === 97 && second === 112 && third === 112 ) { // vendor prefix -webkit- and -moz- // vendor prefix all // flex: f, l, e // order: o, r, d else if ( ( first === 102 && second === 108 && third === 101 ) || ( first === 111 && second === 114 && third === 100 ) ) { // vendor prefix only -webkit- line = '-webkit-' + line + line ; } // transforms & transitions: t, r, a else if ( first === 116 && second === 114 && third === 97 ) { // vendor prefix -webkit- and -ms- if transform line = '-webkit-' + line + ( line . charCodeAt ( 5 ) === 102 ? ( '-ms-' + line ) : '' ) + line ; } line = '}@' + blob + '}' ;", "del_tokens": "line = '-webkit-' + build + '-moz-' + build + build ; // flex: f, l, e // order: o, r, d else if ( ( first === 97 && second === 112 && third === 112 ) || ( first === 102 && second === 108 && third === 101 ) || ( first === 111 && second === 114 && third === 100 ) ) { // vendor prefix // transforms & transitions: t, r, a ( first === 116 && second === 114 && third === 97 ) || // vendor prefix line = '}@-moz-' + blob + '}@' + blob + '}' ;", "commit_type": "remove"}
{"commit_tokens": ["Remove", "resetPasswordToken", "in", "toJSON", "function", "for", "user", "model"], "add_tokens": "// to remove `password` and `resetPasswordToken` values. delete obj . resetPasswordToken ;", "del_tokens": "// to remove password value.", "commit_type": "remove"}
{"commit_tokens": ["Add", "process", "error", "handlers", "null", "movie", "callback"], "add_tokens": "function bail ( reason , err ) { log . error ( 'Exiting process due to ' + reason ) ; log . error ( err . stack || err ) ; process . abort ( ) ; } [ 'unhandledRejection' , 'uncaughtException' ] . forEach ( reason => { process . on ( reason , err => bail ( reason , err ) ) ; } ) ; splash . run ( path . join ( __dirname , 'splash.zip' ) , ( ) => undefined ) ;", "del_tokens": "splash . run ( path . join ( __dirname , 'splash.zip' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "tests", "for", "importing", "bower", "dependencies"], "add_tokens": "var enhancedReqFactory = require ( \"enhanced-require\" ) ; var resolveBowerComponents = { modulesDirectories : [ \"bower_components\" ] } ; var config = { resolve : id === \"imports-bower\" ? resolveBowerComponents : { } } ; var enhancedReq = enhancedReqFactory ( module , config ) ; resolve : config . resolve , test ( \"should resolve all imports of bower dependencies\" , \"imports-bower\" ) ;", "del_tokens": "var enhancedReq = require ( \"enhanced-require\" ) ( module ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "the", "sanity", "check", "for", "npm"], "add_tokens": "storage = storage || ( typeof localStorage !== \"undefined\" ? localStorage : null ) ;", "del_tokens": "storage = storage || localStorage ;", "commit_type": "fix"}
{"commit_tokens": ["use", "built", "-", "in", "path", "instead", "of", "hard", "-", "coded", "path", "formats", ";", "cleanup", "of", "some", "reduendant", "code"], "add_tokens": "validConfig = true ;", "del_tokens": "validConfig = true ;", "commit_type": "use"}
{"commit_tokens": ["use", "storage", ".", "development", "flag", "to", "provide", "automatique", "messages"], "add_tokens": "storage . development = false ; } else if ( hasResult && storage . development ) {", "del_tokens": "} else if ( hasResult ) {", "commit_type": "use"}
{"commit_tokens": ["Updating", "reference", "in", "README", "to", "dist", "minified", "js"], "add_tokens": "* @ version 2.5 .0 - 2012 - 12 - 02 , 12 : 54 : 14 PM", "del_tokens": "* @ version 2.5 .0 - 2012 - 12 - 02 , 12 : 51 : 01 PM", "commit_type": "update"}
{"commit_tokens": ["allow", "dashes", "in", "sub", "-", "store", "names"], "add_tokens": "* Throw an error if sub - store ` ` is already a key on ` ` . if ( ~ store . keys . indexOf ( name ) && ! utils . isStore ( store , name ) ) { / ** * Return true if ` ` is a store object . * / utils . isStore = function ( store , name ) { return ! ! store [ name ] && ( typeof store [ name ] === 'object' ) && store [ name ] . isStore === true ; } ;", "del_tokens": "* Throw an error if sub - store ` ` has non - word characters , or * ` ` is the same as a key on ` ` . if ( ~ store . keys . indexOf ( name ) || / \\W / . test ( name ) ) {", "commit_type": "allow"}
{"commit_tokens": ["update", "local", "cookies", "on", "setCookie"], "add_tokens": "cookies = req ? req . cookies : cookie . parse ( document . cookie ) ; ;", "del_tokens": "cookies = req ? req . cookies : cookie . parse ( document . cookie ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "README", "to", "generated", "project", "."], "add_tokens": "fs . readdirSync ( path . join ( selfPath , 'template/src' ) ) . forEach ( function ( filename ) { path . join ( selfPath , 'template/src' , filename ) , fs . readdirSync ( path . join ( selfPath , 'template' ) ) . forEach ( function ( filename ) { if ( fs . lstatSync ( path . join ( selfPath , 'template' , filename ) ) . isDirectory ( ) ) { return } copySync ( path . join ( selfPath , 'template' , filename ) , path . join ( hostPath , filename ) ) ; } ) ;", "del_tokens": "fs . readdirSync ( path . join ( selfPath , 'src' ) ) . forEach ( function ( filename ) { path . join ( selfPath , 'src' , filename ) , copySync ( path . join ( selfPath , 'index.html' ) , path . join ( hostPath , 'index.html' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "build", "blueprints", ".", "Enable", "postcss", "hooks", "via", "extensions"], "add_tokens": "loader : ExtractTextPlugin . extract ( 'style-loader' , 'css-loader!postcss-loader' ) ,", "del_tokens": "loader : ExtractTextPlugin . extract ( 'style-loader' , 'css-loader' ) ,", "commit_type": "fix"}
{"commit_tokens": ["Use", "HTTPS", "do", "download", "confusables"], "add_tokens": "const URL = 'https://www.unicode.org/Public/security/latest/confusables.txt' ;", "del_tokens": "const URL = 'http://www.unicode.org/Public/security/latest/confusables.txt' ;", "commit_type": "use"}
{"commit_tokens": ["use", "lodash", "toArray", "for", "astral", "string", "length"], "add_tokens": "var _toArray = require ( 'lodash.toarray' ) ; if ( options . astral ) lensum = _toArray ( str1 ) . length + _toArray ( str2 ) . length var achars = _toArray ( a ) ; var bchars = _toArray ( b ) ;", "del_tokens": "var stringLength = require ( 'string-length' ) ; var chars = require ( 'unicode-string/chars' ) ; if ( options . astral ) lensum = stringLength ( str1 ) + stringLength ( str2 ) ; var achars = chars ( a ) ; var bchars = chars ( b )", "commit_type": "use"}
{"commit_tokens": ["Fix", "compressing", "the", "extension", "with", "gulp", "-", "zip"], "add_tokens": "gulp . src ( 'build/extension/**' )", "del_tokens": "gulp . src ( 'build/extension/*' )", "commit_type": "fix"}
{"commit_tokens": ["changing", "current", "month", "to", "two", "months", "back"], "add_tokens": "month = month - 1 ; if ( month <= 0 ) {", "del_tokens": "month = day < 7 ? month - 1 : month ; if ( month < 0 ) {", "commit_type": "change"}
{"commit_tokens": ["allow", "reload", "the", "config", "by", "updating", "the", "file", "-", "tests", "add"], "add_tokens": "// when pass true in the argument \"reload\" then // going to watch the current env file for changes function watchFile ( env , path , file ) { fs . watch ( file , function ( e ) { // stop watching this . close ( ) ; // load new environment if ( e === 'change' ) load ( env , path , true ) ; if ( reload ) watchFile ( environment , path , path + '/' + file ) ;", "del_tokens": "var EventEmitter = require ( 'tiny-eventemitter' ) ; function watchFile ( file ) { fs . watch ( file , function ( event , filename ) { console . info ( event , filename ) ; var em = new EventEmitter ( ) ; if ( reload ) { watchFile ( path + '/' + file ) ; }", "commit_type": "allow"}
{"commit_tokens": ["add", "CSS", "Speech", "Module", "syntaxes"], "add_tokens": "'hz' : true , 'khz' : true 'dpi' : true , 'dpcm' : true , 'dppx' : true 'fr' : true } ; // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume var DECIBEL = { 'db' : true } ; // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch var SEMITONES = { 'st' : true 'decibel' : dimension ( DECIBEL ) , 'semitones' : dimension ( SEMITONES ) ,", "del_tokens": "hz : true , khz : true dpi : true , dpcm : true , dppx : true fr : true", "commit_type": "add"}
{"commit_tokens": ["Fixing", "the", "rest", "of", "the", "tests", "."], "add_tokens": "test . expect ( 2 ) ; } ) ;", "del_tokens": "return test . done ( ) ; / *test.expect(2); } ) ; * /", "commit_type": "fix"}
{"commit_tokens": ["Remove", "adapter", "caching", "and", "bump", "version"], "add_tokens": "var LS = require ( './lib/LocalStorage' ) ; return new LS ( name ) ;", "del_tokens": "var LS = require ( './lib/LocalStorage' ) , adapters = { } ; if ( adapters [ name ] ) { return adapters [ name ] ; } else { adapters [ name ] = new LS ( name ) ; return adapters [ name ] ; }", "commit_type": "remove"}
{"commit_tokens": ["updated", "website", "content", "and", "redirected", "github", "repo", "to", "skynetim"], "add_tokens": "video : true ,", "del_tokens": "video : false ,", "commit_type": "update"}
{"commit_tokens": ["Added", "options", "object", "to", "the", "parameters", "of", "afterInit", "and", "afterUpdate", "callbacks"], "add_tokens": "opt . afterUpdate && opt . afterUpdate ( $self , paper , areas , plots , options ) ; options . map . afterInit && options . map . afterInit ( $self , paper , areas , plots , options ) ; } ) . on ( \"scroll\" , function ( e ) { console . log ( \"test\" ) ;", "del_tokens": "opt . afterUpdate && opt . afterUpdate ( $self , paper , areas , plots ) ; options . map . afterInit && options . map . afterInit ( $self , paper , areas , plots ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "https", ":", "//", "github", ".", "com", "/", "GrosSacASac", "/", "DOM99", "/", "issues", "/", "49", "styling"], "add_tokens": "/ * Decorator function around an Object to provide a default value Arrays are also objects * / if ( Object . prototype . hasOwnProperty . call ( object , key ) ) { // TAG NAME: appropriate property name to retrieve and set the value // Input Type : appropriate property name to retrieve and set the value const tagNamesForUserInput = [ ` ` , ` ` , ` ` , ` ` , ] ; tagNamesForUserInput ,", "del_tokens": "/ *Decorator function around an Object to provide a default value Arrays are also objects * / if ( hasOwnProperty . call ( object , key ) ) { //Input Type : appropriate property name to retrieve and set the value //Input Type : appropriate property name to retrieve and set the value tagNamesForUserInput : [ ` ` , ` ` , ` ` , ` ` ]", "commit_type": "fix"}
{"commit_tokens": ["adding", "a", "production", "flag", "and", "basic", "socket", ".", "io", "thingies"], "add_tokens": "// a flag to tell us that we are runing in production mode global . production = true ; // start the main app", "del_tokens": "// start the real app", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "WP", "REST", "API"], "add_tokens": "this . wpAPI = opt . wpAPI || false ; var api = this . wpAPI ? 'wp-json/' : 'wc-api/' ; url = url + api + this . version + '/' + endpoint ;", "del_tokens": "url = url + 'wc-api/' + this . version + '/' + endpoint ;", "commit_type": "add"}
{"commit_tokens": ["Moved", "tools", "to", "the", "root", "in", "the", "hopes", "that", "it", "fixes", "GitHub", "s", "language", "detection", "."], "add_tokens": "var PROJECT_URL = \"http://createjs.com/\" ; var GOOGLE_CLOSURE_PATH = \"../tools/google-closure/compiler.jar\" ; var YUI_DOC_PATH = \"../tools/yuidoc/bin/yuidoc.py\" ;", "del_tokens": "var PROJECT_URL = \"http://tweenjs.com/\" ; var GOOGLE_CLOSURE_PATH = \"tools/google-closure/compiler.jar\" ; var YUI_DOC_PATH = \"tools/yuidoc/bin/yuidoc.py\" ;", "commit_type": "move"}
{"commit_tokens": ["Use", "better", "wording", "in", "usage"], "add_tokens": "playground Inject application into local Aragon client", "del_tokens": "playground Inject application into local Aragon instance", "commit_type": "use"}
{"commit_tokens": ["Add", "frame", "count", "to", "update", "call", "."], "add_tokens": "this . _frameCount = 0 ; return this . update . invoke ( ++ this . _frameCount ) ;", "del_tokens": "return this . update . invoke ( ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "individual", "model", "calls", "to", "example", "and", "implemented", "update", "and", "remove", "to", "models"], "add_tokens": "// Now you can also update a comment like this: // Now you can also update a comment like this:", "del_tokens": "// TODO: ideally I'd like to get this to a point that looked like the code below // // TODO: ideally I'd like to get this to a point that looked like the code below //", "commit_type": "add"}
{"commit_tokens": ["Add", "Transform_", ".", "transform", "tests"], "add_tokens": "it ( 'should prove that empty transform does nothing, but works' , function ( done ) { transform : function ( chunk , encoding , cb ) { this . push ( chunk ) ; this . push ( 'abcd' ) ; zstreams . fromString ( 'abcd' ) . pipe ( transformStream ) . intoString ( function ( error , str ) { expect ( str ) . to . have . length ( 8 ) ; it ( 'should prove that empty transform does nothing, but works' , function ( done ) { this . push ( chunk ) ; this . push ( 'abcd' ) ; zstreams . fromString ( 'abcd' ) . pipe ( transformStream ) . intoString ( function ( error , str ) { expect ( str ) . to . have . length ( 8 ) ; } ) ;", "del_tokens": "it ( 'should...' , function ( done ) { transform : function ( data , encoding , cb ) { transformStream . intoString ( function ( error , str ) { expect ( str ) . to . have . length ( 4 ) ; / * it ( 'should receive the Readable stream' , function ( done ) { transformStream . intoString ( function ( error , str ) { expect ( str ) . to . have . length ( 0 ) ; * / //}); / *", "commit_type": "add"}
{"commit_tokens": ["Fix", "handling", "of", "incoming", "multi", "-", "frame", "messages", "."], "add_tokens": "data = Buffer . concat ( [ current . data , frame . payload ] , current . data . length + frame . payload . length ) ;", "del_tokens": "data = Buffer . concat ( [ current . data , frame . payload ] , current . data . size ( ) + frame . payload . size ( ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", ":", "simplify", "the", "import", "statements", "checkes"], "add_tokens": "// true if a node is an import statement const isImportStatement = namedTypes . ImportDeclaration . check return body . filter ( isImportStatement ) return body . filter ( node => ! isImportStatement ( node ) )", "del_tokens": "return body . filter ( node => namedTypes . ImportDeclaration . check ( node ) ) return body . filter ( node => ! namedTypes . ImportDeclaration . check ( node ) )", "commit_type": "update"}
{"commit_tokens": ["fix", "HTML", "demo", "by", "setting", "allow_discovery"], "add_tokens": "app . use ( '/' , ExpressPeerServer ( server , { debug : true , allow_discovery : true } ) ) ;", "del_tokens": "app . use ( '/' , ExpressPeerServer ( server , { debug : true } ) )", "commit_type": "fix"}
{"commit_tokens": ["fix", "app", ".", "js", "time", "()"], "add_tokens": "templateUrl : 'views/task-template.html' , //+'?t='+ now.getTime(),", "del_tokens": "templateUrl : 'views/task-template.html' + '?t=' + now . getTime ( ) ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "util", "module", "to", "clean", "up", "some", "of", "the", "start", "up", "code", "in", "the", "mpv", "constructor"], "add_tokens": "// Utility functions var util = require ( '../util' ) ; let ipcCommand = \"\" ; ipcCommand = util . findIPCCommand ( options . binary ) ;", "del_tokens": "var ipcCommand = \"\" ; // the name of the ipc command was changed in mpv version 0.17.0 to \"--input-ipc-server\" // that's why we have to check which mpv version is running // asks for the mpv version var output = exec ( ( options . binary ? options . binary + \" --version\" : \"mpv --version\" ) , { encoding : 'utf8' } ) ; // Version Number found if ( output . match ( / UNKNOWN / ) == null ) { // get the version part of the output var start = ( output . match ( / \\d\\.*\\.* / ) ) . index ; var end = ( output . match ( / \\(C\\) / ) ) . index ; // get the version number var versionNumber = parseInt ( output . substr ( start , end ) . split ( '.' ) [ 1 ] ) ; // with some built packages distributed in some Linux distrubtions // the version number is actually a git hash // in that case fall back to the old command if ( isNaN ( versionNumber ) ) { ipcCommand = \"--input-unix-socket\" ; } // an actually number was found for the version else { // Verison 0.17.0 and higher if ( versionNumber >= 17 ) { ipcCommand = \"--input-ipc-server\" ; } // Version 0.16.0 and below else { ipcCommand = \"--input-unix-socket\" ; } } } // when compiling mpv from source the displayed version number is \"UNKNOWN\" // I assume that version that is compiled from source is the latest version // and use the new command else { ipcCommand = \"--input-ipc-server\" ; }", "commit_type": "add"}
{"commit_tokens": ["update", "tests", "to", "latest", "connect"], "add_tokens": "var serveStatic = require ( 'serve-static' ) ; //serveStatic causes the incoming request stream to be ended for GETs. app . use ( serveStatic ( path . resolve ( '.' ) ) ) ; app . use ( serveStatic ( path . resolve ( '.' ) ) ) ;", "del_tokens": "//connect.directory causes the incoming request stream to be ended for GETs. app . use ( connect . directory ( path . resolve ( '.' ) ) ) ; // TODO app.use(serveStatic(path.resolve('.')))", "commit_type": "update"}
{"commit_tokens": ["Fix", "splitAndMerge", "and", "add", "more", "test", "for", "it"], "add_tokens": "return this . filter ( function ( text , tok ) { return true ; Tokenizer . prototype . splitAndMerge = function tokenizeSplitAndMerge ( fn , opts ) { opts = _ . defaults ( opts || { } , { mergeWith : '' } ) ; // Merge accumulator into one token var tok = tokenUtils . merge ( accu , opts . mergeWith ) ; result . push ( tok ) ; that . split ( function ( word , token ) { //console.log('fn', token); //console.log('fn returns', toks, token); //console.log('->', toks);", "del_tokens": "return this . split ( function ( text , tok ) { return tok ; Tokenizer . prototype . splitAndMerge = function tokenizeSplitAndMerge ( fn ) { result . push ( _ . pluck ( accu , 'value' ) . join ( '' ) ) ; that . split ( function ( token ) {", "commit_type": "fix"}
{"commit_tokens": ["removed", "bug", "when", "tan", "(", "40", "+", "5", ")", "was", "calculating", "tan40", "plus", "5"], "add_tokens": "var Mexp = require ( './math_function.js' ) ; 1 : numbers 3 : Math constant values like e , pi , Cruncher ans if ( str1 [ i + f ] !== str2 [ f ] ) var ptc = [ ] ; //Parenthesis to close at the beginning is after one token var pcounter = 0 ; pcounter += ptc . length ; ptc = [ ] ; while ( pcounter -- ) { //loop over ptc str . push ( { value : \")\" , type : 5 , pre : 0 , show : \")\" } ) ; } pcounter = 0 ; console . log ( str ) ;", "del_tokens": "var Mexp = require ( './math_function.js' ) ; 1 : numbers 3 : Math constant values like e , pi , Cruncher ans if ( str1 [ i + f ] !== str2 [ f ] ) var ptc = [ ] ; //Parenthesis to close at the beginning is after one token inc ( ptc , 1 ) ;", "commit_type": "remove"}
{"commit_tokens": ["removing", "attributes", "on", "null", "values", "to", "allow", "disabled", "+", "required"], "add_tokens": "// TODO remove based on old eventlistener-function not new one if ( value === null ) { elem . removeAttribute ( property ) ; } else { elem . setAttribute ( property , value ) ; }", "del_tokens": "elem . setAttribute ( property , value ) ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", ";", "show", ".", "collections"], "add_tokens": "db . cols ( function ( err , names ) {", "del_tokens": "db . collections ( function ( err , names ) {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "failing", "join", "test", "."], "add_tokens": "query : 'UPDATE `tablea` JOIN tableb ON (tablea.id = tableb.id) SET tablea.foo = tableb.foo WHERE tablea.batch = ?' ,", "del_tokens": "query : 'UPDATE `tablea` JOIN `tableb` ON (tablea.id = tableb.id) SET tablea.foo = tableb.foo WHERE tablea.batch = ?' ,", "commit_type": "fix"}
{"commit_tokens": ["Use", "in", "-", "place", "BN", "calls", "where", "possible"], "add_tokens": "var a = blockTs . sub ( parentTs ) . idivn ( 10 ) . ineg ( ) . iaddn ( 1 ) var exp = new BN ( this . number ) . idivn ( 100000 ) . isubn ( 2 ) if ( number . cmp ( new BN ( parentBlock . header . number ) . iaddn ( 1 ) ) !== 0 ) {", "del_tokens": "var a = blockTs . sub ( parentTs ) . divn ( 10 ) . neg ( ) . addn ( 1 ) var exp = new BN ( this . number ) . divn ( 100000 ) . subn ( 2 ) if ( number . cmp ( new BN ( parentBlock . header . number ) . addn ( 1 ) ) !== 0 ) {", "commit_type": "use"}
{"commit_tokens": ["Make", "generated", "schema", ".", "js", "instantiate", "index", "objects", "only", "once", "."], "add_tokens": "results . push ( ' ' + this . getPrimaryKeyIndex_ ( table ) ) ; results . push ( ' ' + uniqueIndex ) ; var header = ' new lf.schema.Index(\\'' + table . name + '\\', \\'' ;", "del_tokens": "results . push ( ' ' + this . getPrimaryKeyIndex_ ( table ) ) ; results . push ( ' ' + uniqueIndex ) ; var header = ' new lf.schema.Index(\\'' + table . name + '\\', \\'' ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "incorrectly", "-", "refactored", "function"], "add_tokens": "function transformFlow ( [ first , ... rest ] ) {", "del_tokens": "function transformFlow ( first , ... rest ) {", "commit_type": "fix"}
{"commit_tokens": ["added", "save", "mw", "tests", "and", "post", "wrapping", "for", "save", "and", "remove", ".", "still", "need", "to", "fix", "wrapping"], "add_tokens": "* var lounge = new lounge . Lounge ( ) ;", "del_tokens": "this . schemas = { } ; delete this . schemas ; * var lounge = new mongoose . Lounge ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Improve", "support", "for", "default", "parse", "rules"], "add_tokens": "fs . writeFile ( path . join ( options . output , outFile + '.html' ) , html ) ; moveAssets ( outAssetsDirName , options , callback ) ; fs . writeFile ( path . join ( options . output , 'index.html' ) , html , function ( ) { moveAssets ( outAssetsDirName , options , callback ) ; } ) ; } function moveAssets ( outAssetsDirName , options , callback ) { runTests ( options , callback ) ; } function runTests ( options , callback ) { callback ( err ) ; else { callback ( ) ; }", "del_tokens": "fs . writeFile ( path . join ( options . output , outFile + '.html' ) , html , callback ) ; fs . writeFile ( path . join ( options . output , 'index.html' ) , html , callback ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "error", "where", "node_modules", "were", "not", "correctly", "resolved"], "add_tokens": "var trailingSlash = / [\\\\\\/]$ / ; // Less is giving us trailing slashes, but the context should have no trailing slash var context = currentDirectory . replace ( trailingSlash , \"\" ) ; loaderContext . resolve ( context , moduleRequest , function ( err , filename ) { // Less is giving us trailing slashes, but the context should have no trailing slash var context = currentDirectory . replace ( trailingSlash , \"\" ) ; filename = loaderContext . resolveSync ( context , moduleRequest ) ; }", "del_tokens": "loaderContext . resolve ( currentDirectory , moduleRequest , function ( err , filename ) { filename = loaderContext . resolveSync ( currentDirectory , moduleRequest ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Allowed", "starting", "spaces", "in", "Mark", "(", "{", "...", "}", ")", "."], "add_tokens": "const ws = [ ' ' , '\\t' , '\\r' , '\\n' ] ; if ( arguments . length === 1 && ( typeName [ 0 ] === '{' || typeName [ 0 ] === '[' || ws . indexOf ( typeName [ 0 ] ) >= 0 ) ) {", "del_tokens": "if ( arguments . length === 1 && ( typeName [ 0 ] === '{' || typeName [ 0 ] === '[' ) ) { ws = [ ' ' , '\\t' , '\\r' , '\\n' ] ,", "commit_type": "allow"}
{"commit_tokens": ["fix", "generic", "service", "-", "login"], "add_tokens": "seneca . act ( _ . extend ( { } , user , { role : 'auth' , trigger : 'service-login' , service : service } ) ,", "del_tokens": "seneca . act ( { role : 'auth' , trigger : 'service-login' , service : service } , user ,", "commit_type": "fix"}
{"commit_tokens": ["Use", "lodash", ".", "cloneDeep", "to", "ensure", "we", "never", "emit", "any", "references", "to", "the", "raw", "document", "stored", "in", "a", "LocalCollection"], "add_tokens": "import cloneDeep from 'lodash.cloneDeep' ; // Make sure that we emit a cloned copy, so that no consumer holds a direct // reference to the underlying document. this . emit ( 'added' , cloneDeep ( doc ) ) ; // Make sure that we emit a cloned copy, so that no consumer holds a direct // reference to the underlying document. this . emit ( 'changed' , cloneDeep ( doc ) , changeset ) ; export default LocalCollection ;", "del_tokens": "this . emit ( 'added' , doc ) ; this . emit ( 'changed' , doc , changeset ) ; export default LocalCollection ;", "commit_type": "use"}
{"commit_tokens": ["Added", "ability", "to", "configure", "the", "spring", "used", "by", "FlowLayoutController", "+", "ability", "to", "disable", "state", "-", "flowing"], "add_tokens": "this . options = Object . create ( FlowLayoutController . DEFAULT_OPTIONS ) ; nodeSpring : { dampingRatio : 0.8 , period : 300 } layoutNode . setOptions ( { spring : this . options . nodeSpring } ) ; if ( options . nodeSpring ) { this . _nodes . forEach ( function ( node ) { node . setOptions ( { spring : options . nodeSpring } ) ; } ) ; }", "del_tokens": "this . options = Object . create ( this . constructor . DEFAULT_OPTIONS || FlowLayoutController . DEFAULT_OPTIONS ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "helper", "functions", "to", "get", "select", "elements", "by", "model", "and", "examples", "of", "use", "."], "add_tokens": "select : function ( model ) { using : 'css selector' , value : 'select[ng-model=' + model + ']' } ; } , selectedOption : function ( model ) { return { using : 'css selector' , value : 'select[ng-model=' + model + '] option[selected]'", "del_tokens": "select : function ( ) { using : 'css' , value : ''", "commit_type": "add"}
{"commit_tokens": ["Adding", "code", "to", "support", "303", "case"], "add_tokens": "case 303 : return processTypeCode303 ( type , doNotAddBraces ) ; function processTypeCode303 ( type , doNotAddBraces ) { let typeString = '' ; let length = type . types . length ; if ( length !== 2 ) { throw new Error ( \"Dictionary should be key-value pair\" ) ; } if ( type . types [ 0 ] . code !== 8 ) { throw new Error ( \"Expected dictionary key to be a string\" ) ; } typeString = 'key : ' + getTypeStringFromCode ( type . types [ 1 ] , true ) ; return addBracesIfRequired ( typeString , doNotAddBraces ) ; }", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "day", "prior", "bug", ".", "Add", "parser", ".", "isEmpty"], "add_tokens": "var i , pos , errorBuff , oldViewValue , dateBuff , dayBuff ; console . log ( oldViewValue , nodes [ i ] . viewValue ) ; // FIXME: we should apply node.value by their priority, year > month > date > day ... // datebuff and daybuff is a temporary fix } else if ( nodes [ i ] . token . name == \"day\" ) { dayBuff = nodes [ i ] ; if ( dayBuff ) { setDate ( date , dayBuff . value , dayBuff . token ) ; } isEmpty : function ( ) { // Return true if all nodes are empty var i ; for ( i = 0 ; i < nodes . length ; i ++ ) { if ( nodes [ i ] . init && nodes [ i ] . token . type != \"static\" && nodes [ i ] . token . type != \"regex\" ) { return false ; } } return true ; } ,", "del_tokens": "var i , pos , errorBuff , oldViewValue , dateBuff ;", "commit_type": "fix"}
{"commit_tokens": ["implementing", "auto", "schema", "generation", "."], "add_tokens": "ydn . db . conn . IDatabase . prototype . doTransaction = goog . abstractMethod ; / ** * * @ param { ( SQLTransaction | IDBTransaction | Object ) } tx active transaction on version change mode . * @ param { ydn . db . StoreSchema } store_schema * / ydn . db . conn . IDatabase . prototype . addStoreSchema = goog . abstractMethod ;", "del_tokens": "ydn . db . conn . IDatabase . prototype . doTransaction = function ( transaction_callback , store_names , mode , completed_event_handler ) { } ;", "commit_type": "implement"}
{"commit_tokens": ["Add", "data", "to", "query", "string", "when", "method", "is", "GET", "or", "HEAD"], "add_tokens": "method : 'GET' , data : 'a=1&b=2'", "del_tokens": "method : 'GET'", "commit_type": "add"}
{"commit_tokens": ["Fix", "typo", "in", "usage", "for", "the", "log", "command"], "add_tokens": "appLogs . usage = \"Usage: $0 log <app-id>\" ;", "del_tokens": "appLogs . usage = \"Usage: $0 logs <app-id>\" ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "autotyping", "and", "pass", "/", "take", "thread"], "add_tokens": "const autoTyping = reusable ? null : false ; / ** * Take thread from another app * * @ param { string | Object } [ data ] * @ returns { this } * / takeThead ( data = null ) { let metadata = data ; if ( data !== null && typeof data !== 'string' ) { metadata = JSON . stringify ( data ) ; } const messageData = { recipient : { id : this . _senderId } , take_thread_control : { metadata } } ; this . _send ( messageData ) ; return this ; }", "del_tokens": "let autoTyping = null ; if ( ` ${ url } ` . match ( / \\.gif$ / i ) ) { autoTyping = false ; }", "commit_type": "update"}
{"commit_tokens": ["Improve", "strip0x", "()", "and", "prefixox", "()"], "add_tokens": "if ( ! str ) if ( typeof ( str ) !== 'string' ) return str ; return '0x' + strip0x ( str ) ; if ( ! str ) return str ; if ( typeof ( str ) !== 'string' ) return str ; return str . replace ( / ^(0x)+ / i , '' ) ;", "del_tokens": "if ( str . startsWith ( '0x' ) || str . startsWith ( '0X' ) ) return ` ${ str } ` ; if ( str . startsWith ( '0x' ) || str . startsWith ( '0X' ) ) str = str . substring ( 2 ) ; return str ;", "commit_type": "improve"}
{"commit_tokens": ["fix", "cursor", "move", "on", "input", "field", "change"], "add_tokens": "this . _lastValue = v ; // to avoid refreshing the field and move the cursor if ( this . _lastValue !== v1 ) { nd . value = v1 ; } this . _lastValue = null ;", "del_tokens": "nd . value = v1 ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "back", "growl", "for", "errors"], "add_tokens": "var _ = grunt . util . _ ; // Growl is optional var growl ; try { growl = require ( 'growl' ) ; } catch ( e ) { growl = function ( ) { } ; grunt . verbose . write ( 'Growl not found, \\'npm install growl\\' for Growl support' ) ; } grunt . fatal ( 'Reporter specified is unknown' ) ; var stats = runner . stats ; // Show Growl notice // @TODO: Get an example of this // growl('PhantomJS Error!'); grunt . fatal ( err ) ; // If failures, fail and show growl notice if ( stats . failures > 0 ) { var duration = ( stats . end - stats . start ) + 'ms' ; var failMsg = stats . failures + '/' + stats . tests + ' tests failed (' + duration + ')' ; // Show Growl notice, if avail growl ( failMsg , { image : asset ( 'growl/error.png' ) , title : 'Failure in ' + grunt . task . current . target , priority : 3 } ) ; grunt . warn ( failMsg ) ;", "del_tokens": "var _ = require ( 'lodash' ) ; grunt . fail . fatal ( 'Reporter specified is unknown' ) ; grunt . fail . fatal ( err ) ; if ( runner . stats . failures > 0 ) { grunt . fail . warn ( 'An error occured in your tests' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "creatures2", ".", "exe", "killing", "&", "opening"], "add_tokens": "* @ version 0.2 .5 that . log ( 'error' , 'VBOLE reply came too late, callback already called:' , count , args ) ; // Initial wait will be at least 1 second timeout = 3500 ;", "del_tokens": "* @ version 0.2 .4 that . log ( 'error' , 'VBOLE is too late:' , count , args ) ; timeout = 900 ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "bug", "with", "optional", "verifier"], "add_tokens": "validations = [ { any : [ 'type undefined' , validations ] } ] ;", "del_tokens": "validations = { any : [ 'not required' , validations ] } ;", "commit_type": "fix"}
{"commit_tokens": ["Fixing", ".", "ico", "fixing", "removed", "attachments", "from", "remote", "."], "add_tokens": "if ( app . doc . attachments_md5 [ f ] && app . doc . _attachments [ f ] ) { console . log ( \"Removed \" + change [ 1 ] ) ;", "del_tokens": "if ( app . doc . attachments_md5 [ f ] ) { console . log ( \"Removed \" + change [ 0 ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "direction", "instead", "of", "vertical", "prop"], "add_tokens": "if ( props . hasOwnProperty ( 'vertical' ) ) { console . warn ( 'vertical is deprecated, use `direction` instead' ) } var directionProp = props . direction ; if ( directionProp || props . hasOwnProperty ( 'vertical' ) ) { direction = directionProp ? directionProp : ( props . vertical ? 'DIRECTION_ALL' : 'DIRECTION_HORIZONTAL' ) ; hammer . get ( 'pan' ) . set ( { direction : Hammer [ direction ] } ) ; hammer . get ( 'swipe' ) . set ( { direction : Hammer [ direction ] } ) ;", "del_tokens": "if ( props . vertical ) { hammer . get ( 'pan' ) . set ( { direction : Hammer . DIRECTION_ALL } ) ; hammer . get ( 'swipe' ) . set ( { direction : Hammer . DIRECTION_ALL } ) ; } else { hammer . get ( 'pan' ) . set ( { direction : Hammer . DIRECTION_HORIZONTAL } ) ; hammer . get ( 'swipe' ) . set ( { direction : Hammer . DIRECTION_HORIZONTAL } ) ;", "commit_type": "use"}
{"commit_tokens": ["Improve", "new", "operator", "applicability", "detection"], "add_tokens": "const args = dependencies . concat ( Array . from ( arguments ) ) ; switch ( functor . $kind ) { case \"class\" : { const bound = functor . bind . apply ( functor , [ undefined ] . concat ( args ) ) ; return new bound ( ) ; } case \"function\" : { const instance = Object . create ( functor . prototype ) ; const result = functor . apply ( instance , args ) ; return result instanceof Object || Object . getOwnPropertyNames ( instance ) . length === 0 ? result : instance ; } default : return functor . apply ( undefined , args ) ; }", "del_tokens": "const bound = functor . bind . apply ( functor , [ undefined ] . concat ( dependencies , Array . from ( arguments ) ) ) ; return functor . hasOwnProperty ( \"prototype\" ) ? new bound ( ) : bound ( ) ;", "commit_type": "improve"}
{"commit_tokens": ["added", "shell", ".", "future", "()", "as", "utility"], "add_tokens": "try { func . apply ( null , args ) ; if ( shell . verbose ( ) ) console . warn ( \"Finished in \" + process . uptime ( ) + \" seconds\" ) ; } catch ( e ) { console . error ( \"Uncaught exception in nscript function: \" + e ) ; console . error ( e . stack ) ; }", "del_tokens": "func . apply ( null , args ) ; if ( shell . verbose ( ) ) console . warn ( \"Finished in \" + process . uptime ( ) + \" seconds\" ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "selecting", "all", "rows", "when", "pagination", "turned", "off"], "add_tokens": "$scope . tableDataStorageService . setAllRowsSelected ( val , $scope . isPaginationEnabled ( ) ) ;", "del_tokens": "$scope . tableDataStorageService . setAllRowsSelected ( val , $scope . paginatedRows ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "option", "to", "expose", "headers", "on", "event", "object", ".", "Optional", "parameter", "exposeHeaders", "on", "the", "configuration", "object", "when", "creating", "the", "EventSourcePolyfill", "(", "next", "to", "headers", "key", ")", ".", "eg", ".", "new", "EventSourcePolyfill", "(", "url", "{", "exposeHeaders", ":", "true", "}", ")", ";", "If", "not", "explicitly", "added", "and", "set", "to", "true", "headers", "will", "not", "be", "exposed", "."], "add_tokens": "document != undefined && document . readyState != undefined && document . readyState !== \"complete\" ) {", "del_tokens": "document != undefined && document . readyState != undefined && document . readyState !== \"complete\" ) {", "commit_type": "add"}
{"commit_tokens": ["use", "getApp", "method", "inside", "runApps", "method", "to", "keep", "lookup", "logic", "consistent"], "add_tokens": "var instance = this [ method ( 'get' ) ] ( name ) || this ;", "del_tokens": "var instance = this [ plural ] [ name ] || this ;", "commit_type": "use"}
{"commit_tokens": ["use", "path", ".", "sep", "instead", "of", "/", "for", "cross", "-", "platform", "compatibility"], "add_tokens": "var path = require ( 'path' ) ; outputPath : 'tmp' + path . sep + 'deploy-dist'", "del_tokens": "outputPath : 'tmp/deploy-dist'", "commit_type": "use"}
{"commit_tokens": ["added", "check", "throw", "if", "callback", "called", "twice", ".", "Thxs", "@Strix", "-", "CZ"], "add_tokens": "// ------------------- // test callback called more than one time // ------------------- function callItTwice ( callback ) { setTimeout ( callback , 200 ) ; setTimeout ( callback , 300 ) ; setTimeout ( callback , 400 ) ; setTimeout ( callback , 500 ) ; } ; wait . for ( callItTwice ) ; / * } catch ( e ) { } * / console . log ( 'end of tests' ) ; process . on ( 'uncaughtException' , function ( e ) { if ( e . message . indexOf ( 'called twice' ) != - 1 ) console . log ( 'OK: wait.for(callItTwice) throw an expected error' ) else console . log ( e ) ; } ) ; console . log ( 'after wait.launchFiber' ) ; console . log ( 'catched!' ) ; console . log ( e ) ;", "del_tokens": "console . log ( \"Error: \" + e . message ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "QueryBuilder", ".", "build", "method", "public"], "add_tokens": "* Builds the query into a knex query builder . * * @ returns { knex . QueryBuilder } * The built knex query builder .", "del_tokens": "* @ protected", "commit_type": "make"}
{"commit_tokens": ["Add", "timeout", "to", "file", "error", "test", "to", "ensure", "stream", "completes", "before", "assertion", "."], "add_tokens": "it ( 'should use 500 status' , function ( done ) { setTimeout ( function ( ) { res . sent . should . eql ( { status : 500 , body : '<html>\\n\\t<body>Behold, yon error!</body>\\n</html>' } ) ; done ( ) ; } , 50 ) ;", "del_tokens": "it ( 'should use 500 status' , function ( ) { res . sent . should . eql ( { status : 500 , body : '<html>\\n\\t<body>Behold, yon error!</body>\\n</html>' } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "stupid", "batchGet", "data", "response", "bug"], "add_tokens": "data . Responses [ name ] . map ( tablesByName [ name ] . mapFromDb . bind ( tablesByName [ name ] ) ) )", "del_tokens": "data . Responses [ name ] . Items . map ( tablesByName [ name ] . mapFromDb . bind ( tablesByName [ name ] ) ) )", "commit_type": "fix"}
{"commit_tokens": ["Add", "object", "for", "scripts", "in", "default"], "add_tokens": "return { 'test' : 'echo No test Script specified' } ;", "del_tokens": "return 'echo No test Script specified' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "debugging", "for", "version", "not", "showing", "up", "in", "nodester", ".", "Probably", "path", "again", "."], "add_tokens": "function emitVersionNumber ( error , stdout , stderr ) { if ( error ) { console . log ( error , stderr ) ; }", "del_tokens": "function emitVersionNumber ( error , stdout ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "reset", "password", ".", "Added", "account", "lockout", "functionality", "."], "add_tokens": "tokenExpireDurationSecs : 60 * 60 * 24 * 1 , // one day by default. failedAttemptsLockoutCount : 10 if ( user == 'locked' ) { res . status ( 401 ) . send ( { status : \"Error\" , message : config . lockedMessage || \"Account Locked. Please contact an administrator.\" } ) ; } else if ( user ) { if ( user . locked ) return 'locked' ; if ( ( user . loginAttempts || 0 ) + 1 > config . failedAttemptsLockoutCount ) { // unlocking must be implemented by the application due to authorization. if ( dal . lockAccount ) return dal . lockAccount ( user . userId ) ; } m . resetPassword = function ( key ) { var newSecret = generatePassword ( key ) ; return dal . updateUser ( key , { secretHash : encryption . encode ( newSecret , config . secret ) } ) . then ( function ( ) { return newSecret ; } ) . catch ( function ( err ) { logger . error ( 'Failed to reset password.' , err ) ; throw err ; } ) ; } ; //m.updateUser = function(user) { // Support changing the primary email address. // Actually, do to authorization concerns, this needs to be implemented by the application. //};", "del_tokens": "tokenExpireDurationSecs : 60 * 60 * 24 * 1 // one day by default. if ( user ) { m . updateUser = function ( user ) { // TODO: } ;", "commit_type": "add"}
{"commit_tokens": ["fix", "single", "column", "sort", "use", "case"], "add_tokens": "lastIsGroup , columnIndex , direction ; lastIsGroup = last . columnIndex === this . treeview . groupColumn . index ; if ( ! ( lastIsGroup && sortSpec === last ) ) { if ( lastIsGroup || this . sorts . length === 1 ) {", "del_tokens": "columnIndex , direction ; last = last . columnIndex === this . treeview . groupColumn . index && last ; if ( sortSpec !== last ) { if ( last ) {", "commit_type": "fix"}
{"commit_tokens": ["added", "the", "empty", "www", "folder", "fixed", "www", "service", "getAccountInfo"], "add_tokens": "\"display_name\" : request . session . www_user", "del_tokens": "\"display_name\" : \"server storage\" ,", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "bug", "that", "could", "break", "Growl", "support"], "add_tokens": "if ( filename . indexOf ( path . sep ) > - 1 ) {", "del_tokens": "if ( filename . indexOf ( path . sep ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "allIds", "instead", "of", "ids", "in", "Regions", ".", "names", "()"], "add_tokens": "return this . all ( ) . then ( allIds => this . names ( allIds ) ) ;", "del_tokens": "return this . all ( ) . then ( allIds => this . names ( ids ) ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "environment", "setting", "by", "file"], "add_tokens": "app . set ( 'env' , app . config . env || app . get ( 'env' ) ) ; var environmentConfigDir = path . join ( configDir , app . get ( 'env' ) ) ;", "del_tokens": "var environmentConfigDir = path . join ( configDir , app . get ( 'env' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "json", "parse", "work", "for", "windows", "environments"], "add_tokens": "const CSS_PARSE_REGEX = / \\-(.*)\\:before.*\\r?\\n\\s*content: \"(.*)\" / gm module . exports = { generate }", "del_tokens": "const CSS_PARSE_REGEX = / \\-(.*)\\:before.*\\n\\s*content: \"(.*)\" / gm module . exports = { generate }", "commit_type": "make"}
{"commit_tokens": ["implemented", "helper", ".", "js", "mthds"], "add_tokens": "// const uuidv1 = require('uuid/v1') const { pathToJson , __get , __find , __generateId } = require ( '../../helper' ) key : __generateId ( ) , key : __generateId ( ) ,", "del_tokens": "const uuidv1 = require ( 'uuid/v1' ) const { pathToJson , __get , __find } = require ( '../../helper' ) key : uuidv1 ( ) , key : uuidv1 ( ) ,", "commit_type": "implement"}
{"commit_tokens": ["updated", "ES", "reference", "pulled", "in", "latest", "API", "changes", "integration", "test", "runner", "now", "clears", "the", "previous", "tracer", "log", "when", "it", "is", "in", "use", "."], "add_tokens": "'indices.deleteWarmer' : [ '/{index}/_warmer' , '/{index}/_warmers' , '/{index}/_warmers/{name}' ] ,", "del_tokens": "] , 'search' : [ '/_search'", "commit_type": "update"}
{"commit_tokens": ["changed", "constant", "to", "local", "variable"], "add_tokens": "var successResult = true ; callback ( null , successResult ) ;", "del_tokens": "const SUCCESS_RESULT = true ; callback ( null , SUCCESS_RESULT ) ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "xmodem", "crc", "function", "call"], "add_tokens": "sendBuffer = Buffer . concat ( [ sendBuffer , new Buffer ( crc . crc16xmodem ( blockData ) . toString ( 16 ) , \"hex\" ) ] ) ;", "del_tokens": "sendBuffer = Buffer . concat ( [ sendBuffer , new Buffer ( crc . crc16ccitt ( blockData ) . toString ( 16 ) , \"hex\" ) ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["using", "stream", "combiner", "to", "ensure", "the", "stream", "is", "written", "to", "and", "read", "from", "correctly"], "add_tokens": "var output = utils . combine ( [ handle ( this , 'preWrite' ) , vfs . dest . apply ( vfs , arguments ) , handle ( this , 'postWrite' ) ] ) ; output . on ( 'end' , output . emit . bind ( output , 'finish' ) ) ; return output ;", "del_tokens": "return handle ( this , 'preWrite' ) . pipe ( vfs . dest . apply ( vfs , arguments ) )", "commit_type": "use"}
{"commit_tokens": ["Updated", "observer", ".", "add", "()", "and", "observer", ".", "fire", "()", ".", "Firing", "an", "aFrame", ".", "onReady", "event", "before", "returning", "constructor", "{}", "."], "add_tokens": "this . register [ id ] [ event ] . push ( handler ) ; * * @ param scope { string } The object for the registered event * @ param event { string } The event being fired fire : function ( scope , event ) { / ** * Firing the onReady event * / observer . fire ( \"aFrame\" , \"onReady\" ) ;", "del_tokens": "this . register . push ( { object : id , event : event , handler : hander } ) ; fire : function ( event , scope ) {", "commit_type": "update"}
{"commit_tokens": ["adds", "puts", "alias", "to", "compiler", ".", "js"], "add_tokens": "/ ** * Alias puts with console . log * if it ' * / line = line . replace ( / puts\\( / , \"console.log(\" ) ; // if bracketless puts, replace puts & append ); if ( / puts / . test ( line ) ) { line = line . replace ( / puts / , \"console.log(\" ) + \");\" ; }", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["added", "basic", "passport", "test", "cases"], "add_tokens": "it ( \"test - ldapLogin - error config\" , ( done ) => {", "del_tokens": "const nock = require ( \"nock\" ) ; it ( \"test - ldapLogin - error config\" , function ( done ) {", "commit_type": "add"}
{"commit_tokens": ["Adding", "tests", "for", "disabling", "tcp", "/", "webservers"], "add_tokens": "if ( ! options . webServerEnabled && ! options . tcpServerEnabled ) { throw new Error ( 'Can\\'t start deepstream with both webserver and tcp disabled' ) ; } this . _checkClosed ( ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Use", "$", ".", "extend", "()", "instead", "of", "extendr"], "add_tokens": "var graphs = [ $ . extend ( true , { } , this . settings . graphs [ 0 ] ) ] ; graphs . push ( $ . extend ( true , { } , this . settings . graphs [ 1 ] ) ) ; var config = $ . extend ( true , { } , this . settings . chart ) ;", "del_tokens": "Extendr = require ( 'extendr' ) , var graphs = [ Extendr . deepClone ( this . settings . graphs [ 0 ] ) ] ; graphs . push ( Extendr . deepClone ( this . settings . graphs [ 1 ] ) ) ; var config = Extendr . dereference ( this . settings . chart ) ;", "commit_type": "use"}
{"commit_tokens": ["fix", "config", "to", "be", "valid"], "add_tokens": "baseUrl : '/assets/js' , \"cms/modules/dropbox-chooser\" : \"https://www.dropbox.com/static/api/2/dropins\"", "del_tokens": "baseUrl : '/assets/js' \"cms/modules/dropbox-chooser\" : [ \"https://www.dropbox.com/static/api/2/dropins\" ]", "commit_type": "fix"}
{"commit_tokens": ["Changed", "the", "way", "classes", "are", "exported"], "add_tokens": "module . exports = class Minifier extends Transform { } ;", "del_tokens": "class Minifier extends Transform { } // Public interface. module . exports = Minifier ;", "commit_type": "change"}
{"commit_tokens": ["Added", "username", "to", "events", ")"], "add_tokens": "data . username = username ;", "del_tokens": "* @ param type [ Optional ] normal , ironman , hardcore / ultimate", "commit_type": "add"}
{"commit_tokens": ["Add", "level", "attribute", "to", "chapters", "/", "articles"], "add_tokens": "function parseTitle ( src , nums ) { var level = nums . join ( '.' ) ; level : level , level : level , function parseArticle ( chapterNum , nodes , idx ) { return parseTitle ( _ . first ( nodes ) . text , [ chapterNum , idx + 1 ] ) ; function parseChapter ( nodes , idx ) { return _ . extend ( parseTitle ( _ . first ( nodes ) . text , [ idx + 1 ] ) , { articles : _ . map ( listSplit ( filterList ( nodes ) , 'list_item_start' , 'list_item_end' ) , parseArticle . bind ( null , idx + 1 ) )", "del_tokens": "function parseTitle ( src ) { function parseArticle ( nodes ) { return parseTitle ( _ . first ( nodes ) . text ) ; function parseChapter ( nodes ) { return _ . extend ( parseTitle ( _ . first ( nodes ) . text ) , { articles : _ . map ( listSplit ( filterList ( nodes ) , 'list_item_start' , 'list_item_end' ) , parseArticle )", "commit_type": "add"}
{"commit_tokens": ["Fixing", "check", "region", "for", "determining", "the", "position"], "add_tokens": "return this . getElementPosition ( element ) ;", "del_tokens": "// return element.getLocation(); return element . getLocation ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "support", "for", "@fires", "/", "@emits"], "add_tokens": "\"arg\" : parseTypeName , \"argument\" : parseTypeName , \"constant\" : parseTypeName , \"constructor\" : parseTypeName , \"description\" : parseText , \"emits\" : parseName , \"fires\" : parseName , \"member\" : parseTypeName , \"method\" : parseName , \"module\" : parseName , \"overview\" : parseText , \"returns\" : parseTypeText , \"throws\" : parseName , \"title\" : parseText , \"version\" : parseText fn . fires = [ ] ; method . fires = [ ] ; case 'emits' : case 'fires' : fn . fires . push ( tag . name ) ; break ; if ( fn . fires . length > 0 ) { fn . fires . forEach ( function ( event_name ) { out += generateStrong ( \"Fires\" ) + \": \" ; out += generateText ( event_name , true ) ; } ) ; }", "del_tokens": "\"constructor\" : parseTypeName , \"constant\" : parseTypeName , \"description\" : parseText , \"throws\" : parseName , \"module\" : parseName , \"overview\" : parseText , \"method\" : parseName , \"member\" : parseTypeName , \"arg\" : parseTypeName , \"argument\" : parseTypeName , \"returns\" : parseTypeText , \"version\" : parseText , \"title\" : parseText", "commit_type": "add"}
{"commit_tokens": ["Implement", "spec", "registration", "on", "source", "being", "used", "."], "add_tokens": "this . _loadSpec ( id ) ; Container . prototype . _loadSpec = function ( id ) {", "del_tokens": "this . _loadModule ( id ) ; Container . prototype . _loadModule = function ( id ) {", "commit_type": "implement"}
{"commit_tokens": ["added", "tests", "for", "secure", "list"], "add_tokens": "} ) ; describe ( 'List Secure Value' , function ( ) { it ( 'should hide secure value and nested keyPaths' , function ( ) { config . useObject ( { string : \"string\" , mapObject : { key_a : \"value_a\" , key_b : \"value_b\" } } ) ; config . list ( { outputStream : outputStream , noColor : true , secure : [ 'mapObject' ] } ) ; var out = log . join ( '/' ) ; expect ( out ) . toContain ( 'string' ) ; expect ( out ) . toContain ( 'mapObject' ) ; expect ( out ) . toContain ( '****' ) ; expect ( out ) . toNotContain ( 'value_a' ) ; expect ( out ) . toNotContain ( 'value_b' ) ; } ) ; } ) ;", "del_tokens": "} ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "batch", "size", "externally", "configurable", "."], "add_tokens": "this . options . batchsize = this . options . batchsize || 10 ; var tiles = this . xyz . next ( this . options . batchsize ) ;", "del_tokens": "// @TODO make configurable var tiles = this . xyz . next ( 100 ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "the", "description", "of", "the", "#batch", "helper", "function"], "add_tokens": "* @ description Validate that the given value is an integer above ` ` . * * @ param { Number } value - The value to compare . * @ param { Number } minimum - The minimum allowed value . * * @ param { Object } options - The options provided to # batch .", "del_tokens": "* @ description Performs validation on the # batch settings . * @ param { Number } value - The value to compare . * @ param { Number } minimum - The minimum allowed value . * @ param { Object } options - The options provided to # batch .", "commit_type": "fix"}
{"commit_tokens": ["Implement", "getValueDependencies", "in", "DOM", "elements"], "add_tokens": "// Used to hide the methods to add/remove the DOM element dependencies // from the _elementDependenciesMap from the consumers of ListDOMPatcher var privates = new WeakMap ( ) ; //!steal-remove-start // keep logic to register `can.getValueDependencies` private privates . set ( this , { addValueDependency : function addValueDependency ( ) { live . _elementDependenciesMap . set ( parentNode , new Set ( [ compute ] ) ) ; } , deleteValueDependency : function deleteValueDependency ( ) { live . _elementDependenciesMap . delete ( parentNode ) ; } } ) ; //!steal-remove-end // function callback binding var data = this . data = live . setup ( parentNode , this . setupValueBinding . bind ( this ) , this . teardownValueBinding . bind ( this ) ) ; //!steal-remove-start privates . get ( this ) . addValueDependency ( ) ; //!steal-remove-end //!steal-remove-start privates . get ( this ) . deleteValueDependency ( ) ; //!steal-remove-end", "del_tokens": "// function callback binding var data = this . data = live . setup ( parentNode , this . setupValueBinding . bind ( this ) , this . teardownValueBinding . bind ( this ) ) ;", "commit_type": "implement"}
{"commit_tokens": ["Create", "connection", "from", "constructor", "properly"], "add_tokens": "this . setOptions ( options ) ; var c = new Connection ( ) ; c . setOptions ( options ) ; c . reconnect ( ) ; Connection . prototype . setOptions = function ( options ) { var o = { } ; mixin ( o , defaultOptions , options || { } ) ; this . options = o ; } ;", "del_tokens": "this . options = options || { } ; var o = { } ; mixin ( o , defaultOptions , options ) ; var c = new Connection ( o ) ; c . connect ( o . port , o . host ) ;", "commit_type": "create"}
{"commit_tokens": ["Fix", "delayed", "execution", "(", "streaming", "to", "runner", ")"], "add_tokens": "var util = require ( './util' ) ; return false ; return true ; return false ; globalEmitter . once ( 'run_start' , function ( ) { var socketWrite = socket . write . bind ( socket ) ; resultReporter . adapters . push ( socketWrite ) ; // clean up, close runner socket globalEmitter . once ( 'run_complete' , function ( ) { util . arrayRemove ( resultReporter . adapters , socketWrite ) ; socket . end ( ) ; } ) ; } ) ; if ( ! tryExecution ( ) ) { socket . write ( 'Delayed execution...\\n' ) ; }", "del_tokens": "resultReporter . adapters . push ( socket . write . bind ( socket ) ) ; // clean up, close runner socket globalEmitter . once ( 'run_complete' , function ( ) { resultReporter . adapters . length = 1 ; socket . end ( ) ; } ) tryExecution ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "bug", "with", "latest", "Node", ".", "js", "typings"], "add_tokens": "import { EventEmitter } from 'events' ;", "del_tokens": "import EventEmitter from 'events' ;", "commit_type": "fix"}
{"commit_tokens": ["Updating", "version", "and", "removing", "server", "token"], "add_tokens": "token = '' ,", "del_tokens": "token = 'aD1OrYvmUfS8cyB-AVCVPmr4Qv01HtcpR-jGCBM-' ,", "commit_type": "update"}
{"commit_tokens": ["Adding", "hiddenExpression", "to", "make", "it", "easier", "to", "interface", "with", "the", "hide", "feature"], "add_tokens": ". directive ( 'formlyForm' , function formlyForm ( $parse ) { angular . forEach ( scope . fields , function ( field ) { if ( field . hideExpression ) { var getter = $parse ( field . hideExpression ) ; scope . $watch ( function ( ) { return getter ( scope . result ) ; } , function ( hide ) { field . hide = hide ; } ) ; } } ) ;", "del_tokens": ". directive ( 'formlyForm' , function formlyForm ( ) {", "commit_type": "add"}
{"commit_tokens": ["add", "a", "test", "for", "uniqueness", "and", "an", "option", "to", "knex", "for", "sqlite3"], "add_tokens": "} , useNullAsDefault : true", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Updated", "email", "service", "with", "attachment"], "add_tokens": "* @ param { string } [ from ] - E - mail to be indicated for reply ( optional ) * @ param { JSON } attachment - Message scope for the e - mail * @ param { string } attachment . archive - archive itself * @ param { string } attachment . filename - Name for the archive send ( to , subject , message , from , attachment ) { let data = { to , subject , message , from , attachment } ;", "del_tokens": "* @ param { string } [ from ] - E - mail to be indicated for reply send ( to , subject , message , from ) { let data = { to , subject , message , from } ;", "commit_type": "update"}
{"commit_tokens": ["Use", "for", "-", "loops", "instead", "of", "forEach"], "add_tokens": "for ( var j = 0 ; j < numParsers ; j += 1 ) { assertParser ( parsers [ j ] ) ; } for ( var j = 0 ; j < numParsers ; j += 1 ) { assertParser ( parsers [ j ] ) ; }", "del_tokens": "parsers . forEach ( assertParser ) ; parsers . forEach ( assertParser ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "for", "filetrs", "pattern", "preprocessing"], "add_tokens": "filter = filter . toString ( ) . replace ( / \\*\\*|\\*|\\?|\\\\.|\\. / g , function ( m ) { case \" * \": return \" ** \" === m ? \" . + ? \" : \" [ ^ / ]+?\"; case \" ? \": return \" [ ^ / ]?\"; case \".\" : return \"\\\\.\" ; // handle `\\\\.` part default : return m ;", "del_tokens": "filter = filter . toString ( ) . replace ( / \\*\\*|\\*|\\? / , function ( m ) { case \" ** \": return \" . + ? \" case \" * \": return \" [ ^ / ]+\"; case \" ? \": return \" [ ^ / ]?\"; default : return m [ 0 ] ;", "commit_type": "fix"}
{"commit_tokens": ["move", "arg", "ext", "into", "options"], "add_tokens": "var joinExt = function ( filename , ext ) { return [ filename , ext . slice ( 0 , 1 ) === '.' ? ext : ( '.' + ext ) ] . join ( '' ) ; } ; Cache . prototype . load = function ( basepath , options ) { slim : false , ext : '.tpl' if ( isExt ( filename , options . ext ) ) { filename = isExt ( filename , this . _options . ext ) ? filename : joinExt ( filename , this . _options . ext ) ;", "del_tokens": "this . _ext = '' ; Cache . prototype . load = function ( basepath , ext , options ) { slim : false if ( isExt ( filename , ext ) ) { this . _ext = ext ; filename = isExt ( filename , this . _ext ) ? filename : [ filename , this . _ext ] . join ( '' ) ;", "commit_type": "move"}
{"commit_tokens": ["Moved", "node", "-", "sass", "to", "deps", ";", "updated", "WeaveLogo", "example"], "add_tokens": "* import { WeaveLogo } from 'weaveworks-ui-components' * React . render ( < WeaveLogo / > , document . getElementById ( 'logo' ) )", "del_tokens": "* import { Logo } from 'weaveworks-ui-components' * React . render ( < Logo / > , document . getElementById ( 'logo' ) )", "commit_type": "move"}
{"commit_tokens": ["Added", "option", "to", "use", "the", "downloaded", "sonar", "-", "runner", "(", "only", "downloaded", "if", "the", "sonar", "-", "runner", "is", "not", "available", "on", "the", "classpath", ")"], "add_tokens": "version : '0.2.10' ) ; // Actually load this plugin's task(s). // These plugins provide necessary tasks. // Whenever the \"test\" task is run, first clean the \"tmp\" dir, then run this // plugin's task(s), then test the result. // By default, lint and run all tests. } ;", "del_tokens": "version : '0.2.0' ) ; // Actually load this plugin's task(s). // These plugins provide necessary tasks. // Whenever the \"test\" task is run, first clean the \"tmp\" dir, then run this // plugin's task(s), then test the result. // By default, lint and run all tests. } ;", "commit_type": "add"}
{"commit_tokens": ["Add", "custom", "style", "for", "audio", "player"], "add_tokens": "var style = \"width: 50%; height:75px; position: fixed; left: 25%; bottom: 4px;z-index: 33;\" ; // style used for audio controls if ( config . style ) style = config . style ; divElement . setAttribute ( 'style' , style ) ; // create silent source if not yet existent if ( audioFile != null || defaultDuration > 0 ) { container . appendChild ( audioElement ) ; }", "del_tokens": "divElement . setAttribute ( 'style' , \"width: 50%; height:75px; position: fixed; left: 25%; bottom: 4px;z-index: 33;\" ) ; // create silenet source if not yet existent container . appendChild ( audioElement ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "deprecation", "removeSelf", "-", ">", "remove"], "add_tokens": "rule . remove ( ) ; declaration . remove ( ) ;", "del_tokens": "rule . removeSelf ( ) ; declaration . removeSelf ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "requiring", "viewer", ".", "js", "with", "CommonJS", "syntax"], "add_tokens": "banner : '' } , wrapjs : { src : [ 'src/js/wrap.js' ] , dest : 'build/crocodoc.viewer.js' , options : { process : function ( content ) { return content . replace ( '//__crocodoc_viewer__' , grunt . file . read ( 'build/crocodoc.viewer.js' ) ) ; } } dist : { var defaultTasks = [ 'test' , 'concat:js' , 'concat:wrapjs' ] ; grunt . registerTask ( 'release' , [ 'build' , 'copy:dist' ] ) ;", "del_tokens": "var WRAPPER_HEADER = 'var Crocodoc = (function ($) {\\n\\n' , WRAPPER_FOOTER = '\\n\\nreturn Crocodoc;\\n})(jQuery);' ; // also use the jQuery wrapper for js files banner : '<%= concat.options.banner %>' + WRAPPER_HEADER , footer : WRAPPER_FOOTER main : { var defaultTasks = [ 'test' , 'concat:js' ] ; grunt . registerTask ( 'release' , [ 'build' , 'copy' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "comments", "_helpers", ".", "markup"], "add_tokens": "* @ param { string } tag", "del_tokens": "* @ param { string } type", "commit_type": "update"}
{"commit_tokens": ["Added", "offset", "contant", "for", "line", "charts", "to", "align", "with", "bars", "chart"], "add_tokens": "let centeriser = xSpacing / 2 - MARKER_RADIUS ; let fullWidth = xSpacing * ( chart . data . length - 1 ) + centeriser ; let spacing = idx * xSpacing + centeriser ;", "del_tokens": "let fullWidth = xSpacing * ( chart . data . length - 1 ) ; let spacing = idx * xSpacing ;", "commit_type": "add"}
{"commit_tokens": ["fix", "plugin", "name", "in", "index", ".", "js"], "add_tokens": "const PLUGIN_NAME = 'gulp-cog' ;", "del_tokens": "const PLUGIN_NAME = 'gulp-include-chain' ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "the", "read", "-", "blocks", "consumer"], "add_tokens": "this . token = this . lexer . lex ( ) || EOF ; // @fixme should expect {, T_STRING even if not NS_SEP this . expect ( EOF ) ; this . read_top_statements ( this . next ( ) ) : this . read_inner_statements ( this . next ( ) )", "del_tokens": "this . token = this . lexer . lex ( ) || this . error ( EOF ) ; if ( this . token != EOF ) this . error ( this . token , EOF ) ; this . token = this . lexer . lex ( ) || EOF ; this . token = this . lexer . lex ( ) || EOF ; this . token = this . lexer . lex ( ) || EOF ; this . read_inner_statements ( token ) : this . read_top_statements ( token )", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "injectService", "to", "return", "the", "service", "not", "invoke", "it", "if", "it", "s", "not", "a", "string"], "add_tokens": "// TODO extract this into a helper since it's used here and in railsResourceFactory return angular . isString ( service ) ? $injector . get ( service ) : service ;", "del_tokens": "return angular . isString ( service ) ? $injector . get ( service ) : $injector . invoke ( service )", "commit_type": "fix"}
{"commit_tokens": ["Added", "new", "function", "for", "AV", ".", "Object", "and", "it", "s", "subclasses", "."], "add_tokens": "var gameScore = GameScore . new ( ) ; myPost = Post . new ( ) ;", "del_tokens": "var gameScore = new GameScore ( ) ; myPost = new Post ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "custom", "auth", "to", "settings"], "add_tokens": "// Basic & custom authentication are supported // Enable Your own authentication: a function that takes // customAuth(req) // - req - request // must return true if user authenticated, false if not // eg: (req) => { if(req.user.isAdmin) {return true;} else {return false }} this . customAuth = null ;", "del_tokens": "// Only Basic authentication is supported", "commit_type": "add"}
{"commit_tokens": ["updated", "scratchpad", "namespace", "to", "match", "component"], "add_tokens": "var scratchPad = eleOrCy . scratch ( \"_autopanOnDrag\" ) ;", "del_tokens": "var scratchPad = eleOrCy . scratch ( \"_undoRedo\" ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "AMD", "compatibility", "with", "almond", "loader"], "add_tokens": "define ( function ( ) { factory ( root ) ; } ) ;", "del_tokens": "define ( factory ( root ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "the", "ability", "to", "create", "a", "new", "record", "(", "also", "moved", "bootstrapField", "into", "helpers", "-", "form", "and", "form", "creation", "now", "introspects", "for", "default", "values", ")", "."], "add_tokens": "// setup a route for each model create this . f . addRoute . call ( this , this . r . modelCreate , this . options . adminPath + '/model/:model/new' , middleware . modelCreate ( ) ) ; // setup a route for each model create > save this . f . addRoute . call ( this , this . r . modelSave , this . options . adminPath + '/model/:model/create' , middleware . modelSave ( ) , 'post' ) ; // seutp a route for each model records overview handler // setup a route for each model records edit handler // seutp a route for each model records save handler", "del_tokens": "// seutp a route for each model overview handler // setup a route for each models edit handler // seutp a route for each models save handler", "commit_type": "add"}
{"commit_tokens": ["Use", "NamedModulesPlugin", "in", "test", "webpack", "config"], "add_tokens": "const { EnvironmentPlugin , NamedModulesPlugin } = require ( 'webpack' ) new NamedModulesPlugin ( ) ,", "del_tokens": "const { EnvironmentPlugin } = require ( 'webpack' )", "commit_type": "use"}
{"commit_tokens": ["Add", "option", "match", "to", "accept", "multiple", "trailing", "types"], "add_tokens": "const TrailingBlock = require ( '../lib' ) ; const plugin = TrailingBlock ( { match : node => ( node . type == 'paragraph' || node . type == 'footnote' ) } ) ;", "del_tokens": "const EditList = require ( '../lib' ) ; const plugin = EditList ( ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "test", "case", "to", "check", "if", "variables", "are", "declared", "automatically", "(", "correctly", ")"], "add_tokens": "it ( 'a = b = c = (d) -> a + b + c + d' , ( ) => { const example = ` ` ; const expected = ` var c ; var b ; var a = b = c = function ( d ) { return a + b + c + d ; } ; ` expect ( compile ( example ) ) . toBe ( expected ) ; } )", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Move", "readline", "var", "definition", "up"], "add_tokens": "var rl = readline . createInterface ( { input : process . stdin , output : process . stdout } ) ;", "del_tokens": "var rl = readline . createInterface ( { input : process . stdin , output : process . stdout } ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "expiration", "argument", "to", "set", "/", "add", "/", "replace"], "add_tokens": "// operation is signaled through the argument to the callback. The last argument is // an optional expiration which overrides the default expiration Client . prototype . set = function ( key , value , callback , expires ) { makeExpiration ( expires || this . options . expires ) ] ) ; Client . prototype . add = function ( key , value , callback , expires ) { var extras = Buffer . concat ( [ new Buffer ( '00000000' , 'hex' ) , makeExpiration ( expires || this . options . expires ) ] ) ; Client . prototype . replace = function ( key , value , callback , expires ) { var extras = Buffer . concat ( [ new Buffer ( '00000000' , 'hex' ) , makeExpiration ( expires || this . options . expires ) ] ) ;", "del_tokens": "// operation is signaled through the argument to the callback. Client . prototype . set = function ( key , value , callback ) { makeExpiration ( this . options . expires ) ] ) ; Client . prototype . add = function ( key , value , callback ) { var extras = Buffer . concat ( [ new Buffer ( '00000000' , 'hex' ) , makeExpiration ( this . options . expires ) ] ) ; Client . prototype . replace = function ( key , value , callback ) { var extras = Buffer . concat ( [ new Buffer ( '00000000' , 'hex' ) , makeExpiration ( this . options . expires ) ] ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "regression", "when", "negotiation", "fails"], "add_tokens": "if ( ! method || method === 'identity' ) return nocompress ( )", "del_tokens": "if ( ! method || method === 'identity' ) nocompress ( )", "commit_type": "fix"}
{"commit_tokens": ["Added", "test", "case", "testing", "copying", "source"], "add_tokens": "var schemaJSON , copyJSON ; it ( 'Should be able to create a copy of source' , function ( ) { runCli ( [ inputLocalPath , '--jsondir' , './test/fixtures/var/' ] ) ; copyJSON = JSON . parse ( fs . readFileSync ( './test/fixtures/var/valid.json' ) ) ; expect ( inputJSON ) . to . be . deep . equal ( copyJSON ) ; fs . unlinkSync ( './test/fixtures/var/valid.json' ) ; fs . rmdirSync ( './test/fixtures/var' ) ; } ) ;", "del_tokens": "var schemaJSON ;", "commit_type": "add"}
{"commit_tokens": ["adding", "JSON", "parse", "to", "decode", "results"], "add_tokens": "try { const results = JSON . stringify ( JSON . parse ( res . slice ( 5 ) ) ) ; return results ; } catch ( e ) { return res ; }", "del_tokens": "return res . slice ( 5 ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "minimum", "a", "space", "character", "when", "recompose", "values"], "add_tokens": "return strings . reduce ( ( a , b , i ) => a + numbers [ i - 1 ] + ( b ? b : ' ' ) ) ;", "del_tokens": "return strings . reduce ( ( a , b , i ) => a + numbers [ i - 1 ] + b ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "couple", "bugs", "added", "compiled", "lib"], "add_tokens": "callback ( f . payload , f . from ) ; if ( f . id === m . id && f . type === 'response' ) { net . nutella . mqtt_client . subscribe ( padded_channel , mqtt_cb , function ( ) { // Publish message net . nutella . mqtt_client . publish ( padded_channel , m . message ) ; } ) ; return channel . replace ( \"/nutella/apps/\" + app_id + \"/\" , '' ) ; return channel . replace ( \"/nutella/apps/\" + app_id + \"/runs/\" + run_id + \"/\" , '' ) ;", "del_tokens": "callback . call ( f . payload , f . from ) ; if ( f . id === m . id && m . type === 'response' ) { net . nutella . mqtt_client . subscribe ( padded_channel , mqtt_cb ) ; // Publish message net . nutella . mqtt_client . publish ( padded_channel , m . message ) ; //type, from, payload, id = return channel . replace ( \"/nutella/apps/#{app_id}/\" , '' ) ; return channel . replace ( \"/nutella/apps/#{app_id}/runs/#{run_id}/\" , '' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "test", "and", "fixing", "zero", "productId", "and", "vendorId", "."], "add_tokens": "const _ = require ( 'underscore' ) ; const isUndefined = _ . isUndefined ; if ( _ . every ( [ options . path , options . vendorId , options . productId ] , isUndefined ) ) { if ( isUndefined ( options . path ) ) { if ( isUndefined ( options . productId ) ) { throw new Error ( 'no HID productId specified' ) ; } if ( isUndefined ( options . vendorId ) ) { throw new Error ( 'no HID vendorId specified' ) ; }", "del_tokens": "if ( ! options . path && ( typeof options . vendorId == 'undefined' || options . vendorId === null ) && ! options . productId ) { if ( ! options . path && ( typeof options . vendorId != 'undefined' && options . vendorId !== null ) && ! options . productId ) { throw new Error ( 'no HID productId specified' ) ; } if ( ! options . path && ( typeof options . vendorId == 'undefined' || options . vendorId === null ) && options . productId ) { throw new Error ( 'no HID vendorId specified' ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "other", "fields", "test", "to", "ignore", "extraneous", "keys"], "add_tokens": "for ( var i = 0 ; i < otherFieldsCount ; i ++ ) { expect ( eventReceived . otherFields [ 'key' + i ] ) . to . eql ( eventToSend . otherFields [ 'key' + i ] ) }", "del_tokens": "expect ( eventReceived . otherFields ) . to . eql ( eventToSend . otherFields )", "commit_type": "change"}
{"commit_tokens": ["Change", "arrow", "functions", "to", "normal", "functions", "in", "demos"], "add_tokens": "content1 . addEventListener ( 'show' , function ( e ) { content1 . addEventListener ( 'hide' , function ( e ) { content11 . addEventListener ( 'show' , function ( e ) { content11 . addEventListener ( 'hide' , function ( e ) { content111 . addEventListener ( 'show' , function ( e ) { content111 . addEventListener ( 'hide' , function ( e ) {", "del_tokens": "content1 . addEventListener ( 'show' , e => { content1 . addEventListener ( 'hide' , e => { content11 . addEventListener ( 'show' , e => { content11 . addEventListener ( 'hide' , e => { content111 . addEventListener ( 'show' , e => { content111 . addEventListener ( 'hide' , e => {", "commit_type": "change"}
{"commit_tokens": ["update", "obsolete", "comment", "about", "BinomialDistribution"], "add_tokens": "/ * Distribution functions for the binomial distribution. Computes exact binomial results for small samples and falls back on the normal approximation for large samples .", "del_tokens": "/ * Distribution functions for the binomial distribution. Relies entirely on the normal approximation . jStat ' class could be improved by making it compute exact binomial functions for small cases and fall back to the normal approximation for large cases .", "commit_type": "update"}
{"commit_tokens": ["Added", "the", "remaining", "unit", "tests", "."], "add_tokens": "browsers : [ 'Chrome' ] , // PhantomJS", "del_tokens": "browsers : [ 'PhantomJS' ] ,", "commit_type": "add"}
{"commit_tokens": ["add", "answers", "to", "onSubmit", "and", "onCancel", "callbacks"], "add_tokens": "quit = onSubmit ( question , answer , answers ) ; quit = ! onCancel ( question , answers ) ;", "del_tokens": "quit = onSubmit ( question , answer ) ; quit = ! onCancel ( question ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "with", "--", "run", "-", "self", "-", "tests"], "add_tokens": "var suiteConfig ; try { suiteConfig = require ( './mail-settings.nogit.json' ) ; } catch ( e ) { }", "del_tokens": "var suiteConfig = require ( './mail-settings.nogit.json' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "resources", "method", "to", "allow", "pass", "parameters", "in", "the", "resource", "object", ".", "Add", "tests", "for", "the", "resources", "method", "and", "scope", "the", "use", "strict", "call", "."], "add_tokens": "expectResourceExecution ( this . response [ this . config . embedded . value ] [ key ] , this . config . resourcesKey , this . response [ this . config . embedded . value ] [ key ] [ this . config . links . key ] [ \"self\" ] . href , this . httpBackend , \"self\" ) ;", "del_tokens": "spyOnResourceExecution ( this . response [ this . config . embedded . value ] [ key ] , this . config . resourcesKey ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "summary", "runtime", "&", "fire", "start", "event"], "add_tokens": "msg = msg . concat ( Math . round ( amount ) ) . concat ( 's' )", "del_tokens": "msg = msg . concat ( amount ) . concat ( 's' )", "commit_type": "fix"}
{"commit_tokens": ["Add", "keyword", "length", "as", "reserved", "word"], "add_tokens": "var RESERVED = _ . keys ( Behalter . prototype ) . concat ( 'length' ) ;", "del_tokens": "var RESERVED = _ . keys ( Behalter . prototype ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "hex", "matches", "case", "insensitive"], "add_tokens": "'pattern' : / \\b ( 0 x [ \\d a - f ] + | \\d + ) \\b / gi", "del_tokens": "'pattern' : / \\b ( 0 x [ \\d a - f ] + | \\d + ) \\b / g", "commit_type": "make"}
{"commit_tokens": ["Added", "extremely", "basic", "CORS", "middleware"], "add_tokens": "'./oauth2' , './cors'", "del_tokens": "'./oauth2'", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "fallback", "for", "Number", ".", "MIN_VALUE"], "add_tokens": "var MIN_VALUE = - MAX_VALUE ;", "del_tokens": "var MIN_VALUE = Number . MIN_VALUE || 5e-324 ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "some", "spelling", "and", "grammar", "issues", "."], "add_tokens": "define ( 'hr/args' , [ ] , function ( ) { return { \"map\" : { \"apiKey\" : \"AIzaSyAAeM47baWKdmKoqWeIuK5bQCxtur6mWm0\" } , \"revision\" : 1381957756109 , \"baseUrl\" : \"/\" } ; } ) ;", "del_tokens": "define ( 'hr/args' , [ ] , function ( ) { return { \"map\" : { \"apiKey\" : \"AIzaSyAAeM47baWKdmKoqWeIuK5bQCxtur6mWm0\" } , \"revision\" : 1381938109558 , \"baseUrl\" : \"/\" } ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "inch", ".", "json", "support"], "add_tokens": "config = require ( './config' ) , jsdoc_args = jsdoc_args || getConfigJSDocArgs ( ) || getDefaultJSDocArgs ( ) ; function getConfigJSDocArgs ( ) { return config . files ( ) . included ; }", "del_tokens": "jsdoc_args = jsdoc_args || getDefaultJSDocArgs ( ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "option", "for", "auto", "login", "after", "password", "reset"], "add_tokens": "if ( req . app . get ( 'stormpathEnableForgotPasswordChangeAutoLogin' ) ) { req . session . user = account ; res . locals . user = account ; req . user = account ; } } ) ;", "del_tokens": "} )", "commit_type": "add"}
{"commit_tokens": ["Fix", "merging", "npm", "and", "bower", "dependencies", "by", "reference", "(", "by", "cloning", "them", ")", "."], "add_tokens": "_ . map ( _ . merge ( _ . clone ( outdatedNpmPackagesAsArray ) , _ . clone ( outdatedBowerPackagesAsArray ) ) , 'package' ) + '.'", "del_tokens": "_ . map ( _ . merge ( outdatedNpmPackagesAsArray , outdatedBowerPackagesAsArray ) , 'package' ) + '.'", "commit_type": "fix"}
{"commit_tokens": ["Fix", "the", "path", "for", "the", "changelog", "file"], "add_tokens": "path . join ( __dirname , '..' , '..' , '..' , 'CHANGELOG.md' ) ,", "del_tokens": "__dirname , '..' , '..' , '..' , 'CHANGELOG.md' ,", "commit_type": "fix"}
{"commit_tokens": ["removed", "a", "few", "not", "by", "any", "means", "all", "outlineIcons", ".", "src", ".", "commit", "to", "sync", "before", "termType", "changes"], "add_tokens": "updater . put ( doc , [ $rdf . st ( group , ns . rdf ( 'type' ) , ns . vcard ( 'Group' ) , doc ) ] , 'text/turtle' , function ( uri , ok , body ) {", "del_tokens": "updater . put ( doc , [ ] , 'text/turtle' , function ( uri , ok , body ) {", "commit_type": "remove"}
{"commit_tokens": ["add", "attributes", "for", "Cedar", "event", "handlers"], "add_tokens": "this . chart = new Cedar ( specification ) ; // wire up event handlers const supportedEvents = [ 'Click' , 'Mouseover' , 'Mouseout' , 'Mousemove' , 'UpdateStart' , 'UpdateEnd' ] ; supportedEvents . forEach ( eventName => { const attrName = ` ${ eventName } ` ; if ( typeof this [ attrName ] === 'function' ) { const cedarEventName = eventName . toLowerCase ( ) . replace ( 'update' , 'update-' ) ; this . chart . on ( cedarEventName , this [ attrName ] ) ; } } ) ; this . chart . show ( options ) ; this . chart . override = override ; } , willDestroyElement ( ) { if ( this . chart && this . chart . off ) { // remove any event handlers this . chart . off ( ) ; }", "del_tokens": "var chart = new Cedar ( specification ) ; chart . show ( options ) ; chart . override = override ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "padding", "for", "background", "image", "in", "custom", "select"], "add_tokens": "window . alert ( 'WARNING: You appear to be using IE' + nonEmulated + ' in IE' + emulated + ' emulation mode.\\nIE emulation modes can behave significantly differently from ACTUAL older versions of IE.\\nPLEASE DON\\'T FILE CAST FIGURATION BUGS based on testing in IE emulation modes!' ) ;", "del_tokens": "window . alert ( 'WARNING: You appear to be using IE' + nonEmulated + ' in IE' + emulated + ' emulation mode.\\nIE emulation modes can behave significantly differently from ACTUAL older versions of IE.\\nPLEASE DON\\'T FILE CAST FRAMEWOEK BUGS based on testing in IE emulation modes!' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Improving", "code", "documentation", "and", "fixing", "a", "typo", "."], "add_tokens": "var result = { } ; var self = this ; // Loop over all extensions to collect their items. // Scan for JSON files for this type. // If items was found add them to the result. // Process all items from JSON files. // Invoke type hooks on all modules. // Each hook implemention can return many items. // Process each set of items.", "del_tokens": "var result = { } ; var self = this ; // Each hook can return many items.", "commit_type": "improve"}
{"commit_tokens": ["add", "support", "for", "mdm", "push", "notifications"], "add_tokens": "if ( typeof this . mdm == 'string' ) { this . payload . mdm = this . mdm ; return this . payload ; }", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Added", "file", "-", "ext", "validation", "rule"], "add_tokens": "* Version 0.4 .2 - built Sun , Jun 19 th 2016 , 3 : 00 pm // Make sure all files within the input have one of the defined mimetypes // Make sure all files within the input have one of the defined extensions window . Parsley . addValidator ( 'fileExt' , { requirementType : 'string' , validateString : function validateString ( value , extensions , parsleyFieldInstance ) { var allExts = utils . parseArrayStringParameter ( extensions ) ; var files = parsleyFieldInstance . $element [ 0 ] . files ; // If a file is present in the input if ( files . length > 0 ) { // Loop over the files for ( var i = 0 ; i < files . length ; i ++ ) { var explodeNames = files [ i ] . name . split ( '.' ) ; if ( allExts . indexOf ( explodeNames [ explodeNames . length - 1 ] ) == - 1 ) { return false ; } } } return true ; } , messages : { en : 'This file does not have the correct extensions.' } } ) ; // Make sure all images within the input have specific dimensions window . ParsleyExtend = jQuery . extend ( { } , window . ParsleyExtend , { } ) ;", "del_tokens": "* Version 0.4 .1 - built Sun , Jun 19 th 2016 , 12 : 34 am // Make sure all files within the input are an image // Make sure all images withing the input have specific dimensions window . ParsleyExtend = { } ;", "commit_type": "add"}
{"commit_tokens": ["Use", "as", "an", "option", "instead", "of", "a", "command"], "add_tokens": ". describe ( 'l' , 'List all available cipher algorithms' ) . alias ( 'l' , 'list' ) . epilogue ( 'For more information, visit http://github.com/nathanbuchar/node-cipher' ) * Show help menu if ` ` is not chosen and the specified command is invalid . if ( argv . list ) { var algorithmArray = nodecipher . list ( ) ; var algorithmList = algorithmArray . join ( ', ' ) ; console . log ( algorithmList ) ; } else if ( [ 'encrypt' , 'decrypt' ] . indexOf ( argv . _ [ 0 ] ) < 0 ) {", "del_tokens": "var list = require ( './list' ) ; / ** * List valid commands . * / var commands = [ 'encrypt' , 'decrypt' , 'list' ] ; . command ( 'list' , 'List all available cipher algorithms' , list ) . epilogue ( 'For more information, visit http://github.com/nathanbuchar/node-cipher' ) * Show help if the chosen command is invalid . if ( commands . indexOf ( argv . _ [ 0 ] ) < 0 ) {", "commit_type": "use"}
{"commit_tokens": ["add", "a", "json", "transform", "and", "add", "recursive", "selection", "to", "the", "selection", "api"], "add_tokens": "create : require ( './create' ) , json : require ( './json' )", "del_tokens": "create : require ( './create' )", "commit_type": "add"}
{"commit_tokens": ["Implement", "Hertel", "-", "Mehlhorn", "using", "poly2tri", "for", "triangulation", "."], "add_tokens": "var outline = best_poly ; var partitioner = new Partition ( ) ; var parts = partitioner . convexPartition ( outline , polys ) ; return parts ;", "del_tokens": "// Turn holes into arrays of poly2tri Points. var holes = polys . map ( function ( poly ) { return poly . points . map ( function ( p ) { return new poly2tri . Point ( p . x , p . y ) ; } ) ; } ) ; // Do the same for the outline. var contour = best_poly . points . map ( function ( p ) { return new poly2tri . Point ( p . x , p . y ) ; } ) ; var swctx = new poly2tri . SweepContext ( contour ) ; swctx . addHoles ( holes ) ; swctx . triangulate ( ) ; var triangles = swctx . getTriangles ( ) ; // Convert poly2tri triangles back into polygons and filter out the small ones. polys = convertTrianglesToPolys ( triangles ) . filter ( function ( poly ) { return poly . getArea ( ) > 5 ; } ) ; return polys ; //var partitioner = new Partition(); // Remove holes from poly. // Get polygons defining regions of map. //best_poly.subdivide(240); //var with_holes_removed = partitioner.removeHoles(polys); //with_holes_removed = with_holes_removed[0]; //var parts = partitioner.triangulate_del(with_holes_removed); //var parts = partitioner.convexPartition(with_holes_removed); //parts = with_holes_removed; //return parts;", "commit_type": "implement"}
{"commit_tokens": ["Remove", "only", "from", "the", "test"], "add_tokens": "describe ( 'Features – Inserts – Create', () >", "del_tokens": "describe . only ( 'Features – Inserts – Create', () >", "commit_type": "remove"}
{"commit_tokens": ["Add", "test", "cases", "listening", "for", "changes", "in", "state"], "add_tokens": "var stateProperty = ReactiveProperty ( ) ;", "del_tokens": "var stateProperty = ReactiveProperty ( { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "optional", "custom", "DateHeader", "component", "for", "month"], "add_tokens": "dateHeader : elementType ,", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Added", ".", "gitignore", "file", ".", "Changed", "default", "on", "sort", "order", "to", "match", "SQL", "syntax", "."], "add_tokens": "sortDir = sortDir . match ( / ^desc / i ) ? 'DESC' : 'ASC' ;", "del_tokens": "sortDir = sortDir . match ( / ^asc / i ) ? 'ASC' : 'DESC' ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "the", "build", "system", "and", "its", "dependencies"], "add_tokens": "/ ** * The file patterns providing the list of source files . * @ type { string [ ] } * / const sources = [ '*.js' , 'example/*.ts' , 'src/**/*.ts' , 'test/**/*.ts' ] ; gulp . task ( 'clean' , ( ) => del ( [ '.nyc_output' , 'doc/api' , 'lib' , 'var/**/*' , 'web' ] ) ) ; gulp . task ( 'lint' , ( ) => _exec ( 'node_modules/.bin/tslint' , sources ) ) ;", "del_tokens": "gulp . task ( 'clean' , ( ) => del ( [ '.nyc_output' , 'doc/api' , 'var/**/*' , 'web' ] ) ) ; gulp . task ( 'lint' , ( ) => gulp . src ( [ '*.js' , 'example/*.js' , 'lib/**/*.js' , 'test/**/*.js' ] ) . pipe ( eslint ( ) ) . pipe ( eslint . format ( ) ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Moving", "signature", "parsing", "into", "a", "shared", "place", "."], "add_tokens": "var parsedSignature = wtf . data . Variable . parseSignature ( name ) ; name = parsedSignature . name ; opt_args = parsedSignature . args ;", "del_tokens": "var signatureParts = / ^([a-zA-Z0-9_\\.:#]+)(\\((.*)\\)$)? / . exec ( name ) ; name = signatureParts [ 1 ] ; // entire name before () opt_args = signatureParts [ 3 ] ; // contents of () (excluding ())", "commit_type": "move"}
{"commit_tokens": ["Add", "option", "to", "set", "IP", "and", "port", "inside", "webpack", "config"], "add_tokens": "if ( argv . host !== \"localhost\" || ! options . host ) options . host = argv . host ; if ( argv . port !== 8080 || ! options . port ) options . port = argv . port ; var devClient = [ require . resolve ( \"../client/\" ) + \"?\" + protocol + \"://\" + options . host + \":\" + options . port ] ; new Server ( webpack ( wpOpt ) , options ) . listen ( options . port , options . host , function ( err ) { console . log ( protocol + \"://\" + options . host + \":\" + options . port + \"/\" ) ; console . log ( protocol + \"://\" + options . host + \":\" + options . port + \"/webpack-dev-server/\" ) ;", "del_tokens": "var devClient = [ require . resolve ( \"../client/\" ) + \"?\" + protocol + \"://\" + argv . host + \":\" + argv . port ] ; new Server ( webpack ( wpOpt ) , options ) . listen ( argv . port , argv . host , function ( err ) { console . log ( protocol + \"://\" + argv . host + \":\" + argv . port + \"/\" ) ; console . log ( protocol + \"://\" + argv . host + \":\" + argv . port + \"/webpack-dev-server/\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Improve", "class", "names", "for", "increased", "styling"], "add_tokens": "' <span class=\"leaf-value\" ng-if=\"!isExpandable\">{{value}}</span>' + ' <span class=\"branch-preview\" ng-if=\"isExpandable\" ng-show=\"!isExpanded\" ng-click=\"toggleExpanded()\">{{preview}}</span>' + ' <ul class=\"branch-value\" ng-if=\"isExpandable && shouldRender\" ng-show=\"isExpanded\">' + // Add expandable class for CSS usage elem . addClass ( 'not-expandable' ) ;", "del_tokens": "' <span ng-if=\"!isExpandable\">{{value}}</span>' + ' <span class=\"preview\" ng-if=\"isExpandable\" ng-show=\"!isExpanded\" ng-click=\"toggleExpanded()\">{{preview}}</span>' + ' <ul ng-if=\"isExpandable && shouldRender\" ng-show=\"isExpanded\">' +", "commit_type": "improve"}
{"commit_tokens": ["Changed", "low", "-", "level", "metadata", "API", "to", "be", "more", "reasonable"], "add_tokens": "after ( function ( ) { server . shutdown ( ) ; } ) ;", "del_tokens": "server . shutdown ( ) ;", "commit_type": "change"}
{"commit_tokens": ["Adding", "logging", "tag", "to", "identify", "requests"], "add_tokens": "return this . _firestore . getAll ( [ this ] ) . then ( result => { const request = { . request ( 'listCollectionIds' , request , Firestore . requestTag ( ) ) const request = this . toProto ( queryOptions ) ; const requestTag = Firestore . requestTag ( ) ; const self = this ; const stream = through . obj ( function ( proto , enc , callback ) { const readTime = Timestamp . fromProto ( proto . readTime ) ; . readStream ( 'runQuery' , request , requestTag , true ) requestTag ,", "del_tokens": "return this . _firestore . getAll_ ( [ this ] ) . then ( result => { let request = { . request ( 'listCollectionIds' , request ) let request = this . toProto ( queryOptions ) ; let self = this ; let stream = through . obj ( function ( proto , enc , callback ) { let readTime = Timestamp . fromProto ( proto . readTime ) ; . readStream ( 'runQuery' , request , /* allowRetries= */ true )", "commit_type": "add"}
{"commit_tokens": ["Fix", "horizontal", "scrolling", "on", "mobile"], "add_tokens": "if ( this . collection . length > this . chart . maxSelectedSeries ) { this . chart . zoomToIndexes ( 0 , this . chart . maxSelectedSeries ) ; var displayCount = this . chart . maxSelectedSeries ;", "del_tokens": "if ( this . collection . length > this . settings . chart . maxSelectedSeries ) { this . chart . zoomToIndexes ( 0 , this . settings . chart . maxSelectedSeries ) ; var displayCount = this . settings . chart . maxSelectedSeries ; console . log ( start , end ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixes", "bug", "in", "first", "method"], "add_tokens": "Array . isArray ( array ) && array [ 0 ] ? array [ 0 ] : defaults", "del_tokens": "Array . isArray ( array ) ? array [ 0 ] : defaults", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "NOTIFY", "env", "variable", "in", "addition", "to", "NODE_NOTIFIER"], "add_tokens": "gutil . log ( color ( message ) , details ? ( '\\n' + details ) . replace ( / \\n / g , '\\n ' ) : '' ) if ( ! err . warn ) { const notifySetting = ( process . env . NOTIFY || process . env . notify || process . env . NODE_NOTIFIER || process . env . node_notifier || '0' ) . toLowerCase ( ) if ( [ '1' , 'true' , 'on' ] . indexOf ( notifySetting ) !== - 1 ) notifier . notify ( {", "del_tokens": "gutil . log ( color ( message ) , details ? ( '\\n' + details ) . replace ( / \\n / g , '\\n ' ) : '' ) const envSetting = process . env . NODE_NOTIFIER || process . env . node_notifier || '0' const showAlert = [ '1' , 'true' , 'on' ] . indexOf ( envSetting ) !== - 1 if ( showAlert && ! err . warn ) { notifier . notify ( {", "commit_type": "add"}
{"commit_tokens": ["Improve", "default", "sources", "and", "options", "for", "examples"], "add_tokens": "var analysis = JSON . parse ( analysisEditor . getValue ( ) ) ; var dataviews = { } ; var filters = { } ; var sourceId = analysis . id || 'a0' ; dataviews = example . dataviews || { } ; filters = example . filters || { } ; source : { id : sourceId } , dataviews : dataviews , analysis id : example . def . id || 'a0' ,", "del_tokens": "source : { id : 'a0' } , dataviews : { } , JSON . parse ( analysisEditor . getValue ( ) ) id : 'a0' ,", "commit_type": "improve"}
{"commit_tokens": ["Using", "a", "cached", "pool", "on", "Pooled", "class"], "add_tokens": "_cachedPool : null , if ( this . _cachedPool ) { return this . _cachedPool ; } let pool = Pool . getPool ( this ) ; this . _cachedPool = pool ;", "del_tokens": "var pool = Pool . getPool ( this ) ;", "commit_type": "use"}
{"commit_tokens": ["using", "tabs", "for", "indention", "."], "add_tokens": "t . write ( \"line1\\n\" ) ; t . write ( \"ab\\n\" ) ; t . write ( \"line1\\n\" ) ;", "del_tokens": "t . write ( \"line1\\n\" ) ; t . write ( \"ab\\n\" ) ; t . write ( \"line1\\n\" ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "and", "improve", "search", "a", "lot"], "add_tokens": "cmd += \" \" + PATTERN_EDIR + \" \" + var parts , file = prevFile , lineno , result = { } ; file = encodeURI ( Path . normalize ( options . uri + _path ) , \"/\" ) ; if ( ! result [ file ] ) { result [ file ] = [ ] ; result [ file ] . push ( [ lineno , parts . join ( \":\" ) ] ) ; return result ; var PATTERN_EDIR = \" --exclude-dir=\" + dirs . join ( \" --exclude-dir=\" ) ;", "del_tokens": "cmd += \" --exclude=*{\" + PATTERN_EDIR + \"}*\" + var parts , file , lineno , result = \"\" ; var count = 0 ; var filecount = 0 ; file = encodeURI ( options . uri + _path , \"/\" ) ; ++ count ; if ( file !== prevFile ) { ++ filecount ; if ( prevFile ) result += \"\\n \\n\" ; result += file + \":\" ; prevFile = file ; result += \"\\n\\t\" + lineno + \": \" + parts . join ( \":\" ) ; return { count : count , filecount : filecount , prevFile : prevFile , data : result } ; var PATTERN_EDIR = dirs . join ( \",\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "popup", "to", "connect", "even", "if", "redirect", "host", "cannot"], "add_tokens": "/** @private {?function((!ActivityHostDef|!Promise))} */ /** @private {?string} */ this . requestString_ = null ; let redirectHostError ; this . requestString_ = this . redirectHost_ . getRequestString ( ) ; } , reason => { // Don't throw the error immediately - give chance for the popup // connection to succeed. redirectHostError = reason ; } ) . then ( ( ) => { if ( redirectHostError ) { this . connectedResolver_ ( Promise . reject ( redirectHostError ) ) ; } else { this . connectedResolver_ ( this . redirectHost_ ) ; } return this . requestString_ ;", "del_tokens": "/** @private {?function(!ActivityHostDef)} */ this . connectedResolver_ ( this . redirectHost_ ) ; return this . redirectHost_ . getRequestString ( ) ;", "commit_type": "allow"}
{"commit_tokens": ["Update", "google", "-", "cloud", "node", "dependency"], "add_tokens": "var gcloud = require ( 'google-cloud' ) ;", "del_tokens": "var gcloud = require ( 'gcloud' ) ;", "commit_type": "update"}
{"commit_tokens": ["Adding", "special", "case", "handling", "for", "encoding", "close", "frames", "."], "add_tokens": "if ( this . length > this . maxReceivedFrameSize ) { this . frameTooLarge = true ; this . dropReason = \"Frame size of \" + this . length . toString ( 10 ) + \" bytes exceeds maximum accepted frame size\" ; return true ; } // the close frame is a special case because the close reason is // prepended to the payload data. if ( this . opcode === 0x08 ) { this . length = 2 ; if ( this . binaryPayload ) { this . length += this . binaryPayload . length ; } data = new Buffer ( this . length ) ; ctio . wuint16 ( this . closeStatus , 'big' , data , 0 ) ; if ( this . length > 2 ) { this . binaryPayload . copy ( data , 2 ) ; } } else if ( this . binaryPayload ) {", "del_tokens": "if ( this . length > this . maxReceivedFrameSize ) { this . frameTooLarge = true ; this . dropReason = \"Frame size of \" + this . length . toString ( 10 ) + \" bytes exceeds maximum accepted frame size\" ; return true ; } if ( this . binaryPayload ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "path", ".", "posix", "for", "ftp", "paths"], "add_tokens": "basepath = path . posix . normalize ( options . dest ) ;", "del_tokens": "basepath = path . normalize ( options . dest ) ;", "commit_type": "use"}
{"commit_tokens": ["Removed", "all", "but", "beforeCommit", "and", "afterPush", "hooks"], "add_tokens": "if ( hook ) { return resolve ( hook . apply ( hooks , args ) ) ; } else { return resolve ( ) ; } return executeHook ( 'beforeCommit' , versions ) . then ( function ( ) { return executeHook ( 'afterPush' , versions ) ; } ) ;", "del_tokens": "'afterCommit' , 'beforeTag' , 'afterTag' , 'beforePush' , return function ( ) { if ( hook ) { return resolve ( hook . apply ( hooks , args ) ) ; } else { return resolve ( ) ; } } ; return executeHook ( 'beforeCommit' , versions ) ( ) . then ( executeHook ( 'afterCommit' , versions ) ) . then ( executeHook ( 'beforeTag' , versions ) ) . then ( executeHook ( 'afterTag' , versions ) ) . then ( executeHook ( 'beforePush' , versions ) ) . then ( executeHook ( 'afterPush' , versions ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "some", "issues", "in", "update", "process", ".", "If", "application", "is", "updated", "from", "the", "store", "-", "cache", "folder", "is", "re", "-", "installed", "from", "the", "app", "bundle", ".", "Plugin", "preferences", "moved", "from", "platform", "-", "specific", "to", "general", "part", "of", "the", "config", "file", "."], "add_tokens": "// reset the page", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "inline", "enums", "(", "defined", "within", "a", "model", ")"], "add_tokens": "* For example , \"Array<a>\" returns \"a\" , \"a[]\" returns \"a\" , while \"b\" returns \"b\" . if ( type == null || type . length === 0 ) { return type ; } var pos = type . indexOf ( 'Array<' ) ; if ( pos >= 0 ) { var start = 'Array<' . length ; return type . substr ( start , type . length - start - 1 ) ; } pos = type . indexOf ( '[' ) ; if ( property . enum && property . enum . length > 0 ) { return '\\'' + property . enum . join ( '\\' | \\'' ) + '\\'' ; } return 'Array<' + propertyType ( property . items ) + '>' ;", "del_tokens": "* For example , \"a[]\" returns \"a\" , while \"b\" returns \"b\" . var pos = ( type || '' ) . indexOf ( '[' ) ; return propertyType ( property . items ) + '[]' ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "forceWebGL", "in", "dualRendering"], "add_tokens": "var forceWebGL = p . forceWebGL || false ; inAltMode = ! forceWebGL && window . altspace && window . altspace . inClient ;", "del_tokens": "inAltMode = ! p . forceWebGL && window . altspace && window . altspace . inClient ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "no", "-", "cache", "to", "Cache", "-", "Control", "."], "add_tokens": "inject = require ( './middleware/inject' ) , mstatic = require ( './middleware/static' ) , nocache = require ( './middleware/nocache' ) , // no-cache header app . use ( nocache ( ) ) ;", "del_tokens": "mstatic = require ( './middleware/static' ) , inject = require ( './middleware/inject' ) ,", "commit_type": "add"}
{"commit_tokens": ["Add", "github", "webhook", "handler", "to", "update", "cache"], "add_tokens": "var client , ghrepo , cacheInstance = 0 ; console . log ( 'list releases' , page ) ; return cacheInstance + Math . ceil ( Date . now ( ) / opts . timeout ) var clearCache = function ( ) { cacheInstance = cacheInstance + 1 ; } ; clearCache : clearCache , } ;", "del_tokens": "var client , ghrepo ; return Math . ceil ( Date . now ( ) / opts . timeout ) }", "commit_type": "add"}
{"commit_tokens": ["Added", "forceFetch", "option", "to", "get"], "add_tokens": "if ( this . cache [ key ] === undefined || options . forceFetch ) { var staleTtl = options . staleTtl , expiresTtl = options . expiresTtl ; if ( staleTtl === undefined ) {", "del_tokens": "if ( this . cache [ key ] === undefined ) { var staleTtl , expiresTtl ; if ( options . staleTtl === undefined ) {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "JoinPredicate", "to", "work", "with", "already", "joined", "relations", "."], "add_tokens": "goog . require ( 'lf.proc.RelationEntry' ) ; var combinedEntries = [ ] ; var leftRelationTableNames = leftRelation . getTables ( ) ; var rightRelationTableNames = rightRelation . getTables ( ) ; var combinedEntry = lf . proc . RelationEntry . combineEntries ( leftRelation . entries [ i ] , leftRelationTableNames , rightRelation . entries [ j ] , rightRelationTableNames ) ; combinedEntries . push ( combinedEntry ) ; return new lf . proc . Relation ( combinedEntries , srcTables ) ;", "del_tokens": "goog . require ( 'lf.Row' ) ; var combinedRows = [ ] ; var leftTableName = leftRelation . getTables ( ) [ 0 ] ; var rightTableName = rightRelation . getTables ( ) [ 0 ] ; var combinedRow = lf . Row . combineRows ( leftRelation . entries [ i ] . row , leftTableName , rightRelation . entries [ j ] . row , rightTableName ) ; combinedRows . push ( combinedRow ) ; return lf . proc . Relation . fromRows ( combinedRows , srcTables ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "/", "fonts", "to", "fix", "ui", "date", "bug"], "add_tokens": "{ fsdir : \"/bundles/frontend/public/font\" , webdir : \"/font\" } , { fsdir : \"/bundles/frontend/public/font\" , webdir : \"/fonts\" }", "del_tokens": "{ fsdir : \"/bundles/frontend/public/font\" , webdir : \"/font\" }", "commit_type": "add"}
{"commit_tokens": ["Fix", "test", "on", "default", "value", "if", "it", "is", "blank"], "add_tokens": "catch ( ex ) { return def === undefined ? ex . message : def ; }", "del_tokens": "catch ( ex ) { return def || ex . message ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "imported", "CSS", "filenames", "to", "debug", "output"], "add_tokens": "... ( ! debug ? { } : { load : ( filename ) => { console . log ( '[postcss-import]' , filename ) ; // eslint-disable-next-line global-require return require ( 'postcss-import/lib/load-content.js' ) ( filename ) ; } , } ) , // .use(atVariables({ // variables, // }))", "del_tokens": "// TODO: Look into using https://github.com/csstools/postcss-preset-env", "commit_type": "add"}
{"commit_tokens": ["fixed", "date", "issues", "with", "Cell", "Date", "function", "when", "invalid", "date", "was", "sent", "."], "add_tokens": "if ( ! val || ! val . toISOString ) { if ( val . toISOString ( ) != new Date ( val ) . toISOString ( ) ) { val = new Date ( ) ; console . log ( 'Value sent to Date function of cells %s was not a date, it has type of %s' , JSON . stringify ( theseCells . excelRefs ) , typeof ( val ) ) ; } console . log ( 'Value sent to Number function of cells %s was not a number, it has type of %s and value of %s' , val", "del_tokens": "if ( ! val || ! val . toISOString || val . toISOString ( ) != new Date ( val ) . toISOString ( ) ) { val = new Date ( ) ; console . log ( 'Value sent to Date function of cells %s was not a date, it has type of %s' , JSON . stringify ( theseCells . excelRefs ) , typeof ( val ) ) ; console . log ( 'Value sent to Number function of cells %s was not a number, it has type of %s%s' , typeof ( val ) == 'string' ? ' and value of \"' + val + '\"' : ''", "commit_type": "fix"}
{"commit_tokens": ["fix", "a", "bug", "in", "debug", "logging"], "add_tokens": "$debug ( 'Corq: Loading data...' ) ;", "del_tokens": "debug ( 'Corq: Loading data...' ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "sync", "methods", "internally", "for", "greater", "good"], "add_tokens": "before ( function ( done ) { testApp . listen ( port , done ) ; } ) ; before ( function ( done ) { testSequence . listen ( port , done ) ; } ) ;", "del_tokens": "testApp . listen ( port ) ; testSequence . listen ( port ) ;", "commit_type": "use"}
{"commit_tokens": ["Allow", "specifying", "conte", "types", "."], "add_tokens": "contentType = endpoint . contentType , return ajax ( finalPath , body , method , type , contentType ) ;", "del_tokens": "return ajax ( finalPath , body , method , type ) ;", "commit_type": "allow"}
{"commit_tokens": ["fix", "fullscreen", "handler", "if", "adsManager", "uninitialized"], "add_tokens": "if ( adsManager ) { adsManager . resize ( window . screen . width , window . screen . height , google . ima . ViewMode . FULLSCREEN ) ; } if ( adsManager ) { adsManager . resize ( player . width ( ) , player . height ( ) , google . ima . ViewMode . NORMAL ) ; }", "del_tokens": "adsManager . resize ( window . screen . width , window . screen . height , google . ima . ViewMode . FULLSCREEN ) ; adsManager . resize ( player . width ( ) , player . height ( ) , google . ima . ViewMode . NORMAL ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "&", "as", "delimiter", "to", "support", "html", "entities"], "add_tokens": "stopCondition : / [\\-;,<>\\{}()\\[\\]\"'\\s&$] /", "del_tokens": "stopCondition : / [\\-;,<>\\{}()\\[\\]\"'\\s$] /", "commit_type": "add"}
{"commit_tokens": ["Remove", "deprecated", "usage", "of", "sinon", "."], "add_tokens": "function whenTransitionDoneStub ( element , itemCallback , done ) { setTimeout ( done , 0 ) ; } sinon . stub ( Shuffle . prototype , '_whenTransitionDone' ) . callsFake ( whenTransitionDoneStub ) ; sinon . stub ( Shuffle . prototype , '_whenTransitionDone' ) . callsFake ( whenTransitionDoneStub ) ;", "del_tokens": "sinon . stub ( Shuffle . prototype , '_whenTransitionDone' , function ( element , itemCallback , done ) { setTimeout ( done , 0 ) ; } ) ; sinon . stub ( Shuffle . prototype , '_whenTransitionDone' , function ( element , itemCallback , done ) { setTimeout ( done , 0 ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "the", "typeof", "operater", "as", "an", "OpNode"], "add_tokens": "var atype = typeof a ; var btype = typeof b ;", "del_tokens": "var atype = typeof ( a ) ; var btype = typeof ( b ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "EntitySet", "which", "contains", "entities", "matching"], "add_tokens": "async = require ( 'async' ) ; _ . extend ( MemoryStorage . prototype , Backbone . Events , { var self = this ; self . trigger ( 'component:add' , component , entity , { } ) ; return callback ( null , result , componentDefs ) ;", "del_tokens": "_ . extend ( MemoryStorage . prototype , { // component.id; // component.defId; // entity.id; return callback ( null , result ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "prevout", "index", "instead", "of", "transaction", "input", "index"], "add_tokens": "coloringEngine . getOutput ( outHash , i [ 1 ] , fcb ) ;", "del_tokens": "coloringEngine . getOutput ( outHash , idx , fcb ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixed", "a", "problem", "with", "the", "validation"], "add_tokens": "// Validate configuration validate ( configObject . settings , metaObject . settings , metaObject . commands [ command ] . settings ) ; }", "del_tokens": "} // Validate configuration validate ( configObject . settings , metaObject . settings ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "to", "quote", "paths", "rather", "than", "escape", "them"], "add_tokens": "var bundleCommand = util . format ( 'cd \"%s\" && %s bundle %s %s --directory \"%s\"' , context . options . input , context . options . output 'tar czPf \"%s\" -C \"%s\" .' , context . options . tarball , context . options . output", "del_tokens": "/ ** * Escapes special characters out of the specified path . * @ param { String } filePath The path to escape . * / var escapePath = function ( filePath ) { if ( ! filePath || filePath . length === 0 ) return filePath ; filePath = filePath . replace ( / / g , '\\\\ ' ) ; filePath = filePath . replace ( / \\& / g , '\\\\&' ) ; filePath = filePath . replace ( / \\( / g , '\\\\(' ) ; filePath = filePath . replace ( / \\) / g , '\\\\)' ) ; return filePath ; } ; var bundleCommand = util . format ( 'cd %s && %s bundle %s %s --directory %s' , escapePath ( context . options . input ) , escapePath ( context . options . output ) 'tar czPf %s -C %s .' , escapePath ( context . options . tarball ) , escapePath ( context . options . output )", "commit_type": "update"}
{"commit_tokens": ["changed", "double", "quote", "to", "single", "for", "join"], "add_tokens": "} ) . join ( ', ' ) ;", "del_tokens": "} ) . join ( \", \" ) ;", "commit_type": "change"}
{"commit_tokens": ["update", "dice", "roller", "with", "sanity", "checks"], "add_tokens": "if ( post && post . raw ) { console . log ( '\\t' + ( post . raw || '' ) . split ( '\\n' ) [ 0 ] ) ; }", "del_tokens": "console . log ( '\\t' + ( post . raw || '' ) . split ( '\\n' ) [ 0 ] ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "issue", "that", "shallowclone", "false", "is", "converted", "to", "true"], "add_tokens": "options . shallowclone = options . shallowclone !== 'false' ;", "del_tokens": "options . shallowclone = true ;", "commit_type": "fix"}
{"commit_tokens": ["fixing", "the", "grunt", "file", "."], "add_tokens": "port : 3000 ,", "del_tokens": "port : 9000 ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "with", "link", "text"], "add_tokens": "addMarks ( characters , content , updatedOffset ) ; const mark = Mark . create ( { type } ) ; for ( let pos = updatedOffset ; pos < updatedOffset + length && pos < characters . size ; pos ++ ) { let char = characters . get ( pos ) ; let { marks } = char ; marks = marks . add ( mark ) ; char = char . set ( 'marks' , marks ) ; characters . set ( pos , char ) ;", "del_tokens": "if ( type ) { const mark = Mark . create ( { type } ) ; for ( let i = updatedOffset ; i < updatedOffset + length && i < characters . size ; i ++ ) { let char = characters . get ( i ) ; let { marks } = char ; marks = marks . add ( mark ) ; char = char . set ( 'marks' , marks ) ; characters . set ( i , char ) ; } } if ( Array . isArray ( content ) ) { addMarks ( characters , content , updatedOffset ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "the", "audio", "player", "url", "in", "goog", ".", "ui", ".", "media", ".", "Mp3", ".", "See", "http", ":", "//", "code", ".", "google", ".", "com", "/", "p", "/", "closure", "-", "library", "/", "issues", "/", "detail?id", "=", "190", "for", "details", "."], "add_tokens": "'http://www.google.com/reader/ui/3523697345-audio-player.swf' ; / (https?:\\/\\/[\\w-%&\\/.=:#\\+~\\(\\)]+\\.(mp3)+(\\?[\\w-%&\\/.=:#\\+~\\(\\)]+)?) / i ;", "del_tokens": "'http://www.google.com/reader/ui/3247397568-audio-player.swf' ; / (https?:\\/\\/[a-zA-Z0-9-_%&\\/.=:#\\+~\\(\\)]+\\.(mp3)+(\\?[a-zA-Z0-9-_%&\\/.=:#\\+~\\(\\)]+)?) / i ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "matches", "reaching", "to", "end", "of", "document"], "add_tokens": "data . DocLength = text . length ; var f = doc . WordPos [ first ] ; var l ; if ( last == doc . WordPos . length - 1 ) // l = doc . DocLength ; else l = doc . WordPos [ last + 1 ] ; return l - f ;", "del_tokens": "var v = - 1 ; try { v = doc . WordPos [ last + 1 ] ; v = v - doc . WordPos [ first ] ; } catch ( e ) { } if ( v < - 1 ) v = - 1 ; return v ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "dir", "to", "sections", "dto", "to", "store", "rotation", "as", "a", "quaternion"], "add_tokens": "if ( this . dataObject . dir ) { this . quaternion . fromArray ( this . dataObject . dir ) ; } else if ( this . dataObject . rotation ) { this . rotation . fromArray ( this . dataObject . rotation . map ( Number ) ) ; }", "del_tokens": "if ( this . dataObject . rotation ) this . rotation . fromArray ( this . dataObject . rotation . map ( Number ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "examples", "are", "all", "right"], "add_tokens": "const parser = new sax . SaxesParser ( opts ? opts . parser : null )", "del_tokens": "const parser = new sax . SaxesParser ( opts . parser )", "commit_type": "make"}
{"commit_tokens": ["Add", ".", "context", "()", "and", ".", "edit", "()", "parameter", "methods", "to", "CollectionRequest"], "add_tokens": "var path = request . context ( 'edit' ) . _renderURI ( ) ;", "del_tokens": "var path = request . context ( 'edit' ) . renderURI ( ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "more", "lines", "to", "the", "welcome", "message", "change", "command", "strings", "for", "windows"], "add_tokens": "dependencyManager . npmInstall ( projectPath , function ( ) { gitManager . insertAwsmobilejs ( projectPath ) let projectInfo = projectInfoManager . initialize ( projectPath , starterManager . getProjectConfig ( _starterName ) ) if ( callback ) { callback ( projectInfo ) } } ) console . log ( 'Next steps:' ) console . log ( ) console . log ( ' ' + chalk . blue ( 'cd ' + chalk . blue ( projectInfo . ProjectName ) ) ) console . log ( ' Run/Serve/Build your app' ) console . log ( )", "del_tokens": "dependencyManager . insertAmplifyDependency ( projectPath ) gitManager . insertAwsmobilejs ( projectPath ) let projectInfo = projectInfoManager . initialize ( projectPath , starterManager . getProjectConfig ( _starterName ) ) if ( callback ) { callback ( projectInfo ) }", "commit_type": "add"}
{"commit_tokens": ["Use", "this", ".", "import", "instead", "of", "app", ".", "import"], "add_tokens": "var bowerDirectory = app . bowerDirectory || 'bower_components' ; this . import ( bowerDirectory + '/gettext.js/dist/gettext.min.js' , {", "del_tokens": "// Fix for loading it in addons/engines if ( typeof app . import !== 'function' && app . app ) { app = app . app ; } app . import ( app . bowerDirectory + '/gettext.js/dist/gettext.min.js' , {", "commit_type": "use"}
{"commit_tokens": ["Add", "--", "prune", "option", "to", "ignore", "empty", "directories"], "add_tokens": ". option ( '--prune' , 'Prune empty directories from the output' ) const pruneEmptyDirectories = ! ! program . prune const color = chalk [ colors [ depth % colors . length ] ] let printWithoutDescending = false if ( isDirectory ) { if ( fileLimit !== Infinity || pruneEmptyDirectories ) { const dirfiles = fs . readdirSync ( fullPath ) . filter ( shouldBeIncluded ) if ( pruneEmptyDirectories && dirfiles . length === 0 ) { continue } if ( dirfiles . length > fileLimit ) { printWithoutDescending = true postfix = ` ${ dirfiles . length } ${ fileLimit } ` } } } const filename = showFullPath ? color ( fullPath . replace ( cwd + '/' , '' ) ) : color ( file ) if ( printWithoutDescending ) { continue }", "del_tokens": "const color = shouldIndent ? chalk [ colors [ depth % colors . length ] ] : chalk [ colors [ 0 ] ] const filename = showFullPath ? color ( fullPath ) : color ( file ) output += prefix + filename + ( ! isDirectory && showSize ? ` ${ size } ` : '' ) + '\\n' ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "compat", "to", "use", "defaultEventType", "for", "can", "-", "dom", "-", "events"], "add_tokens": "customEventType = customEventType || customEvent . defaultEventType ;", "del_tokens": "customEventType = customEventType || customEvent . defaultEventType ;", "commit_type": "fix"}
{"commit_tokens": ["change", "1", "letter", "fix", "1", "regex"], "add_tokens": "if ( isRegExp ( constraints . callbackId ) && ! constraints . callbackId . test ( payload . callback_id ) ) {", "del_tokens": "if ( isRegExp ( constraints . callbackId ) && ! constraints . callbackId . text ( payload . callback_id ) ) {", "commit_type": "change"}
{"commit_tokens": ["removed", "scrollheight", "max", "height", "logic"], "add_tokens": "Math . min ( container . parentNode . offsetHeight , window . innerHeight ) : attributes . height ) ;", "del_tokens": "Math . min ( container . parentNode . offsetHeight , window . innerHeight , scrollHeight ) : attributes . height ) ;", "commit_type": "remove"}
{"commit_tokens": ["Updated", "addEventListener", "/", "removeEventListener", "method", "so", "they", "lower", "case", "event", "type", "."], "add_tokens": "eventType = eventType . toLowerCase ( ) ; eventType = eventType . toLowerCase ( ) ; callback ( event ) ; callback ( event ) ;", "del_tokens": "callback ( ) ; callback ( ) ;", "commit_type": "update"}
{"commit_tokens": ["Removed", "all", "the", "case", "test", "since", "we", "don", "t", "have", "any", "particular", "action", "to", "perform", "and", "allowing", "to", "use", "custom", "state", "value"], "add_tokens": "// hold public stuff in our singleton default : {", "del_tokens": "// hold public stuff in our singletong case obj . LOADING : case obj . MENU : case obj . PLAY : case obj . READY : case obj . GAMEOVER : case obj . GAME_END : case obj . SCORE : case obj . CREDITS : case obj . SETTINGS : { break ; } default : {", "commit_type": "remove"}
{"commit_tokens": ["Added", "better", "handling", "of", "429", "errors", "in", "the", "case", "that", "user", "procs", "requests", "somewhere", "else"], "add_tokens": "", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["fix", "_getFromList", "()", "method", ";"], "add_tokens": "this . _save ( this . getWritable ( ) ) ; data [ key ] = this . _getOption ( key ) ; } , this ) ;", "del_tokens": "this . _save ( this . _getWritableData ( ) ) ; _getWritableData : function ( ) { var ret = { } ; this . writable ( ) . forEach ( function ( key ) { ret [ key ] = this . get ( key ) ; } , this ) ; return ret ; } , var profile = this . profile ; data [ key ] = profile . option ( key ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "base", "Widget", "class", "to", "check", "version", "and", "patch", "subscribe", "method", "."], "add_tokens": "import Widget from '@wso2-dashboards/widget' ; return Object . getPrototypeOf ( widgetClass . prototype ) . constructor . version !== Widget . version ; superWidgetClassPrototype . subscribe = Widget . prototype . subscribe ;", "del_tokens": "return ! Object . getPrototypeOf ( widgetClass . prototype ) . version ; superWidgetClassPrototype . subscribe = function ( listenerCallback , publisherId , context ) { const self = this ; if ( ! publisherId ) { const publisherIds = self . props . configs . pubsub . publishers ; if ( publisherIds && Array . isArray ( publisherIds ) ) { publisherIds . forEach ( id => self . props . glEventHub . on ( id , listenerCallback ) ) ; } } else { self . props . glEventHub . on ( publisherId , listenerCallback , context ) ; } } ;", "commit_type": "use"}
{"commit_tokens": ["Change", "output", "directory", "of", "results"], "add_tokens": "results : 'results' , '<%=config.paths.tmp%>' , '<%=config.paths.results%>' ,", "del_tokens": "results : tmp + '/results' , '<%=config.paths.tmp%>'", "commit_type": "change"}
{"commit_tokens": ["changed", "initialization", "and", "moved", "callbacks", "to", "debugger", ".", "js"], "add_tokens": "Buffer = require ( 'buffer' ) . Buffer , callback = require ( './callback' ) . create ( ) ; if ( obj . type === 'response' && obj . request_seq > 0 ) { callback . processResponse ( obj . request_seq , [ obj ] ) ; } else if ( obj . type === 'event' && obj . event === 'break' ) { debugr . emit ( 'break' , obj ) ; } else { debugr . emit ( 'data' , obj ) ; } send : { request : { value : function ( command , params , cb ) { var seq = 0 ; if ( typeof cb == 'function' ) { seq = callback . wrap ( cb ) ; } var msg = { seq : seq , type : 'request' , command : command } ; if ( params ) { Object . keys ( params ) . forEach ( function ( key ) { msg [ key ] = params [ key ] ; } ) ; } this . send ( JSON . stringify ( msg ) ) ; } } ,", "del_tokens": "Buffer = require ( 'buffer' ) . Buffer ; debugr . emit ( 'data' , obj ) ; request : {", "commit_type": "change"}
{"commit_tokens": ["allow", "route", "matching", "on", "non", "-", "outlet", "helpers"], "add_tokens": "_ancestorsRenderedName : function ( view ) { while ( view && ! view . get ( 'renderedName' ) ) { view = view . get ( '_parentView' ) ; } if ( view ) { return view . get ( 'renderedName' ) ; } } , // If the old/new views themselves are not part of a route // transition, provide route properties from our surrounding // context. if ( oldView && ! change . leaving . route ) { change . leaving . route = this . _ancestorsRenderedName ( parentView ) ; } if ( newContent && ! change . entering . route ) { change . entering . route = change . leaving . route || this . _ancestorsRenderedName ( parentView ) ; }", "del_tokens": "", "commit_type": "allow"}
{"commit_tokens": ["Fix", "for", "goBack", "when", "not", "using", "micro", "-", "frontend", "without", "routing"], "add_tokens": "if ( ! currentContext . internal . isNavigateBack ) { var hashRoutingModeActive = e . data . viewUrl . indexOf ( '#' ) !== - 1 && window . location . href . indexOf ( '#' ) !== - 1 ; if ( hashRoutingModeActive ) { window . location . hash = e . data . viewUrl . split ( '#' ) [ 1 ] ; } else { window . location . replace ( e . data . viewUrl ) ; }", "del_tokens": "var hashRoutingModeActive = e . data . viewUrl . indexOf ( '#' ) !== - 1 && window . location . href . indexOf ( '#' ) !== - 1 ; if ( hashRoutingModeActive ) { window . location . hash = e . data . viewUrl . split ( '#' ) [ 1 ] ; } else { window . location . replace ( e . data . viewUrl ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "undefined", "-", "to", "-", "void", "transformer"], "add_tokens": "[ 'transform-es2015-classes' , loose ] , [ 'transform-undefined-to-void' ]", "del_tokens": "[ 'transform-es2015-classes' , loose ]", "commit_type": "add"}
{"commit_tokens": ["fix", "lint", "errors", "handle", "SIGINT", "properly", "write", "to", "readline", "output"], "add_tokens": "// eslint-disable-next-line no-use-before-define const cljs = require ( './main' ) ; // eslint-disable-line import/no-unresolved function prompt ( p : string = ` ${ cljs . lumo . repl . get_current_ns ( ) } ` ) { // $FlowIssue: missing property in interface rl . output . write ( 'closing!' ) ; // $FlowIssue: missing property in interface rl . output . write ( '\\n' ) ; readline . clearLine ( process . stdout , 0 ) ; readline . cursorTo ( process . stdout , 0 ) ; name : 'u' ,", "del_tokens": "const cljs = require ( './main' ) ; function prompt ( p ? : string = cljs . lumo . repl . get_current_ns ( ) + '=> ' ) { console . log ( 'crlh, close!' ) ; name : 'u' console . log ( ) ; readline . clearLine ( process . stdout , 0 ) readline . cursorTo ( process . stdout , 0 )", "commit_type": "fix"}
{"commit_tokens": ["improved", "order", "for", "switch", "statement"], "add_tokens": "case 100 : //ignore break ;", "del_tokens": "case 100 : //ignore break ;", "commit_type": "improve"}
{"commit_tokens": ["added", "undent", "option", "to", "trim", "extra", "whitespace", "from", "code", "that", "s", "indented"], "add_tokens": "// given code, removes the smallest indent from each line (e.g. nested code becomes less-indented to the least indented line) function undent ( code ) { let lines = code . split ( \"\\n\" ) ; let minIndent = Number . MAX_VALUE ; // find min indent lines . forEach ( ( line ) => { let startingSpaceMatch = line . match ( / ^\\s* / ) ; let indentLength = startingSpaceMatch [ 0 ] . length ; if ( indentLength < minIndent ) { minIndent = indentLength ; } } ) // remove the indentation from each line return lines . map ( ( line ) => { return line . substring ( minIndent ) ; } ) . join ( '\\n' ) ; } let results = resolveListOfQueries ( ast , root , code , query , engine , opts ) ; if ( opts . undent ) { results . code = undent ( results . code ) ; } return results ;", "del_tokens": "return resolveListOfQueries ( ast , root , code , query , engine , opts ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "compensate", "functions", "for", "Mean", "Vars", "Stdev"], "add_tokens": "var po = ( idx + 1 ) % size ; p [ ( idx ) % size ] = v ;", "del_tokens": "var po = ( idx + 1 ) % size ; // prior open p [ idx % size ] = v ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "transition", "class", "only", "when", "moved"], "add_tokens": "var action = this . action ; var $image = this . $image ; if ( action ) { if ( action === 'move' && options . transition && $image . hasClass ( CLASS_TRANSITION ) ) { $image . removeClass ( CLASS_TRANSITION ) ; }", "del_tokens": "if ( action === 'move' && options . transition ) { this . $image . removeClass ( CLASS_TRANSITION ) ; } if ( this . action ) {", "commit_type": "remove"}
{"commit_tokens": ["Remove", "map", ".", "js", "from", "utils", "."], "add_tokens": "import { registerElement , createJsxdom } from './utils' ; // jsx syntax support", "del_tokens": "import { registerElement , createJsxdom , map } from './utils' ; // // NodeList.prototype.map = map; // HTMLCollection.prototype.map = map;", "commit_type": "remove"}
{"commit_tokens": ["Add", "getInititalData", "()", "to", "Store"], "add_tokens": "Store . prototype . listenTo = function ( listenable , callback , initialCallback ) { if ( initialCallback && _ . isFunction ( initialCallback ) ) { if ( listenable . getInitialData && _ . isFunction ( listenable . getInitialData ) ) { data = listenable . getInitialData ( ) ; if ( data && data . then && _ . isFunction ( data . then ) ) { data . then ( initialCallback ) ; } else { initialCallback ( data ) ; } } }", "del_tokens": "Store . prototype . listenTo = function ( listenable , callback ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "sync", "action", "outputs", "to", "async", "actions"], "add_tokens": "return runAsyncBranch ( index , currentBranch , options ) ; return runSyncBranch ( index , currentBranch , options ) ; return runResult . then ( ( ) => {", "del_tokens": "runAsyncBranch ( index , currentBranch , options ) ; runSyncBranch ( index , currentBranch , options ) ; return result . then ( ( ) => {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "typo", "in", "comment", "in", "example", "config", "file"], "add_tokens": "// If url is supplied, port and host will be ignored } ;", "del_tokens": "// If url is supplied port and url will be ignored } ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "error", "when", "contract", "artifact", "is", "missing"], "add_tokens": "let artifact try { artifact = require ( ` ${ pkg } ${ contract } ` ) } catch ( err ) { throw new Error ( ` ${ contract } ` ) } return artifact", "del_tokens": "return require ( ` ${ pkg } ${ contract } ` )", "commit_type": "improve"}
{"commit_tokens": ["Create", "the", "new", "file", "watcher", "on", "rename"], "add_tokens": "this . a_path = Path . resolve ( path ) ; this . handler = handler ; this . _ . removeListener ( \"change\" , this . handler ) ; watcher . off ( ) ; watcher . _ = FileWatcher ( path , options , callback ) . _ ; watcher = new Watcher ( path , handler ) ;", "del_tokens": "this . a_path = Path . resolve ( Path ) ; this . _ . removeListener ( \"change\" , handler ) ; watcher . removeListener ( \"change\" , handler ) ; newWatcher = FileWatcher ( path , options , callback ) watcher . _ = newWatcher . _ ; watcher . a_path = newWatcher . a_path ; watcher = new Watcher ( path , options ) ; watcher . change ( handler ) ;", "commit_type": "create"}
{"commit_tokens": ["fixing", "existsSync", "and", "a", "path", "bug"], "add_tokens": "var findNodeModuleDir = function ( dirname , path ) { process . chdir ( dirname + '/node_modules' ) ; if ( fs . existsSync ( process . cwd ( ) + '/' + moduleName ) ) { absFilename = findNodeModuleDir ( dirname , url ) + '/' + removeNodeModuleInPath ( url ) ;", "del_tokens": "var findNodeModuleDir = function ( path ) { process . chdir ( 'node_modules' ) ; if ( fs . exists ( process . cwd ( ) + '/' + moduleName ) ) { absFilename = findNodeModuleDir ( url ) + '/' + removeNodeModuleInPath ( url ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "vi", "by", "defult", "otherwise", "don", "t", "use", "anything"], "add_tokens": "function viIsInstalled ( ) { execSync ( 'which vi' ) ; : ( viIsInstalled ( ) ? 'vi' : null )", "del_tokens": "function vimIsInstalled ( ) { execSync ( 'which vim' ) ; : ( vimIsInstalled ( ) ? 'vim' : 'nano' )", "commit_type": "use"}
{"commit_tokens": ["fixing", "URI", "in", "ajax", "test"], "add_tokens": "var uri = window . location . protocol + \"//\" + window . location . host + window . location . pathname ;", "del_tokens": "var uri = window . location . protocol + \"//\" + window . location . host + \"/\" + window . location . pathname ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "bundle", "finding", "more", "forgiving"], "add_tokens": "// If we still haven't found one, set the bundleName as a bundle. if ( ! bundle ) { var bundleName = findBundleName ( moduleName ) ; bundle = bundles [ bundleName ] = { } ; } function findBundleName ( moduleName ) { bundleName = parent ; return bundleName ; } function findBundle ( moduleName ) { var bundleName = findBundleName ( moduleName ) ;", "del_tokens": "function findBundle ( moduleName ) { bundleName = parent ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "condition", "for", "tests", "dependent", "of", "valid", "msg"], "add_tokens": "if ( message . valid && ! t . errors . length ) {", "del_tokens": "if ( message . valid ) {", "commit_type": "fix"}
{"commit_tokens": ["use", "tearDown", "to", "cleanup", "agents", "pool", "before", "each", "test", "run"], "add_tokens": "tearDown : function ( callback ) { // reset agents pools before each test Object . keys ( Asker . agentsPool ) . forEach ( function ( agentName ) { delete Asker . agentsPool [ agentName ] ; } ) ; callback ( ) ; } ,", "del_tokens": "delete Asker . agentsPool [ AGENT_NAME ] ;", "commit_type": "use"}
{"commit_tokens": ["Use", "amount", "of", "CPU", "s", "minus", "2", "instead", "of", "1"], "add_tokens": "asyncLimit : numCPUs - 2 || 1", "del_tokens": "asyncLimit : numCPUs - 1 || 1", "commit_type": "use"}
{"commit_tokens": ["Add", "SVG", "support", "for", "webpack", "loader"], "add_tokens": "test : / \\.(otf|eot|ttf|woff|svg|png|jpe?g|txt) / i ,", "del_tokens": "test : / \\.(otf|eot|ttf|woff|png|jpe?g|txt) / i ,", "commit_type": "add"}
{"commit_tokens": ["move", "cli", ".", "js", "to", "bin"], "add_tokens": "var Normalizer = require ( '..' ) ;", "del_tokens": "var Normalizer = require ( './' ) ;", "commit_type": "move"}
{"commit_tokens": ["Make", "scroll", "event", "listener", "passive"], "add_tokens": "PhantomJS_Desktop : { reporters : [ { type : 'lcov' } ] } ,", "del_tokens": "'PhantomJS_Desktop' : { reporters : [ { type : 'lcov' } ] } ,", "commit_type": "make"}
{"commit_tokens": ["Added", "custom", "browser", "for", "travis"], "add_tokens": "var configuration = { customLaunchers : { Chrome_travis_ci : { base : 'Chrome' , flags : [ '--no-sandbox' ] } } , } ; if ( process . env . TRAVIS ) { configuration . browsers = [ 'Chrome_travis_ci' ] ; } config . set ( configuration ) ;", "del_tokens": "config . set ( { } )", "commit_type": "add"}
{"commit_tokens": ["Add", "cultivated", "herbs", "as", "daily", "crafts"], "add_tokens": "{ id : 67015 , tradable : true , craftInterval : 'daily' } , // Heat Stone { id : 91701 , tradable : true , craftInterval : 'daily' } , // Cultivated Sesame Seed { id : 91715 , tradable : true , craftInterval : 'daily' } , // Cultivated Cilantro Leaf { id : 91793 , tradable : true , craftInterval : 'daily' } , // Cultivated Mint Leaf { id : 91796 , tradable : true , craftInterval : 'daily' } , // Cultivated Clove { id : 91869 , tradable : true , craftInterval : 'daily' } // Cultivated Peppercorn", "del_tokens": "{ id : 67015 , tradable : true , craftInterval : 'daily' } // Heat Stone", "commit_type": "add"}
{"commit_tokens": ["Add", "lisa", "instance", "and", "plugins", "manager"], "add_tokens": "exports . bootstrap = require ( './bootstrap' ) exports . env = require ( './env' ) exports . session = require ( './session' )", "del_tokens": "exports . session = require ( './session' )", "commit_type": "add"}
{"commit_tokens": ["Adding", "support", "for", "environment", "option", "."], "add_tokens": "var env ; if ( grunt . option ( 'env' ) ) { env = grunt . option ( 'env' ) ; } else { env = process . env . NODE_ENV ; } sails . lift ( { port : - 1 , log : { level : 'silent' } , environment : env } , function ( err ) {", "del_tokens": "sails . lift ( { port : - 1 , log : { level : 'silent' } } , function ( err ) {", "commit_type": "add"}
{"commit_tokens": ["added", "the", "classic", "method", "to", "promise", "()", "method"], "add_tokens": "[ \"addCallback\" , \"addErrback\" , \"then\" , \"both\" , \"classic\" ] . forEach ( function ( action ) {", "del_tokens": "[ \"addCallback\" , \"addErrback\" , \"then\" , \"both\" ] . forEach ( function ( action ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "next", "()", "passing", "extra", "arguments", "as", "error", "to", "last", "function", "."], "add_tokens": "if ( steps . length ) { args . shift ( ) ; // error arg args . unshift ( resolve ) ; // next() function }", "del_tokens": "args . shift ( ) ; // error arg. if ( steps . length ) args . unshift ( resolve ) ; // next arg. replacement", "commit_type": "fix"}
{"commit_tokens": ["use", "new", "global", "file", "for", "the", "build"], "add_tokens": "modules : [ \"global\" ] ,", "del_tokens": "modules : [ \"funcunit\" ] ,", "commit_type": "use"}
{"commit_tokens": ["fix", "sticky", "header", "while", "container", "updated", "."], "add_tokens": "if ( process . env . NODE_ENV !== 'production' ) { console . log ( ` ` , el ) } const placeholder = el . cloneNode ( true ) placeholder . _origNode = el placeholder . classList . add ( 'weex-sticky-placeholder' ) el . _placeholder = placeholder if ( process . env . NODE_ENV !== 'production' ) { console . log ( ` ` , el ) } const stickyChildren = [ ] if ( / weex-sticky-placeholder / . test ( child . className ) ) { // is a placeholder. const origNode = child . _origNode if ( ! origNode || ! origNode . parentNode || origNode . parentNode !== child . parentNode ) { child . parentNode . removeChild ( child ) } } else { // is a sticky node. stickyChildren . push ( child ) if ( ! child . _sticky ) { child . _initOffsetTop = child . offsetTop } } this . _stickyChildren = stickyChildren", "del_tokens": "el . _placeholder = el . cloneNode ( true ) this . _stickyChildren = children child . _initOffsetTop = child . offsetTop", "commit_type": "fix"}
{"commit_tokens": ["Adds", "options", ".", "headers", "being", "set", "on", "any", "request", "to", "files", "within", "the", "content", "base", "."], "add_tokens": "this . headers = options . headers ; app . get ( \"*\" , this . setContentHeaders . bind ( this ) , this . serveMagicHtml . bind ( this ) , express . static ( contentBase ) , serveIndex ( contentBase ) ) ; Server . prototype . setContentHeaders = function ( req , res , next ) { if ( this . headers ) { for ( var name in this . headers ) { res . setHeader ( name , this . headers [ name ] ) ; } } next ( ) ; }", "del_tokens": "app . get ( \"*\" , this . serveMagicHtml . bind ( this ) , express . static ( contentBase ) , serveIndex ( contentBase ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "typo", "preventing", "comb", ".", "date", ".", "format", "(", "EEE", ")", "from", "properly", "returning", "an", "abbreviated", "weekday", "name"], "add_tokens": "var monthAbbr = [ \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" ] ; s = ( l === 3 ? dayAbbr : dayNames ) [ day ] ;", "del_tokens": "var monthAbbr = [ \"Jan.\" , \"Feb.\" , \"Mar.\" , \"Apr.\" , \"May.\" , \"Jun.\" , \"Jul.\" , \"Aug.\" , \"Sep.\" , \"Oct.\" , \"Nov.\" , \"Dec.\" ] ; s = ( l === - 3 ? dayAbbr : dayNames ) [ day ] ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "unit", "tests", "for", "Field", "component"], "add_tokens": "var defaultProps = { ref : function ref ( controlDOMNode ) { return _this2 . _control = controlDOMNode ; } } ; var createControlProps = controlPropsMap [ controlType ] || control . type === 'input' && controlPropsMap [ 'text' ] || null ; var controlProps = createControlProps ? _extends ( { } , defaultProps , createControlProps ( props ) ) : null ; console . log ( _extends ( { } , this . props , { onChange : this . handleChange } , control . props ) ) ;", "del_tokens": "'password' : function password ( props ) { return controlPropsMap [ 'text' ] ( props ) ; } , var defaultProps = { } ; var createControlProps = controlPropsMap [ controlType ] ; var controlProps = createControlProps ? createControlProps ( props ) : null ;", "commit_type": "add"}
{"commit_tokens": ["Added", "primary", "prop", "to", "button"], "add_tokens": "import classnames from 'classnames' ; const { children , className , text , disabled , style , primary } = this . props ; const cl = classnames ( 'weave-button' , { primary } ) ; className = { className || cl } / ** * Render the button in $turquoise ( useful for CTAs ) * / primary : React . PropTypes . bool", "del_tokens": "const { children , className , text , disabled , style } = this . props ; className = { className || 'weave-button' }", "commit_type": "add"}
{"commit_tokens": ["Add", "cssmin", "and", "uglify", "."], "add_tokens": "grunt . loadNpmTasks ( 'grunt-contrib-jshint' ) ; grunt . loadNpmTasks ( 'grunt-contrib-cssmin' ) ; grunt . loadNpmTasks ( 'grunt-contrib-uglify' ) ; grunt . loadTasks ( 'node_modules/chronicles_of_grunt/node_modules/grunt-contrib-jshint/tasks/' ) ; grunt . loadTasks ( 'node_modules/chronicles_of_grunt/node_modules/grunt-contrib-cssmin/tasks/' ) ; grunt . loadTasks ( 'node_modules/chronicles_of_grunt/node_modules/grunt-contrib-uglify/tasks/' ) ;", "del_tokens": "grunt . loadNpmTasks ( 'grunt-contrib-jshint' ) ; grunt . loadTasks ( 'node_modules/chronicles_of_grunt/node_modules/grunt-contrib-jshint/tasks/' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "run", "graph", "job", "crashing", "because", "of", "return", "from", "protocol", "runTaskGraph"], "add_tokens": "assert . uuid ( message . instanceId ) ; self . _done ( new Error ( \"Unable to start graph for task \" + self . taskId + \" in graph \" + this . options . graphName ) ) ;", "del_tokens": "assert . uuid ( message ) ; self . _done ( new Error ( \"Unable to start graph: \" + message ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "options", "handling", "in", "streamCompare"], "add_tokens": "* @ param { Object | function ( ! StreamState , ! StreamState ) = } optionsOrCompare * Options , or a comparison function ( as described in options . compare ) . function streamCompare ( stream1 , stream2 , optionsOrCompare , callback ) { var options = assign ( typeof optionsOrCompare === 'function' ? { compare : optionsOrCompare } : optionsOrCompare", "del_tokens": "* @ param { Object | function ( ! StreamState , ! StreamState ) = } options Options , or a * comparison function ( as described in options . compare ) . function streamCompare ( stream1 , stream2 , options , callback ) { if ( typeof options === 'function' ) { options = { compare : options } ; } options = assign ( options", "commit_type": "improve"}
{"commit_tokens": ["Fix", "the", "bug", "I", "introduced"], "add_tokens": "console . log ( subroute ) ; console . log ( module ) ; mountApiSubroute ( app , routeConfig , mod , subroute ) ;", "del_tokens": "mountApiSubroute ( app , routeConfig , module , subroute ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "test", "to", "reflect", "new", "domain", "html", "class"], "add_tokens": "equal ( $ ( \"#cal-heatmap .graph-domain\" ) . length , 12 , \"The graph contains 12 hours\" ) ; equal ( $ ( \"#cal-heatmap .graph-domain rect\" ) . length , 60 * 12 , \"The graph contains 720 minutes\" ) ; equal ( $ ( \"#cal-heatmap .graph-domain\" ) . length , 5 , \"The graph contains only 5 hours\" ) ;", "del_tokens": "equal ( $ ( \"#cal-heatmap .hour\" ) . length , 12 , \"The graph contains 12 hours\" ) ; equal ( $ ( \"#cal-heatmap .hour rect\" ) . length , 60 * 12 , \"The graph contains 720 minutes\" ) ; equal ( $ ( \"#cal-heatmap .hour\" ) . length , 5 , \"The graph contains only 5 hours\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "scaling", "coefficient", "from", "FFT", "both", "webkit", "&", "firefox", "now", "using", "dsp", ".", "js"], "add_tokens": "play : function ( ) { this . audio . play ( ) ; } , stop : function ( ) { this . audio . pause ( ) ; } , return this . fft . spectrum ; } , getTime : function ( ) { return this . time ;", "del_tokens": "// save this so we're not creating a new one on every frame _this . tempFloat = Float32Array ( _this . fbLength / _this . channels ) ; play : function ( ) { this . audio . play ( ) ; } , stop : function ( ) { this . audio . pause ( ) ; } , // Modify spectrum to match WebKit's 0-255 range, Float32Array map for ( var i = 0 , l = this . tempFloat . length ; i < l ; i ++ ) { this . tempFloat [ i ] = this . fft . spectrum [ i ] * 2048 ; // Need a more precise modifier } return this . tempFloat ; getTime : function ( ) { return this . time ; } , // Use dsp.js's FFT to convert time-domain data to frequency spectrum", "commit_type": "remove"}
{"commit_tokens": ["adding", "check", "for", "convert", "binary", "to", "tests"], "add_tokens": "* Converts a pdf file at a given path to a tiff file with var pdf_convert_quality = 400 ; // default to density 400 for the convert command return callback ( err ) ; } return callback ( stderr ) ; }", "del_tokens": "* Module which converts a pdf file to a tiff file with var pdf_convert_quality = 400 ; inspect ( err . stack , 'stack' ) ; inspect ( err . code , 'code' ) ; inspect ( err . signal , 'signle' ) ; return callback ( err ) ; } inspect ( stderr , 'stderr' ) ; return callback ( err ) ; } inspect ( 'module loaded' ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "to", "use", "project", "-", "base"], "add_tokens": "const ARRAY_MUTATING_METHODS = [ * The callback will include a new non - enumerable property named ` ` of * it is being used to watch a property . example : * * const obj1 = { first : \"john\" } ; * const obj2 = { last : \"smith\" } ; * const watcher = ( ) => console . log ( \"changed\" ) ; * * objectWatchProp ( obj , \"first\" , watcher ) ; * objectWatchProp ( obj1 , \"last\" , watcher ) ; * * watcher . stopWatchingAll ( ) ; // removes callback from all objects that it is watching ARRAY_MUTATING_METHODS . forEach ( method => {", "del_tokens": "const mutatingMethods = [ * The callback will receive a new non - enumerable property named ` ` of * it is being used to watch a property . mutatingMethods . forEach ( method => {", "commit_type": "update"}
{"commit_tokens": ["Create", "@bluemath", "/", "geom", "submodule"], "add_tokens": "filename : \"./build/bluemath-common-test.js\" ,", "del_tokens": "filename : \"./build/bmcommon-test.js\" ,", "commit_type": "create"}
{"commit_tokens": ["Implement", "syntax", "rules", "pattern", "matching"], "add_tokens": "length ( cdr = true ) { if ( node != null && cdr ) n ++ ;", "del_tokens": "length ( ) { if ( node != null ) n ++ ;", "commit_type": "implement"}
{"commit_tokens": ["Adding", "PhantomJS", "to", "the", "testing", "harness"], "add_tokens": "browsers : [ 'PhantomJS' ] ,", "del_tokens": "browsers : [ ] ,", "commit_type": "add"}
{"commit_tokens": ["fix", "model", "change", "events", "not", "firing", "by", "string", "changes", "in", "a", "property", "."], "add_tokens": "//console.debug(\"model change attrs\", attrs); //console.debug(\"current[attr], val\", current[attr], val); if ( ( typeof current [ attr ] === \"string\" ) && ( typeof val === \"string\" ) && current [ attr ] !== val ) { changes . push ( attr ) ; } else if ( ! _isEqual ( current [ attr ] , val ) ) { //console.debug(\"notequal current[attr], val\", current[attr], val); //console.debug(\"prev[attr], val\", prev[attr], val); if ( ( typeof prev [ attr ] === \"string\" ) && ( typeof val === \"string\" ) && prev [ attr ] !== val ) { changed [ attr ] = val ; } else if ( ! _isEqual ( prev [ attr ] , val ) ) { //console.debug(\"assign changed[attr]\", val); //console.debug(\"deleted changed[attr]\"); //console.debug(\"unset deleted current[attr]\"); //console.debug(\"assign current[attr]\", val); //console.debug(\"model set: not silent\"); //console.debug(\"model changes to act on\", changes);", "del_tokens": "if ( ! _isEqual ( current [ attr ] , val ) ) { if ( ! _isEqual ( prev [ attr ] , val ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "doc", "for", "tokenize", ".", "words"], "add_tokens": "var WORD_BOUNDARY_CHARS = '\\t\\r\\n\\u00A0 !\\\"#$%&()*+,\\-.\\\\/:;<=>?@\\[\\\\\\]^_`{|}~' ; var WORD_BOUNDARY_REGEX = new RegExp ( '[' + WORD_BOUNDARY_CHARS + ']' ) ; var SPLIT_REGEX = new RegExp ( '([^' + WORD_BOUNDARY_CHARS + ']+)' ) ;", "del_tokens": "var WORD_BOUNDARY_CHARS = '\\t\\r\\n\\u00A0 !\\\"#$%&()*+,\\-.\\\\/:;<=>?@\\[\\\\\\]^_`{|}~' ; var WORD_BOUNDARY_REGEX = new RegExp ( '[' + WORD_BOUNDARY_CHARS + ']' ) ; var SPLIT_REGEX = new RegExp ( '([^' + WORD_BOUNDARY_CHARS + ']+)' ) ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "form", "example", "link", "fixed", "pre", "-", "filled", "inputs", "styling"], "add_tokens": "const $labelAndIcon = $input . siblings ( 'label, i' ) ; const hasValue = $input . val ( ) . length ; const addOrRemove = ` ${ hasValue || hasPlaceholder ? 'add' : 'remove' } ` ; const valid = $input . is ( ':valid' ) ; $ ( 'body' ) . find ( inputSelector ) . removeClass ( 'valid' ) . removeClass ( 'invalid' ) . each ( ( index , input ) => { const $this = $ ( input ) const noDefaultValue = ! $this . val ( ) const noPlaceholder = ! $this . attr ( 'placeholder' ) ; $this . siblings ( 'label, i' ) . toggleClass ( 'active' , ! ( noDefaultValue && noPlaceholder ) ) } )", "del_tokens": "const $labelAndIcon = $input . siblings ( 'label, i' ) ; const hasValue = $input . val ( ) . length ; const addOrRemove = ` ${ hasValue || hasPlaceholder ? 'add' : 'remove' } ` ; const valid = $input . is ( ':valid' ) ;", "commit_type": "remove"}
{"commit_tokens": ["use", "negative", "margins", "to", "compensate", "border", "width"], "add_tokens": "case 'width' : this . parent . element . css ( { 'border-width' : value , 'margin-left' : - value , 'margin-top' : - value } ) ; break ;", "del_tokens": "case 'width' : this . parent . element . css ( 'border-width' , value ) ; break ;", "commit_type": "use"}
{"commit_tokens": ["fix", "the", "bug", "mentioned", "in", "https", ":", "//", "github", ".", "com", "/", "fex", "-", "team", "/", "webuploader", "/", "issues", "/", "144"], "add_tokens": "var hash = file . __hash || ( file . __hash = hashString ( file . name + file . size + file . lastModifiedDate ) ) ; var hash = file . __hash ; hash && mapping [ hash ] = true ; var hash = file . __hash ; hash && ( delete mapping [ hash ] ) ;", "del_tokens": "var hash = hashString ( file . name + file . size + file . lastModifiedDate ) ; var hash = hashString ( file . name + file . size + file . lastModifiedDate ) ; mapping [ hash ] = true ; var hash = hashString ( file . name + file . size + file . lastModifiedDate ) ; delete mapping [ hash ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "class", "name", "prop", "for", "main", "container", "in", "Badge"], "add_tokens": "containerClassName , < div className = { classnames ( containerClassName , getClassNamesWithMods ( 'ui-badge' , { visible } , mods ) ) } > / ** * Class name for main container * / containerClassName : PropTypes . string ,", "del_tokens": "< div className = { getClassNamesWithMods ( 'ui-badge' , { visible } , mods ) } >", "commit_type": "add"}
{"commit_tokens": ["Add", "prefix", "to", "debug", "messages"], "add_tokens": "debug = require ( 'debug' ) ( 'amqp10-Codec' ) ;", "del_tokens": "debug = require ( 'debug' ) ( 'Codec' ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "custom", "login", "firebase", "failure", "action"], "add_tokens": "password = _ref3 . password ; }", "del_tokens": "password = _ref3 . password , _ref3$customFailureAc = _ref3 . customFailureAction , customFailureAction = _ref3$customFailureAc === undefined ? function ( ) { return { } ; } : _ref3$customFailureAc ; } , customFailureAction : customFailureAction ( )", "commit_type": "remove"}
{"commit_tokens": ["use", "simple", "hierarchy", "in", "base", "app", "generator"], "add_tokens": "type : 'list' , name : 'task' , message : 'Task' , choices : [ 'init' , 'ueber' ] , default : 'init' } , { default : defaultPluginType , when : ( props ) => props . task === 'init' if ( props . task === 'init' ) { this . config . set ( 'type' , props . type ) ; this . gen = 'init-' + props . type ; } else { this . gen = props . task ; } const gen = this . gen ; this . composeWith ( ` ${ gen } ` , { local : require . resolve ( ` ${ gen } ` )", "del_tokens": "default : defaultPluginType this . config . set ( 'type' , props . type ) ; const type = this . config . get ( 'type' ) ; this . composeWith ( ` ${ type } ` , { local : require . resolve ( ` ${ type } ` )", "commit_type": "use"}
{"commit_tokens": ["Remove", "the", "position", "option", "of", "css", ".", "parse"], "add_tokens": "* @ param { Object } [ pos ] if ( pos ) { var sourceFile = urix ( pos . source || 'source.css' ) ;", "del_tokens": "* @ param { Number } [ pos ] var sourceFile = urix ( pos && pos . source || 'source.css' ) ; if ( pos && pos . start ) {", "commit_type": "remove"}
{"commit_tokens": ["adding", "getUpdatedPropertyDetails", "method", "updating", "tests", "and", "README"], "add_tokens": "* @ param { Number } id function toQueryString ( params , id ) { return 'zws-id=' + id + paramsString ; '&citystatezip=' + encodeURIComponent ( citystatezip ) + . then ( function ( results ) { / ** * Carries out the getUpdatedPropertyDetails api call * @ memberof Zillow * * @ param { number } zpid = Zillow property id ( can be a string or number ) * / Zillow . prototype . getUpdatedPropertyDetails = function ( zpid ) { var requestUrl = rootUrl + 'GetUpdatedPropertyDetails.htm?' + 'zws-id=' + this . id + '&zpid=' + zpid ; return httprequest ( requestUrl ) . then ( toJson ) . then ( function ( results ) { var result = results [ 'UpdatedPropertyDetails:updatedPropertyDetails' ] ; return result ; } ) ; } ; var paramsString = toQueryString ( params , this . id ) ;", "del_tokens": "function toQueryString ( params ) { return 'zws-id=' + this . id + paramsString ; '&citystatezip=' + encodeURIComponent ( citystatezip ) + . then ( function ( results ) { var paramsString = toQueryString ( params ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "the", "formatting", "of", "the", "documentation"], "add_tokens": "* Initializes the storage . The overriding implementation should freeze the * instance object once it is fully initialized .", "del_tokens": "* Initializes the storage . The overriding implementation * should freeze the instance object once it is fully initialized .", "commit_type": "fix"}
{"commit_tokens": ["Made", "many", "optimizations", "to", "bring", "down", "the", "file", "size", "of", "the", "library", "."], "add_tokens": ". pipe ( uglify ( { output : { beautify : false } } ) )", "del_tokens": ". pipe ( uglify ( ) )", "commit_type": "make"}
{"commit_tokens": ["Fix", "sequelize", ".", "query", "()", "test"], "add_tokens": "it ( 'should pass query along to QueryInterface' , function ( ) { $query : function ( ) {", "del_tokens": "it ( 'should pass query along to QueryInterface' , function ( done ) { query : function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "an", "issue", "where", "the", "config", "version", "header", "wasn", "t", "always", "being", "picked", "up"], "add_tokens": "headers [ headerPair . substring ( 0 , separator ) . toLowerCase ( ) ] = headerPair . substring ( separator + 2 ) ;", "del_tokens": "headers [ headerPair . substring ( 0 , separator ) ] = headerPair . substring ( separator + 2 ) . toLowerCase ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "listen", "to", "use", "middlware", "correctly", "."], "add_tokens": "* Returns a ` ` that can be provided to ` ` or * app . use ( soundwave ( ) ) ; * http . createServer ( soundwave ( ) ) . listen ( 3000 ) ; var server = http . createServer ( middleware ( ) ) ;", "del_tokens": "* A ` ` that can be provided to ` ` or * app . use ( soundwave ) ; * http . createServer ( soundwave ) . listen ( 3000 ) ; var server = http . createServer ( middleware ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "accessible", "prop"], "add_tokens": "accessible : PropTypes . bool , accessible : true , accessible , accessible = { accessible }", "del_tokens": "_cancelEvent ( event ) { event . preventDefault ( ) event . stopPropagation ( ) }", "commit_type": "add"}
{"commit_tokens": ["added", "XMing", "version", "description", "in", "benchmarks"], "add_tokens": "// WinServ2008R2 64bit, Intel(R) Core(TM) i7 CPU 870 @ 2.93GHz + Xming 6.9.0.31 // 0.4.3/cygwin 32bit: 12000 +/-1000 InternAtom/sec // 0.5.1/win32 : 12000 +/-1000", "del_tokens": "// WinServ2008R2, Intel(R) Core(TM) i7 CPU 870 @ 2.93GHz // 0.4.3: 12000 +/-1000 InternAtom/sec // 0.5.1: 12000 +/-1000", "commit_type": "add"}
{"commit_tokens": ["Add", "ability", "to", "find", ".", "git", "folder", "on", "upper", "levels"], "add_tokens": "var git = getGitFolderPath ( root ) ; // Function to recursively finding .git folder function getGitFolderPath ( currentPath ) { var git = path . resolve ( currentPath , '.git' ) if ( ! exists ( git ) || ! fs . lstatSync ( git ) . isDirectory ( ) ) { console . log ( 'pre-commit:' ) ; console . log ( 'pre-commit: Not found .git folder in' , git ) ; var newPath = path . resolve ( currentPath , '..' ) ; // Stop if we on top folder if ( currentPath === newPath ) { return null ; } return getGitFolderPath ( newPath ) ; } console . log ( 'pre-commit:' ) ; console . log ( 'pre-commit: Found .git folder in' , git ) ; return git ; } if ( ! git ) { console . log ( 'pre-commit:' ) ; console . log ( 'pre-commit: Not found any .git folder for installing pre-commit hook' ) ; return ; } var hooks = path . resolve ( git , 'hooks' ) , precommit = path . resolve ( hooks , 'pre-commit' ) ;", "del_tokens": "var git = path . resolve ( root , '.git' ) , hooks = path . resolve ( git , 'hooks' ) , precommit = path . resolve ( hooks , 'pre-commit' ) ; if ( ! exists ( git ) || ! fs . lstatSync ( git ) . isDirectory ( ) ) return ;", "commit_type": "add"}
{"commit_tokens": ["Use", "es6", "method", "syntax", "and", "add", "isNumber", "check"], "add_tokens": "left ( value ) { if ( empty ( value ) ) { right ( value ) { if ( empty ( value ) ) { clear ( value = 'both' ) { align ( value ) { } , / ** * Vertical align * * @ param { string } [ value ] * @ return { [ prop , value ] } * / vAlign ( value ) { return prop ( 'vertical-align' , unit ( value ) ) ; function empty ( value ) { return value === undefined ; } if ( ! isUnit ( value ) && isNumber ( value ) ) { } function isNumber ( value ) { return ! isNaN ( parseInt ( value ) ) ;", "del_tokens": "left : function ( value ) { if ( value === undefined ) { right : function ( value ) { if ( value === undefined ) { clear : function ( value = 'both' ) { align : function ( value ) { if ( ! isUnit ( value ) ) {", "commit_type": "use"}
{"commit_tokens": ["add", "test", "for", "raw", "cursor"], "add_tokens": "if ( opts . remove ) { return docs && docs [ 0 ] || null", "del_tokens": "if ( opts . delete ) { return docs && docs [ 0 ] || docs", "commit_type": "add"}
{"commit_tokens": ["Fix", "references", "in", "sumCounter", "."], "add_tokens": "* Get a query range appropriate for using with { @ link sn . api . datum . loader } . Returns an object", "del_tokens": "* Get a query range appropriate for using with { @ link sn . datum . loader } . Returns an object", "commit_type": "fix"}
{"commit_tokens": ["Updating", "isBrowser", "for", "not", "being", "computed", "on", "build"], "add_tokens": "export default isBrowser ( ) ? require ( 'mapbox-gl' ) : { } ;", "del_tokens": "export default isBrowser ? require ( 'mapbox-gl' ) : { } ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "bug", "related", "to", "mime", "type", "for", "retrieving", "frames"], "add_tokens": "var promise = this . _httpGetImageJpeg ( url ) ; var promise = this . _httpGetImageJpeg2000 ( url ) ; var promise = this . _httpGetImageJpeg2000 ( url ) ; } else { var promise = this . _httpGetApplicationOctetStream ( url ) ; return ( promise . then ( ( response ) => {", "del_tokens": "var func = this . _httpGetApplicationOctetStream ; func = this . _httpGetImageJpeg ; func = this . _httpGetImageJpeg2000 ; func = this . _httpGetImageJpeg2000 ; // FIXME return ( this . _httpGetImageJpeg ( url ) . then ( ( response ) => {", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "a", "bug", "with", "tag", "and", "kungFig", ".", "load", "()", "again"], "add_tokens": "if ( config instanceof kungFig . TagContainer ) { config = config . children ; } else if ( config instanceof kungFig . Tag ) { config = config . content ; } if ( ! config || typeof config !== 'object' ) { return ; }", "del_tokens": "if ( config instanceof kungFig . TagContainer ) { config = config . children ; } else if ( config instanceof kungFig . Tag ) { config = config . content ; }", "commit_type": "fix"}
{"commit_tokens": ["add", "secondary", "configuration", "file", "to", "sockbot", "this", "one", "is", "excluded", "from", "git", "via", "gitignore"], "add_tokens": "function getAlt ( ) { try { return require ( './.SockBot.conf.json' ) ; } catch ( e ) { console . warn ( 'Alternate conf file not found: ' + e ) ; return { } ; } } exports . configuration = merge ( def , conf , getAlt ( ) ) ;", "del_tokens": "exports . configuration = merge ( def , conf ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "unique", "id", "s", "to", "the", "docs", "components", "page", "titles"], "add_tokens": "< h3 id = \"modals-live\" > Live demo < / h3 > < h2 id = \"progress-basic\" > Basic example < / h2 > < h2 id = \"progress-label\" > With label < / h2 > < h2 id = \"progress-screenreader-label\" > Screenreader only label < / h2 > < h2 id = \"progress-contextual\" > Contextual alternatives < / h2 > < h2 id = \"progress-striped\" > Striped < / h2 > < h2 id = \"progress-animated\" > Animated < / h2 > < h2 id = \"progress-stacked\" > Stacked < / h2 >", "del_tokens": "< h3 id = \"modals-static\" > Live demo < / h3 > < h2 id = \"modals-static\" > Basic example < / h2 > < h2 id = \"modals-label\" > With label < / h2 > < h2 id = \"modals-label\" > Screenreader only label < / h2 > < h2 id = \"modals-label\" > Contextual alternatives < / h2 > < h2 id = \"modals-label\" > Striped < / h2 > < h2 id = \"modals-label\" > Animated < / h2 > < h2 id = \"modals-label\" > Stacked < / h2 >", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "comments", "+", "remove", "dot", "-", "less", "hostname", "validation", "tests"], "add_tokens": "// Flags representing steps in the `parse` function. They are used to implement // a early stop mechanism (simulating some form of laziness) to avoid doing more // work than necessary to perform a given action (e.g.: we don't need to extract // the domain and subdomain if we are only interested in public suffix).", "del_tokens": "var IS_VALID = 0 ;", "commit_type": "add"}
{"commit_tokens": ["Add", "extractProperty", "/", "ies", "NodeUtils", "functions"], "add_tokens": "var topic = NodeUtils . defaultIfEmpty ( nodeConfig . topic , NodeUtils . extractProperty ( msg , 'dxlTopic' ) )", "del_tokens": "var topic = NodeUtils . defaultIfEmpty ( nodeConfig . topic , msg . dxlTopic )", "commit_type": "add"}
{"commit_tokens": ["add", "extra", "output", "add", "static", "file", "component", "to", "module", "for", "busting", "purposes"], "add_tokens": "console . log ( \"Request for :\" + request . url ) ; context . components = { \"resource\" : resource_component , \"static\" : require ( './components/static' ) } ;", "del_tokens": "context . components = { \"resource\" : resource_component } ;", "commit_type": "add"}
{"commit_tokens": ["Use", "Ember", ".", "$", "instead", "of", "$"], "add_tokens": "Ember . $ ( element ) . on ( 'scroll' , this . _scroll ) ; Ember . $ ( element ) . off ( 'scroll' , this . _scroll ) ;", "del_tokens": "$ ( element ) . on ( 'scroll' , this . _scroll ) ; $ ( element ) . off ( 'scroll' , this . _scroll ) ;", "commit_type": "use"}
{"commit_tokens": ["adding", "version", "checking", "and", "update", "-", "library", "command"], "add_tokens": "require ( './init.js' ) ; if ( cmd === 'update-library' ) { require ( './updateVersion' ) ; return ; } } ;", "del_tokens": "require ( '../../init.js' ) ; }", "commit_type": "add"}
{"commit_tokens": ["Making", "test", "and", "samples", "IE", "/", "ES5", "aware"], "add_tokens": "document . getElementById ( id ) . addEventListener ( 'click' , function ( event ) {", "del_tokens": "document . getElementById ( id ) . addEventListener ( 'click' , event => {", "commit_type": "make"}
{"commit_tokens": ["Fixed", "a", "smaller", "bug", "with", "lightbox", "closing", "on", "mobile", "devices", "."], "add_tokens": "// Add the closing button var lightboxCloseButton = afterglow . getPlayer ( playerid ) . TopControlBar . addChild ( \"LightboxCloseButton\" ) ; addEventHandler ( lightboxCloseButton . el_ , 'click tap' , function ( ) { afterglow . closeLightbox ( ) ; } ) ; } ) ;", "del_tokens": "} ) ; // Add the closing button var lightboxCloseButton = afterglow . getPlayer ( playerid ) . TopControlBar . addChild ( \"LightboxCloseButton\" ) ; addEventHandler ( lightboxCloseButton . el_ , 'click tap' , function ( ) { afterglow . closeLightbox ( ) ; } )", "commit_type": "fix"}
{"commit_tokens": ["Fix", "for", "https", ":", "//", "github", ".", "com", "/", "nordnet", "/", "cordova", "-", "universal", "-", "links", "-", "plugin", "/", "issues", "/", "22"], "add_tokens": "var ConfigParser ; // If we are running Cordova 5.4 or abova - use parser from cordova-common. // Otherwise - from cordova-lib. try { ConfigParser = context . requireCordovaModule ( 'cordova-common/src/ConfigParser/ConfigParser' ) ; } catch ( e ) { ConfigParser = context . requireCordovaModule ( 'cordova-lib/src/configparser/ConfigParser' ) }", "del_tokens": "var ConfigParser = context . requireCordovaModule ( 'cordova-lib/src/configparser/ConfigParser' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "to", "replace", "when", "it", "is", "not", "ready"], "add_tokens": "if ( ! this . disabled && url ) {", "del_tokens": "if ( this . ready && ! this . disabled && url ) {", "commit_type": "allow"}
{"commit_tokens": ["updated", "package", "to", "include", "more", "libs"], "add_tokens": "import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { PasswordComponent } from './password.component' ; import { UserEditComponent } from './user-edit.component' ; FormsModule , ReactiveFormsModule , UsersEventLogComponent , UserEditComponent , PasswordComponent UsersEventLogComponent , UserEditComponent", "del_tokens": "UsersEventLogComponent UsersEventLogComponent", "commit_type": "update"}
{"commit_tokens": ["Add", "test", "for", "hashing", "Error", "objects"], "add_tokens": "assert . plan ( 9 ) ; assert . ok ( validSha1 . test ( hash ( new Error ( ) ) ) , 'hash error' ) ;", "del_tokens": "assert . plan ( 8 ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "some", "bugs", "with", "tests", "."], "add_tokens": "it ( 'perPage should have a default of 20 items per page' , function ( ) { assert ( paginated . length === 20 ) ; assert ( paginated . getPerPage ( ) === 20 ) ; assert ( numPages === 10 ) ; assert ( numPages === 5 ) ;", "del_tokens": "it ( 'perPage should be the same as defaultPerPage' , function ( ) { assert ( paginated . length === paginated . defaultPerPage ) ; assert ( paginated . getPerPage ( ) === paginated . defaultPerPage ) ; assert ( numPage === 10 ) ; assert ( numPage === 5 ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "README", "and", "adding", "tests", "for", "htmlParser", "and", "trendData"], "add_tokens": "var obj = { } ; obj [ curr . split ( '\"' ) [ 3 ] ] = data [ index ] . split ( '\"' ) [ 3 ] ; acc . push ( obj ) ; return acc ;", "del_tokens": "acc . push ( { date : curr . split ( '\"' ) [ 3 ] , value : data [ index ] . split ( '\"' ) [ 3 ] } ) ; return acc ;", "commit_type": "update"}
{"commit_tokens": ["Add", "output", "option", "to", "build", "command"], "add_tokens": "const config = require ( '../config' ) const buildDir = createAndGetBuildFolder ( ) function createAndGetBuildFolder ( ) { const destination = path . join ( config . commands . build . output || process . cwd ( ) , 'build' ) sfs . createDir ( destination ) return destination createAndGetBuildFolder", "del_tokens": "// Export result in HTML // --------------------------------------------------------------- // -- Ensure ./build exists let buildDir = getBuildFolder ( basePath ) // Create and returns the path to the build directory from the given path function getBuildFolder ( basePath ) { let buildDir = path . join ( basePath , 'build' ) sfs . createDir ( buildDir ) return buildDir getBuildFolder", "commit_type": "add"}
{"commit_tokens": ["Improve", "unit", "tests", "with", "a", "connect", "server", "and", "testing", "locals", "variables"], "add_tokens": "'index_teamId' : function ( teamId , reqVar , resLocalVar , appLocalVar ) { return { teamId , reqVar , resLocalVar , appLocalVar } } , next ( )", "del_tokens": "'index_teamId' : function ( teamId ) { return teamId } , next ( req . params . stuff )", "commit_type": "improve"}
{"commit_tokens": ["add", "check", "for", "session", "attributes"], "add_tokens": "says : \"Hello World!\" , repromptsNothing : true , shouldEndSession : true , hasAttributes : { foo : 'bar' }", "del_tokens": "says : \"Hello World!\" , repromptsNothing : true , shouldEndSession : true", "commit_type": "add"}
{"commit_tokens": ["Create", "output", "dir", "if", "doesn", "t", "exist"], "add_tokens": "return utils . ensureExists ( this . _tempDir ) . then ( ( ) => { return utils . ensureExists ( this . _outputDir ) . then ( ( ) => { return utils . rename ( location , newLocation ) . then ( ( ) => { return Promise . resolve ( newFileName ) ; } ) ; module . exports = ThumbnailGenerator ;", "del_tokens": "return utils . exists ( this . _tempDir ) . then ( ( exists ) => { if ( ! exists ) { // create temp directory return utils . mkdir ( this . _tempDir ) ; } } ) . then ( ( ) => { return utils . rename ( location , newLocation ) . then ( ( ) => { return Promise . resolve ( newFileName ) ; module . exports = ThumbnailGenerator ;", "commit_type": "create"}
{"commit_tokens": ["Adding", "support", "for", "catalan", "and", "fixing", "French", "and", "Spanish", "translations"], "add_tokens": "'ca_ES' : { prefixAgo : 'fa' , prefixFromNow : 'd\\'aquí', suffixAgo : null , suffixFromNow : null , seconds : ' \\' minute : ' \\' minutes : '%d minuts' , hour : ' \\' hours : 'prop de %d hores' , day : 'un dia' , days : '%d dies' , month : 'prop d\\'un mes' , months : '%d mesos' , year : 'prop d\\'un any' , years : '%d anys' , numbers : [ ] } , prefixFromNow : 'en' , suffixFromNow : null , prefixFromNow : 'en' , suffixFromNow : null , day : 'un día', days : '%d días',", "del_tokens": "prefixFromNow : null , suffixFromNow : 'from now' , prefixFromNow : null , suffixFromNow : 'apartir de ahora' , day : 'un dia' , days : '%d dias' ,", "commit_type": "add"}
{"commit_tokens": ["Added", "tolerance", "for", "distribution", "next", "alignment"], "add_tokens": "HTree . forEach ( function ( $ , rightNodes ) { //if (rightNodes){ if ( Math . abs ( ll - lines . getDims ( right ) [ \"horizontal\" ] [ otherSide ] ) < 2 * options . guidelinesTolerance ) { //} } , ll - options . guidelinesTolerance , ll + options . guidelinesTolerance ) ; //aboveNodes = VTree.get(ll); VTree . forEach ( function ( $ , aboveNodes ) { //if (aboveNodes){ if ( Math . abs ( ll - lines . getDims ( above ) [ \"vertical\" ] [ otherSide ] ) < 2 * options . guidelinesTolerance ) { //} } , ll - options . guidelinesTolerance , ll + options . guidelinesTolerance ) ;", "del_tokens": "rightNodes = HTree . get ( ll ) ; if ( rightNodes ) { if ( ll == lines . getDims ( right ) [ \"horizontal\" ] [ otherSide ] ) { } aboveNodes = VTree . get ( ll ) ; if ( aboveNodes ) { if ( ll == lines . getDims ( above ) [ \"vertical\" ] [ otherSide ] ) { }", "commit_type": "add"}
{"commit_tokens": ["Make", "things", "more", "markdown", "like", ".", "Remove", "the", "_toTitleCase", "code", ".", "Not", "the", "affect", "I", "really", "wanted", "."], "add_tokens": "l . li ( \"This is an li log message.\" ) ;", "del_tokens": "l . li ( \"This is an li (indented text) log message.\" ) ;", "commit_type": "make"}
{"commit_tokens": ["improve", "whiteSpace", "&", "lineBreak", "needsBefore", "&", "needsAfter"], "add_tokens": "if ( typeof type === 'boolean' ) { return type && needsBeforeToken ( token ) ; } else if ( type == null ) { if ( typeof type === 'boolean' ) { return type && needsAfterToken ( token ) ; } else if ( type == null ) {", "del_tokens": "// can pass just a type or token + type if ( type == null ) { // can pass just a type or token + type if ( type == null ) {", "commit_type": "improve"}
{"commit_tokens": ["Allow", "existing", "db", "connection", "to", "be", "used"], "add_tokens": "function Connection ( ) { this . state = 0 ; this . state = 2 ; if ( typeof options . db === 'string' ) { self . state = err ? 0 : 1 ; if ( db . state === 'connected' ) return done ( null , db ) ; switch ( this . state ) { this . state = 3 ; self . state = 0 ;", "del_tokens": "function Connection ( options ) { this . readyState = 0 ; this . readyState = 2 ; if ( typeof db === 'string' ) { self . readyState = err ? 0 : 1 ; switch ( this . readyState ) { this . readyState = 3 ; self . readyState = 0 ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "distance", "-", "to", "-", "point", "calculation", "."], "add_tokens": "var xbit , ybit , level for ( level = 1 ; level < height && distance > 0 ; level *= 2 ) { distance = Math . floor ( distance / 4 )", "del_tokens": "var xbit , ybit , level , distance for ( level = 1 ; level < height ; level *= 2 ) { distance /= 4", "commit_type": "fix"}
{"commit_tokens": ["changed", "bounces", "option", "to", "bounce"], "add_tokens": "var bounce = true ; var bounceDeceleration = 0.04 ; var bounceAcceleration = 0.11 ; if ( bounce ) { if ( bounce ) { if ( cfg . bounce === false ) { bounce = false ;", "del_tokens": "var bounces = true ; var bounceDeceleration = 0.05 ; var bounceAcceleration = 0.09 ; if ( bounces ) { if ( bounces ) { if ( cfg . bounces === false ) { bounces = false ;", "commit_type": "change"}
{"commit_tokens": ["update", "docs", "thunk", "the", "limit", "and", "fix", "typo"], "add_tokens": "sqlASTNode . limit = typeof field . limit === 'function' ? field . limit ( sqlASTNode . args || { } , context ) : field . limit sqlASTNode . sortKey = field . sortKey ( sqlASTNode . args || { } , context )", "del_tokens": "sqlASTNode . limit = field . limit sqlASTNode . sortKey = field . sortKey ( sqlASTNode . args , context )", "commit_type": "update"}
{"commit_tokens": ["Allow", "self", "-", "closing", "interpolated", "tags"], "add_tokens": "var tok = this . tok ( 'interpolation' , match . src ) ; if ( this . input [ 0 ] === '/' ) { tok . selfClosing = true ; this . consume ( 1 ) ; } this . tokens . push ( tok ) ;", "del_tokens": "this . tokens . push ( this . tok ( 'interpolation' , match . src ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["Remove", "Readable", "/", "Writable", "stream", "logic", "from", "REPL", "tests", "."], "add_tokens": "useGlobal : true useGlobal : false // Use context.strictEqual to test itself!", "del_tokens": "var input = new Readable ; input . _read = function ( ) { } ; var output = new Writable ; output . _write = function ( ) { } ; useGlobal : true , input : input , output : output useGlobal : false , input : input , output : output // Use the globally-defined assertStrictEqual to test itself!", "commit_type": "remove"}
{"commit_tokens": ["remove", "queries", "array", "use", "BlameRange", "in", "BlameRangeList"], "add_tokens": "var BlameRange = require ( '../models/blame-range' ) ; var blameQuery = fs . readFileSync ( path . join ( __dirname , 'git-blame.graphql' ) , 'utf8' ) ; return BlameRange ( { } ) ; 'query' : blameQuery ,", "del_tokens": "//todo: remove queries var queries = [ 'git-blame' ] ; queries = queries . reduce ( function ( map , name ) { map [ name ] = fs . readFileSync ( path . join ( __dirname , name + '.graphql' ) , 'utf8' ) ; return map ; } , { } ) ; //todo: use BlameRange return { } ; var query = queries [ 'git-blame' ] ; 'query' : query ,", "commit_type": "remove"}
{"commit_tokens": ["Improve", "error", "message", "when", "loading", "a", "bad", "js", "file"], "add_tokens": "var mod ; try { mod = subRequire ( modPath ) ; //subRequire inserts the _id field } catch ( e ) { throw new Error ( 'Could not load ' + modPath + ': ' + e . message ) ; } var mod ; try { mod = require ( modPath ) ; } catch ( e ) { throw new Error ( 'Could not load ' + modPath + ': ' + e . message ) ; }", "del_tokens": "var mod = subRequire ( modPath ) ; //subRequire inserts the _id field var mod = require ( modPath ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fixed", "node", "-", "init", ".", "js", "not", "finding", "target", "file", "from", "command", "line", "."], "add_tokens": "if ( process . mainModule . filename === __filename ) { if ( process . argv . length > 2 ) { require ( path . join ( process . cwd ( ) , process . argv [ 2 ] ) ) ; }", "del_tokens": "var argv = process . argv ; if ( argv . length > 2 ) { var i = argv [ 1 ] . indexOf ( \"/node-init.js\" ) ; if ( i >= 0 ) { var p1 = path . normalize ( argv [ 1 ] ) ; var p2 = path . normalize ( process . cwd ( ) + \"/\" + argv [ 2 ] ) ; var n1 = p1 . split ( '/' ) . length ; var n2 = p2 . split ( '/' ) . length ; var n = Math . min ( n1 , n2 ) - 1 ; var p = \"../\" . repeat ( n ) + p2 . split ( '/' ) . slice ( n2 - n ) . join ( '/' ) ; console . log ( \"p=\" + p ) require ( p ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Use", "ynab", ".", "js", "name", "for", "browser", "build"], "add_tokens": "filename : \"browser/ynab.js\" ,", "del_tokens": "filename : \"browser/index.js\" ,", "commit_type": "use"}
{"commit_tokens": ["change", "the", "parser", "to", "get", "callback", "instead", "of", "promise"], "add_tokens": "var defaultEntryParser = function ( entry , callback ) { callback ( entry . object ) ; defaultEntryParser ( entry , function ( item ) {", "del_tokens": "var defaultEntryParser = function ( entry ) { resolve ( entry . object ) ; defaultEntryParser ( entry ) . then ( function ( item ) {", "commit_type": "change"}
{"commit_tokens": ["Added", "JavaDocs", "for", "Accumulator", "and", "DStream"], "add_tokens": "/ ** * @ author billreed * * / / ** * Represents a datatype that can be accumulated , ie has an commutative and associative \"add\" operation , but where the result type , R , may be different from the element type being added , T . * @ constructor * @ param { object } initialValue - initial value of accumulator param * @ param { object } accumulatorParam - helper object defining how to add elements of type R and T param * @ param { object } name - human - readable name for use in Spark ' * / } ;", "del_tokens": "} ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "support", "for", "pretty", "URLs"], "add_tokens": "var templateName = path . parse ( templateInPath ) . name ; if ( config . html . prettyurls && templateName != \"index\" ) { //convert out files like about.html to about/index.html templateOutDir = path . join ( templateOutDir , templateName ) ; templateName = \"index\" ; } var templateOutName = templateName + \".html\" ;", "del_tokens": "var templateOutName = path . parse ( templateInPath ) . name + \".html\" ;", "commit_type": "add"}
{"commit_tokens": ["Added", "option", "to", "configure", "swagger", "UI", "initial", "expansion", "state", "."], "add_tokens": "} , expanded : config . docExpansion", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Using", "an", "object", "as", "container", "via", "config", "options", "rather", "than", "a", "DOM", "id", ".", "Also", "help", "legend", "(", "final", "style", "and", "content", "tbd", ")", "."], "add_tokens": "element : document . getElementById ( \"target\" ) ,", "del_tokens": "var target = \"target\" ; target : \"target\" ,", "commit_type": "use"}
{"commit_tokens": ["Use", "noop", "function", "if", "callback", "is", "not", "defined"], "add_tokens": "/ ** * Empty noop function * / var noop = function ( ) { } ; if ( cb && typeof cb !== 'function' ) { this . client . hmset ( key , data , cb || noop ) ; this . client . del ( args , cb || noop ) ;", "del_tokens": "if ( typeof cb !== 'function' ) { this . client . hmset ( key , data , cb ) ; this . client . del ( args , cb ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "examples", ":", "relative", "link", "to", "the", "bundle"], "add_tokens": "plugins . push ( new HtmlWebpackPlugin ( { template : 'index.html' , inject : false } ) ) ;", "del_tokens": "plugins . push ( new HtmlWebpackPlugin ( { template : 'index.html' } ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "reset", "password", "request", "to", "omit", "the", "username", "parameter", "."], "add_tokens": "const missingParams = getMissingParameters ( req . body , [ 'password' , 'token' ] ) ; req . db . collection ( '__users__' ) . findOneAndUpdate ( filter , update ) . then ( result => { if ( ! result . value ) { throw new Error ( 'wrong reset token' ) ; } // we set the username as a param because if the update succeeds, // the request is forwarded to the passport local callback and will // authorize the user with the new password req . body . username = result . value . identities . local . username ; return handlers . callback ( req , res ) ; } )", "del_tokens": "const missingParams = getMissingParameters ( req . body , [ 'password' , 'token' , 'username' ] ) ; // we set the username as a param because the if the update succeeds, // the request is forwarded to the passport local callback and will // authorize the user with the new password req . db . collection ( '__users__' ) . updateOne ( filter , update ) . then ( ( ) => handlers . callback ( req , res ) )", "commit_type": "allow"}
{"commit_tokens": ["Add", "var", "renaming", "in", "webui", "and", "fix", "various", "bugs"], "add_tokens": "if ( r2ui . _dis . tmp_address !== undefined ) r2ui . _dis . tmp_address = addr ;", "del_tokens": "return addr ;", "commit_type": "add"}
{"commit_tokens": ["use", "local", "node", "-", "test", "-", "runner"], "add_tokens": "var _ = require ( 'lodash' ) ; var fs = require ( 'fs-extra' ) ; rm ( '-Rf' , 'tmp' ) ; // use local node-test-runner var tmpPackage = fs . readJsonSync ( './elm-package.json' ) ; tmpPackage [ 'source-directories' ] . push ( '../../src' ) ; var keys = _ . reject ( _ . keys ( tmpPackage . dependencies ) , function ( name ) { return name === \"rtfeldman/node-test-runner\" ; } ) ; tmpPackage . dependencies = _ . pick ( tmpPackage . dependencies , keys ) ; fs . writeJsonSync ( './elm-package.json' , tmpPackage ) ; sed ( '-i' , / Expect.fail \"Failed as expected!\" / , 'Expect.pass' , 'tests/Tests.elm' ) ;", "del_tokens": "sed ( '-i' , / Expect.fail \"failed as expected!\" / , 'Expect.pass' , 'tests/Tests.elm' ) ;", "commit_type": "use"}
{"commit_tokens": ["remove", "logmessage", "fix", "login", "and", "auth", "checking"], "add_tokens": "data . response . username = user . username ;", "del_tokens": "data . response . accountname = user . accountname ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "new", "obstacle", "and", "performance", "examples", ".", "Updated", "scenes", "to", "work", "with", "PBR", ".", "Updated", "grid", "and", "hemisphere", "components", ".", "Added", "cylinder", "component", "."], "add_tokens": "var color = this . getAttribute ( 'color' ) || \"#666\" ; var material = new THREE . LineBasicMaterial ( { color : color } ) ;", "del_tokens": "var material = new THREE . LineBasicMaterial ( { color : 0x303030 } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "initial", "api", "and", "docs"], "add_tokens": "var emberRollup = require ( 'ember-rollup' ) ; module . exports = emberRollup ( [ { name : 'spaniel' , namespaced : false } ] , { } ) ;", "del_tokens": "module . exports = { } ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "console", ".", "log", "to", "node", ".", "info"], "add_tokens": "node . info ( response + ' ' + offer + ' ' + from ) ; node . info ( 'randomaccept' ) ; node . info ( offer + ' ' + other ) ; node . info ( 'Precache' ) ; node . info ( 'Instructions' ) ; node . info ( 'Quiz' ) ; node . info ( 'RECEIVED BIDDER!' ) ; node . info ( ' Your offer was accepted.' ) ; node . info ( ' Your offer was rejected.' ) ; node . info ( 'RECEIVED RESPONDENT!' ) ; node . info ( 'Ultimatum' ) ; node . info ( 'Postgame' ) ; node . info ( 'Game ended' ) ;", "del_tokens": "console . log ( response , offer , from ) ; console . log ( 'randomaccept' ) ; console . log ( offer + ' ' + other ) ; console . log ( 'Precache (bot)' ) ; console . log ( 'Instructions (bot)' ) ; console . log ( 'Quiz (bot)' ) ; console . log ( 'RECEIVED BIDDER!' ) ; console . log ( ' Your offer was accepted.' ) ; console . log ( ' Your offer was rejected.' ) ; console . log ( 'RECEIVED RESPONDENT!' ) ; console . log ( 'Ultimatum (bot)' ) ; console . log ( 'Postgame (bot)' ) ; console . log ( 'Game ended (bot)' ) ;", "commit_type": "change"}
{"commit_tokens": ["use", "lodash", "merge", "instead", "of", "...", "to", "support", "deep", "merging"], "add_tokens": "const merge = require ( 'lodash.merge' ) config : merge ( defaultBuildConfig , userBuildConfig ) '\\nNot launching electron as debug argument was passed. You must launch electron though your debugger.'", "del_tokens": "config : { ... defaultBuildConfig , ... userBuildConfig } 'Not launching electron as debug argument was passed. You must launch electron though your debugger.'", "commit_type": "use"}
{"commit_tokens": ["Add", "captcha", ".", "url", "and", "example"], "add_tokens": "response . captcha = { url : response . request . uri . href , siteKey : match [ 1 ] , form : payload } ;", "del_tokens": "response . captcha = { siteKey : match [ 1 ] , form : payload } ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "s3router", ".", "js", "to", "only", "set", "the", "region", "of", "the", "s3", "service", "object", "instead", "of", "the", "global", "region", "config"], "add_tokens": "var s3Options = { } ; s3Options . region = options . region ; var s3 = new aws . S3 ( s3Options ) ; var s3 = new aws . S3 ( s3Options ) ;", "del_tokens": "aws . config . update ( { region : options . region } ) ; var s3 = new aws . S3 ( ) ; var s3 = new aws . S3 ( ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "typo", "in", "set", "-", "context", "-", "data"], "add_tokens": "dottie . set ( data , theKey , _this . resourceConfig [ key ] )", "del_tokens": "dottie . set ( data , theKey , this . resourceConfig [ key ] )", "commit_type": "fix"}
{"commit_tokens": ["Add", "include", "async", "library", "in", "ColoringEngine"], "add_tokens": "var async = require ( 'async' ) , buffertools = require ( 'buffertools' ) ,", "del_tokens": "var buffertools = require ( 'buffertools' ) ,", "commit_type": "add"}
{"commit_tokens": ["fixing", "default", "route", "to", "open", "non", "xin", "view", "page"], "add_tokens": "if ( data . indexOf ( '<body' ) >= 0 ) { } else if ( data . indexOf ( '<BODY' ) >= 0 ) { } else { data = '<div>' + data + '</div>' ; } else if ( $data . find ( 'body' ) . length > 0 ) { } ) ( window . xin ) ;", "del_tokens": "if ( data . indexOf ( '<body' ) ) { } else if ( data . indexOf ( '<BODY' ) ) { } else if ( $data . find ( 'body' ) ) { } ) ( window . xin ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "mocha", ".", "opts", "and", "do", "some", "error", "detection", "on", "shell", "/", "keepup", "level"], "add_tokens": "var run = require ( '../' ) , assert = require ( 'assert' ) ; run ( 'auth-basic' , function ( err , prog ) { assert . ifError ( err ) ; assert ( prog ) ; prog . stop ( ) ; done ( ) ; } ) ;", "del_tokens": "var run = require ( '../' ) ; run ( 'auth-basic' , done ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "on", "logging", "on", "pir", "even", "because", "it", "cannot", "detect", "log", "in", "scope"], "add_tokens": "this . log = log ; this . log . error ( \"This does not seem to be an Rpi. I'll continue, but I sure hope you know what you're doing...\" ) ; m . log . info ( 'Intruder was detected.' ) ;", "del_tokens": "log . error ( \"This does not seem to be an Rpi. I'll continue, but I sure hope you know what you're doing...\" ) ; log . info ( 'Intruder was detected.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "lodash", ".", "Simplified", "logic", "in", "checkSystem", ".", "js", "."], "add_tokens": "const _ = require ( \"lodash\" ) ; . then ( ( inspections ) => { const environmentIsValid = _ . every ( inspections , ( inspection ) => inspection . isFulfilled ( ) && inspection . value ( ) ) ; if ( environmentIsValid ) {", "del_tokens": "let environmentValid = true ; const numberOfValidations = Object . keys ( engines ) . length ; . each ( function ( inspection ) { if ( inspection . isFulfilled ( ) ) { if ( ! inspection . value ( ) ) { environmentValid = false ; } } else { environmentValid = false ; } } ) . then ( ( ) => { if ( environmentValid ) {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "logline", "line", "in", "_initializeStream"], "add_tokens": "'Firestore._initializeStream' ,", "del_tokens": "'Firestore.readWriteStream' ,", "commit_type": "fix"}
{"commit_tokens": ["add", "vendor", "prefixes", "for", "custom", "styles"], "add_tokens": "var appendVendorPrefix = require ( 'domkit/appendVendorPrefix' ) ; var prefixedModalStyle = appendVendorPrefix ( this . props . modalStyle ) ; for ( var style in prefixedModalStyle ) { modalStyle [ style ] = prefixedModalStyle [ style ] ; } var prefixedBackdropStyle = appendVendorPrefix ( this . props . backdropStyle ) ; for ( var style in prefixedBackdropStyle ) { backdropStyle [ style ] = prefixedBackdropStyle [ style ] ; } var prefixedContentStyle = appendVendorPrefix ( this . props . contentStyle ) ; for ( var style in prefixedContentStyle ) { contentStyle [ style ] = prefixedContentStyle [ style ] ; }", "del_tokens": "for ( var style in this . props . modalStyle ) { modalStyle [ style ] = this . props . modalStyle [ style ] ; } ; for ( var style in this . props . backdropStyle ) { backdropStyle [ style ] = this . props . backdropStyle [ style ] ; } ; for ( var style in this . props . contentStyle ) { contentStyle [ style ] = this . props . contentStyle [ style ] ; } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "check", "if", "token", "acquired", "before", "closing", "a", "asession"], "add_tokens": "if ( state . sessionToken !== null ) { util . log ( 'UAPI-JSON WARNING: Process left TerminalService session open' ) ; util . log ( 'UAPI-JSON WARNING: Session closing' ) ; terminal . closeSession ( ) . then ( ( ) => util . log ( 'UAPI-JSON WARNING: Session closed' ) ) . catch ( ( ) => util . log ( 'UAPI-JSON WARNING: Error closing session' ) ) ; } if ( state . sessionToken !== null ) { util . log ( 'UAPI-JSON WARNING: Process left TerminalService session open' ) ; }", "del_tokens": "util . log ( 'UAPI-JSON WARNING: Process left TerminalService session open' ) ; util . log ( 'UAPI-JSON WARNING: Session closing' ) ; terminal . closeSession ( ) . then ( ( ) => util . log ( 'UAPI-JSON WARNING: Session closed' ) ) . catch ( ( ) => util . log ( 'UAPI-JSON WARNING: Error closing session' ) ) ; util . log ( 'UAPI-JSON WARNING: Process left TerminalService session open' ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "Error", ":", "GeoPoint", ".", "lng", "field", "type", "must", "be", "Output", "Type", "but", "got", ":", "undefined", "."], "add_tokens": "type : new GraphQLNonNull ( GraphQLFloat ) ,", "del_tokens": "lng : new GraphQLNonNull ( GraphQLFloat ) ,", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "load", "-", "all", "-", "locales"], "add_tokens": "var path = require ( 'path' ) var javascript_time_ago = require ( 'javascript-time-ago' ) . default fs . readdirSync ( path . resolve ( __dirname , 'locale' ) ) . forEach ( function ( filename ) var locale_path = path . resolve ( __dirname , 'locale' , filename ) var stats = fs . statSync ( locale_path ) if ( stats . isDirectory ( ) ) javascript_time_ago . locale ( require ( locale_path ) )", "del_tokens": "var javascript_time_ago = require ( 'javascript-time-ago' ) fs . readdirSync ( path . resolve ( __dirname , 'locales' ) ) . forEach ( function ( filename ) var path = path . resolve ( __dirname , 'locales' , filename ) var stats = fs . statSync ( path ) if ( stat . isDirectory ( ) ) javascript_time_ago . locale ( require ( path ) ) )", "commit_type": "fix"}
{"commit_tokens": ["add", "private", "context", "mixin", "settings"], "add_tokens": "options . mixins = options . mixins || { } ; spec . mixins = [ spec . mixins , _mixins [ name ] , _mixins . all , options . mixins [ name ] , options . mixins . all ] ; exports [ name ] = React . createClass ( spec ) ;", "del_tokens": "data . mixins = [ data . mixins , _mixins [ name ] , _mixins . all ] ; exports [ name ] = React . createClass ( data ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "additional", "options", "to", "to", "pending", "resolution"], "add_tokens": "fromScene = this . _current , complete = this . _complete = _ . Deferred ( ) , enterComplete = _ . Deferred ( ) ,", "del_tokens": "var complete ; if ( _ . isObject ( sceneName ) ) { complete = sceneName [ 'with' ] ; sceneName = sceneName . name ; } else { complete = _ . Deferred ( ) ; } this . _complete = complete ; //for cancelling transitions fromScene = this . _current ; enterComplete = _ . Deferred ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Created", "and", "exposed", "component", "-", "specific", "error", "types"], "add_tokens": "expect ( function ( ) { Backbone . DeclarativeViews . clearCachedTemplate ( ) ; } ) . to . throw ( Backbone . DeclarativeViews . Error ) ; expect ( function ( ) { Backbone . DeclarativeViews . clearCachedTemplate ( \"\" ) ; } ) . to . throw ( Backbone . DeclarativeViews . Error ) ;", "del_tokens": "expect ( function ( ) { Backbone . DeclarativeViews . clearCachedTemplate ( ) ; } ) . to . throw ( Error ) ; expect ( function ( ) { Backbone . DeclarativeViews . clearCachedTemplate ( \"\" ) ; } ) . to . throw ( Error ) ;", "commit_type": "create"}
{"commit_tokens": ["Add", "iocane", "to", "webpack", "config"], "add_tokens": "const IOCANE = fs . realpathSync ( path . resolve ( NODE_MODULES , \"./iocane\" ) ) ; BUTTERCUP_CORE , IOCANE modules : [ NODE_MODULES , BUTTERCUP_CORE , IOCANE ]", "del_tokens": "// const BABEL_PRESET = fs.realpathSync(path.resolve(__dirname, \"./node_modules/babel-preset-es2015\")); BUTTERCUP_CORE modules : [ NODE_MODULES , BUTTERCUP_CORE ]", "commit_type": "add"}
{"commit_tokens": ["Remove", "const", "keyword", "and", "replaced", "it", "with", "var"], "add_tokens": "var newMax = max - min , newVal = value - min ;", "del_tokens": "const newMax = max - min , newVal = value - min ;", "commit_type": "remove"}
{"commit_tokens": ["Adding", "the", "ability", "to", "configure", "the", "protractor", "command", "line", "via", "a"], "add_tokens": "var protractor = require ( '../lib/protractor.js' ) ; describe ( 'angularjs homepage' , function ( ) { var ptor = process . protractorInstance ; //var ptor = protractor.getInstance();", "del_tokens": "describe ( 'angularjs homepage' , function ( ) { var webdriver = require ( 'selenium-webdriver' ) ; var protractor = require ( '../lib/protractor.js' ) ; var driver = new webdriver . Builder ( ) . usingServer ( 'http://localhost:4444/wd/hub' ) . withCapabilities ( { 'browserName' : 'chrome' , 'version' : '' , 'platform' : 'ANY' , 'javascriptEnabled' : true } ) . build ( ) ; driver . manage ( ) . timeouts ( ) . setScriptTimeout ( 10000 ) ; var ptor = protractor . wrapDriver ( driver ) ; //ptor.setup(); it ( 'afterAll' , function ( ) { // This is a sad hack to do any shutdown of the server. // TODO(juliemr): Add afterall functionality to jasmine-node driver . quit ( ) ; } )", "commit_type": "add"}
{"commit_tokens": ["change", "the", "policy", "on", "caching", "nulls", "to", "omit", "the", "key", "entirely"], "add_tokens": "if ( definition . nullable && typeof value === \"undefined\" ) { for ( var key in this . _definition . fields ) { if ( ! this . _definition . fields . hasOwnProperty ( key ) ) { this [ '_' + key ] = fix_data_type ( this . _definition . fields [ key ] , data [ key ] ) ;", "del_tokens": "if ( definition . nullable && value === '' ) { for ( var key in data ) { if ( ! data . hasOwnProperty ( key ) ) { if ( this . _definition . fields [ key ] ) { // make sure the datatype in the object is accurate this [ '_' + key ] = fix_data_type ( this . _definition . fields [ key ] , data [ key ] ) ; }", "commit_type": "change"}
{"commit_tokens": ["added", "unary", "operators", "to", "cell", "filters"], "add_tokens": "name : 'Compare a column to a value' , * * ` ` - A text box . literal : this . makeElement ( root ) // hard text when there would be only 1 option in the dropdown this . el . addEventListener ( 'change' , this . onChange = this . onChange || cleanUpAndMoveOn . bind ( this ) ) ; q : function ( ) { return this . literal ; } , return this . op . sql ( this . column , this . literal ) ;", "del_tokens": "name : 'column ? value' , preInitialize : function ( ) { this . onChange = cleanUpAndMoveOn . bind ( this ) ; } , * * ` ` - A text box . value : this . makeElement ( root ) this . el . addEventListener ( 'change' , this . onChange ) ; q : function ( ) { return this . value ; } , return this . SQL_QUOTED_IDENTIFIER + this . column + this . SQL_QUOTED_IDENTIFIER + ' ' + ( typeof this . op . sql === 'function' ? this . op . sql ( this . value ) : ( this . op . sql || this . operator ) + operators . sq ( this . value ) ) ;", "commit_type": "add"}
{"commit_tokens": ["made", "getRoutes", "a", "prototype", "method"], "add_tokens": "Controller . prototype . getRoutes = function ( options ) { . post ( periodicResources . core . controller . save_revision , middleware . create ) . delete ( middleware . remove ) ; routesObject . router = Controller . prototype . getRoutes ( {", "del_tokens": "var getRoutes = function ( options ) { . post ( periodicResources . core . controller . save_revision , middleware . create ) ; router . delete ( ` ${ model . name_plural } ` , middleware . remove ) ; routesObject . router = getRoutes ( {", "commit_type": "make"}
{"commit_tokens": ["added", "Angular", "for", "testing", "updating", "area", ".", "js"], "add_tokens": "width = args . width , height = args . height , el = args . element , data = args . data , xValue = args . x , yValue = args . y , parseDate , x , y , xAxis , yAxis , area , svg , groups ; groups = svg . selectAll ( \"\" )", "del_tokens": "width = args . width , height = args . height , el = args . element , data = args . data , xValue = args . x , yValue = args . y , // Parses date for time series. parseDate , x , y , xAxis , yAxis , area , svg , groups ; groups = svg . selectAll ( \"\" )", "commit_type": "add"}
{"commit_tokens": ["added", "Formula", "and", "Number", "methods", "to", "Rows", "."], "add_tokens": "//console.log(thisWS); var thisRow = { row : [ ] } ; var attr = '@' + a ; var obj = { } ; obj [ attr ] = thisWS . rows [ r ] . attributes [ a ] ; thisRow . row . push ( obj ) ; console . log ( thisRow ) ; var thisCellIndex = thisRow . row . push ( { 'c' : { } } ) ; var thisCell = thisRow . row [ thisCellIndex - 1 ] [ 'c' ] ;", "del_tokens": "console . log ( thisWS ) ; var thisRow = { row : { } } ; thisRow . row [ '@' + a ] = thisWS . rows [ r ] . attributes [ a ] ; var cells = thisRow . row . c = [ ] ; var thisCellIndex = cells . push ( { } ) ; var thisCell = cells [ thisCellIndex - 1 ] ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "isBN", "not", "always", "returning", "a", "boolean"], "add_tokens": "return x && typeof x === 'object' && Boolean ( x . words )", "del_tokens": "return x && typeof x === 'object' && x . words", "commit_type": "fix"}
{"commit_tokens": ["changed", "maxerr", "to", "allow", "negative", "numbers", "to", "pass", "all", "lint", "errors"], "add_tokens": "if ( maxerr >= 0 ) { issues = lodash . first ( issues , maxerr ) ; }", "del_tokens": "issues = lodash . first ( issues , maxerr ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "padding", "space", "between", "table", "name", "and", "loaded", "data"], "add_tokens": "var command = 'load --table ' + this . table + ' ' + JSON . stringify ( [ line ] ) ;", "del_tokens": "var command = 'load --table ' + this . table + JSON . stringify ( [ line ] ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "arrays", "to", "policy", "test", "data"], "add_tokens": "'Resource' : [ '*' ] 'Action' : [ 'iam:ChangeAdminPassword' ] , 'Resource' : [ '*' ] 'Resource' : [ '*' ] 'Action' : [ 'iam:ChangeAdminPassword' ] , 'Resource' : [ '*' ] 'Resource' : [ '*' ] 'Action' : [ 'iam:ChangeAdminPassword' ] , 'Resource' : [ '*' ] 'Resource' : [ '*' ] 'Action' : [ 'iam:ChangeAdminPassword' ] , 'Resource' : [ '*' ] 'Resource' : [ '*' ] 'Action' : [ 'iam:ChangeAdminPassword' ] , 'Resource' : [ '*' ]", "del_tokens": "'Resource' : '*' 'Action' : 'iam:ChangeAdminPassword' , 'Resource' : '*' 'Resource' : '*' 'Action' : 'iam:ChangeAdminPassword' , 'Resource' : '*' 'Resource' : '*' 'Action' : 'iam:ChangeAdminPassword' , 'Resource' : '*' 'Resource' : '*' 'Action' : 'iam:ChangeAdminPassword' , 'Resource' : '*' 'Resource' : '*' 'Action' : 'iam:ChangeAdminPassword' , 'Resource' : '*'", "commit_type": "add"}
{"commit_tokens": ["updated", "tests", "to", "work", "with", "iojs", ".", "assert"], "add_tokens": "return new Error ( 'Wrong number of arguments; 3 arguments necessary' ) ;", "del_tokens": "//return new Error('Wrong number of arguments; 3 arguments necessary'); //return new WrongNumberOfArgumentsError( // 'Wrong number of arguments; 3 arguments necessary'); return new WrongNumberOfArgumentsError ( 'Wrong number of arguments; 3 arguments necessary' ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "support", "for", "Visual", "Studio", "Code", "when", "creating", "new", "projects"], "add_tokens": "// Generate Visual Studio Code workspace settings let addVSCode ; if ( typeof answers . vscode === 'boolean' ) { addVSCode = answers . vscode ; } else { addVSCode = ( await inquirer . prompt ( [ { type : 'confirm' , name : 'vscode' , message : 'Would you like to add Visual Studio Code settings?' , default : true , } , ] ) ) . vscode ; } spinner = ora ( 'Downloading starter project' ) ; spinner . start ( ) ; spinner . stop ( ) ; await fs . remove ( destDir ) ; // BUG: don't remove the directory if it existed before if ( addVSCode ) { await fs . copy ( path . join ( __dirname , 'vscode' , 'jsconfig.json' ) , path . join ( destDir , 'jsconfig.json' ) ) ; await fs . copy ( path . join ( __dirname , 'vscode' , 'settings.json' ) , path . join ( destDir , '.vscode' , 'settings.json' ) ) ; } spinner . start ( 'Installing packages' ) ; spinner . stop ( ) ;", "del_tokens": "spinner = ora ( 'Downloading starter project' ) . start ( ) ; spinner . stop ( ) ; spinner . text = 'Installing packages' ; spinner . stop ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "stack", "bug", "with", "invalid", "region", "names"], "add_tokens": "if ( self . newestDeployments [ region ] === undefined ) { callback ( new errors . NotFoundError ( 'Region not found' ) ) ; } else if ( self . newestDeployments [ region ] === 0 ) {", "del_tokens": "if ( self . newestDeployments [ region ] === 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "ImageUrl", "not", "interpolating", "a", "template", "property", "with", "value", "0", "correctly", "."], "add_tokens": "var templateProperty = templateProperties [ property ] ; var valueFromTile = tile . hasOwnProperty ( templateProperty ) ? tile [ templateProperty ] : '' ;", "del_tokens": "var valueFromTile = tile [ templateProperties [ property ] ] || '' ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "require", "paths", "that", "were", "broken", "by", "plugin", "id", "changes"], "add_tokens": "FileTransferError = require ( 'org.apache.cordova.core.file-transfer.FileTransferError' ) , ProgressEvent = require ( 'org.apache.cordova.core.file.ProgressEvent' ) ; entry = new ( require ( 'org.apache.cordova.core.file.DirectoryEntry' ) ) ( ) ; entry = new ( require ( 'org.apache.cordova.core.file.FileEntry' ) ) ( ) ;", "del_tokens": "FileTransferError = require ( 'org.apache.cordova.core.FileTransfer.FileTransferError' ) , ProgressEvent = require ( 'org.apache.cordova.core.FileUtils.ProgressEvent' ) ; entry = new ( require ( 'org.apache.cordova.core.FileUtils.DirectoryEntry' ) ) ( ) ; entry = new ( require ( 'org.apache.cordova.core.FileUtils.FileEntry' ) ) ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "shifted", "ranks", "due", "to", "missing", "song"], "add_tokens": "var ranks = [ ] ; var positions = [ ] ; positions . push ( positionInfo ) ; $ ( '.chart-row__current-week' ) . each ( function ( index ) { ranks . push ( $ ( this ) . text ( ) . replace ( / \\r?\\n|\\r / g , \"\" ) . replace ( / \\s+ / g , ' ' ) ) ; } ) ; \"rank\" : ranks [ i ] , \"position\" : positions [ i ]", "del_tokens": "var position = [ ] ; position . push ( positionInfo ) ; \"rank\" : i + 1 , \"position\" : position [ i ]", "commit_type": "fix"}
{"commit_tokens": ["Remove", "extra", "information", "attached", "to", "the", "event", ".", "It", "s", "not", "necessary", "for", "most", "purposes", "and", "we", "can", "getAssignedNodes", "()", "anyways", "."], "add_tokens": "this . dispatchEvent ( new CustomEvent ( 'slotchange' , { cancelable : false } ) ) ;", "del_tokens": "import mapSlotAddedNodes from './map-slot-added-nodes' ; import mapSlotRemovedNodes from './map-slot-removed-nodes' ; function clearSlotNodeData ( slot ) { mapSlotAddedNodes . set ( slot , null ) ; mapSlotRemovedNodes . set ( slot , null ) ; } const addedNodes = mapSlotAddedNodes . get ( this ) || [ ] ; const removedNodes = mapSlotRemovedNodes . get ( this ) || [ ] ; // Don't do anything if nothing changed. if ( ! addedNodes . length && ! removedNodes . length ) { return clearSlotNodeData ( this ) ; } const ce = new CustomEvent ( 'slotchange' , { cancelable : false , detail : { addedNodes , removedNodes } } ) ; clearSlotNodeData ( this ) ; this . dispatchEvent ( ce ) ;", "commit_type": "remove"}
{"commit_tokens": ["Changed", "testJava", "()", "to", "allow", "Java", "8"], "add_tokens": "if ( stderr . match ( / 1\\.[7-8]+ / ) ) {", "del_tokens": "if ( stderr . indexOf ( \"version \\\"1.7.\" ) >= 0 ) {", "commit_type": "change"}
{"commit_tokens": ["Fix", "function", "call", "in", "binary", "after", "rename"], "add_tokens": "manager . propagateEvents ( ) ;", "del_tokens": "manager . propagateChanges ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "very", "basic", "support", "for", "highlighting", "formatting", "tools", "when", "the", "cursor", "is", "over", "content", "which", "is", "formatted", "that", "way"], "add_tokens": "/ ** * Gets a clone of this object . * * @ method * @ returns { es . Range } Clone of range * / es . Range . prototype . clone = function ( ) { return new es . Range ( this . from , this . to ) ; } ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "where", "collapse", "click", "event", "would", "fire", "multiple", "times"], "add_tokens": "$ ( collapseDiv ) . text ( expandIndicator ) ; $ ( collapseDiv ) . text ( hideIndicator ) ; $ ( \"div.collapse\" ) . off ( ) . click ( function ( ) { var indicator = $ ( this ) . text ( ) ; console . log ( indicator ) ; $ ( this ) . text ( indicator == hideIndicator ? expandIndicator : hideIndicator ) ;", "del_tokens": "collapseDiv . innerHTML = expandIndicator ; collapseDiv . innerHTML = hideIndicator ; $ ( \"div.collapse\" ) . click ( function ( ) { $ ( this ) . text ( ( $ ( this ) . text ( ) == hideIndicator ) ? expandIndicator : hideIndicator ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixing", "functions", "and", "methods", "returning", "values", "by", "reference"], "add_tokens": "group ( concat ( [ \"function \" , node . byref ? \"&\" : \"\" , node . name , \"(\" ] ) ) , node . byref ? \"&\" : \"\" ,", "del_tokens": "group ( concat ( [ \"function \" , node . name , \"(\" ] ) ) ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "a", "placeholder", "for", "Set"], "add_tokens": "} // TODO: Implement Set semantics } else if ( t . type === 'Set' ) { return specs . ASet ( this . lookupType ( t . fieldType ) ) ;", "del_tokens": "} ; // TODO: handle Set", "commit_type": "add"}
{"commit_tokens": ["moved", "YASGUI", "code", "to", "separate", "package"], "add_tokens": "var yasgui = require ( 'trifid-yasgui' )", "del_tokens": "var yasgui = require ( './lib/yasgui' )", "commit_type": "move"}
{"commit_tokens": ["add", "expand", "and", "collapse", "methods"], "add_tokens": ". controller ( 'MainController' , function ( $scope ) {", "del_tokens": ". controller ( 'AccordionController' , function ( $scope ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "Chrome", "Packaged", "Apps"], "add_tokens": "this . socket = navigator . TCPSocket . open ( this . host , this . port , { window . log ( \"SERVER: \" + this . _command + str . substr ( 0 , match . index ) ) ; var cmd = imapHandler . compiler ( { tag : \"A\" , command : \"LOGOUT\" } ) ; window . log ( \"CLIENT: \" + cmd ) ; this . socket . send ( mimefuncs . toArrayBuffer ( cmd + \"\\r\\n\" ) . buffer ) ;", "del_tokens": "var socket = navigator . TCPSocket || navigator . mozTCPSocket ; this . socket = socket . open ( this . host , this . port , { window . log ( \"Received a command from the server\" ) ; window . log ( \"Sending LOGOUT command...\" ) ; this . socket . send ( mimefuncs . toArrayBuffer ( \"a LOGOUT\\r\\n\" ) . buffer ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "test", "for", "building", "common", "3rd", "-", "party", "libraries", "."], "add_tokens": "* are loaded independently ) or to framework built - in modules ( ex . 'ng' ) . externalModules : 'ng' ,", "del_tokens": "* are loaded independently ) . externalModules : null ,", "commit_type": "add"}
{"commit_tokens": ["add", "custom", "handlebars", "handler", "example"], "add_tokens": "handlers ( source , context ) { handlers ( source , context ) { const test = '<script type=\"application/json\" src=\"foo.json\" inline inline-var=\"window.foo\"></script>' ; handlers ( source , context ) { if ( source . type == 'json' ) source . content = source . props . var + ' = ' + source . fileContent ; expect ( html ) . to . eql ( '<script type=\"application/json\">window.foo = {\\n \"foo\": \"foo\"\\n}</script>' ) ; } ) ; it ( 'should inline handlebars sources with custom handler' , async ( ) => { const test = '<script type=\"text/x-handlebars-template\" src=\"foo.handlebars\" inline></script>' ; const html = normaliseNewLine ( await inline ( test , { handlers : [ require ( './fixtures/handlebarsHandler' ) ] } ) ) ; expect ( html ) . to . contain ( 'container.escapeExpression(((helper = (helper = helpers.title' ) ;", "del_tokens": "handlers : function ( source , context ) { handlers : function ( source , context ) { const test = '<script type=\"application/json\" src=\"foo.json\" inline inline-var=\"window.foo\"></script>' ; handlers : function ( source , context ) { if ( source . type == 'json' ) source . content = source . props . var + ' = ' + source . fileContent ; expect ( html ) . to . eql ( '<script type=\"application/json\">window.foo = {\\n \"foo\": \"foo\"\\n}</script>' ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "Map", ".", "reduce", "2", "-", "3", "times", "faster", "."], "add_tokens": "var get , arrayUpdate , arrayRemove , updateInternal , reduceSparse ; reduceSparse = function ( arr , f , acc ) { for ( var i = 0 , len = arr . length ; i < len ; ++ i ) if ( i in arr ) acc = f ( acc , arr [ i ] ) ; return acc ; } ; return reduceSparse ( this . _children , function ( acc2 , child ) { return reduce ( function ( acc ) { } , 0 , this . _root ) ;", "del_tokens": "var get , arrayUpdate , arrayRemove , updateInternal ; return this . _children . reduce ( function ( acc2 , child ) { return this . reduce ( function ( acc ) { } , 0 ) ;", "commit_type": "make"}
{"commit_tokens": ["Make", "queue", "property", "private", "i", ".", "e", ".", "#", ".", "_queue"], "add_tokens": "queue = async . _queue ( function ( task , callback ) { this . _queue = queue ; self . _queue . resume ( ) ; this . _queue . push ( this . get . bind ( this , selector , callback ) ) ; this . _queue . push ( this . count . bind ( this , selector , callback ) ) ; this . _queue . push ( this . set . bind ( this , properties , callback ) ) ; this . _queue . push ( this . del . bind ( this , selector , callback ) ) ;", "del_tokens": "queue = async . queue ( function ( task , callback ) { this . queue = queue ; self . queue . resume ( ) ; this . queue . push ( this . get . bind ( this , selector , callback ) ) ; this . queue . push ( this . count . bind ( this , selector , callback ) ) ; this . queue . push ( this . set . bind ( this , properties , callback ) ) ; this . queue . push ( this . del . bind ( this , selector , callback ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Removed", "test", "for", "all", "blogs"], "add_tokens": "// helper.nock(helper.test_shop) // .get('/admin/blogs.json') // .reply(200, helper.load(\"blogs\"), { server: 'nginx', // status: '200 OK', // }); // it('should get all blogs', function(done) { // resource.all(function(err, res){ // res.should.not.be.empty; // res[0].should.have.property('id'); // done(); // }); // });", "del_tokens": "helper . nock ( helper . test_shop ) . get ( '/admin/blogs.json' ) . reply ( 200 , helper . load ( \"blogs\" ) , { server : 'nginx' , status : '200 OK' , } ) ; it ( 'should get all blogs' , function ( done ) { resource . all ( function ( err , res ) { res . should . not . be . empty ; res [ 0 ] . should . have . property ( 'id' ) ; done ( ) ; } ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Use", "1003", "(", "CLOSE_UNSUPPORTED", ")", "when", "JSON", "is", "invalid"], "add_tokens": "var CLOSE_ERROR = 1008 ; var CLOSE_NORMAL = 1000 ; var CLOSE_UNSUPPORTED = 1003 ; var KEEP_ALIVE = 30 * 1000 ; } catch ( _ ) { var err = new Error ( 'Client sent invalid JSON' ) ; err . code = CLOSE_UNSUPPORTED ; this . emit ( 'error' , err ) ; this . ws . close ( CLOSE_NORMAL ) ; this . ws . close ( err . code || CLOSE_ERROR , err . message ) ;", "del_tokens": "var KEEP_ALIVE = 30 * 1000 ; } catch ( err ) { this . emit ( 'error' , new Error ( 'Client sent invalid JSON' ) ) ; this . ws . close ( 1000 ) ; this . ws . close ( 1008 , err . message ) ;", "commit_type": "use"}
{"commit_tokens": ["Allow", "middleware", "to", "modify", "payload"], "add_tokens": "payload = req . payload = util . formRequestPayload ( req , req . options . values || { } ) ;", "del_tokens": "payload = req . payload = util . formRequestPayload ( req , values || { } ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fixed", "bugs", "with", "compass", "."], "add_tokens": "if ( config . compass ) { if ( config . compass ) { } else { document . getElementById ( 'compass' ) . style . display = 'none' ;", "del_tokens": "if ( config . northOffset ) { if ( config . northOffset ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "a", "bug", "where", "the", "compiled", "form", "of", "require", "(", "a", ")", "require", "(", "b", ")", "would", "cause", "a", "runtime", "error", ".", "The", "inline", "comment", "explains", "the", "issue", "and", "the", "fix", "in", "detail"], "add_tokens": "// we could replace require('path') with (function(){})(). However, if // you have require('path1') require('path2'), then we end up with // (function a(){})() (function b(){}()). This causes a runtime error, // since it gets interpreted as an invocation of the return value of // function a. Instead, insert a throwaway variable assignment, such that // we get require._=(function a(){})() require._=(function b(){})(). This // gets interpreted as two separate statements, which solves the problem. // (an alternative faulty approach is to put a semi-colon at the end of // the function invocation, but that would fail in the case of // var a = require('a'), b = require('b')) 'require._=(function() {' ,", "del_tokens": "'(function() {' ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "runFile", "()", "method", "for", "running", "a", "suite", "file", "in", "a", "child", "process"], "add_tokens": "exports . runFile = testing . runFile ;", "del_tokens": "exports . runFiles = testing . runFiles ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "unminified", "browser", "build", "rollup", ".", "config", ".", "js"], "add_tokens": "module . exports . default = WaveFile ;", "del_tokens": "module . exports . default = WaveFile", "commit_type": "remove"}
{"commit_tokens": ["added", "Mdd", "date", "format", "defaulted", "date", "format", "to", "null"], "add_tokens": "chart . setPadding ( ) ; chart . setPadding ( ) ;", "del_tokens": "q . padding . top = 40 ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "IE", "11", "compatibility", "."], "add_tokens": "corejs : [ 'node_modules/core-js-bundle/minified.js' , 'https://unpkg.com/core-js@2/client/shim.min.js' 'https://unpkg.com/systemjs@0.21/dist/system.js' // 1. Load core-js if native Promise support is missing. typeof ( Promise ) != 'function' && 'corejs' , var retried = false ; var uri = urls . shift ( ) ; if ( retried ) return ; retried = true ; if ( xhr . readyState != 4 ) return ; cache [ key ] = xhr . responseURL || uri ; xhr . open ( 'GET' , uri , true ) ;", "del_tokens": "bluebird : [ 'node_modules/bluebird/js/browser/bluebird.core.min.js' , '//unpkg.com/bluebird@3/js/browser/bluebird.core.min.js' '//unpkg.com/systemjs@0.21/dist/system.js' // 1. Load Bluebird if native Promise support is missing. typeof ( Promise ) != 'function' && 'bluebird' , cache [ key ] = xhr . responseURL ; xhr . open ( 'GET' , urls . shift ( ) , true ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "fixing", "t", "to", "first", "ns", "provided", "not", "to", "the", "ns", "array", "acting", "as", "fallback", "-", "fixes", "savemissing", "to", "correct", "ns"], "add_tokens": "if ( typeof namespaces === 'string' ) namespaces = [ namespaces ] ; this [ translateFuncName ] = this . i18n . getFixedT ( null , namespaces [ 0 ] ) ;", "del_tokens": "this [ translateFuncName ] = this . i18n . getFixedT ( null , namespaces ) ;", "commit_type": "fix"}
{"commit_tokens": ["Made", "the", "default", "flavor", "whatever", "produces", "README", "-", "like", "output", ".", "Improved", "the", "README", ".", "md", "content", "."], "add_tokens": "var path = require ( 'path' ) ; var name = path . basename ( process . argv [ 1 ] ) ; . usage ( 'Convert a ' + name + ' or gfm file into HTML. \"gfm\" refers to Github flavored markdown.\\n' + 'Usage: ' + name + ' file-to-convert [options]' ) . example ( name + ' README.md -h' , . example ( name + ' test/test.md -h -s test/style.css' , . example ( name + ' REAMDE.md -f markdown' , . example ( name + ' REAMD.md -c cwjohan/node-redis' , . example ( name + ' --help' , 'Display this usage info.' ) . options ( 'f' , { alias : 'flavor' } ) t : 'Add a page title to the header (e.g., $FILENAME, $DIRNAME, $BASENAME, or $PATHNAME).' ,", "del_tokens": ". usage ( 'Convert a markdown or gfm file into HTML. \"gfm\" refers to Github flavored markdown.\\n' + 'Usage: markdown file-to-convert [options]' ) . example ( 'markdown README.md -h' , . example ( 'markdown test/test.md -h -s test/style.css' , . example ( 'markdown REAMDE.md -f markdown' , . example ( 'markdown REAMD.md -c cwjohan/node-redis' , . example ( 'markdown --help' , 'Display this usage info.' ) . options ( 'f' , { alias : 'flavor' , default : 'gfm' } ) t : 'Add a page title to the header (e.g., $FILENAME or $FILEPATH).' ,", "commit_type": "make"}
{"commit_tokens": ["removed", "Vec3Ds", "async", "load", "of", "Vec2D", "and", "AABB"], "add_tokens": "var internals = require ( '../internals' ) , Vec2D = require ( './Vec2D' ) , AABB = require ( './AABB' ) , mathUtils = require ( '../math/mathUtils' ) ;", "del_tokens": "var internals = require ( '../internals' ) ; var Vec2D , AABB ; require ( [ './Vec2D' , './AABB' ] , function ( v2 , AB ) { Vec2D = v2 ; AABB = AB ; } ) ; var mathUtils = require ( '../math/mathUtils' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "new", "file", "for", "time", "unit", "operations", "fixed", "some", "JSHints"], "add_tokens": "function standardTime ( coefficient ) { standardTimers . nanoseconds = standardTime ( 1e-9 ) ; standardTimers . microseconds = standardTime ( 1e-6 ) ; standardTimers . milliseconds = standardTime ( 1e-3 ) ; standardTimers . seconds = standardTime ( 1 ) ; standardTimers . minutes = standardTime ( 60 ) ; standardTimers . hours = standardTime ( 60 * standardTimers . minutes . coefficient ) ; standardTimers . days = standardTime ( 24 * standardTimers . hours . coefficient ) ; standardTimers . weeks = standardTime ( 7 * standardTimers . days . coefficient ) ; } ;", "del_tokens": "function StandardTime ( coefficient ) { standardTimers . nanoseconds = StandardTime ( 1e-9 ) ; standardTimers . microseconds = StandardTime ( 1e-6 ) ; standardTimers . milliseconds = StandardTime ( 1e-3 ) ; standardTimers . seconds = StandardTime ( 1 ) ; standardTimers . minutes = StandardTime ( 60 ) ; standardTimers . hours = StandardTime ( 60 * standardTimers . minutes . coefficient ) ; standardTimers . days = StandardTime ( 24 * standardTimers . hours . coefficient ) ; standardTimers . weeks = StandardTime ( 7 * standardTimers . days . coefficient ) ; }", "commit_type": "add"}
{"commit_tokens": ["Fix", "test", "/", "clientTests", ".", "js", "no", "keyspace", "error"], "add_tokens": "var con = new Connection ( utils . extend ( { host : clientOptions . hosts [ 0 ] , keyspace : null } , clientOptions ) ) ;", "del_tokens": "var con = new Connection ( utils . extend ( { host : clientOptions . hosts [ 0 ] } , clientOptions ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "_clear", "private", "method", "."], "add_tokens": "collection . localStorage . _clear ( ) ; model . localStorage . _clear ( ) ; , error before ( function ( done ) { model . localStorage . _clear ( ) ; // TODO MOCK // TODO combine BEFORE // TODO MOCK & REMOVE LIB SHIM done ( ) ; // TODO RESTORE MOCKS.", "del_tokens": "// Clear localStorage for specific collection. var clearStorage = function ( name ) { var itemRe = new RegExp ( \"^\" + name + \"-\" ) ; // Remove id-tracking item (e.g., \"foo\"). window . localStorage . removeItem ( name ) ; // Match all data items (e.g., \"foo-ID\") and remove. _ . chain ( window . localStorage ) . keys ( ) . filter ( function ( k ) { return itemRe . test ( k ) ; } ) . each ( function ( k ) { window . localStorage . removeItem ( k ) ; } ) ; } ; clearStorage ( \"collectionStore\" ) ; clearStorage ( \"modelStore\" ) ; before ( function ( ) { clearStorage ( \"modelStore\" ) ; } ) ; before ( function ( ) { } ) ; var error ; before ( function ( ) {", "commit_type": "add"}
{"commit_tokens": ["improve", "comments", "around", "debug", "info", "test"], "add_tokens": "it ( 'error should contain debug info in debug mode' , function ( done ) { // err should have format like: // time: 0 | opened css // time: 2 | parsed ast (without errors) done ( new Error ( 'did not throw any error, which was expected' ) )", "del_tokens": "it ( 'error should contain debug in debug mode' , function ( done ) { done ( new Error ( 'did not have expected error' ) )", "commit_type": "improve"}
{"commit_tokens": ["added", "example", "with", "start", "/", "total", "value", "of", "0", "/", "0"], "add_tokens": "Example4 ( function ( ) { console . log ( '\\nDemo finished!' ) ; } ) ; } function Example4 ( onComplete ) { // EXAMPLE 1 --------------------------------------------- console . log ( '\\nExample 4 - Start ZERO' ) ; // create new progress bar using default values var b1 = new _progress . Bar ( ) ; b1 . start ( 0 , 0 ) ; setTimeout ( function ( ) { b1 . stop ( ) ; // run complete callback onComplete . apply ( this ) ; } , 1000 ) ; }", "del_tokens": "console . log ( '\\nDemo finished!' ) ; }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "bugs", "if", "options", "deps", "is", "missing", "improved", "html", "file", "handling"], "add_tokens": "return gulp . src ( options . files . html ) options . files . html , } ;", "del_tokens": "return gulp . src ( 'app/index.html' ) 'app/index.html' , } ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "check", "for", "url", "threshold", "config", "when", "determining", "pass", "/", "fail"], "add_tokens": "const withinThreshold = config . threshold ? results . issues . length <= config . threshold : false ; if ( results . issues . length && ! withinThreshold ) { if ( withinThreshold ) { message += chalk . green ( ` ${ config . threshold } ` ) ; }", "del_tokens": "if ( results . issues . length ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "method", "option", "for", "coap", "in", "nodes"], "add_tokens": "if ( this . _inputNodes [ i ] . options . url == req . url && this . _inputNodes [ i ] . options . method == req . method ) { this . options . method = n . method ;", "del_tokens": "if ( this . _inputNodes [ i ] . options . url == req . url ) {", "commit_type": "add"}
{"commit_tokens": ["move", "peer", "caching", "into", "gridcontrol", "worker", "+", "wait", "that", "local", "node", "is", "ready", "to", "re", "route", "task", "actions", "+", "better", "error", "handling", "on", "task_wrapper", "+", "synchronize", ":", "false", "for", "every", "peers", "on", "new", "initialization", "+", "doc", "+", "tests"], "add_tokens": "try { var msg = new Message ( buf ) ; } catch ( e ) { console . error ( 'Weird data received:' ) ; console . error ( buf . toString ( ) ) ; console . error ( '[Skipping]' ) ; return false ; }", "del_tokens": "var msg = new Message ( buf ) ;", "commit_type": "move"}
{"commit_tokens": ["updated", "to", "fix", "user", "register"], "add_tokens": "} , // // After register one create activity // afterCreate: function(record, next) { // sails.log.warn('afterCreate', record); // // emit one event to plug others we.js features // sails.emit('we:model:mention:afterCreate', record); // next(); // } Mention . create ( query ) . exec ( function ( err , mentions ) { if ( err ) return cb ( err ) ; mentions . forEach ( function ( mention ) { sails . emit ( 'we:model:mention:afterCreate' , mention ) ; } ) } ) ;", "del_tokens": "} Mention . create ( query ) . exec ( cb ) ;", "commit_type": "update"}
{"commit_tokens": ["made", "license", "null", "by", "default"], "add_tokens": "( resource . status . pub_date || 'NULL' ) + '\", \"' + ( resource . status . license || 'NULL' ) + '\", \"' + resource . status . version + '\", license=\"' + ( resource . status . license || 'NULL' ) + '\", version=\"' + resource . status . version +", "del_tokens": "( resource . status . pub_date || 'NULL' ) + '\", \"' + resource . status . license + '\", \"' + resource . status . version + '\", license=\"' + resource . status . license + '\", version=\"' + resource . status . version +", "commit_type": "make"}
{"commit_tokens": ["Added", "support", "for", "native", "Node", "ES6", "modules"], "add_tokens": "import copy from 'rollup-plugin-copy' external : [ 'glob' , 'path' , 'util' , 'camel-case' , './load-module-native.js' ] , plugins : [ // Copy the native module loader copy ( { targets : [ { src : 'src/load-module-native.js' , dest : 'lib' } ] } ) , typescript ( tsOpts ) ] , external : [ 'glob' , 'path' , 'util' , './load-module-native.js' ] , 'loadModulesNative,' : 'loadModulesNative: () => { throw new Error(\"loadModulesNative is not supported in the browser.\") },' ,", "del_tokens": "external : [ 'glob' , 'path' , 'util' , 'camel-case' ] , plugins : [ typescript ( tsOpts ) ] , external : [ 'glob' , 'path' , 'util' ] ,", "commit_type": "add"}
{"commit_tokens": ["Add", "more", "options", "for", "passing", "actions", "to", "middleware"], "add_tokens": "actions , types , ... options } = lpApi // Alias 'actions' with 'types' for backwards compatibility const actionTypes = actions || types || [ ] const [ requestFallback , successFallback , failureFallback ] = actionTypes const { url , requestAction = requestFallback , successAction = successFallback , failureAction = failureFallback , } = options validateOptions ( { url , actionTypes : [ requestAction , successAction , failureAction ] } ) if ( ! actionTypes . length ) throw 'Must provide at least one action definition. Use \\'api\\' module for requests with no associated actions.'", "del_tokens": "actions , types , url , } = lpApi // Alias 'actions' with 'types' for backwards compatibility const actionTypes = actions || types validateOptions ( { url , actionTypes } ) const [ requestAction , successAction , failureAction ] = actionTypes if ( ! actionTypes || ! Array . isArray ( actionTypes ) ) throw 'Must provide an array of actions. Use \\'api\\' module for requests with no associated actions.'", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "async", "iterators"], "add_tokens": "rCbSet = new Set ( ) , rElSet = new Set ( ) ; function resolveEl ( res ) { rElSet . delete ( r ) ; el = res ; thread . next ( ) ; } if ( el === IGNORE || done ) { //#if iterators.async //#endif case 'asyncIterator' : let asyncIterator = '' ; //#if iterators.async if ( p . type === 'asyncIterator' ) { asyncIterator = ws ` while ( isPromise ( el ) ) { if ( ! rElSet . has ( el ) ) { rElSet . add ( el ) ; el . then ( resolveEl , onError ) ; } thread . pause = true ; yield ; } ` ; } //#endif iFn += ` ${ asyncIterator } ` ; //#if iterators.async //#endif iFn += ` ${ asyncIterator } ` ;", "del_tokens": "rCbSet = new Set ( ) ; if ( done ) { iFn += \"el = 'value' in key ? key.value : key;\" ; iFn += 'el = key;' ;", "commit_type": "add"}
{"commit_tokens": ["Use", "private", "-", "cli", "s", "server", "instead", "of", "packager", ".", "js"], "add_tokens": "var server = require ( '../private-cli/src/server/server' ) ; // var runPackager_DEPRECATED = require('./run-packager.js'); server ( args , config ) . done ( ) ; // runPackager_DEPRECATED();", "del_tokens": "var runPackager = require ( './run-packager.js' ) ; runPackager ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "dumb", "segment", "matching", "bug"], "add_tokens": "while ( positionOffset > segment . distB && segmentIndex < nbSegments - 1 ) {", "del_tokens": "while ( positionOffset > segment . distA && segmentIndex < nbSegments - 1 ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "a", "bug", "with", "IE<10"], "add_tokens": "Version : 0.4 .1 if ( win . ArrayBuffer && ( data instanceof ArrayBuffer || data instanceof Blob || data instanceof Document || data instanceof FormData ) ) {", "del_tokens": "Version : 0.4 .0 if ( data instanceof ArrayBuffer || data instanceof Blob || data instanceof Document || data instanceof FormData ) {", "commit_type": "fix"}
{"commit_tokens": ["Update", "partial", "lenses", "to", "version", "3", ".", "x"], "add_tokens": "import P , * as L_ from \"partial.lenses\" export const L = Object . assign ( P , L_ )", "del_tokens": "import L_ from \"partial.lenses\" export const L = L_", "commit_type": "update"}
{"commit_tokens": ["Add", "still", "broken", "ssl", "/", "tls", "stuff"], "add_tokens": "const isServer = ! ! options . stream const p = new protocol ( stream , { isServer } , zeronet )", "del_tokens": "const p = new protocol ( stream )", "commit_type": "add"}
{"commit_tokens": ["use", "promise", "-", "polyfill", "so", "it", "still", "works", "in", "older", "versions", "of", "node"], "add_tokens": "// Some css-modules-loader-code dependencies use Promise so we'll provide it for older node versions if ( ! global . Promise ) { global . Promise = require ( 'promise-polyfill' ) }", "del_tokens": "", "commit_type": "use"}
{"commit_tokens": ["fixed", "typo", "in", "require", "clause", "for", "case", "sensitive", "filesystems"], "add_tokens": "unrar = require ( \"../lib/Unrar\" ) ,", "del_tokens": "unrar = require ( \"../lib/unrar\" ) ,", "commit_type": "fix"}
{"commit_tokens": ["Removed", "COMPILATION_COUNTER", "and", "added", "check", "for", "info", ".", "assetsManifest"], "add_tokens": "if ( asset . info . assetsManifest ) { continue ; } this . emitAssetsManifest ( compilation ) ;", "del_tokens": "const COMPILATION_COUNTER = Symbol ( 'compilationCounter' ) ; this [ COMPILATION_COUNTER ] = 0 ; if ( -- this [ COMPILATION_COUNTER ] === 0 ) { this . emitAssetsManifest ( compilation ) ; } ++ this [ COMPILATION_COUNTER ] ;", "commit_type": "remove"}
{"commit_tokens": ["Use", "assert", ".", "notStrictEqual", "()", "correctly", "."], "add_tokens": "assert . notStrictEqual ( val , EXPECTED ) ;", "del_tokens": "assert . notStrictEqual ( val !== EXPECTED ) ;", "commit_type": "use"}
{"commit_tokens": ["made", "http", "method", "for", "the", "products", "API", "configureable", "and", "put", "saved", "some", "demo", "data", "to", "hack", "offline"], "add_tokens": "return $http ( { method : cc . Config . apiHttpMethod , url : cc . Config . apiUrl + '&callback=JSON_CALLBACK' } ) . then ( function ( data ) { //FixMe we are effectively creating a memory leak here by caching all //seen products forever. This needs to be more sophisticated products [ categoryUrlId ] = data . data . products ; return data . data . products ; } ) ; return $http ( { method : 'get' , url : 'data/dasgibtesnureinmal/categories.json' } ) . then ( function ( data ) { self . categories = data . data ; augmentCategories ( self . categories ) ; currentCategory = self . categories ; return data . data ; } ) ;", "del_tokens": "return $http . jsonp ( cc . Config . apiUrl + '&callback=JSON_CALLBACK' ) . then ( function ( data ) { //FixMe we are effectively creating a memory leak here by caching all //seen products forever. This needs to be more sophisticated products [ categoryUrlId ] = data . data . products ; return data . data . products ; } ) ; return $http . get ( 'data/dasgibtesnureinmal/categories.json' ) . then ( function ( data ) { self . categories = data . data ; augmentCategories ( self . categories ) ; currentCategory = self . categories ; return data . data ; } ) ;", "commit_type": "make"}
{"commit_tokens": ["remove", "undefined", "check", "from", "Clay", ".", "prepareSettingsForAppMessage", "because", "it", "is", "impossible"], "add_tokens": "result [ messageKey + index ] = setting ;", "del_tokens": "if ( typeof setting !== 'undefined' ) { result [ messageKey + index ] = setting ; }", "commit_type": "remove"}
{"commit_tokens": ["Add", "the", "alchemy", ".", "getArgument", "function", "which", "will", "retrieve", "an", "argument", "from", "the", "callchain"], "add_tokens": "var renderCallback = function renderCallback ( viewNames , viewVars ) {", "del_tokens": "renderCallback = function ( viewNames , viewVars ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "or", "and", "and", "function", "operators"], "add_tokens": "__export ( require ( \"./or\" ) ) ; __export ( require ( \"./and\" ) ) ; function unit ( value ) { return value ; }", "del_tokens": "function unit ( value ) { return value ; }", "commit_type": "add"}
{"commit_tokens": ["removing", "long", ".", "js", "call", "."], "add_tokens": "return util . format ( 'A list of long values representing the ids for the' , cSharpName ) ; return util . format ( 'A long value representing the id for the' , cSharpName ) ;", "del_tokens": "return util . format ( 'A list of long values representing the ids for the' , cSharpName , 'see [Long.js]{@link https://www.npmjs.com/package/long}' ) ; return util . format ( 'A long value representing the id for the' , cSharpName , 'see [Long.js]{@link https://www.npmjs.com/package/long}' ) ;", "commit_type": "remove"}
{"commit_tokens": ["removed", "tools", "updated", "grunt", "configuration", "added", "soajs", ".", "mongodb", ".", "data", "in", "devDependencies", "updated", "tests", "to", "use", "soajs", ".", "mongodb", ".", "data", "bumped", "version"], "add_tokens": "ignores : [ 'test/coverage/**/*.js' ] grunt . registerTask ( \"coverage\" , [ 'clean' , 'env:coverage' , 'instrument' , 'mochaTest:unit' , 'mochaTest:integration' , 'storeCoverage' , 'makeReport' , 'coveralls' ] ) ;", "del_tokens": "ignores : [ 'tools/data/**/*.js' , 'test/coverage/**/*.js' ] grunt . registerTask ( \"coverage\" , [ 'clean' , 'env:coverage' , 'instrument' , 'mochaTest:integration' , 'storeCoverage' , 'makeReport' , 'coveralls' ] ) ;", "commit_type": "remove"}
{"commit_tokens": ["Changed", "to", "not", "reassign", "imported", "identifier"], "add_tokens": "import makeDebug from 'debug' const debug = makeDebug ( 'immpatch' )", "del_tokens": "import debug from 'debug' debug = debug ( 'immpatch' )", "commit_type": "change"}
{"commit_tokens": ["Added", "null", "default", "value", "handling"], "add_tokens": "if ( \"undefined\" !== baseType && null !== baseMember // Special case as null is common && newType !== baseType ) {", "del_tokens": "if ( \"undefined\" !== baseType && newType !== baseType ) {", "commit_type": "add"}
{"commit_tokens": ["Updated", "deps", "and", "switched", "to", "lab"], "add_tokens": "var _ = require ( 'lodash' ) ; list : function ( args , done ) { case \"\\b\" : case \"\\t\" : return \"\\\\\" + char ;", "del_tokens": "var _ = require ( 'underscore' ) ; //var eyes = require('eyes'); list : function ( args , done ) { case \"\\b\" : case \"\\t\" : return \"\\\\\" + char ;", "commit_type": "update"}
{"commit_tokens": ["move", "some", "geo", "functions", "into", "their", "own", "file"], "add_tokens": "center = Geo . latLngToMeters ( Point ( center . lng , center . lat ) ) ;", "del_tokens": "center = latLngToMeters ( Point ( center . lng , center . lat ) ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "ability", "to", "expose", "app", "and", "request", "locals", "as", "private", "variables"], "add_tokens": "var data = locals . __hbsLocals ; delete locals . __hbsLocals ; var res = template ( locals , { data : data } ) ; Instance . prototype . localsAsTemplateData = function ( app ) { app . render = ( function ( render ) { return function ( view , options , callback ) { if ( typeof options === \"function\" ) { callback = options ; options = { } ; } // Mix response.locals (options._locals) with app.locals (this.locals) options . _locals = options . _locals || { } ; for ( var key in this . locals ) { options . _locals [ key ] = this . locals [ key ] ; } // Store the data again, so that we can differentiate this data from // the data passed to response.data() when we're inside the view options . _locals . __hbsLocals = options . _locals ; return render . call ( this , view , options , callback ) ; } ; } ) ( app . render ) ; } ;", "del_tokens": "var res = template ( locals ) ;", "commit_type": "add"}
{"commit_tokens": ["implement", "server", "-", "side", "fields", "object"], "add_tokens": "CollectionInstance . fields = { } ; collection . labelField = path ; field . collection = collection ; field . path = path ; collection . fields [ path ] = field ; const fieldName = lastDot > - 1 ? path . substring ( lastDot + 1 ) : path ; denormal [ path ] = fieldDef . denormal ; return compiler . field ( path ? path + '.' + name : name , field ) ;", "del_tokens": "collection . labelField = path . substring ( 1 ) ; field . path = path . substring ( 1 ) ; const fieldName = path . substring ( lastDot + 1 ) ; denormal [ path . substring ( 1 ) ] = fieldDef . denormal ; return compiler . field ( path + '.' + name , field ) ;", "commit_type": "implement"}
{"commit_tokens": ["Make", "the", "configuration", "from", "HtmlWebpackplugin", "(", "options", ".", "favicons", ")", "work"], "add_tokens": "callback ( null , htmlPluginData ) ;", "del_tokens": "callback ( null , htmlPluginData ) ;", "commit_type": "make"}
{"commit_tokens": ["Move", "receiver", "methods", "into", "consumer"], "add_tokens": "Receiver : require ( './lib/consumer.js' ) ,", "del_tokens": "Receiver : require ( './lib/receiver.js' ) ,", "commit_type": "move"}
{"commit_tokens": ["fix", "unwrap", "to", "not", "fail", "when", "using", "_", ".", "prototype", ".", "commit", "()"], "add_tokens": "( ( lodashUtil . isChainable ( node ) && ! lodashUtil . isCallToMethod ( node , 'commit' ) ) || ( lodashUtil . isExplicitMethodChaining ( node ) && ! lodashUtil . isChainBreaker ( node ) ) ) ) {", "del_tokens": "( lodashUtil . isChainable ( node ) || ( lodashUtil . isExplicitMethodChaining ( node ) && ! lodashUtil . isChainBreaker ( node ) ) ) ) { module . exports . schema = [ // JSON Schema for rule options goes here ] ;", "commit_type": "fix"}
{"commit_tokens": ["added", "ability", "to", "skip", "already", "downloaded", "containers"], "add_tokens": "const catalogUrl = 'https://api.unfoldingword.org/ts/txt/2/catalog.json' ; const indexPath = './out/library.sqlite' ; const resourceDir = './out/res' ; if ( err . message === 'Resource container already exists' ) { readline . cursorTo ( process . stdout , 0 ) ; readline . clearLine ( process . stdout , 0 ) ; console . log ( 'Skipping' , data ) ; } else { readline . cursorTo ( process . stdout , 0 ) ; readline . clearLine ( process . stdout , 0 ) ; console . log ( err , 'while downloading' , data ) ; }", "del_tokens": "const catalogUrl = 'https://api.unfoldingword.org/ts/txt/2/catalog.json' , indexPath = './out/library.sqlite' , resourceDir = './out/res' ; const indexPath = './out/library.sqlite' , resourceDir = './out/res' ; rimraf . sync ( resourceDir ) ; console . log ( err , 'while downloading' , data ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "scrolling", "issue", "for", "iOS", "Devices"], "add_tokens": "// Create the wrapper & iframe modal var iOS = ( navigator . userAgent . match ( / (iPad|iPhone|iPod) / g ) ? true : false ) ; var attributes = [ 'position: fixed' , 'top: 0' , 'left: 0' , 'width: 100%' , 'height: 100%' , 'z-index: 10000000' , 'background-color: white' , 'border: 0' ] ; //only add scrolling fix for ios devices if ( iOS ) { attributes . push ( 'overflow-y: scroll' ) ; attributes . push ( '-webkit-overflow-scrolling: touch' ) ; } //create wrapper for iOS scroll fix var wrapper = document . createElement ( \"div\" ) ; wrapper . setAttribute ( 'style' , attributes . join ( ';' ) ) ; 'width: 100%' , 'height: 100%' , 'position:absolute' , 'border: 0' wrapper . appendChild ( iframe ) ; body . appendChild ( wrapper ) ; // On back-button remove the wrapper wrapper . removeChild ( iframe ) ; body . removeChild ( wrapper ) ; } ) ( ) ;", "del_tokens": "// Create the iframe modal 'position: fixed' , 'top: 0' , 'left: 0' , 'width: 100%' , 'height: 100%' , 'z-index: 3' , 'background-color: white' , 'border: 0' body . appendChild ( iframe ) ; // On back-button remove the iframe body . removeChild ( iframe ) ; } ) ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "jasmine", "-", "node", "failure", "case", "so", "that", "it", "properly", "aborts", "."], "add_tokens": "function abortOnError ( exitCode ) { if ( exitCode ) { grunt . fail . fatal ( \"jasmine-node:test-on-server exited with exit code: \" + exitCode ) ; . on ( \"exit\" , abortOnError ) ;", "del_tokens": "function afterJasmineNodeCompletes ( exitCode ) { if ( exitCode !== 0 ) { grunt . fail ( ) ; return ; . on ( \"exit\" , afterJasmineNodeCompletes ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "sspi", "plugin", "and", "exported", "it"], "add_tokens": ", SSPI = require ( '../auth/sspi' ) ; this . addAuthProvider ( 'gssapi' , new GSSAPI ( ) ) ; this . addAuthProvider ( 'sspi' , new SSPI ( ) ) ;", "del_tokens": "this . addAuthProvider ( 'gssapi' , new GSSAPI ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "query", ".", "set", "not", "overwriting", "values", "on", "replacement", "."], "add_tokens": "var column = clause ; // if we've previously created a clause for this column, overwrite it. var key = this . _attributes . setKeys [ column ] ; if ( isDefined ( key ) ) { this . _attributes . set [ key ] = clause ; } else { this . _attributes . setKeys [ column ] = this . _attributes . set . length ; this . _attributes . set . push ( clause ) ; } this . _attributes . set . push ( clause ) ; return this ; } ;", "del_tokens": "this . _attributes . set . push ( clause ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "setting", "dbpath", "for", "standalone"], "add_tokens": "var tasks = [ ] ; if ( this . get ( 'dbpath' ) === undefined ) { tasks . push ( function ( cb ) { options . dbpath ( self . get ( 'name' ) , function ( err , p ) { if ( err ) return cb ( err ) ; self . set ( 'dbpath' , p ) ; debug ( 'resolved dbpath' ) ; cb ( ) ; } ) ; }", "del_tokens": "var tasks = [ function ( cb ) { options . dbpath ( self . get ( 'name' ) , function ( err , p ) { if ( err ) return cb ( err ) ; self . set ( 'dbpath' , p ) ; debug ( 'resolved dbpath' ) ; cb ( ) ; } ] ;", "commit_type": "allow"}
{"commit_tokens": ["fixed", "error", "on", "missing", "modal"], "add_tokens": "if ( modal ) { for ( var y = 0 ; y < modal . classList . length ; y ++ ) { if ( modal . classList [ y ] . search ( 'ts-modal-effect-' ) >= 0 ) { hasModalEffect = true ; }", "del_tokens": "for ( var y = 0 ; y < modal . classList . length ; y ++ ) { if ( modal . classList [ y ] . search ( 'ts-modal-effect-' ) >= 0 ) { hasModalEffect = true ;", "commit_type": "fix"}
{"commit_tokens": ["add", "onReducer", "hook", "to", "support", "reducer", "enhancer"], "add_tokens": "const app = dva ( { onReducer : undoable , } ) ; reducers : { } , const App = connect ( state => ( { count : state . present . count ,", "del_tokens": "const app = dva ( ) ; reducers : [ { } , undoable ] , const App = connect ( ( { count } ) => ( { count : count . present ,", "commit_type": "add"}
{"commit_tokens": ["fixing", "off", "by", "one", "!", "error"], "add_tokens": "return process . env . DEBUG ;", "del_tokens": "return ! process . env . DEBUG ;", "commit_type": "fix"}
{"commit_tokens": ["moving", "to", "minimist", "for", "cli", "parsing"], "add_tokens": ", parseArgv = require ( 'minimist' ) , argv = parseArgv ( process . argv ) , commands = argv . _ . slice ( 2 ) , options console . log ( argv ) ; // if (astroCmds.length === 0 || astroCmds[0] === 'help' || astroCmds[0] === '-h') { // help(); // } else { // // parse astroCmds // // process the provided astro commands // astroCmds.forEach(handleAstroCommand); // }", "del_tokens": ", argv = process . argv , astroCmds = argv . splice ( 2 ) if ( astroCmds . length === 0 || astroCmds [ 0 ] === 'help' || astroCmds [ 0 ] === '-h' ) { help ( ) ; } else { // parse astroCmds // process the provided astro commands astroCmds . forEach ( handleAstroCommand ) ; }", "commit_type": "move"}
{"commit_tokens": ["Changing", "the", "sequence", "of", "defered", "result", "to", "make", "Modules", "tab", "more", "responsive", "when", "user", "came", "back", "after", "it", "has", "been", "loaded"], "add_tokens": "$scope . obj_response = DeferredObject . get ( \"This is defered response\" , 2000 ) ; $scope . str_response = DeferredString . get ( \"Show case ngWrite with promise\" , 1000 ) ;", "del_tokens": "$scope . obj_response = DeferredObject . get ( \"This is defered response\" , 4000 ) ; $scope . str_response = DeferredString . get ( \"Show case ngWrite with promise\" , 3000 ) ;", "commit_type": "change"}
{"commit_tokens": ["Added", "partial", "serialization", "support", "via", "exposed", "Serializable", ".", "serialize", "enum"], "add_tokens": "exports . _serializeTypeEnum = { Never : Symbol ( '@Serializable:Serialize:Never' ) , DeserializeOnly : Symbol ( '@Serializable:Serialize:DeserializeOnly' ) , SerializeOnly : Symbol ( '@Serializable:Serialize:SerializeOnly' ) , Always : Symbol ( '@Serializable:Serialize:Always' ) } ; if ( [ true , exports . _serializeTypeEnum . Always , exports . _serializeTypeEnum . SerializeOnly ] . indexOf ( metadata . serialize ) !== - 1 ) { if ( [ true , exports . _serializeTypeEnum . Always , exports . _serializeTypeEnum . DeserializeOnly ] . indexOf ( metadata . serialize ) !== - 1 ) {", "del_tokens": "if ( metadata . serialize ) { if ( metadata . serialize ) {", "commit_type": "add"}
{"commit_tokens": ["Adding", "getDatePattern", "globalization", "wrapping", "+", "some", "missing", "commas"], "add_tokens": "} , } , } , getDatePattern : function ( options ) { var q = $q . defer ( ) ; navigator . globalization . getDatePattern ( function ( result ) { q . resolve ( result ) ; } , function ( err ) { q . reject ( err ) ; } , options ) ; return q . promise ;", "del_tokens": "} } // getDatePattern", "commit_type": "add"}
{"commit_tokens": ["Updated", "contributor", "list", "with", "guys", "from", "recent", "PRs", "automated", "the", "bower", "install", "step", "as", "a", "post", "-", "install", "script", "."], "add_tokens": "} ) ;", "del_tokens": "} ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "crlf", "match", "in", "compileRegularExpression", "to", "add", "compatibility", "with", "win32", "/", "git", "core", ".", "autocrlf", "=", "true"], "add_tokens": "source = require ( \"fs\" ) . readFileSync ( __filename , \"utf8\" ) . split ( / \\r?\\n / ) ;", "del_tokens": "source = require ( \"fs\" ) . readFileSync ( __filename , \"utf8\" ) . split ( / \\n / ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "mag", "from", "mag", "-", "control", "UMD", "deps", "."], "add_tokens": "define ( [ 'jquery' , 'jquery-bridget' ] , function ( $ ) { return ( root [ name ] = factory ( $ ) ) ;", "del_tokens": "define ( [ 'jquery' , 'jquery-bridget' ] , function ( mag , $ ) { return ( root [ name ] = factory ( mag , $ ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "bug", "where", "functions", "with", "a", "length", ">", "0", "were", "treated", "as", "indexable", "."], "add_tokens": "function getSimpleTestTree ( ) { } function getMixedTestTree ( ) { } var f = function ( x , y ) { } ; var visited = walk . map ( f , walk . preorder , _ . identity ) ; t . deepEquals ( visited , [ f ] , 'function w/ no properties is treated as a leaf' ) ; f . foo = 3 ; visited = walk . map ( f , walk . preorder , _ . identity ) ; t . deepEqual ( visited , [ f , 3 ] , 'own property of function is be visited' ) ; ( function ( x ) { visited = walk . map ( arguments , walk . preorder , _ . identity ) ; } ) ( 'x' , 99 ) ; t . equal ( visited . length , 3 ) ; t . deepEqual ( visited . slice ( 1 ) , [ 'x' , 99 ] , 'arguments is treated like an array' ) ;", "del_tokens": "var getSimpleTestTree = function ( ) { } ; var getMixedTestTree = function ( ) { } ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "manifest", "to", "be", "transformed", "based", "on", "app", "or", "test", "index"], "add_tokens": "var appTransformedManifest = this . transformer ( manifest , 'app' ) ; var index = this . replacer ( indexFile , appTransformedManifest ) ; var testsTransformedManifest = this . transformer ( manifest , 'test' ) ; var testIndex = this . replacer ( testIndexFile , testsTransformedManifest ) ;", "del_tokens": "var transformedManifest = this . transformer ( manifest ) ; var index = this . replacer ( indexFile , transformedManifest ) ; var testIndex = this . replacer ( testIndexFile , transformedManifest ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "issue", "with", "connectionTimeout", "and", "operationTimeout", "passing", "through"], "add_tokens": "this . client . connectionTimeout = connectOptions . connectionTimeout || 10000 ; this . client . operationTimeout = connectOptions . operationTimeout || 10000 ;", "del_tokens": "this . client . connectionTimeout = 10000 ;", "commit_type": "fix"}
{"commit_tokens": ["added", "react", "support", "via", "enzyme"], "add_tokens": "bin : coverageBin , args : coverageArgs } , { } , { bin : rmBin , args : removeCoverageArgs", "del_tokens": "// bin: coverageBin, // args: coverageArgs // }, { // }, { // bin: rmBin, // args: removeCoverageArgs", "commit_type": "add"}
{"commit_tokens": ["Make", "displayNameHandler", "take", "displayName", "getter", "into", "account"], "add_tokens": "import { traverseShallow } from '../utils/traverse' ; const { types : { namedTypes : types } } = recast ; let displayNamePath = getMemberValuePath ( path , 'displayName' ) ; // If display name is defined as a getter we get a function expression as // value. In that case we try to determine the value from the return // statement. if ( types . FunctionExpression . check ( displayNamePath . node ) ) { traverseShallow ( displayNamePath . get ( 'body' ) , { visitReturnStatement : path => { displayNamePath = resolveToValue ( path . get ( 'argument' ) ) ; return false ; } , } ) ; }", "del_tokens": "var { types : { namedTypes : types } } = recast ; var displayNamePath = getMemberValuePath ( path , 'displayName' ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "example", "of", "use", "for"], "add_tokens": "$static : { $const : { CONSTANT : \"frozen value\" , Namespace : { FIRST_OPTION : \"first option\" , SECOND_OPTION : \"second option\" } } ,", "del_tokens": "$statics : {", "commit_type": "add"}
{"commit_tokens": ["Remove", "unused", "import", "and", "tweak", "sessionsConverter", "export"], "add_tokens": "var sessionsConverter = require ( './sessionsConverter.js' ) ( ) ;", "del_tokens": "var sessionsConverter = require ( './sessionsConverter.js' ) ;", "commit_type": "remove"}
{"commit_tokens": ["update", "demo", "code", "and", "gulp", "."], "add_tokens": "mode : \"checkbox\" , selected : [ ] , //default selection on table // page: 3, // sizePerPage: 5, // sizePerPageList: [5,10,15,20], // paginationSize: 6,", "del_tokens": "mode : \"radio\" , selected : [ ] , //default select on table", "commit_type": "update"}
{"commit_tokens": ["Implemented", "activate", "/", "deactivate", "breakpoints", "."], "add_tokens": "var convert = require ( './convert.js' ) , async = require ( 'async' ) ; setBreakpointsActive : function ( params , done ) { this . _session . sendDebugRequest ( 'listbreakpoints' , { } , function ( error , response ) { if ( error ) { done ( error ) ; return ; } function setBreakpointState ( bp , next ) { var req = { breakpoint : bp . number , enabled : params . active } ; this . _session . sendDebugRequest ( 'changebreakpoint' , req , next ) ; } async . eachSeries ( response . breakpoints , setBreakpointState . bind ( this ) , done ) ; } . bind ( this ) ) ; } , exports . DebuggerAgent = DebuggerAgent ;", "del_tokens": "var convert = require ( './convert.js' ) ; exports . DebuggerAgent = DebuggerAgent ;", "commit_type": "implement"}
{"commit_tokens": ["use", "node_modules", "/", "homestar", "for", "commands"], "add_tokens": "if ( 0 ) { console . log ( { consumerKey : settings . d . keys . homestar . key , consumerSecret : settings . d . keys . homestar . secret , callbackURL : client_url + \"/auth/homestar/callback\" , requestTokenURL : server_url + '/oauth/request_token' , accessTokenURL : server_url + '/oauth/access_token' , userAuthorizationURL : server_url + '/oauth/authenticate' , userProfileURL : server_url + '/api/1.0/profile' } ) ; } if ( wsd . all ) {", "del_tokens": "if ( wsd . all || 1 ) {", "commit_type": "use"}
{"commit_tokens": ["change", "redbird", "to", "Redbird", "in", "text"], "add_tokens": "// Create Redbird Instance and Log", "del_tokens": "// Create RedBird Instance and Log", "commit_type": "change"}
{"commit_tokens": ["Allow", "the", "server", "to", "send", "messages", "to", "the", "runner", "."], "add_tokens": "type : 'clearMocks' , start : Date . now ( )", "del_tokens": "type : 'clearMocks'", "commit_type": "allow"}
{"commit_tokens": ["Adding", "less", "task", "for", "dist", "build"], "add_tokens": "var less = require ( 'gulp-less' ) ; gulp . task ( 'build:dist:scripts' , [ 'clean:dist' ] , function ( ) { var buildTasks = [ 'build:dist:scripts' ] ; if ( config . component . less ) { gulp . task ( 'build:dist:css' , [ 'clean:dist' ] , function ( ) { return gulp . src ( config . component . less ) . pipe ( less ( ) ) . pipe ( gulp . dest ( 'dist' ) ) ; } ) ; buildTasks . push ( 'build:dist:css' ) ; } gulp . task ( 'build:dist' , buildTasks ) ;", "del_tokens": "gulp . task ( 'build:dist' , [ 'clean:dist' ] , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["ADD", ":", "Functions", "for", "extracting", "channel", "settings", "from", "register", "query"], "add_tokens": "const _ = require ( 'lodash' ) ; let dataBuf = openBCIUtilities . sampleBLERaw ( ) ; describe ( '#syncChannelSettingsWithRawData' , function ( ) { it ( 'should set the channel settings from the data buffer' , function ( ) { let channelSettings = k . channelSettingsArrayInit ( k . OBCINumberOfChannelsCyton ) ; _ . forEach ( channelSettings , ( channelSetting ) => { channelSetting . channelNumber = 50 ; channelSetting . powerDown = true ; channelSetting . gain = 59 ; channelSetting . inputType = k . OBCIStringADCBiasDrn ; channelSetting . bias = false ; channelSetting . srb2 = false ; channelSetting . srb1 = true ; } ) ; let data = Buffer . from ( openBCIUtilities . sampleRegisterQueryCyton ( ) + openBCIUtilities . sampleRegisterQueryAccelerometer ( ) ) ; openBCIUtilities . syncChannelSettingsWithRawData ( { data , channelSettings } ) ; } ) ; } ) ;", "del_tokens": "let dataBuf = Buffer . alloc ( k . OBCIPacketSizeBLERaw ) ; dataBuf [ 2 ] = 1 ; dataBuf [ 5 ] = 2 ; dataBuf [ 8 ] = 3 ; dataBuf [ 11 ] = 4 ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "highlighting", "of", "connections", "in", "the", "third", "level", "view"], "add_tokens": "} else if ( ( this . intersectedObject instanceof this . NodeClass && ! this . nodeName ) || ( this . intersectedObject instanceof this . ConnectionClass ) ) { // If clicked on a node and there is no focused node, highlight. // Or if clicked on a connection, highlight. this . highlightObject ( this . intersectedObject ) ;", "del_tokens": "} else if ( this . intersectedObject instanceof this . NodeClass || this . intersectedObject instanceof this . ConnectionClass ) { // If we are not currently focused on a node, highlight the clicked object if ( ! this . nodeName ) { this . highlightObject ( this . intersectedObject ) ; }", "commit_type": "allow"}
{"commit_tokens": ["Add", "additional", "checks", "for", "decryptSync", "()"], "add_tokens": "it ( 'should decrypt a file using the default algorithm' , function ( done ) { fs . readFile ( dec . name , 'utf8' , function ( err , data ) { should . not . exist ( err ) ; expect ( data ) . to . equal ( 'I am the night!' ) ; done ( ) ; } ) ; it ( 'should decrypt a file using a custom algorithm' , function ( done ) { fs . readFile ( dec . name , 'utf8' , function ( err , data ) { should . not . exist ( err ) ; expect ( data ) . to . equal ( 'I am the night!' ) ; done ( ) ; } ) ;", "del_tokens": "it ( 'should decrypt a file using the default algorithm' , function ( ) { it ( 'should decrypt a file using a custom algorithm' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["move", "io", "creation", "to", "make", "-", "io", ".", "js"], "add_tokens": ", makeIO = require ( './make-io.js' ) var io = makeIO ( process , stdout , stderr )", "del_tokens": "var io = { isTTY : process . stdout . isTTY , error : outputError , log : outputLog } function outputLog ( what ) { stdout . write ( what ) stdout . write ( '\\n' ) } function outputError ( what ) { stderr . write ( what ) stderr . write ( '\\n' ) }", "commit_type": "move"}
{"commit_tokens": ["moved", "default", "hostname", "localhost", "from", "the", "namespace", "mapping", "function", "to", "the", "configuration"], "add_tokens": "hostname : config . hostname , hostname : 'localhost' ,", "del_tokens": "hostname : config . hostname || 'localhost' ,", "commit_type": "move"}
{"commit_tokens": ["use", "registry", ".", "npmjs", ".", "org", "directly", "for", "repo", "packages"], "add_tokens": "Repo . prototype . package = function ( version ) { version = version || 'latest' ; if ( ! self . has ( 'pkg-' + version ) ) { var registry = new self . Registry ( ) ; var results = yield registry . get ( self . name ) ; var pkg = version === 'all' ? results : ( results . versions [ version ] || results . versions [ results [ 'dist-tags' ] [ version ] ] ) ; self . set ( 'pkg-' + version , pkg ) ; return self . get ( 'pkg-' + version ) ;", "del_tokens": "Repo . prototype . package = function ( ) { if ( ! self . has ( 'pkg' ) ) { //https://skimdb.npmjs.com/registry/_design/app/_view/listAll?key=%22assemble%22 var view = new self . View ( 'listAll' ) ; var results = yield view . query ( { key : JSON . stringify ( self . name ) } ) ; self . set ( 'pkg' , results . map ( function ( pkg ) { return pkg . value ; } ) [ 0 ] ) ; return self . get ( 'pkg' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "test", "and", "add", "15", "character"], "add_tokens": "return ( ( connote . length === 14 || connote . length === 15 ) && connote . indexOf ( \"CP\" ) === 0 ) ;", "del_tokens": "return connote . length === 14 && connote . indexOf ( \"CP\" ) === 0 ;", "commit_type": "fix"}
{"commit_tokens": ["Implement", "status", "request", "before", "completing", "the", "find", "()", "operation", "."], "add_tokens": "name : name2 , console . log ( 'ADD: [' + name2 + '] resulted in [' + success + ']' ) ;", "del_tokens": "/ * * / name : name , console . log ( 'ADD: [' + name + '] resulted in [' + success + ']' ) ;", "commit_type": "implement"}
{"commit_tokens": ["Fix", "wrong", "method", "signature", "for", "base", "url"], "add_tokens": "url : config . getBaseUrl ( ) + \"/music/playlist/song/\" + song , url : config . getBaseUrl ( ) + \"/music/playlist/album/\" + album ,", "del_tokens": "url : config . baseURL ( ) + \"/music/playlist/song/\" + song , url : config . baseURL ( ) + \"/music/playlist/album/\" + album ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "one", "more", "method", "for", "future", "proof", "edge", "cases"], "add_tokens": "'getItems' : function ( ) { return this . packedItems ; } , // Return the packed items", "del_tokens": "// Returnthe packed items", "commit_type": "add"}
{"commit_tokens": ["fixes", "reference", "bugs", "and", "prevent", "duplication"], "add_tokens": "return callback ( { } ) ; walker . _parse_js ( content . toString ( ) , function ( err , ast ) { // Removes duplicate items dependencies = dependencies . reduce ( function ( prev , current ) { if ( ! ~ prev . indexOf ( current ) ) { prev . push ( current ) ; } return prev ; } , [ ] ) ; var args = node . arguments ; walker . _throw ( strict , loc_text + 'Method `require` should not contains more than one parameters' ) ; return 'Line ' + loc . line + ': Column ' + loc . column + ': ' ;", "del_tokens": "return callback ( walker . _error ( { } , err ) ) ; walker . _parse_js ( content , function ( err , ast ) { var args = node . callee . arguments ; walker . _throw ( strictoptions . noStrictRequire , loc_text + 'Method `require` should not contains more than one parameters' ) ; return 'Line ' + loc . line + ': Column ' + loc . column ':' ;", "commit_type": "fix"}
{"commit_tokens": ["Moving", "where", "bower_components", "are", "installed", "and", "how", "they", "re", "ignored", "."], "add_tokens": "} ;", "del_tokens": "console . log ( commonCopyPatterns ) ; } ;", "commit_type": "move"}
{"commit_tokens": ["fix", "publish", "-", "demo", "task"], "add_tokens": "grunt . registerTask ( 'publish-docs' , [ 'build-demo' , 'gh-pages' ] ) ;", "del_tokens": "grunt . registerTask ( 'publish-docs' , [ 'demo' , 'gh-pages' ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "merge", "cells", "example", "-", "skip", ".", "in", "evalGet"], "add_tokens": "var fn = 'return obj' + ( path [ 0 ] !== '[' && path [ 0 ] !== '.' ? '.' : '' ) + path var fn = 'obj' + ( path [ 0 ] !== '[' && path [ 0 ] !== '.' ? '.' : '' ) + path + '= val'", "del_tokens": "var fn = 'return obj' + ( path [ 0 ] !== '[' ? '.' : '' ) + path var fn = 'obj' + ( path [ 0 ] !== '[' ? '.' : '' ) + path + '= val'", "commit_type": "fix"}
{"commit_tokens": ["Remove", "console", "and", "use", "proper", "assert"], "add_tokens": "Analysis . create ( testConfig , invalidAnalysis , function ( err ) { assert . ok ( err ) ; assert . equal ( err . message , 'Invalid type for param \"time\", expects \"number\" type, got `\"text is invalid here\"`' ) ;", "del_tokens": "Analysis . create ( testConfig , invalidAnalysis , function ( err , analysis ) { console . log ( err , analysis ) ;", "commit_type": "remove"}
{"commit_tokens": ["Making", "unit", "test", "OS", "agnostic", "."], "add_tokens": "find = mitto . find , path = require ( \"path\" ) ; find ( 'package.json' ) . should . equal ( process . cwd ( ) + path . sep + \"package.json\" ) ; find ( 'package.json' , template ) . should . equal ( process . cwd ( ) + path . sep + \"package.json\" ) ;", "del_tokens": "find = mitto . find ; find ( 'package.json' ) . should . equal ( process . cwd ( ) + \"/package.json\" ) ; find ( 'package.json' , template ) . should . equal ( process . cwd ( ) + \"/package.json\" ) ;", "commit_type": "make"}
{"commit_tokens": ["use", "multiline", "comments", "to", "make", "easier", "to", "comment", "out"], "add_tokens": "debounce : 500 , /* ms */ latest : true , /* take latest only */ /* let's prevent empty requests */ } else { /* empty request, silently reject */", "del_tokens": "debounce : 500 , // ms latest : true , // take latest only // let's prevent empty requests } else { // empty request, silently reject", "commit_type": "use"}
{"commit_tokens": ["Added", "a", "default", "value", "for", "the", "form", "option", "validateOnFormSubmit", "in", "the", "validator", "."], "add_tokens": "* angular - auto - validate - v1 .18 .13 - 2015 - 08 - 21 removeExternalValidationErrorsOnSubmit : true , validateOnFormSubmit : false", "del_tokens": "* angular - auto - validate - v1 .18 .12 - 2015 - 08 - 21 removeExternalValidationErrorsOnSubmit : true", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "for", "failing", "spac", "specification"], "add_tokens": "const editors = [ 'vi' , 'nano' ] ; } }", "del_tokens": "const editors = [ 'vim' , 'nano' ] ; } ; } ;", "commit_type": "add"}
{"commit_tokens": ["Adds", "flag", "to", "indicate", "if", "dependencies", "should", "also", "be", "renamed"], "add_tokens": "return merge ( { normalizeFn : normalizeSystemJs , renameDependencies : true , renameFn : renameSystemJs } , options ) ;", "del_tokens": "return merge ( { normalizeFn : normalizeSystemJs , renameFn : renameSystemJs } , options ) ;", "commit_type": "add"}
{"commit_tokens": ["Create", ".", "missing", "files", "in", "playback"], "add_tokens": "var createMissingFiles = true ; if ( createMissingFiles ) { var requestData = { url : reqUrl , method : options . method , headers : options . headers , body : reqBody . toString ( ) } fs . writeFileSync ( filename + '.missing' , JSON . stringify ( requestData , null , 2 ) ) ; } headers . request = { method : options . method , headers : options . headers }", "del_tokens": "", "commit_type": "create"}
{"commit_tokens": ["Make", "\\", "n", "in", "a", "string", "start", "a", "new", "line"], "add_tokens": "// Replace '/', '(', and ')' with pdf-safe versions // If there are any newlines in text, we assume // the user wanted to print multiple lines, so break the // text up into an array. If the text is already an array, // we assume the user knows what they are doing. if ( typeof text === 'string' && text . match ( / [\\n\\r] / ) ) { text = text . split ( / \\r\\n|\\r|\\n / g ) } if ( typeof text === 'string' ) { } else if ( text instanceof Array ) /* Array */ { // thus, pdfEscape each component separately } else { throw new Error ( 'Type of text must be string or Array. \"' + text + '\" is not recognized.' ) } }", "del_tokens": "if ( typeof text === 'string' ) { } else /* Array */ { // thus, pdfEscape eash component separately } }", "commit_type": "make"}
{"commit_tokens": ["make", ".", "env", "optional", ";", "user", "adds", "it", "to", "run", "tests"], "add_tokens": "console . log ( \"Using externall set env vars if exist.\" )", "del_tokens": "console . log ( \"Process exiting with code 1.\" ) process . exit ( 1 )", "commit_type": "make"}
{"commit_tokens": ["Fix", "font", "-", "family", "metrics"], "add_tokens": "result . uniqueFontFamily . push ( declaration . value . replace ( / (\\!important) / g , '' ) . trim ( ) ) ;", "del_tokens": "var formatedFontNamesStr = declaration . value . replace ( / (\\!important|\"|') / g , '' ) . trim ( ) ; formatedFontNamesStr . split ( ',' ) . forEach ( function ( fontName ) { result . uniqueFontFamily . push ( fontName ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "html", "content", "refresh", "on", "sort"], "add_tokens": "if ( $scope . paginatedRows === true || ( $scope . paginatedRows && $scope . paginatedRows . hasOwnProperty ( 'isEnabled' ) && $scope . paginatedRows . isEnabled === true ) ) {", "del_tokens": "if ( $scope . paginatedRows === true || ( $scope . paginatedRows . hasOwnProperty ( 'isEnabled' ) && $scope . paginatedRows . isEnabled === true ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "growl", "-", "node", "to", "display", "notifications"], "add_tokens": ", growl = require ( 'growl' ) * Displays a desktop notification . growl ( msg , { title : title || 'node.js' , image : __dirname + '/icons/node_' + level + '.png' } )", "del_tokens": "* Displays a desktop notification ( see notify . sh ) spawn ( __dirname + '/notify.sh' , [ title || 'node.js' , msg , __dirname + '/icons/node_' + level + '.png' ] )", "commit_type": "use"}
{"commit_tokens": ["adding", "head", "support", "and", "adding", "getCount", "to", "yaas", "-", "document", ".", "js"], "add_tokens": "this . head = function ( path , params ) { var queryParamString = querystring . stringify ( params ) ; var pathWithParams = path + ( queryParamString . length > 0 ? '?' + queryParamString : '' ) ; return this . sendRequest ( 'HEAD' , pathWithParams , null , { } ) ; } ; responseBody = response . body ? JSON . parse ( response . body ) : null ;", "del_tokens": "responseBody = JSON . parse ( response . body ) ;", "commit_type": "add"}
{"commit_tokens": ["Made", "cc", "indicator", "less", "intrusive"], "add_tokens": "attributeBindings : [ 'cardType:data-card-type' ]", "del_tokens": "attributeBindings : [ 'cardType:data-type' ] , applyTransform : function ( ) { // Reset all. this . $ ( '[data-icon]' ) . css ( { transform : 'none' } ) ; // Then position selected. var type = this . get ( 'cardType' ) ; if ( ! type ) return ; var selectedCard = this . $ ( '[data-icon=\"cc-%@\"]' . fmt ( type ) ) ; var width = this . width || this . $ ( ) . width ( ) ; var translation = width - selectedCard . width ( ) ; translation = translation - selectedCard . position ( ) . left ; translation = 'translateX(%@px)' . fmt ( translation ) ; selectedCard . css ( { transform : translation } ) ; } . observes ( 'cardType' )", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "sending", "custom", "HTTP", "request", "headers", "with", "the", "Icecast", "Client", "."], "add_tokens": "headers . push ( 'Host: ' + parsedUrl . host ) ; headers . push ( 'Icy-MetaData: 1' ) ; stream . get ( parsedUrl . pathname , headers ) ; this . metaint = Number ( res . headers [ 'icy-metaint' ] ) ; * Convenience function to create a new Icecast 'Client' instance . function createClient ( url , headers , retainMetadata ) { if ( headers === true || headers === false ) { retainMetadata = headers ; headers = [ ] ; } else if ( ! Array . isArray ( headers ) ) { headers = [ ] ; } return new Client ( url , headers , retainMetadata ) ;", "del_tokens": "stream . get ( parsedUrl . pathname , { 'Host' : parsedUrl . host , 'Icy-MetaData' : 1 } ) ; this . metaint = res . headers [ 'icy-metaint' ] ; * Convenience function to create a new Client instance . function createClient ( url , retainMetadata ) { return new Client ( url , retainMetadata ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "template", "and", "copy", "scripts"], "add_tokens": "componentsDir = path . join ( __dirname , '../../../components' ) ;", "del_tokens": "componentsDir = './components' ;", "commit_type": "add"}
{"commit_tokens": ["Make", "cache", "-", "busting", "optional", "&&", "document", "it"], "add_tokens": "dest : ( grunt . template . process ( happyplan . assets [ type ] [ data ] . dest , { data : { happyplan : happyplan } } ) + ( happyplan . env == 'dist' && happyplan . cachebuster ? '?' + happyplan . cachebuster : '' ) )", "del_tokens": "dest : ( grunt . template . process ( happyplan . assets [ type ] [ data ] . dest , { data : { happyplan : happyplan } } ) + '?' + happyplan . cachebuster )", "commit_type": "make"}
{"commit_tokens": ["Allow", "using", "mixins", "to", "set", "syncers"], "add_tokens": "Vue . config = BaseVue . config // Not cloned", "del_tokens": "export function addVueInstance ( t ) { t . context . instance = new BaseVue ( { data : function ( ) { return { // To avoid vue-warn for setting paths on vm variables : { } } } } ) }", "commit_type": "allow"}
{"commit_tokens": ["Move", "redirect", "inside", "main", "function"], "add_tokens": "/ ** * Redirects image requests with a temporary signed URL , giving access * to GET an upload . * / function tempRedirect ( req , res ) { var params = { Bucket : S3_BUCKET , Key : checkTrailingSlash ( getFileKeyDir ( req ) ) + req . params [ 0 ] } ; var s3 = new aws . S3 ( ) ; s3 . getSignedUrl ( 'getObject' , params , function ( err , url ) { res . redirect ( url ) ; } ) ; } ;", "del_tokens": "/ ** * Redirects image requests with a temporary signed URL , giving access * to GET an upload . * / function tempRedirect ( req , res ) { var params = { Bucket : S3_BUCKET , Key : checkTrailingSlash ( getFileKeyDir ( req ) ) + req . params [ 0 ] } ; var s3 = new aws . S3 ( ) ; s3 . getSignedUrl ( 'getObject' , params , function ( err , url ) { res . redirect ( url ) ; } ) ; } ;", "commit_type": "move"}
{"commit_tokens": ["Add", "functions", "for", "mapping", "comparison"], "add_tokens": "function compare ( mapping1 , mapping2 , prefix ) { mapping1 = addMappingIdentifiers ( mapping1 ) mapping2 = addMappingIdentifiers ( mapping2 ) let id1 = mapping1 . identifier . find ( element => element . startsWith ( prefix ) ) let id2 = mapping2 . identifier . find ( element => element . startsWith ( prefix ) ) return id1 == id2 } function compareMappings ( mapping1 , mapping2 ) { return compare ( mapping1 , mapping2 , \"urn:jskos:mapping:content:\" ) } const compareMappingContent = compareMappings function compareMappingMembers ( mapping1 , mapping2 ) { return compare ( mapping1 , mapping2 , \"urn:jskos:mapping:members:\" ) } addMappingIdentifiers , compareMappings , compareMappingContent , compareMappingMembers ,", "del_tokens": "addMappingIdentifiers", "commit_type": "add"}
{"commit_tokens": ["Added", "event", "hooks", "in", "the", "API", "also", "added", "PING", "event", "incase", "someone", "wants", "to", "setup", "a", "timer", "for", "example"], "add_tokens": "Events . setMaxListeners ( 0 ) ; self . connection . on ( 'ready' , function ( ) { self . connection . on ( 'close' , function ( ) { Events . emit ( [ self . key , 'close' ] , { } ) ; } ) ; PING : function ( message ) { Events . emit ( [ this . key , 'ping' ] , { timestamp : + new Date ( ) } ) ; }", "del_tokens": "self . connection . once ( 'ready' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "handlebars", "instead", "of", "mustache"], "add_tokens": "from : \"-!-\" ,", "del_tokens": "from : \"\" ,", "commit_type": "use"}
{"commit_tokens": ["added", "a", "default", "value", "for", "gradient", "proportions", "in", "order", "to", "avoid", "issues", "with", "undefined", "values", "when", "generating", "color", "stops"], "add_tokens": "constructor ( colorArray , colorPt1 , colorPt2 , proportion = 0 , angle ) {", "del_tokens": "constructor ( colorArray , colorPt1 , colorPt2 , proportion , angle ) {", "commit_type": "add"}
{"commit_tokens": ["changed", "checkFolderExist", ";", "and", "tested", "build"], "add_tokens": "const checkFolderExist = ( path_ , mkdir ) => { let paths = path . normalize ( path_ ) . split ( path . sep ) ; let currentPath = paths [ 0 ] ; let result = true ; for ( let i = 1 , len = paths . length ; i < len ; i ++ ) { currentPath += path . sep + paths [ i ] ; if ( ! fs . existsSync ( currentPath ) ) { if ( mkdir ) { fs . mkdirSync ( currentPath ) ; } result = false ; return result", "del_tokens": "const checkFolderExist = ( path , mkdir ) => { if ( ! fs . existsSync ( path ) ) { if ( mkdir ) { fs . mkdirSync ( path ) ; return false ; } else { return true ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "the", "popup", "delay", "by", "removing", "the", "poster", "."], "add_tokens": "// Prepare the element if ( playerel . hasAttribute ( \"poster\" ) ) { playerel . removeAttribute ( \"poster\" ) ; } if ( playerel . hasAttribute ( \"data-poster\" ) ) { playerel . removeAttribute ( \"data-poster\" ) ; } var wrapper = $dom . create ( \"div.afterglow-lightbox-wrapper.hidden\" ) ; lightbox . appendChild ( playerel ) ;", "del_tokens": "var wrapper = $dom . create ( \"div.afterglow-lightbox-wrapper\" ) ; lightbox . appendChild ( playerel ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "options", "override", "to", "collection", "fetchHttpAction"], "add_tokens": "this . fetchHttpAction = options . fetchHttpAction || 'POST' ;", "del_tokens": "this . fetchHttpAction = 'POST' ;", "commit_type": "add"}
{"commit_tokens": ["add", "custom", "validate", "and", "sanitize", "function"], "add_tokens": "// Initialize `_methods` property if ( ! self . _methods ) { self . _methods = { } ; self . _methods [ name ] = { fn : _fn , args : args , type : type } ;", "del_tokens": "let containerName = ` ${ type } ` ; // Initialize `__validators` and `__sanitizers` property if ( ! self [ containerName ] ) { self [ containerName ] = { } ; self [ containerName ] [ name ] = { fn : _fn , args : args } ;", "commit_type": "add"}
{"commit_tokens": ["added", "mode", "AspectFill", "to", "ai"], "add_tokens": "const MODE_ASPECT_FIT = 'AspectFit' ; const MODE_ASPECT_FILL = 'AspectFill' ; let mode = req . query . mode || MODE_ASPECT_FIT ; if ( mode == MODE_ASPECT_FILL ) { img . resize ( width , height , '^' ) . gravity ( 'Center' ) . crop ( width , height ) ; } else if ( mode == MODE_ASPECT_FIT ) { if ( allowResize ) { let w = imageWidth == 0 ? null : ( crop ? ` ${ width } ` : imageWidth ) ; let h = imageHeight == 0 ? null : ( crop ? ` ${ height } ` : imageHeight ) ; img = img . resize ( w , h ) ; } img . gravity ( 'Center' ) . extent ( canvasWidth , canvasHeight ) ;", "del_tokens": "if ( allowResize ) { let w = imageWidth == 0 ? null : ( crop ? ` ${ imageWidth } ` : imageWidth ) ; let h = imageHeight == 0 ? null : ( crop ? ` ${ imageHeight } ` : imageHeight ) ; img = img . resize ( w , h ) ; . gravity ( 'Center' ) . extent ( canvasWidth , canvasHeight )", "commit_type": "add"}
{"commit_tokens": ["Changed", "regex", "definition", "so", "to", "avoid", "amdtools", "bug"], "add_tokens": "// FIXME added some crazy comment markers to fix bug in amdtools conversion return html . toString ( ) . replace ( / ([&<>\"/*\"*/]) / g , function ( character ) { //\"", "del_tokens": "return html . toString ( ) . replace ( / ([&<>\"]) / g , function ( character ) { // \"", "commit_type": "change"}
{"commit_tokens": ["Use", "bigip", ".", "list", "in", "ready", "function"], "add_tokens": "this . list ( '/shared/echo-js' ) . then ( function ( response ) { } ) . catch ( function ( err ) { deferred . reject ( 'Error calling /shared/echo-js: ' + err . message ) ; } ) ; return util . tryUntil ( this , maxRetries , retryIntervalMs , isReady ) ;", "del_tokens": "icontrol . list ( '/shared/echo-js' , function ( err , response ) { if ( err ) { deferred . reject ( 'Error calling /shared/echo-js' ) ; } else { } } ) ; return util . tryUntil ( maxRetries , retryIntervalMs , isReady ) ;", "commit_type": "use"}
{"commit_tokens": ["Change", "to", "string", "enum", "pattern", "when", "initializing", "Compressor", "/", "Decompressor"], "add_tokens": "function Decompressor ( type ) { var initial_table = ( type === 'REQUEST' ) ? CompressionContext . initialRequestTable : CompressionContext . initialResponseTable ; function Compressor ( type ) { var initial_table = ( type === 'REQUEST' ) ? CompressionContext . initialRequestTable : CompressionContext . initialResponseTable ;", "del_tokens": "function Decompressor ( request ) { var initial_table = request ? CompressionContext . initialRequestTable : CompressionContext . initialResponseTable ; function Compressor ( request ) { var initial_table = request ? CompressionContext . initialRequestTable : CompressionContext . initialResponseTable ;", "commit_type": "change"}
{"commit_tokens": ["Upgrade", "fluxury", ".", "Remove", "composeStore", "."], "add_tokens": "let { getState , getStores , subscribe , createStore , dispatch , promiseAction , replaceReducer } = require ( 'fluxury' )", "del_tokens": "let { getState , getStores , subscribe , composeStore , createStore , dispatch , promiseAction , replaceReducer } = require ( 'fluxury' ) xander . composeStore = composeStore ;", "commit_type": "upgrade"}
{"commit_tokens": ["Created", "a", "custom", "path", "module", "based", "on", "built", "-", "in", "NodeJS", "module", "."], "add_tokens": "var path = require ( './path' ) ;", "del_tokens": "var path = require ( 'path' ) ;", "commit_type": "create"}
{"commit_tokens": ["Add", ".", "dispose", "()", "method"], "add_tokens": "function Shader ( gl , prog , attributes , typeInfo , vertShader , fragShader ) { this . vertShader = vertShader this . fragShader = fragShader Shader . prototype . dispose = function ( ) { var gl = this . gl gl . deleteShader ( this . vertShader ) gl . deleteShader ( this . fragShader ) gl . deleteProgram ( this . handle ) } } , vertShader , fragShader )", "del_tokens": "function Shader ( gl , prog , attributes , typeInfo ) { } )", "commit_type": "add"}
{"commit_tokens": ["Use", "safe", "-", "buffer", "for", "improved", "Buffer", "API"], "add_tokens": "var Buffer = require ( 'safe-buffer' ) . Buffer ? stream . write ( Buffer . from ( chunk , encoding ) ) ? stream . end ( Buffer . from ( chunk , encoding ) )", "del_tokens": "? stream . write ( new Buffer ( chunk , encoding ) ) ? stream . end ( new Buffer ( chunk , encoding ) )", "commit_type": "use"}
{"commit_tokens": ["Fixed", "typo", "in", "getting", "position", "of", "the", "element"], "add_tokens": "var position = window . getComputedStyle ( element ) . getPropertyValue ( 'position' ) ;", "del_tokens": "var position = window . getComputedStyle ( element ) . getPropertyPriority ( 'position' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "a", "bug", "in", "vivliostyle", ".", "sizing", ".", "getSize"], "add_tokens": "position : element . style . position , width : /** @type {string} */ ( element . style . width ) , height : /** @type {string} */ ( element . style . height ) adapt . base . setCSSProperty ( element , \"width\" , \"auto\" ) ; adapt . base . setCSSProperty ( element , \"height\" , \"auto\" ) ; break ; adapt . base . setCSSProperty ( element , \"width\" , original . width ) ; adapt . base . setCSSProperty ( element , \"height\" , original . height ) ;", "del_tokens": "position : element . style . position", "commit_type": "fix"}
{"commit_tokens": ["fixed", "bug", "in", "loan", "balance"], "add_tokens": "sumOfPayments += typeof tx . principal === \"number\" ? tx . principal : 0 ; console . log ( loan . loanBalance ) ;", "del_tokens": "sumOfPayments += ! _ . isEmpty ( tx . principal ) ? Number ( tx . principal ) : 0 ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "for", "expect", "()", "for", "PlainOption", "/", "PlainResult"], "add_tokens": "const { createSome , createNone , } = require ( '../../__dist/cjs/PlainOption/Option' ) ; const { expectIsSome , } = require ( '../../__dist/cjs/PlainOption/expect' ) ; test ( 'input=Some' , ( t ) => { const EXPECTED = Symbol ( 'expected' ) ; const input = createSome ( EXPECTED ) ; let actual ; t . notThrows ( ( ) => { actual = expectIsSome ( input , 'do not throw any errors' ) ; } ) ; t . is ( actual , EXPECTED ) ; } ) ; test ( 'input=None' , ( t ) => { const input = createNone ( ) ; const MSG = 'throw if the input is None' ; t . throws ( ( ) => { expectIsSome ( input , MSG ) ; } , { instanceOf : TypeError , message : MSG , } ) ; } ) ;", "del_tokens": "test . todo ( 'Some' ) ; test . todo ( 'None' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "initial", "spatial", "-", "index", ".", "preprocessor", "implementation"], "add_tokens": "'tif-toBytes.preprocessor' , 'tif-reproject.preprocessor' , 'shp-index.preprocessor' , 'geojson-bom.preprocessor' , 'spatial-index.preprocessor' preprocessor ( infile , outfile , function ( err ) { if ( err ) return next ( err ) ; infile = outfile ; next ( ) ; } ) ;", "del_tokens": "'tif-toBytes.preprocessor' , 'tif-reproject.preprocessor' , 'shp-index.preprocessor' , 'geojson-bom.preprocessor' preprocessor ( infile , outfile , function ( err ) { if ( err ) return next ( err ) ; infile = outfile ; next ( ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "datab", ".", "data", ".", "from_input", "to", "handle", "file", "selection", "input"], "add_tokens": "* * from_input - create data object from a file input selection * ( csv files only ) * from_obj - create data object from an array of dict - like * row objects", "del_tokens": "* append_to - append as an html table to a d3 selection", "commit_type": "add"}
{"commit_tokens": ["Using", "shared", "toolbar", "CSS", "for", "examples"], "add_tokens": "document . querySelector ( '.toolbar' ) . addEventListener ( 'click' , handleMenuClick ) ; document . querySelector ( '.toolbar' ) . addEventListener ( 'keyup' , handleMenuKeyUp ) ;", "del_tokens": "document . querySelector ( '.menu' ) . addEventListener ( 'click' , handleMenuClick ) ; document . querySelector ( '.menu' ) . addEventListener ( 'keyup' , handleMenuKeyUp ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "a", "readme", ".", "md", "documentation", "explaining", "the", "basics", "of", "the", "module"], "add_tokens": "this . emit ( \"start\" ) ;", "del_tokens": "this . emit ( \"play\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "use", "strict", "from", "the", "templates", ";", "not", "working", "too", "well", "with", "eval", "()", "and", "Firefox", "."], "add_tokens": "var fname = null , filter = null ; _res += 'var __filter__ = ' ;", "del_tokens": "_res += '\\\"use strict\\\"\\nvar __filter__ = ' ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "edge", "case", "with", "single", "data", "entry", "not", "being", "rendered"], "add_tokens": "let endAngle = startAngle + lengthDegrees ; if ( endAngle === 360 ) { endAngle = 359.999 } ; degreesToRadians ( endAngle ) ,", "del_tokens": "degreesToRadians ( startAngle + lengthDegrees ) ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "query", "support", "on", "joins"], "add_tokens": "joinQuery = args . joinQuery || '' , subqueries = getSubqueries ( inQueries , joinLookups , joinQuery , args . pageSize || 25 , rightKeys ) ; //example function getSubqueries ( inQueries , orQueries , otherQuery , pageSize , rightKeys ) { otherQuery , queryArray , queryArray = [ { $match : inQuery } , { $match : orQuery } ] ; if ( otherQuery ) { queryArray . push ( { $match : otherQuery } ) ; } subqueries . push ( queryArray ) ; }", "del_tokens": "subqueries = getSubqueries ( inQueries , joinLookups , args . pageSize || 25 , rightKeys ) ; //example function getSubqueries ( inQueries , orQueries , pageSize , rightKeys ) { subqueries . push ( [ { $match : inQuery } , { $match : orQuery } ] ) ; }", "commit_type": "add"}
{"commit_tokens": ["fix", "windows", "path", "issue", "in", "generating", "id"], "add_tokens": "var reg = new RegExp ( \"\\\\\" + path . sep , \"g\" ) ; var relative_path = relative ? filepath : path . relative ( cwd , filepath ) . replace ( reg , \"/\" ) ; var id = main_id + '/' + relative_path ;", "del_tokens": "var relative_path = relative ? filepath : path . relative ( cwd , filepath ) ; var id = path . join ( main_id , relative_path ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "previously", "resolved", "TODO", ".", "Add", "callback", "params"], "add_tokens": "waitForUpdate ( function ( err , manifest ) { //if (err) { return cleanup(err); }", "del_tokens": "//TODO: the updateCallback should return the pre-parsed manifest object! (and the ready callback as well) waitForUpdate ( function ( ) {", "commit_type": "remove"}
{"commit_tokens": ["Fix", "a", "duplicate", "slashes", "regression", "."], "add_tokens": "var path = props . path ; if ( typeof path === 'string' ) { path = path . replace ( slashes , '' ) ; }", "del_tokens": "var path = typeof path === 'string' ? props . path . replace ( slashes , '' ) : props . path ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "Node", ".", "js", "util", ".", "types", "tests"], "add_tokens": "test ( require . resolve ( './callbackify' ) ) , test ( require . resolve ( './types' ) )", "del_tokens": "test ( require . resolve ( './callbackify' ) )", "commit_type": "add"}
{"commit_tokens": ["use", "var", "instead", "of", "const", "for", "tests", "remove", "unused", "files"], "add_tokens": "var baz = Foo . baz ( ) ; assert . ok ( bar ( ) . inheritsFromBaz ) ;", "del_tokens": "const baz = Foo . baz ( ) ; assert . ok ( bar ( ) . inheritsFromBaz ) ;", "commit_type": "use"}
{"commit_tokens": ["fixing", "an", "issue", "on", "the", "last", "commit", "mistyped", "variable"], "add_tokens": "server . use ( session ( {", "del_tokens": "app . use ( session ( {", "commit_type": "fix"}
{"commit_tokens": ["Update", "hesse", "-", "convergence", ".", "js"], "add_tokens": "* http : //www.xarg.org/2014/03/rational-numbers-in-javascript/", "del_tokens": "* http : //www.xarg.org/2014/03/precise-calculations-in-javascript/", "commit_type": "update"}
{"commit_tokens": ["Moving", "to", "better", "icomoon", "error", "messaging"], "add_tokens": "var modalAlertShowing = page . evaluate ( function ( ) { var $modalAlert = $ ( '#modal_alert' ) ; return $modalAlert . length && ! $modalAlert . hasClass ( 'hidden' ) ; } ) ; if ( modalAlertShowing ) { var errMsg = page . evaluate ( function ( ) { return $ ( '#alert_msg' ) . text ( ) ; } ) ; err = new Error ( 'icomoon error encountered: ' + errMsg ) ; }", "del_tokens": "console . log ( page . evaluate ( function ( ) { return $ ( '#modal_alert' ) . hasClass ( 'hidden' ) ; } ) ) ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "an", "issue", "that", "occured", "when", "no", "session", "support", "was", "enabled"], "add_tokens": "defaultOptions . flash = req . flash && req . flash . getMessages && req . flash . getMessages ( ) ; defaultOptions . currentProfile = req . auth && req . auth . currentProfile ; if ( req . flash . empty ) { req . flash . empty ( ) ; }", "del_tokens": "defaultOptions . flash = req . flash . getMessages ( ) ; defaultOptions . currentProfile = req . auth . currentProfile ; req . flash . empty ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removing", "currency", "code", "from", "appearing", "on", "cart"], "add_tokens": "self . UI . subtotalAmount . innerHTML = $ . util . formatCurrency ( subtotal , currency_code ) ; // TODO: The supportd currency patterns need to be refined and // should support values for before, after, decimal, and separator.", "del_tokens": "self . UI . subtotalAmount . innerHTML = $ . util . formatCurrency ( subtotal , currency_code ) + ' ' + currency_code ;", "commit_type": "remove"}
{"commit_tokens": ["Moved", "wms", "-", "downloader", "from", "module", "to", "class"], "add_tokens": "2", "del_tokens": "4", "commit_type": "move"}
{"commit_tokens": ["made", "some", "changes", "to", "add", "a", "lastError", "variable", "(", "+", "add", "tests", ")"], "add_tokens": "lastError : false , this . lastError = false ; this . lastError = { token : this . token , tokenName : token , expected : expect , messageExpected : msgExpect , message : 'Parse Error : unexpected ' + token + msgExpect + ' at line ' + this . lexer . yylloc . first_line , line : this . lexer . yylloc . first_line } ; if ( this . suppressErrors ) { this . token = EOF ; throw new Error ( this . lastError . message ) ; if ( ! this . lastError ) { if ( Array . isArray ( token ) ) { if ( token . indexOf ( this . token ) === - 1 ) { this . error ( token ) ; } } else if ( this . token != token ) {", "del_tokens": "var errorMessage = 'Parse Error : unexpected ' + token + msgExpect + ' at line ' + this . lexer . yylloc . first_line ; if ( suppressErrors ) { console . error ( errorMessage ) throw new Error ( errorMessage ) ; if ( Array . isArray ( token ) ) { if ( token . indexOf ( this . token ) === - 1 ) { } else if ( this . token != token ) { this . error ( token ) ;", "commit_type": "make"}
{"commit_tokens": ["Adds", "linter", "support", "for", "showing", "undeclared", "bindings"], "add_tokens": "findUnusedOrUndeclaredBindings ( ast ) // TODO: Add standard library for Squiggle and Node and browsers. function implicitlyDeclared ( k ) { return ( k === 'require' || k === 'is' || k === '++' || k === 'console' ) ; } function findUnusedOrUndeclaredBindings ( ast ) { var k = node . data ; if ( ! implicitlyDeclared ( k ) && ! scopes . hasKey ( k ) ) { messages . push ( \"undeclared variable \" + k ) ; } scopes . setBest ( k , true ) ;", "del_tokens": "findUnusedBindings ( ast ) function findUnusedBindings ( ast ) { scopes . setBest ( node . data , true ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "field", "to", "pride", "the", "Facebook", "PageToken", "without", "using", "config", ".", "json"], "add_tokens": "facebookThreadAPI ( node , config , GET_STARTED ) ; facebookThreadAPI ( node , config , GREETING_MSG ) ; facebookThreadAPI ( node , config , PERSISTANT_MENU ) ; const getPageToken = ( config ) => { if ( config && config . pageToken ) return config . pageToken ; if ( CONFIG && CONFIG . facebook && CONFIG . facebook . pageToken ) return CONFIG . facebook . pageToken ; const facebookThreadAPI = ( node , config , json ) => { let token = getPageToken ( config ) ;", "del_tokens": "facebookThreadAPI ( node , GET_STARTED ) ; facebookThreadAPI ( node , GREETING_MSG ) ; facebookThreadAPI ( node , PERSISTANT_MENU ) ; const getPageToken = ( ) => { if ( ! CONFIG || ! CONFIG . facebook || ! CONFIG . facebook . pageToken ) return ; return CONFIG . facebook . pageToken ; const facebookThreadAPI = ( node , json ) => { let token = getPageToken ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "Event", "to", "Data", "loaded"], "add_tokens": "if ( angular . isUndefined ( val ) || val === prev ) { return ; } if ( val === \"\" || val . length < $scope . minChars ) { return ; } if ( val === $scope . lastSearch ) { return ; }", "del_tokens": "if ( angular . isUndefined ( val ) ) return ; if ( val === prev ) return ; if ( val === \"\" || val . length < $scope . minChars ) return ; if ( val === $scope . lastSearch ) return ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "tests", "now", "they", "to", "stop", "them", "inheriting", "from", "base", "prettierrc", "file"], "add_tokens": "{ code : ` \\n ` } , // Double quote from .prettierrc. { code : '\"\";\\n' , filename : getPrettierRcJsFilename ( 'double-quote' ) } , errors : eval ( sections [ 4 ] ) , // eslint-disable-line no-eval filename : getPrettierRcJsFilename ( 'double-quote' , name + '.txt' )", "del_tokens": "{ code : '\"\";\\n' } , // Single quote from .prettierrc. { code : ` \\n ` , filename : getPrettierRcJsFilename ( 'single-quote' ) } , errors : eval ( sections [ 4 ] ) // eslint-disable-line no-eval", "commit_type": "fix"}
{"commit_tokens": ["Use", "run", "-", "as", "when", "launching", "worker", "process"], "add_tokens": "var path = require ( 'path' ) ; path . join ( __dirname , 'run-as.js' ) , appSpec . runAs , rprog , this . $proc = child_process . spawn ( process . execPath , args , {", "del_tokens": "this . $proc = child_process . spawn ( rprog , args , {", "commit_type": "use"}
{"commit_tokens": ["Fix", "selector", "driver", "extension", "."], "add_tokens": "if ( err ) { return next ( new Error ( 'Unable to retrieve element \"' + name + '\": (' + err + ')' ) ) ; } return next ( new Error ( 'Unable to retrieve element \"' + name + '\" tagname\\'s: (' + err + ')' ) ) ; return cb ( err ) ; //ensure boolean value = ! ! value ; if ( value === selected ) {", "del_tokens": "return next ( new Error ( 'Unable to retrieve element \"' + name + '\": (' + err + ')' ) ) ; cb ( err ) ; if ( ! value !== selected ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "tests", "for", "whitespace", "and", "nesting"], "add_tokens": "closeLevels ( level + 1 ) ;", "del_tokens": "closeLevels ( level ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "some", "issues", "with", "chaining"], "add_tokens": "self . on ( 'play' , function ( ) { self . on ( 'play' , function ( ) { self . on ( 'play' , function ( ) { self . mute ( id ) ; self . on ( 'play' , function ( ) { self . unmute ( id ) ; self . on ( 'play' , function ( ) { self . volume ( vol , id ) ; self . on ( 'play' , function ( ) { self . pos3d ( x , y , z , id ) ; self . on ( 'play' , function ( ) { self . fadeOut ( to , len , callback , id ) ;", "del_tokens": "self . on ( 'load' , function ( ) { self . on ( 'load' , function ( ) { self . on ( 'load' , function ( ) { self . mute ( ) ; self . on ( 'load' , function ( ) { self . unmute ( ) ; self . on ( 'load' , function ( ) { self . volume ( vol ) ; self . on ( 'load' , function ( ) { self . pos3d ( x , y , z ) ; self . on ( 'load' , function ( ) { self . fadeOut ( to , len , callback ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "suppport", "for", "saving", "WAV", "file", "directly", "."], "add_tokens": "audioinput . _cfg . fileUrl = cfg . fileUrl || null ; audioinput . _cfg . audioSourceType , audioinput . _cfg . fileUrl ] ) ; } else if ( audioInputData && audioInputData . file ) { audioinput . _audioInputFinishedEvent ( audioInputData . file ) ; / ** * Finished callback for AudioInputCapture start * @ private * / audioinput . _audioInputFinishedEvent = function ( fileUrl ) { cordova . fireWindowEvent ( \"audioinputfinished\" , { file : fileUrl } ) ; } ;", "del_tokens": "audioinput . _cfg . audioSourceType ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "policy", "input", "and", "output", "consistent"], "add_tokens": "/* Query2: For fetching policies attached to the teams the user belongs to */ /* TO-DO Query3: For fetching policies attached to the organization the user belongs to */ return cb ( null , result . rows [ 0 ] ) return cb ( null , { id , version , name , statements : JSON . parse ( statements ) } )", "del_tokens": "/* Query2: For fetching policies attached to the teams user belongs to */ var policy = result . rows [ 0 ] return cb ( null , { id : policy . id , name : policy . name , version : policy . version , statements : policy . statements . Statement } ) return cb ( null , { id , version , name , statements : JSON . parse ( statements ) . Statement } )", "commit_type": "make"}
{"commit_tokens": ["fixed", "pixel", "doubled", "sprite", "sizes"], "add_tokens": "spriteWidth : features . width / 2 , spriteHeight : features . height / 2", "del_tokens": "spriteWidth : features . width , spriteHeight : features . height", "commit_type": "fix"}
{"commit_tokens": ["Fix", "path", "to", "package", ".", "json"], "add_tokens": "this . _version = require ( '../package.json' ) . version ; * DeepFramework . Kernel ( context ) . loadFromFile ( \"_config.json\" , function ( deepKernel ) { * Kernel Kernel ( context ) {", "del_tokens": "this . _version = require ( '../../package.json' ) . version ; * DeepFramework . KernelFromLambdaContext ( context ) . loadFromFile ( \"_config.json\" , function ( deepKernel ) { * KernelFromLambdaContext KernelFromLambdaContext ( context ) {", "commit_type": "fix"}
{"commit_tokens": ["remove", "dup", "files", "that", "are", "actually", "in", "the", "Web", "IDE", "make", "sure", "new", "version", "warning", "appears", "for", "pico"], "add_tokens": "if ( vAvailable > vCurrent && ( env . BOARD == \"ESPRUINOBOARD\" || env . BOARD . substr ( 0 , 4 ) == \"PICO\" ) ) {", "del_tokens": "if ( vAvailable > vCurrent && env . BOARD == \"ESPRUINOBOARD\" ) {", "commit_type": "remove"}
{"commit_tokens": ["added", "rest", "interface", "to", "run", "and", "interrupt", "the", "monkey"], "add_tokens": "var formatter = new cucumberjs . Listener . JsonFormatter ( ) ; formatter . log = function ( results ) { process . send ( results ) ; } ; runtime . attachListener ( formatter ) ;", "del_tokens": "if ( process . env [ 'monkey.ipc' ] ) { var formatter = new cucumberjs . Listener . JsonFormatter ( ) ; formatter . log = function ( results ) { process . send ( results ) ; } ; runtime . attachListener ( formatter ) ; }", "commit_type": "add"}
{"commit_tokens": ["Removed", "slate", "-", "read", "-", "only", "wrapping", "div", "on", "Read", "only", "editor"], "add_tokens": "export default function ReadOnly ( ) { onBeforeInput", "del_tokens": "import React from \"react\" ; import PropTypes from \"prop-types\" ; export default function ReadOnly ( opts = { readOnlyClass : \"slate-read-only\" } ) { const { readOnlyClass } = opts ; function renderEditor ( props ) { return < div className = { readOnlyClass } > { props . children } < / div > ; } renderEditor . propTypes = { children : PropTypes . node . isRequired } ; onBeforeInput , renderEditor", "commit_type": "remove"}
{"commit_tokens": ["add", "discovery", "option", "and", "deprecate", "upload", "opt"], "add_tokens": "if ( typeof opts . upload !== 'undefined' && typeof opts . discovery === 'undefined' ) opts . discovery = { upload : opts . upload , download : true } // 3.2.0 backwards compat if ( ! self . options . discovery ) return var discovery = self . options . discovery || { } if ( typeof self . options . discovery !== 'object' ) discovery = { upload : true , download : true } upload : discovery . upload , download : discovery . download ,", "del_tokens": "upload : true , if ( ! this . options . discovery ) return upload : self . options . upload ,", "commit_type": "add"}
{"commit_tokens": ["Add", "defined", "behavior", "for", "HTTP", "CONNECT", "requests"], "add_tokens": "return Boolean ( msg . upgrade || ! socket || ! socket . readable || ( msg . complete && ! msg . readable ) )", "del_tokens": "return Boolean ( ! socket || ! socket . readable || ( msg . complete && ! msg . readable ) )", "commit_type": "add"}
{"commit_tokens": ["added", "displayName", "to", "array", "methods"], "add_tokens": "exports [ methodName ] . displayName = exports [ methodName ] . name = \"icepick.\" + methodName ; exports . splice = function splice ( arr /*, args*/ ) {", "del_tokens": "exports . splice = function ( arr /*, args*/ ) {", "commit_type": "add"}
{"commit_tokens": ["Using", "RFC", "3986", "encoding", "for", "signature", "generation"], "add_tokens": "return RFC3986Encode ( key ) + '=' + RFC3986Encode ( params [ key ] ) ; function RFC3986Encode ( str ) { return encodeURIComponent ( str ) . replace ( / [!'()*] / g , function ( c ) { return '%' + c . charCodeAt ( 0 ) . toString ( 16 ) ; } ) ; }", "del_tokens": "var qs = require ( 'querystring' ) ; var param = { } ; param [ key ] = params [ key ] ; return qs . stringify ( param ) . replace ( \"%7E\" , \"~\" ) ;", "commit_type": "use"}
{"commit_tokens": ["Adding", "first", "section", "of", "signing"], "add_tokens": "var client = new minio ( { host : 'localhost' , port : 9000 , accessKey : \"accesskey\" , secretKey : \"secretkey\" } )", "del_tokens": "var client = new minio ( { host : 'localhost' , port : 9000 } )", "commit_type": "add"}
{"commit_tokens": ["added", ":", "tsconfig", ".", "base", ".", "json"], "add_tokens": "* Date : 2017 - 07 - 06 T02 : 37 : 32.078 Z", "del_tokens": "* Date : 2017 - 07 - 06 T00 : 37 : 54.889 Z", "commit_type": "add"}
{"commit_tokens": ["Remove", "js", "-", "logger", "in", "favour", "of", "logger", ".", "js"], "add_tokens": "let level = 0 ; const levels = { debug : 0 , info : 1 , warn : 2 , error : 3 , disable : 4 } ; export default { setLevel ( levelName ) { level = levels [ levelName ] ; } , debug ( ... args ) { if ( level > 0 ) { return ; } console . log ( ... args ) ; } , log ( ... args ) { if ( level > 1 ) { return ; } console . log ( ... args ) ; } , info ( ... args ) { if ( level > 1 ) { return ; } console . info ( ... args ) ; } , warn ( ... args ) { if ( level > 2 ) { return ; } console . warn ( ... args ) ; } , error ( ... args ) { if ( level > 3 ) { return ; } console . error ( ... args ) ; } } ;", "del_tokens": "export default function ( ) { }", "commit_type": "remove"}
{"commit_tokens": ["fixing", "case", "where", "level", "is", "null"], "add_tokens": "if ( ( ast . kind === \"continue\" || ast . kind === \"break\" ) && ast . level ) {", "del_tokens": "if ( ast . kind === \"continue\" || ast . kind === \"break\" ) {", "commit_type": "fix"}
{"commit_tokens": ["updated", "Powered", "by", "Hour", "text"], "add_tokens": "var hourLogo = require ( '!svg-inline!./assets/hour-logo.svg' ) ; hourLogo : hourLogo", "del_tokens": "var timekitIcon = require ( '!svg-inline!./assets/timekit-icon.svg' ) ; timekitIcon : timekitIcon", "commit_type": "update"}
{"commit_tokens": ["Add", "content", "&", "code", "generation", "for", "exercise", "sections"], "add_tokens": "// Render a section using our custom renderer function render ( section ) { // marked's Render expects this, we don't use it yet section . links = { } ; // Build options using defaults and our custom renderer var options = _ . extend ( { } , marked . defaults , { renderer : renderer ( ) } ) ; return marked . parser ( section , options ) ; } var nonCodeNodes = _ . reject ( section , { 'type' : 'code' } ) ; var codeNodes = _ . filter ( section , { 'type' : 'code' } ) ; content : render ( nonCodeNodes ) , code : { base : codeNodes [ 0 ] . text , solution : codeNodes [ 1 ] . text , validation : codeNodes [ 2 ] . text , } content : render ( section )", "del_tokens": "// marked's Render expects this, we don't use it yet section . links = { } ; // Build options using defaults and our custom renderer var options = _ . extend ( { } , marked . defaults , { renderer : renderer ( ) } ) ; content : marked . parser ( section , options )", "commit_type": "add"}
{"commit_tokens": ["Move", "http", "connection", "logic", "into", "library"], "add_tokens": "var Stack = require ( 'stack' ) , TopCube ( Stack ( Creationix . static ( \"/\" , __dirname + \"/www\" , \"index.html\" ) ) ) ;", "del_tokens": "var Http = require ( 'http' ) , Stack = require ( 'stack' ) , var PORT = 7569 ; var handler = Stack ( Creationix . static ( \"/\" , __dirname + \"/www\" ) ) ; ( function listen ( ) { try { Http . createServer ( handler ) . listen ( PORT ) ; } catch ( err ) { if ( err . code === \"EADDRINUSE\" ) { PORT ++ ; listen ( ) ; return ; } throw err ; } TopCube ( \"http://127.0.0.1:\" + PORT + \"/index.html\" ) ; } ( ) ) ;", "commit_type": "move"}
{"commit_tokens": ["add", "support", "of", "swagger", "docs"], "add_tokens": "function authenticationLocalManagement ( options1 = { } , docs = { } ) { options . app . use ( options . path , Object . assign ( authLocalMgntMethods ( options ) , { docs } ) ) ;", "del_tokens": "function authenticationLocalManagement ( options1 = { } ) { options . app . use ( options . path , authLocalMgntMethods ( options ) ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "trailing", "slash", "in", "MSN", ".", "listP", "()"], "add_tokens": "var url = this . _url . slice ( 0 , - 1 ) ; debug ( \"GET \" + url ) ; return this . _openStack . sendP ( \"GET\" , url , null , headers ) ; //# sourceMappingURL=index.js.map", "del_tokens": "debug ( \"GET \" + this . _url ) ; return this . _openStack . sendP ( \"GET\" , this . _url , null , headers ) ; //# sourceMappingURL=index.js.map", "commit_type": "remove"}
{"commit_tokens": ["Add", "travis", "add", "test", "command"], "add_tokens": "grunt . registerTask ( 'test' , [ 'jshint' , 'mochaTest' ] ) ;", "del_tokens": "grunt . registerTask ( 'test' , [ '' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "incorrect", "cropped", "canvas", "when", "scaleX", "/", "Y", ">", "1"], "add_tokens": "var canvasData = _this . canvasData ; var params = [ source ] ; var srcX = data . x + canvasData . naturalWidth * ( abs ( data . scaleX || 1 ) - 1 ) / 2 ; var srcY = data . y + canvasData . naturalHeight * ( abs ( data . scaleY || 1 ) - 1 ) / 2 ; params . push ( floor ( srcX ) , floor ( srcY ) , floor ( srcWidth ) , floor ( srcHeight ) ) ; params . push ( floor ( dstX ) , floor ( dstY ) , floor ( dstWidth ) , floor ( dstHeight ) ) ; return params ;", "del_tokens": "var args = [ source ] ; var srcX = data . x ; var srcY = data . y ; args . push ( floor ( srcX ) , floor ( srcY ) , floor ( srcWidth ) , floor ( srcHeight ) ) ; args . push ( floor ( dstX ) , floor ( dstY ) , floor ( dstWidth ) , floor ( dstHeight ) ) ; return args ;", "commit_type": "fix"}
{"commit_tokens": ["added", "innerHTML", "helper", "and", "tests"], "add_tokens": "failures : [ ] . map . call ( document . querySelectorAll ( '.fail' ) , function ( node ) { return node . textContent ; } ) , errored : Math . max ( 0 , document . querySelectorAll ( '.error' ) . length - 1 ) , errors : [ ] . map . call ( document . querySelectorAll ( '.error' ) , function ( node ) { return node . textContent ; } ) if ( results . failed ) { console . log ( 'failures: \\n' + results . failures . join ( '\\n' ) ) ; } else { console . log ( 'failed: ' + results . failed ) ; } if ( results . errored ) { console . log ( 'errors: \\n' + results . errors . join ( '\\n' ) ) ; } else { console . log ( 'errored: ' + results . errored ) ; }", "del_tokens": "errored : Math . max ( 0 , document . querySelectorAll ( '.error' ) . length - 1 ) console . log ( 'failed: ' + results . failed ) ; console . log ( 'errored: ' + results . errored ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "any", "storage", "to", "local", "array"], "add_tokens": "var any = this . $private . any ; var rule = any [ i ] ; W . $exec ( rule [ 0 ] , { args : rule [ 1 ] } ) ; any = [ ] ; / ** * Any route matching storage * / any : [ ] , W . routes . $private . any . push ( [ child , seg ] ) ; 'any:fire' : function ( seg , child ) { W . $exec ( child , { args : [ seg ] } ) ; var split = opt . split ( '/' ) ; if ( new RegExp ( split [ 1 ] , split [ 2 ] ) . test ( seg ) ) {", "del_tokens": "var any = this . $get ( 'any' ) ; W . $exec ( any [ i ] ) ; this . $set ( 'any' , [ ] ) ; W . routes . $push ( 'any' , child ) ; 'any:fire' : function ( ) { return true ; if ( new RegExp ( opt ) . test ( seg ) ) {", "commit_type": "move"}
{"commit_tokens": ["Added", "a", "new", "feature", ".", "Enable", "zipping", "log", "content", "before", "sending", "it", "to", "the", "server", ".", "This", "feature", "needs", "further", "development", "on", "the", "server", "side", "and", "has", "a", "configurable", "flag", "compressPosts", "that", "is", "currently", "set", "to", "false"], "add_tokens": "if ( config . debug_services && config . debug_services . length > 0 ) { for ( var i = 0 ; i < config . debug_services . length ; i ++ ) { if ( config . debug_service . type === 'service' ) {", "del_tokens": "if ( config . debug_services && config . debug_services . length > 0 ) { for ( var i = 0 ; i < config . debug_services . length ; i ++ ) { if ( config . debug_service . type === 'service' ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "files", "-", "property", "to", "package", ".", "json", "Added", "missing", "helpers", "-", "io", ".", "js", "file"], "add_tokens": "var key for ( key in customize ) { if ( customize . hasOwnProperty ( key ) ) { module . exports [ key ] = customize [ key ] } } module . exports . Customize = Recustomize", "del_tokens": "module . exports . Customize = Recustomize ; module . exports . overrider = customize . overrider ;", "commit_type": "add"}
{"commit_tokens": ["remove", "feature", "-", "detection", "-", "related", "style", "in", "han", ".", "css"], "add_tokens": "'./support' clazz = ( support [ feature ] ? '' : 'no-' ) + feature", "del_tokens": "'./support' , './detect-font' clazz = ( support [ feature ] ? '' : 'no-' ) + feature", "commit_type": "remove"}
{"commit_tokens": ["Use", "small", "sized", "id", "in", "sending", "event", "to", "client"], "add_tokens": "// An auto-increment id for event. var eventId = 0 ; // In case of long polling, these ids are echoed back as a query // string to the URL in GET. To avoid `414 Request-URI Too Long` // error, though it is really not that important, it would be // better to use small sized id. id : \"\" + eventId ++ ,", "del_tokens": "crypto = require ( \"crypto\" ) , id : crypto . randomBytes ( 3 ) . toString ( \"hex\" ) ,", "commit_type": "use"}
{"commit_tokens": ["Fixing", "device", ".", "js", "so", "it", "finds", "the", "Android"], "add_tokens": "if ( window . DroidGap ) {", "del_tokens": "if ( window . DroidGap . exists ( ) ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "the", "X", "-", "KeenSDKTracking", "-", "X", "header", "to", "all", "events"], "add_tokens": "'Content-Length' : Buffer . byteLength ( data ) , 'X-KeenSDKVersion-X' : 'keen_tracking_server-' + require ( '../package.json' ) . version", "del_tokens": "'Content-Length' : Buffer . byteLength ( data )", "commit_type": "add"}
{"commit_tokens": ["fixed", "path", "resolution", "on", "windows"], "add_tokens": "seleniumLogs : path . relative ( './' , path . join ( workfloConf . testDir , 'logs' , 'selenium' , dateTime ) ) , logOutput : path . join ( workfloConf . testDir , 'logs' ) , reporters : [ 'workflo-spec' , 'workflo-allure' ] , outputDir : path . join ( workfloConf . testDir , 'results' , dateTime ) , outputDir : path . join ( workfloConf . testDir , 'results' , dateTime , 'allure-results' ) ,", "del_tokens": "seleniumLogs : ` ${ workfloConf . testDir } ${ dateTime } ` , logOutput : ` ${ workfloConf . testDir } ` , reporters : [ 'workflo-spec' , 'workflo-allure' /*, 'allure-addons'*/ ] , outputDir : ` ${ workfloConf . testDir } ${ dateTime } ` , outputDir : ` ${ workfloConf . testDir } ${ dateTime } ` , debug : false , debugSeleniumCommand : true } , 'allure-addons' : { outputDir : ` ${ workfloConf . testDir } ${ dateTime } ` ,", "commit_type": "fix"}
{"commit_tokens": ["Improving", "error", "handling", "on", "Model", ".", "list", "()", "."], "add_tokens": "if ( error ) { return callback ( error ) ; } application . collect ( type , items , function ( error ) {", "del_tokens": "application . collect ( type , items , function ( err ) {", "commit_type": "improve"}
{"commit_tokens": ["Updating", "to", "fix", "logic", "for", "checking", "on", "old", "documents"], "add_tokens": "if ( originalSlug && originalSlug . length > 0 && originalSlug !== slug ) {", "del_tokens": "if ( originalSlug && originalSlug . length > 0 & originalSlug !== slug ) {", "commit_type": "update"}
{"commit_tokens": ["added", "bulk", "/", "multi", "file", "upload"], "add_tokens": ". command ( 'upload [files...]' ) . option ( '-n, --remotename <remotename>' , 'Set destination file name. Default is same as original. Only available when uploading a single file!' , false ) . action ( function ( localFiles , options ) { // files provided ? if ( localFiles . length == 0 ) { console . error ( _colors . red ( '[NodeMCU-Tool]' ) , 'No files provided for upload (empty file-list)' ) ; return ; } // handle multiple uploads var currentFileNumber = 0 ; _nodemcutool . upload ( _cli . port , _cli . baud , localFiles , options , function ( current , total , fileNumber ) { // new file ? if ( currentFileNumber != fileNumber ) { bar . stop ( ) ; currentFileNumber = fileNumber ; bar . start ( total , 1 ) ; } else {", "del_tokens": ". command ( 'upload <file>' ) . option ( '-n, --remotename <remotename>' , 'Set destination file name. Default is same as original' , false ) . action ( function ( localFile , options ) { _nodemcutool . upload ( _cli . port , _cli . baud , localFile , options , function ( current , total ) { // bar initialized ? if ( current == 0 ) { bar . start ( total , 0 ) ; } else {", "commit_type": "add"}
{"commit_tokens": ["Add", "checks", "for", "window", ".", "DEBUG", ".", "enabled"], "add_tokens": "if ( window . DEBUG && window . DEBUG . enabled && window . postMessage ) {", "del_tokens": "if ( window . DEBUG && window . postMessage ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "models", "not", "showing", "up", "in", "docs"], "add_tokens": "if ( ! this . framework . models [ key ] ) continue ; var newModels = utils . getModels ( this . framework . models [ key ] ) ; spec . models [ key ] = this . framework . models [ key ] ;", "del_tokens": "this . apis = [ ] ; this . models = { } ; if ( ! this . models [ key ] ) continue ; var newModels = utils . getModels ( this . models [ key ] ) ; spec . models [ key ] = this . models [ key ] ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "disableAutostart", "()", "isAutostartEnabled", "()", "and", "testing"], "add_tokens": "crontab . save ( function ( error ) { if ( err === '' || err === undefined ) err = null ; callback ( err ) ; err = 'Autostart is not enabled, so you cannot disable it' ; } /* istanbul ignore next */ else if ( os . platform ( ) === 'linux' ) { crontab . remove ( { comment : key } ) ; crontab . save ( function ( error ) { err = error ; if ( err === '' || err === undefined ) err = null ; callback ( err ) ; } ) ; } /* istanbul ignore next */ else if ( os . platform ( ) === \"linux\" ) { crontab . load ( function ( error , crontabData ) { crontab = crontabData ; //Make crontab's data globally available crontab . load = function ( callback ) { callback ( null , crontab ) ; } ; //Make .load() a dummy since data already is loaded (npm test calls it several times) if ( crontab . jobs ( { comment : key } ) . length == '0' ) { isEnabled = false ; } else { isEnabled = true ; } if ( err === '' || err === undefined ) err = null ; callback ( isEnabled , err ) ; } ) ;", "del_tokens": "crontab . save ( function ( error , crontab ) { err = 'Autostart is not enabled, so you cannot disable it ¯\\\\_(ツ)_/¯'; //} else if (os.platform() === 'linux') { //crontab stuff //} else if (os.platform() === \"linux\") { //crontab stuff", "commit_type": "add"}
{"commit_tokens": ["Make", "relative", "applied", "source", "paths", "relative", "to", "CWD"], "add_tokens": "var urix = require ( 'urix' ) ; var path = require ( 'path' ) ; var sourceFile = urix ( pos && pos . source || 'source.css' ) ; var map = new SourceMapConsumer ( originalMap . map ) ; var relativeTo = originalMap . sourcesRelativeTo ; this . map . applySourceMap ( map , file , urix ( path . dirname ( relativeTo ) ) ) ;", "del_tokens": "var sourceFile = pos && pos . source || 'source.css' ; originalMap = new SourceMapConsumer ( originalMap . map ) ; this . map . applySourceMap ( originalMap , file ) ;", "commit_type": "make"}
{"commit_tokens": ["Fixed", "setStringValueForKey", "not", "working", "on", "Android"], "add_tokens": "window . fabric . core . execPlugin ( 'setStringValueForKey' , defaults ) ;", "del_tokens": "window . fabric . core . execPlugin ( 'setObjectValueForKey' , defaults ) ;", "commit_type": "fix"}
{"commit_tokens": ["create", "new", "utf8", "buffer", "from", "url", "encoded", "string", "for", "special", "character", "handling"], "add_tokens": "urlencoded = new Buffer ( urlencoded . substring ( 0 , urlencoded . length - 1 ) , 'utf8' ) ;", "del_tokens": "urlencoded = urlencoded . substring ( 0 , urlencoded . length - 1 ) ;", "commit_type": "create"}
{"commit_tokens": ["Fix", "NaN", "for", "DatePicker", "when", "init", "date", "value", "is", "empty"], "add_tokens": "if ( input . value != '' ) { input . value = this . getEuropeanDateFromISODate ( input . value ) ; }", "del_tokens": "input . value = this . getEuropeanDateFromISODate ( input . value ) ;", "commit_type": "fix"}
{"commit_tokens": ["FIXED", ":", "Scene", ".", "setBackground", "didn", "t", "use", "correct", "display", "target", "element"], "add_tokens": "// DOM element to use for the game (it will be cleared) this . target = target && target . length && target [ 0 ] || new Dom ( 'div' ) . css ( { width : ` ${ this . width } ` , height : ` ${ this . height } ` } ) . appendTo ( 'body' ) [ 0 ] ;", "del_tokens": "// DOM element to use for the game (it will be cleared) this . target = target && target . length && target [ 0 ] || new Dom ( 'div' ) . appendTo ( 'body' ) [ 0 ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "insert", "if", "not", "exists"], "add_tokens": "\"ifNotExists\" : { \"name\" : \"ifNotExists\" , \"grouping\" : \"ifNotExists\" } ,", "del_tokens": "\"ifNotExists\" : { \"name\" : \"ifNotExists\" , \"grouping\" : \"if\" } ,", "commit_type": "add"}
{"commit_tokens": ["fixed", "attributes", "gotcha", "and", "added", "form", ".", "html", "example"], "add_tokens": "attributes = slice . call ( node . attributes ) ,", "del_tokens": "attributes = node . attributes ,", "commit_type": "fix"}
{"commit_tokens": ["adding", "plualize", "to", "reset", "url", "append", "token", "to", "redirect"], "add_tokens": "func ( req , res , sails , params ) ; } else if ( typeof req . session . resetToken !== 'undefined' && req . session . resetToken = false ; res . json ( auth ) ; } ) ; return res . forbidden ( 'Your token is expired.' ) ; res . redirect ( authConfig . passwordReset . mail . forwardUrl + '?token=' + auth . resetToken ) ; }", "del_tokens": "func ( req , res , sails , params ) ; } else if ( typeof req . session . resetToken !== 'undefined' && req . session . resetToken = false ; res . json ( auth ) ; } ) ; return res . forbidden ( 'Your token is expired.' ) ; res . redirect ( authConfig . passwordReset . mail . forwardUrl ) ; }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "endsWith", "so", "that", "it", "works", "with", "list", "types", "better"], "add_tokens": "t . true ( endsWith ( [ 'a' ] , [ 'c' , 'b' , 'a' ] ) ) t . false ( endsWith ( 'b' , 'abc' ) )", "del_tokens": "t . true ( endsWith ( 1 , [ 3 , 2 , 1 ] ) ) t . false ( endsWith ( 1 , [ 3 , 2 , 12 ] ) ) t . true ( fn ( [ 'a' , 'b' , 'c' ] ) ) t . true ( fn ( [ 'c' ] ) ) t . false ( fn ( [ 12 ] ) )", "commit_type": "fix"}
{"commit_tokens": ["Added", "model", "property", "to", "List", ".", "set", "CHANGE", "event"], "add_tokens": "this . trigger ( new conbo . ConboEvent ( conbo . ConboEvent . CHANGE , { model : model } ) ) ;", "del_tokens": "this . trigger ( new conbo . ConboEvent ( conbo . ConboEvent . CHANGE ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "dot", "notation", "."], "add_tokens": "rule { ( threadf $v ( $ [ . ] $fn $args . . . ) ) } => { _sexpr ( . $fn $v $args . . . ) } rule { ( threadf $v ( $ [ . ] $fn $args . . . ) $x . . . ) } => { _sexpr ( threadf ( . $fn $v $args . . . ) $x . . . ) } //rule { (threadl $v ($[.]$fn $args ...)) } => { // _sexpr (.$fn $args ... $v) //} //rule { (threadl $v ($[.]$fn $args ...) $x ...) } => { // _sexpr (threadl (.$fn $args ... $v) $x ...) //} rule { ( $ [ . ] $fn $obj $args . . . ) } => { _sexpr $obj . $fn ( _args ( $args . . . ) ) } if ( i == 0 && el . token . value != ':' ) { ki_ast . push ( el ) ; } else { acc . push ( el ) ; }", "del_tokens": "acc . push ( el ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "0", "gas", "price", "on", "matic"], "add_tokens": "// NOTE: Gas Price is set to '0', take care of type of gasPrice on web3^1.0.0-beta.36 ! options . gasPrice ? ! web3 . matic ? await web3 . eth . getGasPrice ( ) : '0' : options . gasPrice ,", "del_tokens": "const gas = ! web3 . matic ? await web3 . eth . getGasPrice ( ) : 0 ! options . gasPrice ? gas : options . gasPrice ,", "commit_type": "fix"}
{"commit_tokens": ["Change", "uri", "regexp", "splitting", "to", "delimiter", "splitting"], "add_tokens": "split , split = uri . split ( '/' ) ; match = split [ 1 ] ; this . uri = uri . replace ( '/' + match , '' ) ;", "del_tokens": "match = uri . match ( / (\\/\\w+)\\/? / ) ; this . uri = uri . replace ( match [ 1 ] , '' ) ;", "commit_type": "change"}
{"commit_tokens": ["Move", "hooks", "and", "helpers", "into", "env"], "add_tokens": "'return function template(context, env) {\\n' + ' var hooks = env.hooks;\\n' +", "del_tokens": "'return function template(context, options) {\\n' + ' var hooks = options && options.hooks;\\n' + ' var helpers = options && options.helpers || {};\\n' +", "commit_type": "move"}
{"commit_tokens": ["Remove", "search", "from", "theme", "-", "default"], "add_tokens": "// Notify that gitbook is ready", "del_tokens": "var Search = require ( './core' ) . search ; var research ; // Init research research = new Search ( config ) ; console . log ( 'research:' ) ; console . log ( research ) ; research : research ,", "commit_type": "remove"}
{"commit_tokens": ["Use", "consistent", "zoom", "controls", "in", "2D", "and", "3D", "."], "add_tokens": "if ( scene . isDestroyed ( ) ) { return ; } map = L . map ( 'cesiumContainer' , { zoomControl : false } ) . setView ( [ - 28.5 , 135 ] , 5 ) ; this . _navigationWidget . showTilt = false ; this . _navigationWidget . showTilt = true ;", "del_tokens": "map = L . map ( 'cesiumContainer' , { zoomControl : false } ) . setView ( [ - 28.5 , 135 ] , 5 ) ; new L . Control . Zoom ( { position : 'topright' } ) . addTo ( map ) ; this . _navigationWidget . show = false ; this . _navigationWidget . show = true ;", "commit_type": "use"}
{"commit_tokens": ["added", "check", "for", "content", "type", "in", "parseBody"], "add_tokens": "if ( req . headers [ 'content-type' ] === 'application/json' ) { req . rawBody = JSON . stringify ( req . body ) ; } else { let result = [ ] ; for ( key in req . body ) { result . push ( ` ${ key } ${ req . body [ key ] } ` ) ; } req . rawBody = result . join ( '&' ) ;", "del_tokens": "let result = [ ] ; for ( key in req . body ) { result . push ( ` ${ key } ${ req . body [ key ] } ` ) ; req . rawBody = result . join ( '&' ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "readme", "and", "demo", ";", "updated", "build"], "add_tokens": "collection = new Collection ( models , { autoSelect : \"first\" , selectIfRemoved : \"prevNoLoop\" } ) ;", "del_tokens": "collection = new Collection ( models , { initialSelection : \"first\" , selectIfRemoved : \"prevNoLoop\" } ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "context", "issue", "in", "Function#prepareProperty"], "add_tokens": "overrideValue = getter . call ( this ) ;", "del_tokens": "overrideValue = getter ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "where", "slider", "value", "can", "become", "NaN"], "add_tokens": "this . setState ( function ( prevState ) { return { startValue : this . state . value [ i ] , startPosition : position !== undefined ? position : prevState . startPosition , index : i , zIndices : zIndices } ;", "del_tokens": "this . setState ( { startValue : this . state . value [ i ] , startPosition : position , index : i , zIndices : zIndices", "commit_type": "fix"}
{"commit_tokens": ["fixed", "a", "bug", "in", "eager", "evaluation"], "add_tokens": "var binding = makeBinding ( this . value ) ; if ( ! lazy ) { // This rule may or may not produce a value. If it doesn't, this.value is a value thunk w/ a value of undefined, // in which case it's ok to force it unconditionally. binding . value ; } return memo [ this . id ] = action . call ( addlInfo , binding ) ; args . forEach ( function ( arg ) { arg . value ; } ) ;", "del_tokens": "// This rule may or may not produce a value. If it doesn't, this.value is a value thunk w/ a value of undefined, // in which case it's ok to force it unconditionally. return memo [ this . id ] = action . call ( addlInfo , makeBinding ( this . value ) ) ; args . map ( function ( arg ) { arg . value ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "firefoxdeveloperedition", "alias", "on", "Linux"], "add_tokens": "if ( binaryPath === \"firefoxdeveloperedition\" ) { binaryPath = \"deved\" ; } \"firefox\" , \"deved\" , \"beta\" , \"nightly\" , \"aurora\" \"deved on osx\" : \"/Applications/FirefoxDeveloperEdition.app/Contents/MacOS/firefox-bin\" , \"deved on linux\" : \"firefox-developer-edition\" , \"deved on windows\" : \"Firefox Developer Edition\" ,", "del_tokens": "\"firefox\" , \"firefoxdeveloperedition\" , \"beta\" , \"nightly\" , \"aurora\" \"firefoxdeveloperedition on osx\" : \"/Applications/FirefoxDeveloperEdition.app/Contents/MacOS/firefox-bin\" , \"firefoxdeveloperedition on windows\" : \"Firefox Developer Edition\" ,", "commit_type": "add"}
{"commit_tokens": ["Add", "primary", "style", "for", "buttons", "etc"], "add_tokens": "'default' , 'info' , 'warning' , 'success' , 'danger' , 'primary'", "del_tokens": "'default' , 'info' , 'warning' , 'success' , 'danger'", "commit_type": "add"}
{"commit_tokens": ["updated", "to", "fall", "2017", "eslit", "home", ".", "js", "."], "add_tokens": "termId : '201810' ,", "del_tokens": "termId : '201710' ,", "commit_type": "update"}
{"commit_tokens": ["fixed", "issue", "with", "the", "services"], "add_tokens": "var result ; result = service . initialize ( ) ; return Promise . resolve ( result ) ; service . $name = name ; var builtServices = subdivision . build ( subdivision . systemPaths . services ) ; //TODO: This assumes that there is a builder side effect that adds the services to the services map var initializedServices = new Set ( ) ; return _ . reduce ( builtServices , function ( promise , service ) { if ( initializedServices . has ( service . $name ) ) { return promise ; } initializedServices . add ( service . $name ) ; subdivision . vent . trigger ( 'before:service:initialized' , service . $name ) ; return initializeServiceRecursive ( subdivision . getService ( service . $name ) ) . then ( function ( ) { subdivision . vent . trigger ( 'after:service:initialized' , service . $name , subdivision . getService ( service . $name ) ) ;", "del_tokens": "return service . initialize ( ) ; } else { return Promise . resolve ( ) ; var services = subdivision . build ( subdivision . systemPaths . services ) ; //TODO: This assumes that there is a builder side effect that adds the services to the services map return _ . reduce ( services , function ( promise , name ) { subdivision . vent . trigger ( 'before:service:initialized' , name ) ; return initializeServiceRecursive ( subdivision . getService ( name ) ) . then ( function ( ) { subdivision . vent . trigger ( 'after:service:initialized' , name , subdivision . getService ( name ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "zero", "padding", "in", "debug", "identifiers", "."], "add_tokens": "var debugKey = Math . random ( ) . toString ( 16 ) . slice ( 2 , 4 ) ;", "del_tokens": "var debugKey = Math . floor ( Math . random ( ) * 256 ) . toString ( 16 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "api", "docs", "to", "readme", "generation", "task"], "add_tokens": "return { } ;", "del_tokens": "grunt . registerTask ( 'docs' , 'Generate docs.' , [ 'concurrent:docs' , 'project-docs' ] ) ; return { tasks : { concurrent : { docs : { target : [ 'gitdown:readme' , 'jsdoc2md:api' ] } } } } ;", "commit_type": "add"}
{"commit_tokens": ["add", "events", "on", "the", "document", "scoping", "by", "target"], "add_tokens": "var generateGuid = Ember . geneateGuid ; var id = $element . attr ( 'id' ) ; if ( id == null ) { id = generateGuid ( ) ; $element . attr ( 'id' , id ) ; } $document . on ( event , '#' + id , eventManager [ event ] ) ; var id = $element . attr ( 'id' ) ; $document . off ( event , '#' + id , eventManager [ event ] ) ;", "del_tokens": "$element . on ( event , eventManager [ event ] ) ; $element . off ( event , eventManager [ event ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "username", "from", "arguments", "to", "validate", "callback", "."], "add_tokens": "self . _validate ( {", "del_tokens": "self . _validate ( creds . username , {", "commit_type": "remove"}
{"commit_tokens": ["Fix", "error", "on", "collapse", "for", "node", "with", "no", "links"], "add_tokens": "const rootConnectionsNodesIds = linksMatrix [ rootNodeId ] ? Object . keys ( linksMatrix [ rootNodeId ] ) : [ ] ;", "del_tokens": "const rootConnectionsNodesIds = Object . keys ( linksMatrix [ rootNodeId ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "expressions", "for", "the", "autoprefixed", "properties"], "add_tokens": "new RegExp ( currentReplacement . replacement , 'g' ) ,", "del_tokens": "currentReplacement . replacement ,", "commit_type": "fix"}
{"commit_tokens": ["add", "double", "colon", "cast", "in", "pg"], "add_tokens": "if ( expr . symbol === 'as' ) { return ` ${ exprToSQL ( expr . expr ) } ${ expr . symbol . toUpperCase ( ) } ${ expr . target . dataType } ${ str } ` } return ` ${ exprToSQL ( expr . expr ) } ${ expr . symbol . toUpperCase ( ) } ${ expr . target . dataType } ${ str } `", "del_tokens": "return ` ${ exprToSQL ( expr . expr ) } ${ expr . target . dataType } ${ str } `", "commit_type": "add"}
{"commit_tokens": ["fix", "mkdirSync", "location", "when", "given", "cwd", "option"], "add_tokens": "let dirPath = dir ; if ( typeof options . cwd !== ' dirPath = path . join ( options . cwd , dir ) ; if ( ! fs . existsSync ( dirPath ) ) { fs . mkdirsSync ( dirPath ) ;", "del_tokens": "if ( ! fs . existsSync ( dir ) ) { fs . mkdirsSync ( dir ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "property", "mocking", "to", "mock", "helper"], "add_tokens": "var propNames = [ ] ; Object . keys ( proto ) . forEach ( function ( propName ) { if ( typeof proto [ propName ] === 'function' ) { // Ignore the constructor if ( proto [ propName ] !== proto ) { methodNames . push ( propName ) ; } } else { propNames . push ( propName ) ; propNames . forEach ( function ( propName ) { Object . defineProperty ( mock , propName , { get : function ( ) { var propCallbacks = callbacks [ propName ] ; if ( ! propCallbacks || ! propCallbacks . length ) { throw new Error ( className + \" getter '\" + propName + \"' called but no handler was provided\" ) ; } var value = propCallbacks . shift ( ) . apply ( null , arguments ) ; return value ; } , enumerable : true , } ) ; } ) ;", "del_tokens": "Object . keys ( proto ) . forEach ( function ( methodName ) { // Ignore the constructor if ( proto [ methodName ] !== proto ) { methodNames . push ( methodName ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "bugs", "with", "logging", "and", "teardown"], "add_tokens": "logger . warn ( 'Unable to read config file ' + filePath ) ; if ( app . config . logFile && ! logger . transports [ 'file' ] ) { scarab . server . app . teardown ( function ( err ) {", "del_tokens": "logger . warn ( 'Error reading config file ' + filePath ) ; if ( app . config . logFile ) { app . teardown ( function ( err ) {", "commit_type": "fix"}
{"commit_tokens": ["update", "close", "connection", "log", "websocketgroup"], "add_tokens": "group . log . info ( this . toString ( ) , \"client connection closed with server (\" + group . getNodeName ( ) + \")\" ) ;", "del_tokens": "group . log . info ( this . toString ( ) , \"client connection closed with server (\" + ws . _socket . remoteAddress + \":\" + ws . _socket . remotePort + \")\" ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "exception", "handling", "to", "load"], "add_tokens": "try { if ( hadErrors ) { callback ( errors , null ) } else { callback ( null , results ) } } catch ( e ) { console . log ( e ) console . log ( e . stack )", "del_tokens": "if ( hadErrors ) { callback ( errors , null ) } else { callback ( null , results )", "commit_type": "add"}
{"commit_tokens": ["Use", "http", "-", "proxy", "xfwd", "option"], "add_tokens": "ws : true , xfwd : true", "del_tokens": "ws : true proxyReq . setHeader ( 'X-Forwarded-Proto' , 'https' )", "commit_type": "use"}
{"commit_tokens": ["Fix", "duplicate", "in", "format", ".", "js"], "add_tokens": "format . toDefaultTemplate ( function ( html ) { } , '../assets/html.hbs' ) ; format . toDefaultTemplate ( function ( md ) { } , '../assets/markdown.hbs' ) ;", "del_tokens": "format . toHTML ( function ( html ) { } ) ; format . toMarkdown ( function ( md ) { } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "extractTestDetails", "to", "strip", "out", "atomic", "units", "of", "the", "parsed", "input"], "add_tokens": "src : [ 'speck.js' , 'Gruntfile.js' , 'parsing/**/*.js' ]", "del_tokens": "src : [ 'speck.js' , 'Gruntfile.js' , '", "commit_type": "implement"}
{"commit_tokens": ["Updating", "gruntfile", ".", "js", "-", "fixing", "watch", "task", ".", "Removing", "unneeded", "dependencies", "."], "add_tokens": "\"http://localhost:8001/test/index.html\" base : \".\" , keepalive : true } } , qunit : { options : { port : 8001 , files : [ \"src/**/*.js\" , \"test/unit/*.js\" ] , tasks : [ \"jshint\" , \"connect:qunit\" , \"qunit\" ] grunt . registerTask ( \"default\" , [ \"jshint\" , \"connect:qunit\" , \"qunit\" , \"concat\" , \"uglify\" , \"node\" ] ) ;", "del_tokens": "\"http://localhost:8000/test/index.html\" files : \"<config:lint.files>\" , tasks : \"lint qunit\" grunt . loadNpmTasks ( \"grunt-contrib-less\" ) ; grunt . loadNpmTasks ( \"grunt-contrib-compress\" ) ; grunt . registerTask ( \"default\" , [ \"jshint\" , \"connect\" , \"qunit\" , \"concat\" , \"uglify\" , \"node\" ] ) ;", "commit_type": "update"}
{"commit_tokens": ["updated", "to", "use", "new", "stylesheet"], "add_tokens": "//wrench.copyDirSyncRecursive('./sdk/docs', '../gh-pages/sdk/docs'); 'lessc ./template/less/bootstrap.less > ../css/F2.css --compress | lessc ./template/less/bootstrap-docs.less > ../css/F2.Docs.css --compress | lessc ./template/less/bootstrap-sdk.less > ../css/F2.Sdk.css --compress' , outdir : '../gh-pages/sdk/' , docsAssets : '../' ,", "del_tokens": "wrench . copyDirSyncRecursive ( './sdk/docs' , '../gh-pages/sdk/docs' ) ; 'lessc ./template/less/bootstrap.less > ../css/F2.css --compress | lessc ./template/less/bootstrap-docs.less > ../css/F2.Docs.css --compress' , outdir : './sdk/docs' ,", "commit_type": "update"}
{"commit_tokens": ["Adding", "babel", "plugin", "to", "ensure", "displayName", "on", "classes", "when", "uglified"], "add_tokens": "import invariant from 'invariant' // Note: Component.displayName is being ensured via babel/plugins/class-display-name invariant ( typeof Component === 'string' || typeof Component . displayName !== 'undefined' , '%s is missing the property \"displayName\" which is needed for themeUtil.getComponentCss. ' + 'Once this code is minified the name will be obfuscated to something that is not useful.' , Component . name ) return typeof Component === 'string' ? Component : Component . displayName", "del_tokens": "return Component . displayName || Component . name || ( typeof Component === 'string' ? Component : 'Component' )", "commit_type": "add"}
{"commit_tokens": ["Allow", "apps", "to", "specify", "FastBoot", "dependencies"], "add_tokens": ". then ( addFastBootDeps ) . then ( function ( ) { return app . run ( 'npm' , 'install' ) ; } ) ; \"baz\" : \"0.2.0\" , \"rsvp\" : \"3.2.1\" 'baz' , 'rsvp' pkg [ 'fastbootDependencies' ] = [ \"rsvp\" ] ; pkg [ 'dependencies' ] = { rsvp : \"3.2.1\" } ;", "del_tokens": ". then ( addFastBootDeps ) ; \"baz\" : \"0.2.0\" 'baz'", "commit_type": "allow"}
{"commit_tokens": ["make", "things", "more", "aot", "friendly"], "add_tokens": ") , new AotPlugin ( { tsConfigPath : './tsconfig.json' } ) use : '@ngtools/webpack' ,", "del_tokens": ") // new AotPlugin({ // tsConfigPath: './tsconfig.json' // }) use : 'ts' ,", "commit_type": "make"}
{"commit_tokens": ["Fix", "_request", "-", ">", "request"], "add_tokens": "return request ( {", "del_tokens": "return _request ( {", "commit_type": "fix"}
{"commit_tokens": ["Added", "frisby", "tests", ".", "Fixed", "case", "in", "namespaces", ".", "Added", "new", "routes", "to", "support", "new", "controllers", ".", "Updated", "composer", "."], "add_tokens": "var baseURL = process . env . baseURL + '/ajax/users/roles/' ; beforeEach ( function ( ) { } ) ;", "del_tokens": "var baseURL = process . env . baseURL + '/users/roles/' ; beforeEach ( function ( ) { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "with", "supporting", "allOf", "references", "to", "model", "with", "circular", "reference"], "add_tokens": "it ( 'should handle allOf $ref to a definition with circular reference (Issue 38)' , function ( done ) { var cSwaggerDoc = _ . cloneDeep ( helpers . swaggerDoc ) ; cSwaggerDoc . definitions . A = { allOf : [ { $ref : '#/definitions/B' } ] , properties : { b : { $ref : '#/definitions/B' } } } ; cSwaggerDoc . definitions . B = { properties : { a : { $ref : '#/definitions/A' } } } ; cSwaggerDoc . definitions . C = { allOf : [ { $ref : '#/definitions/A' } ] } ; helpers . swaggerApi . create ( { definition : cSwaggerDoc } ) . then ( function ( api ) { assert . ok ( api . validate ( ) ) ; } ) . then ( done , done ) ; } ) ;", "del_tokens": "console . log ( paramValue . error ) ;", "commit_type": "fix"}
{"commit_tokens": ["made", "it", "so", "that", "when", "you", "call", "content", "and", "the", "there", "is", "only", "one", "item", "in", "the", "list", "it", "will", "return", "it", "instaed", "of", "the", "array"], "add_tokens": "Message . prototype . content = setOrGet ( 'content' , function ( ) { return [ ] ; } , function ( a ) { if ( typeof a === 'object' && a instanceof Array && a . length === 1 ) { return a [ 0 ] ; } else { return a ; } } ) ; function get ( name , def , onGet ) { onGet = onGet || f ; return onGet ( this . data [ name ] ) ; function set ( name , onSet ) { onSet = onSet || f ; this . data [ name ] = onSet ( v ) ; function setOrGet ( name , def , onGet , onSet ) { var g = get ( name , def , onGet ) , s = set ( name , onSet ) ; function f ( a ) { return a ; }", "del_tokens": "Message . prototype . content = setOrGet ( 'content' , function ( ) { return [ ] ; } ) ; function get ( name , def ) { return this . data [ name ] ; function set ( name ) { this . data [ name ] = v ; function setOrGet ( name , def ) { var g = get ( name , def ) , s = set ( name ) ;", "commit_type": "make"}
{"commit_tokens": ["Fixing", "verification", "of", "SelectProjectMixedColumns", "test", "."], "add_tokens": "obj [ 'avg_salary' ] , this . dataGenerator_ . employeeGroundTruth . avgSalary ,", "del_tokens": "obj . avgSalary , this . dataGenerator_ . employeeGroundTruth [ 'avg_salary' ] ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "scale", "=", "nnn", "param", "to", "debug", "scaling"], "add_tokens": "var matchStyle = location . search . match ( / s=([^&\\/]*) / ) ; var style = ( matchStyle && matchStyle [ 1 ] ) || 'osm-intl' ; var matchScale = location . search . match ( / scale=([.0-9]*) / ) ; var scale = ( matchScale && parseFloat ( matchScale [ 1 ] ) ) || bracketDevicePixelRatio ( ) ;", "del_tokens": "var match = location . search . match ( / s=([^&\\/]*) / ) ; var style = ( match && match [ 1 ] ) || 'osm-intl' ; var scale = bracketDevicePixelRatio ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "contextmenu", "not", "reposition", "at", "bottom", "of", "screen", "on", "IE"], "add_tokens": "var winHeight = $window . pageYOffset + event . view . innerHeight ; $document . find ( 'body' ) . off ( 'mousedown touchstart' , removeOnOutsideClickEvent ) ; // Cleanup any leftover contextmenus(there are cases with longpress on touch where we // still see multiple contextmenus) removeAllContextMenus ( ) ; $document . find ( 'body' ) . on ( 'mousedown touchstart' , removeOnOutsideClickEvent ) ;", "del_tokens": "var winHeight = $window . scrollY + event . view . innerHeight ; $document . find ( 'body' ) . off ( 'mousedown' , removeOnOutsideClickEvent ) ; $document . find ( 'body' ) . on ( 'mousedown' , removeOnOutsideClickEvent ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "SHA", "-", "1", "hash", "of", "our", "SteamID", "when", "enabling", "2FA"], "add_tokens": "hash . update ( self . steamID . getSteamID64 ( ) ) ;", "del_tokens": "hash . update ( Math . random ( ) . toString ( ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "lib", "/", "format", ":", "Custom", "consolidated", "response", "format"], "add_tokens": "FlightStats . formatStatus = require ( './format/status' ) FlightStats . formatSchedule = require ( './format/schedule' ) data = data ? FlightStats . formatStatus ( data ) : data data = data ? FlightStats . formatSchedule ( data ) : data", "del_tokens": "// data = data ? FlightStats.formatStatus( data ) : data // data = data ? FlightStats.formatSchedule( data ) : data", "commit_type": "add"}
{"commit_tokens": ["fix", "the", "strange", "case", "of", "canceled", "config", "writing"], "add_tokens": "console . log ( result . wroteFile ? 'Created config file!' : '' ) ;", "del_tokens": "console . log ( result ? 'Created config file!' : '' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "bug", "in", "the", "the", "Options", "code"], "add_tokens": "var srcChild = src [ topKey ] ; if ( dest [ topKey ] === undefined ) { dest [ topKey ] = srcChild ; } else { var childKeys = Object . keys ( srcChild ) ; for ( var j = 0 ; j < childKeys . length ; j ++ ) { var childKey = childKeys [ j ] ; var srcChildValue = srcChild [ childKey ] ; if ( srcChildValue !== undefined ) { dest [ topKey ] [ childKey ] = srcChildValue ; }", "del_tokens": "var child = src [ topKey ] ; var childKeys = Object . keys ( child ) ; for ( var j = 0 ; j < childKeys . length ; j ++ ) { var childKey = childKeys [ j ] ; var childValue = child [ childKey ] ; if ( childValue !== undefined ) { dest [ topKey ] [ childKey ] = childValue ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "ability", "to", "export", "styles", "in", "customStyleMap", "and", "default", "inline", "styles"], "add_tokens": "var _createStyles = ( 0 , _src2 . default ) ( [ 'color' , 'font-size' , 'text-transform' ] , 'CUSTOM_' ) , _react2 . default . createElement ( 'button' , { onClick : function onClick ( ) { return _this2 . updateEditorState ( _draftJs . RichUtils . toggleInlineStyle ( _this2 . state . editorState , 'ITALIC' ) ) ; } } , 'ITALIC' ) , // default inline styles if ( _draftJs . DefaultDraftInlineStyle [ style ] ) { var _inlineStyle = _defineProperty ( { } , style , _draftJs . DefaultDraftInlineStyle [ style ] ) ; return Object . assign ( { } , acc , _inlineStyle ) ; } // no matches if ( ! match || ! match [ 1 ] || ! match [ 2 ] ) { return acc ; } // custom styles", "del_tokens": "var _createStyles = ( 0 , _src2 . default ) ( [ 'font-size' , 'color' , 'text-transform' ] ) ,", "commit_type": "add"}
{"commit_tokens": ["change", "back", "to", "microgateway", "-", "util"], "add_tokens": "var getInterval = require ( 'microgateway-util/rate-limiting/get-interval.js' ) ;", "del_tokens": "var getInterval = require ( '../../../policies/rate-limiting/get-interval' ) ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "edge", "case", "when", "unwrapping", "objects", "."], "add_tokens": "unwrap : function ( response , resource , isObject ) { } else if ( response . data && response . data . hasOwnProperty ( resource . config . pluralName ) && ! isObject ) { response = railsRootWrapper . unwrap ( response , this . constructor , true ) ; return railsRootWrapper . unwrap ( response , config . resourceConstructor , false ) ;", "del_tokens": "unwrap : function ( response , resource ) { } else if ( response . data && response . data . hasOwnProperty ( resource . config . pluralName ) ) { response = railsRootWrapper . unwrap ( response , this . constructor ) ; return railsRootWrapper . unwrap ( response , config . resourceConstructor ) ;", "commit_type": "fix"}
{"commit_tokens": ["Made", "request", "-", "promise", "client", "local", "to", "each", "Foscam", "instance"], "add_tokens": "this . rpClient = rp . defaults ( { return this . rpClient . get ( this . url , options ) ;", "del_tokens": "rp = rp . defaults ( { return rp . get ( this . url , options ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "mocha", "-", "lint", "testing"], "add_tokens": "output [ i ] . name = ( path . replace ( '/' , '_' ) ) + output [ i ++ ] . name ;", "del_tokens": "output [ i ] . name = path + output [ i ++ ] . name ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "downloading", "remote", "files", "over", "https"], "add_tokens": "https = require ( 'https' ) , if ( parsedUrl . protocol == 'https:' ) { var req = https ; } else { var req = http ; } req = req . get ( options , function ( res ) {", "del_tokens": "var req = http . get ( options , function ( res ) {", "commit_type": "add"}
{"commit_tokens": ["implemented", "delta", "encoding", "of", "ids"], "add_tokens": "var id ; if ( i === 0 ) { id = pg . dense . id [ i ] . toNumber ( ) ; } else { id = get ( i - 1 ) . _id + pg . dense . id [ i ] . toNumber ( ) ; } _id : id , id : '' + id ,", "del_tokens": "id : pg . dense . id [ 0 ] . toString ( ) ,", "commit_type": "implement"}
{"commit_tokens": ["Added", "Spanish", "translation", ".", "Thanks", "to", "@pollin14", "."], "add_tokens": "* @ version 2.0 .2 lang : [ 'en' , 'pt' , 'ja' , 'hu' , 'it' , 'fr' , 'tr' , 'ru' , 'de' , 'ar' , 'nl' , 'pl' , 'vi' , 'zh' , 'el' , 'he' , 'es' ] ,", "del_tokens": "* @ version 2.0 .1 lang : [ 'en' , 'pt' , 'ja' , 'hu' , 'it' , 'fr' , 'tr' , 'ru' , 'de' , 'ar' , 'nl' , 'pl' , 'vi' , 'zh' , 'el' , 'he' ] ,", "commit_type": "add"}
{"commit_tokens": ["Update", "jquery", "-", "scrolltofixed", ".", "js"], "add_tokens": "target . addClass ( base . options . baseClassName ) ; zIndex : 1000 , baseClassName : 'scroll-to-fixed-fixed'", "del_tokens": "target . addClass ( 'scroll-to-fixed-fixed' ) ; zIndex : 1000", "commit_type": "update"}
{"commit_tokens": ["updated", "seed", "with", "compilable", "code", ";", "updated", "generator", "to", "produce", "nearly", "complete", "compilable", "code!"], "add_tokens": "timerFunc += ` ${ prefix } ${ state . stateName } ${ state . path . length } \\n ` ; timerFunc += ` ${ prefix } \\n ` ; irqFunc += ` ${ prefix } ${ state . stateName } ${ state . path . length } \\n ` ; var states = [ ] for ( var objPath in self . projectObjects ) { var obj = self . projectObjects [ objPath ] ; if ( obj . type == 'State' ) { states . push ( obj ) ; } } 'states' : states self . artifacts [ libFileName ] += '\\n' + event . function ;", "del_tokens": "timerFunc += ` ${ prefix } ${ state . path . length } ${ state . path } \\n ` ; timerFunc += ` ${ prefix } \\n ` ; irqFunc += ` ${ prefix } ${ state . path . length } ${ state . path } \\n ` ; self . artifacts [ libFileName ] += event . function ;", "commit_type": "update"}
{"commit_tokens": ["Updating", "superficial", "details", "about", "the", "libwebsockets", "-", "test", "-", "server", "implementation"], "add_tokens": "console . log ( ( new Date ( ) ) + \" lws-mirror-protocol connection accepted from \" + connection . remoteAddress ) ; console . log ( ( new Date ( ) ) + \" dumb-increment-protocol onnection accepted from \" + connection . remoteAddress ) ; console . log ( ( new Date ( ) ) + \" Peer \" + connection . remoteAddress + \" disconnected\" ) ;", "del_tokens": "console . log ( ( new Date ( ) ) + \" Connection accepted.\" ) ; console . log ( ( new Date ( ) ) + \" Connection accepted from \" + connection . remoteAddress ) ; console . log ( ( new Date ( ) ) + \" Client \" + connection . remoteAddress + \" disconnected\" ) ;", "commit_type": "update"}
{"commit_tokens": ["add", "legal", "info", "comment", "cli", "options", "not", "implemented", "yet", "from", "the", "help"], "add_tokens": "import { printLegalInformation } from './legal' ; legal : boolean , l : boolean , [ key : string ] : boolean | string , // -m, --main ns-name Call the -main function from a namespace with args // - Run a script from standard input 'legal' , l : 'legal' , const { help , legal , repl , quiet } = opts ; if ( legal ) { return printLegalInformation ( ) ; }", "del_tokens": "[ key : string ] : boolean | string , - m , -- main ns - name Call the - main function from a namespace with args - Run a script from standard input const { help , repl , quiet } = opts ;", "commit_type": "add"}
{"commit_tokens": ["Add", "version", "API", "runtime", ".", "version", "()"], "add_tokens": "cons . write ( 'runtime.js v' + runtime . version ( ) . join ( '.' ) , messageColorLight ) ;", "del_tokens": "cons . write ( 'runtime.js' , messageColorLight ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "types", "to", "resolve", "theme"], "add_tokens": "function _resolveTheme ( source : string , data : Object , identifier : string ) {", "del_tokens": "function _resolveTheme ( source , data , identifier ) {", "commit_type": "add"}
{"commit_tokens": ["changed", "default", "route", "to", "rosemary", "-", "ui"], "add_tokens": "< Route path = \"/rosemary-ui/\" component = { TimelogLibrary } >", "del_tokens": "< Route path = \"/\" component = { TimelogLibrary } >", "commit_type": "change"}
{"commit_tokens": ["Fixed", "Prev", "/", "Next", "Buttons"], "add_tokens": "this . playItem ( i ) ; this . playItem ( i ) ;", "del_tokens": "this . playItem ( wjsPlayer . currentItem ( ) + 1 ) ; this . playItem ( this . currentItem ( ) - 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "badges", "usage", "and", "installation", "to", "README"], "add_tokens": "* Exports a function that builds a middleware to render an HTML sitemap * Builds an express middleware that renders an HTML sitemap based let html if ( ! html ) html = view ( parseRoutes ( app ) ) * Returns an array of Endpoint objects containing : the methods ; and", "del_tokens": "* Exports a function that builds a middleware to render a html sitemap * Builds an express middleware that renders a html sitemap based let toc if ( ! toc ) toc = parseRoutes ( app ) const html = view ( toc ) * Returns an array of Enddpoint objects containing : the methods ; and", "commit_type": "add"}
{"commit_tokens": ["adding", "some", "tests", "and", "documentation", "on", "the", "code"], "add_tokens": "module . exports = { PRE_ANNOTATION : 999 , ANNOTATION : 1000 , POST_ANNOTATION : 1001", "del_tokens": "var sequence ; sequence = { ANNOTATION : 1000 module . exports = sequence ;", "commit_type": "add"}
{"commit_tokens": ["move", "generic", "streams", "to", "index"], "add_tokens": "var pswitch = require ( 'pull-switch' ) var u = require ( './util' ) var bsum = u . bsum var sbs return sbs = { return Feed ( db , id , keys ) pl . read ( db , { gte : first , lte : last , keys : false } ) , } , createReadStream : function ( opts ) { return this . createFeedStream ( ) } , createWriteStream : function ( cb ) { var cbs = u . groups ( cb ) return pswitch ( function ( msg ) { return msg . author . toString ( 'hex' ) } , function ( msg ) { var key = msg . author . toString ( 'hex' ) feeds [ key ] = feeds [ key ] || sbs . feed ( msg . author ) return feeds [ key ] . createWriteStream ( cbs ( ) ) } )", "del_tokens": "function bsum ( value ) { return new Blake2s ( ) . update ( value ) . digest ( ) } return { return Feed ( db , keys ) pl . read ( db , { gt : first , lte : last , keys : false } ) ,", "commit_type": "move"}
{"commit_tokens": ["removed", "initialize", "anti", "-", "pattern", "in", "favor", "of", "using", "constructor", ".", "combined", "Button", "constructor", "arguments", "into", "idiomatic", "single", "options", "object"], "add_tokens": "srcDown : this . _resolveUrl ( navImages . zoomIn . DOWN ) , srcDown : this . _resolveUrl ( navImages . zoomOut . DOWN ) , srcDown : this . _resolveUrl ( navImages . home . DOWN ) , srcDown : this . _resolveUrl ( navImages . fullpage . DOWN ) ,", "del_tokens": "srcDown : this . _resolveUrl ( navImages . zoomIn . DOWN ) } , { srcDown : this . _resolveUrl ( navImages . zoomOut . DOWN ) } , { srcDown : this . _resolveUrl ( navImages . home . DOWN ) } , { srcDown : this . _resolveUrl ( navImages . fullpage . DOWN ) } , {", "commit_type": "remove"}
{"commit_tokens": ["Updated", "help", "text", "to", "be", "more", "descriptive", "about", "shieldStyle", "parameter"], "add_tokens": "// The style of shield icon to generate (plastic, flat-square, flat)", "del_tokens": "// The type of shield icon to generate (plastic, flat-square, flat)", "commit_type": "update"}
{"commit_tokens": ["Allow", "selectors", "to", "work", "with", "action", "constants"], "add_tokens": "LP_API_ACTION_NAMESPACE , // Remove action namespace if it's at the beginning function stripNamespace ( requestKey ) { return requestKey . startsWith ( LP_API_ACTION_NAMESPACE ) ? requestKey . slice ( LP_API_ACTION_NAMESPACE . length ) : requestKey } const key = stripNamespace ( requestKey ) if ( ! key || ! state ) throw new Error ( 'Must include key and state params' ) return get ( ` ${ slice } ${ key } ` , state )", "del_tokens": "if ( ! requestKey || ! state ) throw new Error ( 'Must include key and state params' ) return get ( ` ${ slice } ${ requestKey } ` , state )", "commit_type": "allow"}
{"commit_tokens": ["Fix", "bug", "to", "do", "with", "stale", "scope", "path", "references"], "add_tokens": "it ( 'should not inline in a different scope' , ( ) => { var x = function ( a ) { return a ; } ; while ( 1 ) x ( 1 ) ; var x = function ( a ) { while ( 1 ) x ( 1 ) ;", "del_tokens": "it ( 'should inline function expression (complex)' , ( ) => { ( function ( ) { return ( function ( a ) { return a ; } ) ( 1 ) ; } ) ( ) ; var x = function ( a ) { var y = function ( ) { return x ( 1 ) ; } ; y ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "const", "error", "in", "finalizeIndexCreation"], "add_tokens": "let modelIndexCount = 0 ;", "del_tokens": "const modelIndexCount = 0 ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "shallow", "copy", "bug", "regen", "combined"], "add_tokens": "DateGraph . DEFAULT_ATTRS = { highlightCircleSize : 3 , pixelsPerXLabel : 60 , labelsDivWidth : 250 , labelsDivStyles : { } } ; this . attrs_ = { } ; MochiKit . Base . update ( this . attrs_ , DateGraph . DEFAULT_ATTRS ) ; var _112 = this . attrs_ . highlightCircleSize ;", "del_tokens": "DateGraph . DEFAULT_ATTRS = { pixelsPerXLabel : 60 , labelsDivWidth : 250 , labelsDivStyles : { } } ; this . attrs_ = DateGraph . DEFAULT_ATTRS ; var _112 = 3 ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "to", "accept", "db", "username", "and", "password"], "add_tokens": "var dbURI ; if ( dbConfig . userName && dbConfig . password ) { dbURI = 'mongodb://' + dbConfig . userName + ':' + dbConfig . password + '@' + dbConfig . host + ':' + dbConfig . port + '/' + dbConfig . name ; } else { dbURI = 'mongodb://' + dbConfig . host + ':' + dbConfig . port + '/' + dbConfig . db ; } db : options . db || 'sessionStore' , userName : options . userName , password : options . password", "del_tokens": "var dbURI = 'mongodb://' + dbConfig . host + ':' + dbConfig . port + '/' + dbConfig . db ; db : options . db || 'sessionStore'", "commit_type": "update"}
{"commit_tokens": ["Updated", "running", "of", "separate", "grunt", "tasks", "from", "patsy", "and", "added", "check", "symbol", "for", "passed", "tests"], "add_tokens": "console . log ( String ( '✓ Module ' + m dule + ' found!'). g r een);", "del_tokens": "console . log ( '>> ' . green + 'Module ' + module + ' found!' ) ;", "commit_type": "update"}
{"commit_tokens": ["change", "marker", "s", "default", "symbol", "to", "vector", "marker", "symbol"], "add_tokens": "'symbol' : { 'markerType' : 'pie' , 'markerHeight' : 24 , 'markerWidth' : 24 , 'markerFill' : \"#de3333\" , \"markerLineColor\" : \"#ffffff\" , \"markerLineWidth\" : 1", "del_tokens": "'symbol' : { 'markerType' : 'pin' , 'markerHeight' : 26 , 'markerWidth' : 18", "commit_type": "change"}
{"commit_tokens": ["added", "config", "parameter", "for", "requires", "AWS", "configurations"], "add_tokens": "AWS . mock = function ( service , method , replace , config ) { mockService ( service , method , replace , config ) ; function mockService ( service , method , replace , config ) { var client = new services [ service ] . Constructor ( config ) ;", "del_tokens": "AWS . mock = function ( service , method , replace ) { mockService ( service , method , replace ) ; function mockService ( service , method , replace ) { var client = new services [ service ] . Constructor ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "method", "of", "referencing", "window"], "add_tokens": "( function ( module ) module [ 'jsSHA' ] = jsSHA ; } ( this ) ) ;", "del_tokens": "( function ( window ) window [ 'jsSHA' ] = jsSHA ; } ( window ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Updated", "to", "latest", "assigned", "numbers"], "add_tokens": "\"fe02\" : \"Robert Bosch GmbH\" , \"fe01\" : \"Duracell U.S. Operations Inc.\" , \"fe00\" : \"Amazon Fulfillment Services Inc.\" , \"fdff\" : \"OSRAM GmbH\" , \"fdfe\" : \"ADHERIUM(NZ) LIMITED\" , \"fdfd\" : \"RecursiveSoft Inc.\" , \"fdfc\" : \"Optrel AG\" , \"fdfb\" : \"Tandem Diabetes Care\" , \"fdfa\" : \"Tandem Diabetes Care\"", "del_tokens": "\"fe02\" : \"Robert Bosch GmbH\"", "commit_type": "update"}
{"commit_tokens": ["Updated", "the", "example", "to", "reflect", "the", "now", "mandatory", "object", "creation"], "add_tokens": "var Wanted = require ( './lib/wanted' ) , wanted = new Wanted ( ) ; console . log ( 'installing' , install ) ; console . log ( 'ready' ) ; wanted . check ( { scope : 'devDependencies' } ) ;", "del_tokens": "var wanted = require ( './lib/wanted' ) ; console . log ( 'install' , install ) ; console . log ( 'ready' , wanted ) ; wanted . check ( { scope : 'dependencies' } ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "error", "when", "trying", "to", "insert", "morph", "many", "relation", "with", "value", "of", "null"], "add_tokens": "import { createStore , createState } from 'test/support/Helpers' it ( 'can create morph many relation with value of null' , async ( ) => { class Post extends Model { static entity = 'posts' static fields ( ) { return { id : this . attr ( null ) , comments : this . morphMany ( Comment , 'commentable_id' , 'commentable_type' ) } } } class Comment extends Model { static entity = 'comments' static fields ( ) { return { id : this . attr ( null ) , body : this . attr ( '' ) , commentable_id : this . attr ( null ) , commentable_type : this . attr ( null ) } } } const store = createStore ( [ { model : Post } , { model : Comment } ] ) await store . dispatch ( 'entities/posts/create' , { data : { id : 1 , comments : null } } ) const expected = createState ( { posts : { '1' : { $id : 1 , id : 1 , comments : [ ] } } , comments : { } } ) expect ( store . state . entities ) . toEqual ( expected ) } )", "del_tokens": "import { createStore } from 'test/support/Helpers'", "commit_type": "fix"}
{"commit_tokens": ["make", "client", "-", "session", "self", "-", "aware"], "add_tokens": "const propertyName = opts . requestKey || opts . cookieName ; if ( req [ propertyName ] ) { return next ( ) ; //self aware } req [ propertyName ] = raw_session . monitor ( ) ;", "del_tokens": "req [ opts . requestKey || opts . cookieName ] = raw_session . monitor ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Fixed", "a", "typo", "in", "a", "function", "name", "."], "add_tokens": "LJM_FUNCTIONS . LJM_OpenAll = {", "del_tokens": "LJM_FUNCTIONS . ljM_OpenAll = {", "commit_type": "fix"}
{"commit_tokens": ["Make", "better", "use", "of", "harmony", "features", "in", "harmony", "examples"], "add_tokens": "\"use strict\" ; let platform = require ( 'git-node-platform' ) ; let jsGit = require ( '../.' ) ( platform ) ; let fsDb = require ( 'git-fs-db' ) ( platform ) ; let fs = platform . fs ; let run = require ( 'gen-run' ) ; let repo = jsGit ( fsDb ( fs ( \"test.git\" ) ) ) ; let mock = require ( './mock.js' ) ; let head ; mode : 33188 , // 0100644, let obj = { } ; for ( let key in object ) { let value = object [ key ] ;", "del_tokens": "var platform = require ( 'git-node-platform' ) ; var jsGit = require ( '../.' ) ( platform ) ; var fsDb = require ( 'git-fs-db' ) ( platform ) ; var fs = platform . fs ; var run = require ( 'gen-run' ) ; var repo = jsGit ( fsDb ( fs ( \"test.git\" ) ) ) ; var mock = require ( './mock.js' ) ; var head ; mode : 0100644 , var obj = { } ; for ( var key in object ) { var value = object [ key ] ;", "commit_type": "make"}
{"commit_tokens": ["Added", "warning", "for", "removed", "transformGutter", "-", "parameter", "."], "add_tokens": "// warning about removed parameter if ( options . transformGutter !== undefined ) { grunt . log . error ( \"Parameter 'transformGutter' is no longer supported. See #71 for details.\" ) ; }", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Add", "timeout", "option", "for", "globalSetup"], "add_tokens": "// Clone globalSetup (not reference) var _gs = cloneObject ( globalSetup ( ) ) ; request : _gs . request , this . _timeout = _gs . timeout || 5000 ; exports . version = '0.5.5' ;", "del_tokens": "request : cloneObject ( globalSetup ( ) . request ) , this . _timeout = 5000 ; exports . version = '0.5.4' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "promises", "support", "for", "the", "connection", "method"], "add_tokens": "if ( callback ) { // allow to register the error callback later process . nextTick ( function ( ) { new Chrome ( options , notifier ) ; } ) ; return notifier . on ( 'connect' , callback ) ; } else { return new Promise ( function ( fulfill , reject ) { notifier . on ( 'connect' , fulfill ) ; notifier . on ( 'error' , reject ) ; new Chrome ( options , notifier ) ; } ) ;", "del_tokens": "if ( typeof callback === 'function' ) { notifier . on ( 'connect' , callback ) ; // allow to register callbacks later process . nextTick ( function ( ) { // the default listener just disconnects from Chrome, this can be used // to simply check the connection if ( notifier . listeners ( 'connect' ) . length === 0 ) { notifier . on ( 'connect' , function ( chrome ) { chrome . close ( ) ; } ) ; } // create the client passing the notifier new Chrome ( options , notifier ) ; } ) ; return notifier ;", "commit_type": "add"}
{"commit_tokens": ["Added", "bouncing", "to", "Player", "paddle", "on", "edges", "of", "screen"], "add_tokens": "// Setup dimensions. var levelWidth = 600 ; var levelHeight = 400 ; var renderer = PIXI . autoDetectRenderer ( levelWidth , levelHeight ) ; var PlayerPaddleSystem = function ( ) { var verticalBounce = function ( entity ) { entity . c . velocity . yspeed *= - 1.4 ; } ; if ( entity . has ( 'player' ) && entity . has ( 'paddle' ) ) { // Handle player input. // Add friction to paddle. // Stop paddle from leaving screen. if ( entity . c . position . y < 0 ) { verticalBounce ( entity ) ; } if ( entity . c . position . y + entity . c . paddle . height > levelHeight ) { verticalBounce ( entity ) ; } world . register ( new PlayerPaddleSystem ( ) ) ; . attach ( { 'id' : 'player' } ) 'friction' : 0.9 , 'height' : 128 , 'width' : 16", "del_tokens": "var renderer = PIXI . autoDetectRenderer ( 600 , 400 ) ; var PaddleSystem = function ( ) { if ( entity . has ( 'paddle' ) ) { world . register ( new PaddleSystem ( ) ) ; 'friction' : 0.9", "commit_type": "add"}
{"commit_tokens": ["fix", "npm", "version", "vs", "git"], "add_tokens": "export const VERSION = \"0.5.2\" ;", "del_tokens": "export const VERSION = \"0.4.4\" ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "a", "test", "name", "."], "add_tokens": "\"it has the same length as its mutable equivalent\" : {", "del_tokens": "\"it has the same length as the length of its constructor mutable\" : {", "commit_type": "improve"}
{"commit_tokens": ["Allow", "transform", "scale", "to", "accept", "a", "scalar", "value"], "add_tokens": "if ( ! isNaN ( scope . scale ) ) { scope . scale = new THREE . Vector3 ( scope . scale , scope . scale , scope . scale ) ; }", "del_tokens": "", "commit_type": "allow"}
{"commit_tokens": ["Added", "regexp", "escaping", "for", "shortpath", "creation", "."], "add_tokens": "var ESCAPE_CHARACTERS = / [-\\/\\\\^$*+?.()|[\\]{}] / g ; function escapeRx ( str ) { return str . replace ( ESCAPE_CHARACTERS , '\\\\$&' ) ; } var shortPath = fullPath . replace ( new RegExp ( '^' + escapeRx ( basePath ) , 'i' ) , '' ) ;", "del_tokens": "var shortPath = fullPath . replace ( new RegExp ( '^' + basePath , 'i' ) , '' ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "typo", "and", "don", "t", "scroll", "when", "unlocking", "the", "highlight"], "add_tokens": "this . _lockHighlight ( i ) ; this . _lockHighlight ( null ) ; this . _lockHighlight ( null ) ; _lockHighlight ( index : ? number ) { this . _listItems [ newVisibleHighlightedIndex ] . control . notifyHighlighted ( true , false ) ;", "del_tokens": "this . _lockHightlight ( i ) ; this . _lockHightlight ( null ) ; this . _lockHightlight ( null ) ; _lockHightlight ( index : ? number ) { this . _listItems [ newVisibleHighlightedIndex ] . control . notifyHighlighted ( true , true ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "memory", "leakage", "after", "calling", "unregisterAll", "()"], "add_tokens": "const windowsEventCallbacks = new WeakMap ( ) ; /* unregister all event callbacks */ const eventCallbacks = windowsEventCallbacks . get ( win ) ; for ( let key in eventCallbacks ) { win . removeListener ( key , eventCallbacks [ key ] ) ; } windowsEventCallbacks . delete ( win ) ; const eventCallbacks = { 'close' : _unregister ( 'the window was closed.' ) , 'hide' : _unregister ( 'the window was hidden.' ) , 'minimize' : _unregister ( 'the window was minimized.' ) , 'restore' : _register ( 'the window was restored from minimized state.' ) , 'show' : _register ( 'the window was showed.' ) } ; for ( let key in eventCallbacks ) { win . on ( key , eventCallbacks [ key ] ) ; } windowsEventCallbacks . set ( win , eventCallbacks ) ;", "del_tokens": "win . on ( 'close' , _unregister ( 'the window was closed.' ) ) ; win . on ( 'hide' , _unregister ( 'the window was hidden.' ) ) ; win . on ( 'minimize' , _unregister ( 'the window was minimized.' ) ) ; win . on ( 'restore' , _register ( 'the window was restored from minimized state.' ) ) ; win . on ( 'show' , _register ( 'the window was showed.' ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Created", "a", "promise", "-", "based", "Cleaver", "service"], "add_tokens": "Cleaver = require ( './render' ) ; var cleaver = new Cleaver ( contents , argv ) ; cleaver . run ( ) ; } ) ;", "del_tokens": "path = require ( 'path' ) , render = require ( './render' ) . render ; CLEAVER_ROOT = path . normalize ( __dirname + '/../' ) ; render ( contents , argv ) ; } ) ;", "commit_type": "create"}
{"commit_tokens": ["Add", "vertical", "bars", "between", "lat", "/", "lon", "/", "elev", "."], "add_tokens": "' | Lon: ' + Math . abs ( CesiumMath . toDegrees ( cartographic . longitude ) ) . toFixed ( 3 ) + '&deg; ' + strWE ; text += ' | Elev: ' + terrainPos [ 0 ] . height . toFixed ( 1 ) + ' m' ;", "del_tokens": "' Lon: ' + Math . abs ( CesiumMath . toDegrees ( cartographic . longitude ) ) . toFixed ( 3 ) + '&deg; ' + strWE ; text += ' Elev: ' + terrainPos [ 0 ] . height . toFixed ( 1 ) + ' m' ;", "commit_type": "add"}
{"commit_tokens": ["added", "some", "new", "properties", "to", "the", "sort", "order"], "add_tokens": ", 'transform' , 'box-align' , 'box-flex' , 'box-orient' , 'box-pack' , 'box-sizing'", "del_tokens": ", 'box-sizing'", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "distinction", "between", "type", "constraint", "on", "element", "or", "value"], "add_tokens": "constructor ( isA , path , onValue ) { this . _onValue = onValue ; get onValue ( ) { return this . _onValue ; }", "del_tokens": "constructor ( isA , path ) {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "issue", "of", "CONTENT_RESUME_REQUESTED", "hiding", "non", "-", "linear", "ads", "."], "add_tokens": "if ( currentAd && currentAd . isLinear ( ) ) { adContainerDiv . style . display = 'none' ; }", "del_tokens": "adContainerDiv . style . display = 'none' ;", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "a", "mock", "Domain", "module", "for", "older", "node", "versions"], "add_tokens": ", Domain try { Domain = require ( 'domain' ) } catch ( err ) { Domain = function Domain ( ) { var self = this ; this . run = function ( fn ) { setTimeout ( function ( ) { try { fn ( ) } catch ( err ) { self . emit ( 'error' , err ) ; } } , 0 ) ; } ; } ; Domain . prototype = EventEmitter . prototype Domain . createDomain = function ( ) { return new Domain ( ) ; } ; }", "del_tokens": ", Domain = require ( 'domain' )", "commit_type": "implement"}
{"commit_tokens": ["Removed", "well", "-", "known", "classes"], "add_tokens": "return 'gdbots/common/' + moduleName . substr ( 4 ) ;", "del_tokens": "return 'gdbots/' + moduleName . substr ( 4 ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "client", "state", "support", "."], "add_tokens": "passport = require ( \"passport\" ) , crypto = require ( \"crypto\" ) ; wrap_callback : opts . callbackUrl if ( ( opts . useClientState || true ) ) { query . wrap_client_state = crypto . randomBytes ( 16 ) . toString ( \"hex\" ) ; req . session . wrapClientState = query . wrap_client_state ; }", "del_tokens": "passport = require ( \"passport\" ) ; wrap_callback : req . originalUrl || req . url", "commit_type": "add"}
{"commit_tokens": ["Removed", "csp", "error", "message", "comming", "from", "svg", "-", "sprite", "-", "loader", ":", "hammer", ":"], "add_tokens": "loader : 'svg-sprite?' + JSON . stringify ( { name : '[name]_[hash]' , spriteModule : path . join ( __dirname , 'config/csp-proof-sprite' ) } )", "del_tokens": "loader : 'svg-sprite?name=[name]_[hash]'", "commit_type": "remove"}
{"commit_tokens": ["fix", "a", "bug", "that", "mousemove", "handler", "won", "t", "properly", "removed", "when", "componentWillUnmount"], "add_tokens": "__getMouseMoveDocumentHandler : function ( ) { if ( ! this . __mouseMoveDocumentHandler ) { this . __mouseMoveDocumentHandler = handleMouseMoveDocument . bind ( this ) ; } return this . __mouseMoveDocumentHandler ; } , on ( document , 'mousemove' , this . __getMouseMoveDocumentHandler ( ) ) ; off ( document , 'mousemove' , this . __getMouseMoveDocumentHandler ( ) ) ; mouseLocs = [ ] ; this . __mouseMoveDocumentHandler = null ;", "del_tokens": "on ( document , 'mousemove' , handleMouseMoveDocument . bind ( this ) ) ; off ( document , 'mousemove' , this . handleMouseMoveDocument ) ; mouseLocs = null ;", "commit_type": "fix"}
{"commit_tokens": ["adding", "extra", "entries", "to", "switch", "."], "add_tokens": "const buildProcedureCall = require ( '../procedure-call' ) ; const proto = require ( '../utilities/proto' ) ; const decoders = require ( '../decoders' ) ; decode : proto . krpc . schema . Service decode : proto . krpc . schema . Stream decode : null decode : proto . krpc . schema . List decode : decoders . enum ( { 0 : 'SpaceCenter' , 1 : 'Flight' , 2 : 'TrackingStation' , 3 : 'EditorVAB' , 4 : 'EditorSPH' } )", "del_tokens": "let buildProcedureCall = require ( '../procedure-call' ) ; let proto = require ( '../utilities/proto' ) ; decode : proto . krpc . schema . Status decode : proto . krpc . schema . Status decode : proto . krpc . schema . Status decode : proto . krpc . schema . Status decode : proto . krpc . schema . Status", "commit_type": "add"}
{"commit_tokens": ["updated", "SanitizeHtmlService", "do", "remove", "unused", "tags", "from", "texts"], "add_tokens": "'p' , //'pre', //'blockquote', 'br' , //'h1', 'h2', 'h3', 'h4', 'h5','h5', //'ul', 'ol', 'nl', 'li'", "del_tokens": "'p' , 'pre' , 'blockquote' , 'br' , 'h1' , 'h2' , 'h3' , 'h4' , 'h5' , 'h5' , 'ul' , 'ol' , 'nl' , 'li'", "commit_type": "update"}
{"commit_tokens": ["changed", "error", "bubbling", "&", "fatal$", ":", "false", "override"], "add_tokens": "this . _seneca = seneca . delegate ( { fatal$ : false } ) this . _allowedProperties = { } this . _allowedProperties = properties err . code = ACL_ERROR_CODE err . critical = false", "del_tokens": "this . _seneca = seneca this . _allowedProperties = { } ; debug ( JSON . stringify ( args ) ) this . _allowedProperties = properties ; err . code = ACL_ERROR_CODE err . status = 403 err . seneca = seneca err . toString = selfErrorString function selfErrorString ( ) { var jsonReadyError = { summary : this . summary , message : this . message , status : this . status , code : this . code , reason : this . reason } ; return JSON . stringify ( jsonReadyError ) ; }", "commit_type": "change"}
{"commit_tokens": ["Changed", "phonegap", "to", "use", "gap", ":", "//", "command", "/", "arguments", "URLs", "for", "commands", "complete", "with", "URI", "encoding"], "add_tokens": "if ( ! window . console && DEBUG ) { log : function ( message ) { Device . exec ( 'consolelog' , 'LOG' , message ) ; error : function ( message ) { Device . exec ( 'consolelog' , 'ERROR' , message ) ; } else if ( ! window . console ) { console = { log : function ( ) { } , error : function ( message ) { } } Device . run_command ( u ) ; exec : function ( ) { Device . events . push ( arguments ) ; } , run_command : function ( args ) { var uri = [ ] ; for ( var i = 1 ; i < args . length ; i ++ ) { uri . push ( encodeURIComponent ( args [ i ] ) ) ; } document . location = \"gap://\" + args [ 0 ] + \"/\" + uri . join ( \"/\" ) ;", "del_tokens": "if ( ! window . console || ! DEBUG ) { log : function ( ) { error : function ( ) { } run_command = function ( cmd ) { document . location = \"gap:\" + cmd ; run_command ( u ) ; exec : function ( command ) { Device . events . push ( command ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "support", "for", "recording", "buffers", "in", "mock", "mode"], "add_tokens": "it ( 'should record buffers when mocked' , function ( finished ) { var statsd = new StatsD ( { mock : true } ) ; statsd . send ( 'test' , { } , function ( ) { assert . deepEqual ( statsd . mockBuffer , [ 'test' ] ) ; finished ( ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["updating", "the", "plugin", "name", "and", "its", "address", "in", "annotation"], "add_tokens": "* grunt - inline * https : //github.com/chyingp/grunt-inline", "del_tokens": "* casper - inline * https : //github.com/tactivos/casper-inline", "commit_type": "update"}
{"commit_tokens": ["Add", "error", "handling", "around", "RSAA", ".", "ok", "function"], "add_tokens": "import { InvalidRSAA , RequestError , InternalError } from './errors' ; let res ; res = await doFetch ( endpoint , { let isOk ; try { isOk = ok ( res ) } catch ( e ) { return next ( await actionWith ( { ... failureType , payload : new InternalError ( '[RSAA].ok function failed' ) , error : true } , [ action , getState ( ) , res ] ) ) ; } if ( isOk ) {", "del_tokens": "import { InvalidRSAA , RequestError } from './errors' ; var res = await doFetch ( endpoint , { if ( ok ( res ) ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "check", "to", "ignore", "non", "-", "mendelified", "files", "for", "mendel", "-", "requirify", "server", "output", "."], "add_tokens": "if ( ! row . variation ) { // mendelify did now find a match, // i.e. file is outside base or variation dirs, skipping. return done ( ) ; } var file = row . file || row . id ; var nm = file . split ( '/node_modules/' ) [ 1 ] ; // ignore node_modules", "del_tokens": "var file = row . file || row . id ; var nm = file . split ( '/node_modules/' ) [ 1 ] ;", "commit_type": "add"}
{"commit_tokens": ["Add", "functionality", "for", "triggering", "a", "slot", "change", "event", "with", "added", "/", "removed", "nodes", "detail", "."], "add_tokens": "import debounce from 'debounce' ; import mapSlotAddedNodes from './map-slot-added-nodes' ; import mapSlotRemovedNodes from './map-slot-removed-nodes' ; function polyfillSlot ( slot ) { slot . __triggerSlotChangeEvent = debounce ( triggerSlotChangeEvent ) ; return slot ; } function triggerSlotChangeEvent ( ) { const addedNodes = mapSlotAddedNodes . get ( this ) || null ; const removedNodes = mapSlotRemovedNodes . get ( this ) || null ; const ce = new CustomEvent ( 'slotchange' , { bubbles : false , cancelable : false , detail : { addedNodes , removedNodes } } ) ; // Clean up the added / removed nodes before any side-effects can happen from // triggering the event. mapSlotAddedNodes . set ( this , null ) ; mapSlotRemovedNodes . set ( this , null ) ; this . dispatchEvent ( ce ) ; } slots [ cacheKey ] = polyfillSlot ( slotElement ) ;", "del_tokens": "slots [ cacheKey ] = slotElement ;", "commit_type": "add"}
{"commit_tokens": ["fixes", "bad", "checking", "for", "delimiter"], "add_tokens": "\"DELIMITER\" : function ( tag ) { this . delimiter = String . fromCharCode ( parseInt ( tag . attributes . VALUE ) ) ;", "del_tokens": "\"DELIMITER\" : function ( /* tag */ ) { this . delimiter = String . fromCharCode ( parseInt ( this . delimiter ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "a", "test", "to", "case", "4"], "add_tokens": "var async3 = async_test ( 'Case 4: hash changed to content[hash=\"case4-1/case4-112\"]' ) ; async3 . next ( ) ; } ) ; window . addEventListener ( 'hashchange' , check_hash ) ; window . location . hash = \"case4-1/case4-111\" ; } ) ; async3 . next = async3 . step_func ( _ => { var check_hash = async3 . step_func ( ( e ) => { var content1 = document . querySelector ( '#case4-1' ) ; var content2 = document . querySelector ( '#case4-11' ) ; var content3 = document . querySelector ( '#case4-112' ) ; var content4 = document . querySelector ( '#case4-112-e' ) ; assert_false ( content1 . hidden ) ; assert_true ( content2 . hidden ) ; assert_true ( content3 . hidden ) ; assert_false ( content4 . hidden ) ; async3 . done ( ) ; window . location . hash = \"case4-1/case4-112\" ;", "del_tokens": "//var async3 = async_test('Case 4: hash changed to content[hash=\"case4-1/case4-112\"]'); window . location . hash = \"case4-1/case4-111\" ;", "commit_type": "add"}
{"commit_tokens": ["Use", "namespace", "in", "HostingContainer", "."], "add_tokens": "var hc = new HostingContainer ( this , ns ) ;", "del_tokens": "var hc = new HostingContainer ( this , prefix ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "various", "streaming", "tests", "and", "apis"], "add_tokens": "if ( firstLength == 0 ) { finish ( null , null ) ; } else if ( firstLength < 126 ) { var packet = self . unmask ( mask , data , true ) ; if ( packet != null ) self . currentMessage . push ( packet ) ; if ( firstLength == 0 ) { finish ( null , null ) ; } else if ( firstLength < 126 ) {", "del_tokens": "if ( firstLength < 126 ) { self . currentMessage . push ( self . unmask ( mask , data , true ) ) ; if ( firstLength < 126 ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "URL", "formatting", "in", "corporation", "module"], "add_tokens": "* an HTTP GET request to [ ` ` ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id). * makes an HTTP GET request to [ ` ` ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_alliancehistory). * an HTTP GET request to [ ` ` ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_icons). * makes an HTTP GET request to [ ` ` ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_members). * [ ` ` ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_roles). * This makes an HTTP GET request to [ ` ` ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_names). * @ param { Array . < Integer > } ids The corporation ids to lookup", "del_tokens": "* an HTTP GET request to [ ` corporations / { id } / ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id). * makes an HTTP GET request to [ ` corporations / { id } / alliancehistory / ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_alliancehistory). * an HTTP GET request to [ ` corporations / { id } / icons / ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_icons). * makes an HTTP GET request to [ ` corporations / { id } / members / ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_members). * [ ` corporations / { id } / members / ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_corporation_id_roles). * This makes an HTTP GET request to [ ` corporations / names / ] ( https : //esi.tech.ccp.is/latest/#!/Corporation/get_corporations_names). * @ param { Integer } id The corporation id", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "setting", "projection", "in", "renderer"], "add_tokens": "* @ param projectionName the name of a projection from d3 - geo or d3 - geo - projection renderGeoJson : function ( geoJson , projectionName , height , width ) { var projection = projectionLib . getFittedProjection ( projectionName , geoJson , height , width ) ;", "del_tokens": "renderGeoJson : function ( geoJson , height , width ) { var projection = projectionLib . getFittedProjection ( 'geoIdentity' , geoJson , height , width ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "for", "range", "-", "hours", "input", "type", "."], "add_tokens": "test . done ( ) ; } , rangeHours : function ( test ) { test . expect ( 1 ) ; var actual = grunt . file . read ( 'tmp/test-range-hours.html' ) ; var expected = grunt . file . read ( 'test/expected/test-range-hours.html' ) ; test . equal ( actual , expected , 'Range Hours functionality worked.' ) ; } ;", "del_tokens": "} ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "ability", "to", "stream", "to", "API"], "add_tokens": "// if the operation is a string, then it is the name of the handler method if ( _ . isString ( operation ) ) { server . route ( { method : httpMethod , path : apiPrefix + path , handler : me . getApiRouteHandler ( resource , operation , auth ) } ) ; } // else if object with type stream, need to use a slightly different call to server.route else if ( _ . isObject ( operation ) && operation . type === 'stream' && operation . operation ) { server . route ( { method : httpMethod , path : apiPrefix + path , config : { payload : { maxBytes : 209715200 , output : 'stream' , parse : true } , handler : me . getApiRouteHandler ( resource , operation . operation , auth ) } } ) ; } // else error else { throw new Error ( 'Invalid type of operation for ' + resource . name + ' ' + path ) ; } function getApiRouteHandler ( resource , operation , auth ) {", "del_tokens": "server . route ( { method : httpMethod , path : apiPrefix + path , handler : me . getApiRouteHandler ( resource , operation , auth ) } ) ; function getApiRouteHandler ( resource , operation , auth ) {", "commit_type": "add"}
{"commit_tokens": ["fixing", "bug", "where", "log", "()", "would", "only", "take", "one", "argument", "while", "console", ".", "log", "()", "can", "take", "any", "number", "of", "arguments"], "add_tokens": "dataSource . connector . dataSource . log = console . log ;", "del_tokens": "dataSource . connector . dataSource . log = function ( msg ) { console . log ( msg ) ; } ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "some", "further", "string", "helpers"], "add_tokens": "let camelName = name . toCamelCase ( ) ;", "del_tokens": "let camelName = name . camelCase ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "notifyWhenNoOpenRequests", "check", "asynchronously", "."], "add_tokens": "// check for openReqs asynchronously to give any pending requests // a chance to begin. setTimeout ( function ( ) { if ( openReqs > 0 ) { doneCallbacks . push ( cb ) ; } else { setTimeout ( cb , 1 ) ; } } , 1 ) ;", "del_tokens": "if ( openReqs > 0 ) { doneCallbacks . push ( cb ) ; } else { setTimeout ( cb , 1 ) ; }", "commit_type": "make"}
{"commit_tokens": ["add", "explicit", "callback", "on", "yieldable", "error"], "add_tokens": "step . apply ( self , args ) } else { step ( new Error ( 'Callback on yieldable is prohibited' ) )", "del_tokens": "if ( ! isYieldable ) step . apply ( self , args )", "commit_type": "add"}
{"commit_tokens": ["Use", "keys", "to", "determine", "if", "there", "is", "a", "change", "or", "not"], "add_tokens": "let changedKeys = keys ( changed ) ; if ( changedKeys . includes ( qp . as ) ) {", "del_tokens": "if ( changed [ qp . as ] ) {", "commit_type": "use"}
{"commit_tokens": ["Added", "touch", "identifier", "checking", "to", "pinchMove"], "add_tokens": "if ( touches . length !== 2 ) { return this . onPinchEnd ( event ) // bail out before disaster } var currentPinch = touches [ 0 ] . identifier === this . _initialPinch . touches [ 0 ] . identifier && touches [ 1 ] . identifier === this . _initialPinch . touches [ 1 ] . identifier ? getPinchProps ( touches ) // the touches are in the correct order : touches [ 1 ] . identifier === this . _initialPinch . touches [ 0 ] . identifier && touches [ 0 ] . identifier === this . _initialPinch . touches [ 1 ] . identifier ? getPinchProps ( touches . reverse ( ) ) // the touches have somehow changed order : getPinchProps ( touches ) ; // something is wrong, but we still have two touch-points, so we try not to fail // But it should never fire an onTap or onPress event. // Since there is no support swipes yet, this should be disregarded for now // if (event.touches.length === 1) { // this.onTouchStart(event); // }", "del_tokens": "var currentPinch = getPinchProps ( touches ) ; //TODO add helper function to order touches by identifier if ( event . touches . length === 1 ) { this . onTouchStart ( event ) ; }", "commit_type": "add"}
{"commit_tokens": ["added", "general", "response", "message", "for", "express"], "add_tokens": "return console . error ( \"Error executing \" + functionName + \": \" , e ) ; } / ** * General internal error for express * @ param e * @ param functionName * / function expressResponseError ( response , message ) { let errorMessage = \"there was an error in the request\" ; if ( message ) errorMessage = message response . json ( { success : false , error : errorMessage } ) ; module . exports . expressResponseError = expressResponseError ;", "del_tokens": "return console . error ( 'Error executing ' + functionName + ': ' , e ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "gulp", "test", "fail", "properly"], "add_tokens": "return gulp . src ( 'test' ) . pipe ( jest ( opts ) ) ;", "del_tokens": "gulp . src ( 'test' ) . pipe ( jest ( opts ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Fixing", "Cannot", "call", "method", "call", "of", "undefined"], "add_tokens": "( done || function ( ) { } ) . call ( self , null , self ) ;", "del_tokens": "done . call ( self , null , self ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "example", "formatting", "to", "be", "consistent", "with", "others"], "add_tokens": "* \"alliance_id\" : 434243723 , * \"ceo_id\" : 180548812 , * \"corporation_name\" : \"C C P\" , * \"member_count\" : 656 , * \"ticker\" : \"-CCP-\"", "del_tokens": "* alliance_id : 434243723 , * ceo_id : 180548812 , * corporation_name : \"C C P\" , * member_count : 656 , * ticker : \"-CCP-\"", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "the", "logger", ".", "It", "opened", "way", "to", "many", "streams", "...", "now", "only", "one!"], "add_tokens": "{ if ( this . logWriter == null ) { this . logWriter = this . fs . createWriteStream ( ( this . configData . logFolder + \"/\" + this . configData . logFile ) , { flags : \"a\" } ) ; } this . logWriter . write ( message + \"\\r\\n\" ) ;", "del_tokens": "{ this . fs . createWriteStream ( ( this . configData . logFolder + \"/\" + this . configData . logFile ) , { flags : \"a\" } ) . write ( message + \"\\r\\n\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Made", "multires", "FOV", "match", "other", "formats", "."], "add_tokens": "var fov = 2 * Math . atan ( Math . tan ( hfov / 2 ) * this . canvas . width / this . canvas . height ) ; var perspMatrix = this . makePersp ( fov , this . canvas . width / this . canvas . height , 0.1 , 100.0 ) ; this . checkZoom ( fov ) ; this . testMultiresNode ( rotPersp , ntmp , pitch , yaw , fov ) ; setTimeout ( this . processNextTile ( program . currentNodes [ i ] , pitch , yaw , fov ) , 0 ) ;", "del_tokens": "var perspMatrix = this . makePersp ( hfov , this . canvas . width / this . canvas . height , 0.1 , 100.0 ) ; this . checkZoom ( hfov ) ; this . testMultiresNode ( rotPersp , ntmp , pitch , yaw , hfov ) ; setTimeout ( this . processNextTile ( program . currentNodes [ i ] , pitch , yaw , hfov ) , 0 ) ;", "commit_type": "make"}
{"commit_tokens": ["improve", "the", "implementation", "of", "touching", "a", "file"], "add_tokens": "// Force to touching a file, if the file is not exists // If there's already a dir named `path`, the former dir will be copied as a backup before being deleted profile . touchFile = function ( path ) { if ( ! fs . isFile ( path ) ) { if ( fs . isDir ( path ) ) { fs . copy ( path , path + '-bak-' + Date . now ( ) , { force : true } ) ; fs . delete ( path ) ; } // create empty file fs . write ( path , '' ) ; } } ; profile . touchFile ( profiles ) ; profile . touchFile ( current ) ;", "del_tokens": "if ( ! fs . isFile ( profiles ) ) { fs . write ( profiles , '' ) ; } if ( ! fs . isFile ( current ) ) { fs . write ( current , '' ) ; }", "commit_type": "improve"}
{"commit_tokens": ["Add", "support", "for", "metadata", "extensions", "PATH"], "add_tokens": "t . plan ( 5 ) ; t . equal ( cli . availableCommands . subcommandInPython . description , '' , 'A non-JavaScript command doesn\\'t have a description' ) ;", "del_tokens": "t . plan ( 4 ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "spelling", "mistake", "in", "tests"], "add_tokens": "it ( 'should automatically queue subscribe invocations until connected to RabbitMQ server' , function ( done ) { it ( 'should automatically queue publish invocations until connected to RabbitMQ server' , function ( done ) { it ( 'should not queue publish invocations if already connected to RabbitMQ server' , function ( done ) { it ( 'should not queue subscribe invocations if already connected to RabbitMQ server' , function ( done ) {", "del_tokens": "it ( 'should automatically queue subscribe invokations until connected to RabbitMQ server' , function ( done ) { it ( 'should automatically queue publish invokations until connected to RabbitMQ server' , function ( done ) { it ( 'should not queue publish invokations if already connected to RabbitMQ server' , function ( done ) { it ( 'should not queue subscribe invokations if already connected to RabbitMQ server' , function ( done ) {", "commit_type": "fix"}
{"commit_tokens": ["made", "some", "serious", "improvements", "to", "the", "unit", "tests", ".", "also", "patched", "bugs", "in", "singly", "linked", "list", "and", "began", "queue"], "add_tokens": "} nodeFound = false ; while ( curNode !== null ) { return true ; // Find the node without a next element (will be the tail) / ** * Remove a node based on the given position in the linked list * @ param { int } index of node to remove * @ return { void } * /", "del_tokens": "} ; nodeFound = false ; while ( curNode . next !== null ) {", "commit_type": "make"}
{"commit_tokens": ["Add", "an", "init", "method", "to", "plugins", "to", "be", "able", "to", "perform", "operations", "before", "the", "server", "starts"], "add_tokens": "* Offers the possibility to initialize the plugin . * A plugin may want , for example , to use this method to create indexes for its collections . * * @ method init * @ async * @ param { Function } callback Function to call when it ' * - ** Error ** An error if something went wrong , null otherwise * / Plugin . prototype . init = null ; / ** * Indicates that the plugin is fully loaded in application process and can be started . * @ async * @ param { Function } callback Function to call when it ' * - ** Error ** An error if something went wrong , null otherwise", "del_tokens": "* Indicates that the plugin is fully loaded . * This won '", "commit_type": "add"}
{"commit_tokens": ["remove", "unecessary", "code", "in", "equal", "method"], "add_tokens": "if ( typeof obj !== OBJECT || obj === null )", "del_tokens": "var NUMBER = types . NUMBER var t = typeof obj if ( t === NUMBER ) { if ( obj === 0 && ( 1 / obj ) === - Infinity ) return - 0 return obj } else if ( t !== OBJECT || obj === null )", "commit_type": "remove"}
{"commit_tokens": ["changed", "configuration", "in", "tests", "."], "add_tokens": "password : '1q2w3e4r' var api = require ( '../lib/grasshopper-api' ) ( this . config ) ; api . auth . init ( { } ) ;", "del_tokens": "password : '$databassic$' var api = require ( '../lib/grasshopper-api' ) ; api . init ( this . config ) ;", "commit_type": "change"}
{"commit_tokens": ["add", "option", "to", "change", "initial", "quality"], "add_tokens": "* @ param { Object } options * @ param { boolean } [ options . useWebWorker = false ] * @ param { number } [ options . initialQuality = 1.0 ] let quality = options . initialQuality || 1.0", "del_tokens": "* @ param { Object } options - { maxSizeMB = Number . POSITIVE_INFINITY , maxWidthOrHeight , useWebWorker = false , maxIteration = 10 , exifOrientation , fileType } let quality = 1", "commit_type": "add"}
{"commit_tokens": ["Adding", "ava", "support", "removing", "unused", "scripts", "in", "the", "tool"], "add_tokens": "const paths = require ( '../config/paths' ) ; let result ; result = spawn . sync ( case 'test' : result = spawn . sync ( 'ava' , [ ` ${ paths . src } ` ] . concat ( args ) , { stdio : 'inherit' } ) ; process . exit ( result . status ) ; break ; console . log ( ` ${ script } ` ) ;", "del_tokens": "case 'test' : const result = spawn . sync ( console . log ( ` ${ script } ` ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "error", "handling", "for", "failed", "full", "screen", "attempt", "."], "add_tokens": "document . addEventListener ( 'mozfullscreenerror' , fullScreenError , false ) ; document . addEventListener ( 'webkitfullscreenerror' , fullScreenError , false ) ; document . addEventListener ( 'fullscreenerror' , fullScreenError , false ) ; fullScreenError ( ) ; function fullScreenError ( ) { if ( getURLParameter ( 'popout' ) != 'yes' ) { // open new window instead var windowspecs = 'width=' + screen . width + ',height=' + screen . height + ',left=0,top=0' ; var windowlocation = window . location . href + '&popout=yes' ; try { camera . aspect = window . innerWidth / window . innerHeight ; windowlocation += '&popoutautoload=yes' ; } catch ( event ) { // panorama not loaded } window . open ( windowlocation , null , windowspecs ) } else { window . close ( ) ; } }", "del_tokens": "if ( getURLParameter ( 'popout' ) != 'yes' ) { // open new window instead var windowspecs = 'width=' + screen . width + ',height=' + screen . height + ',left=0,top=0' ; var windowlocation = window . location . href + '&popout=yes' ; try { camera . aspect = window . innerWidth / window . innerHeight ; windowlocation += '&popoutautoload=yes' ; } catch ( event ) { // panorama not loaded } window . open ( windowlocation , null , windowspecs ) } else { window . close ( ) ; }", "commit_type": "add"}
{"commit_tokens": ["Improve", "readability", "of", "general", "spec", "descriptions"], "add_tokens": "describe ( 'Functionality that is common to all documents:' , function ( ) { describe ( 'the document type identifier' , function ( ) { it ( 'rejects document creation with an unrecognized doc type' , function ( ) { it ( 'rejects document replacement with an unrecognized doc type' , function ( ) { it ( 'rejects document deletion with an unrecognized type' , function ( ) { it ( 'rejects document creation for a user without permission' , function ( ) { it ( 'rejects document replacement for a user without permission' , function ( ) { it ( 'rejects document deletion for a user without permission' , function ( ) {", "del_tokens": "describe ( 'Functionality that is common to all documents' , function ( ) { describe ( 'unrecognized document types' , function ( ) { it ( 'cannot create a document with an unrecognized type' , function ( ) { it ( 'cannot replace a document with an unrecognized type' , function ( ) { it ( 'cannot delete a document with an unrecognized type' , function ( ) { it ( 'cannot create a document for a user without permission' , function ( ) { it ( 'cannot replace a document for a user without permission' , function ( ) { it ( 'cannot delete a document for a user without permission' , function ( ) {", "commit_type": "improve"}
{"commit_tokens": ["add", "models", "and", "mongoose", "connection", "in", "tests"], "add_tokens": "", "del_tokens": "//Dependencies", "commit_type": "add"}
{"commit_tokens": ["Remove", "some", "vestigial", "THREE", ".", "js", "functions", "added", "more", "tests"], "add_tokens": "mocha . run ( ) ;", "del_tokens": "mocha . run ( failures => { process . on ( 'exit' , ( ) => { process . exit ( failures ) ; // exit with non-zero status if there were failures } ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "express", "-", "validator", "to", "bootstrap"], "add_tokens": "var path = require ( 'path' ) ; var enrouten = require ( 'express-enrouten' ) ; var bodyParser = require ( 'body-parser' ) ; var cors = require ( 'cors' ) ; var cache = require ( 'express-cache-response-directive' ) ; var zoologist = require ( './zoologist' ) ; var log = require ( './logger' ) ; var partialRes = require ( 'express-partial-response' ) ; var validator = require ( 'express-validator' ) // Parse application/json / validators app . use ( validator ( ) ) ;", "del_tokens": "var path = require ( 'path' ) ; var enrouten = require ( 'express-enrouten' ) ; var bodyParser = require ( 'body-parser' ) ; var cors = require ( 'cors' ) ; var cache = require ( 'express-cache-response-directive' ) ; var zoologist = require ( './zoologist' ) ; var log = require ( './logger' ) ; var partialRes = require ( 'express-partial-response' ) ; // Parse application/json", "commit_type": "add"}
{"commit_tokens": ["Fix", "extraction", "of", "frame", "numbers", "from", "uri"], "add_tokens": "uid = findSubstring ( uri , \"studies/\" ) ; uid = findSubstring ( uri , \"series/\" ) ; uid = findSubstring ( uri , \"/instances/\" , \"/metadata\" ) ; uid = findSubstring ( uri , \"/instances/\" ) ; var numbers = findSubstring ( uri , \"/frames/\" , \"/rendered\" ) ; if ( ! numbers ) { numbers = findSubstring ( uri , \"/frames/\" ) ; }", "del_tokens": "var uid = findSubstring ( uri , \"studies/\" ) ; var uid = findSubstring ( uri , \"series/\" ) ; var uid = findSubstring ( uri , \"/instances/\" , \"/metadata\" ) ; var uid = findSubstring ( uri , \"/instances/\" ) ; var numbers = findSubstring ( uri , \"/frames/\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "more", "single", "-", "syllable", "suffix", "matches"], "add_tokens": "/ ^[^aeiou]?iled / , // -ing, -ent / [aeiou][n][gt]$ / , // -ate, -age / \\wa[gt]e$ / ,", "del_tokens": "/ ^[^aeiou]?iled /", "commit_type": "add"}
{"commit_tokens": ["Make", "it", "return", "all", "keys", "of", "an", "empty", "line"], "add_tokens": "var newLine = lineData . getEmptyLine ( ) ; newLine . row = i + 1 ;", "del_tokens": "var newLine = { row : i + 1 , retailers : lineData . getEmptyRetailers ( ) } ;", "commit_type": "make"}
{"commit_tokens": ["FIXED", "calling", "browser", ".", "debug", "()", "reuses", "instance"], "add_tokens": "this . _debug = Browser . _enableDebugging ( ) ; // Deprecated soon // Call this to return a debug() instance with debugging enabled. static _enableDebugging ( ) { // With debugging enabled, every time we call debug('zombie') we get a new // instance which outputs with a different color. This can be confusing, so // if debugging is already enabled (DEBUG=zombie) we want to use the current // instance. Otherwise, we want to create a new instance (_debugEnabled) // and reuse it every time someone calls browser.debug(). if ( this . _debug . enabled ) return this . _debug . enabled ; if ( ! this . _debugEnabled ) { debug . enable ( 'zombie' ) ; this . _debugEnabled = debug ( 'zombie' ) ; } return this . _debugEnabled ; } // Set after calling _enableDebugging _debugEnabled : null ,", "del_tokens": "debug . enable ( 'zombie' ) ; this . _debug = debug ( 'zombie' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "network", "it", "for", "Rinkeby"], "add_tokens": "network_id : 4", "del_tokens": "network_id : 2", "commit_type": "fix"}
{"commit_tokens": ["Fix", "archivist", ":", "create", "script"], "add_tokens": "mage . core . archivist . openVaults ( function ( error ) { if ( error ) { mage . core . logger . emergency ( error ) ; return cb ( error ) ; } migrate . start ( mage , options , cb ) ; } ) ;", "del_tokens": "migrate . start ( mage , options , cb ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "comments", "for", "touch", "test", "case", "in", "operate", "fn", "."], "add_tokens": "// TEST LOGIC // 1.Write a record to an aerospike server. // 2.Read the record, to get the ttl and calculate // the difference in the ttl written and the ttl returned by server. // 3.Touch the record with a definite ttl. // 4.Read the record and calculate the difference in the ttl between the // touch ttl value and read ttl value. // 5.Compare the difference with the earlier difference calculated. // 6.This is to account for the clock asynchronicity between // the client and the server machines. // 7.Server returns a number, at which the record expires according the server clock. // 8.The client calculates the time in seconds, and gives back ttl. In the case , where // clocks are not synchronous between server and client, the ttl client calculates may not // be accurate to the user. Nevertheless server expires the record in the correct time. expect ( 500 + ttl_diff + 10 ) . to . be . above ( metadata2 . ttl ) ; expect ( 500 + ttl_diff - 10 ) . to . be . below ( metadata2 . ttl ) ;", "del_tokens": "expect ( 500 + ttl_diff ) . to . equal ( metadata2 . ttl ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "packages", ";", "removed", "unused", "babel", "dependency", ";", "added", "respository", "metadata", "to", "package", ".", "json"], "add_tokens": "// Add a CSS class hook, in case people need to override styles for any reason. if ( $container . className . indexOf ( \"object-fit-polyfill\" ) === - 1 ) { $container . className = $container . className + \" object-fit-polyfill\" ; }", "del_tokens": "$container . classList . add ( \"object-fit-polyfill\" ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "sortParam", "sortOrder", "skip", "limit", "to", "controller", "prototype", ".", "added", "queryParams", "float", "type"], "add_tokens": "sortParam : \"created\" , sortOrder : \"desc\" , skip : 0 , limit : 50 , var sortBy = req . query . sort || this . sortParam ; // validate sortableParams var orderBy = req . query . order || this . sortOrder ; // validate [asc, desc] var skip = req . query . skip || req . query . offset || this . skip ; // validate int var limit = req . query . limit || req . query . count || this . limit ; // validate int } else if ( type === 'float' ) { // floats val = parseFloat ( val ) ; filter [ key ] = val ;", "del_tokens": "var sortBy = req . query . sort || \"created\" ; // validate sortableParams var orderBy = req . query . order || \"desc\" ; // validate [asc, desc] var skip = req . query . skip || req . query . offset || 0 ; // validate int var limit = req . query . limit || req . query . count || 50 ; // validate int", "commit_type": "add"}
{"commit_tokens": ["Remove", "443", "from", "self", "-", "ip", "port", "allow", "list", "if", "we", "change", "port", "to", "not", "443"], "add_tokens": "'tcp:123' , 'tcp:443' } , testRemove443 : function ( test ) { var portToAdd = 456 ; bigIp . onboard . sslPort ( portToAdd , null , true ) . then ( function ( ) { var newDefaults = icontrolMock . getRequest ( 'modify' , '/tm/net/self-allow' ) . defaults ; test . strictEqual ( newDefaults . indexOf ( 'tcp:443' ) , - 1 ) ; } ) . catch ( function ( err ) { test . ok ( false , err . message ) ; } ) . finally ( function ( ) { test . done ( ) ; } ) ;", "del_tokens": "'tcp:123'", "commit_type": "remove"}
{"commit_tokens": ["Added", "text", "editor", "icons", "from", "font", "awesome"], "add_tokens": "// Font Awesome Editor Icons 'bold' , 'italic' , 'list' , 'font' , 'text-height' , 'text-width' , 'align-left' , 'align-center' , 'align-right' , 'align-justify' , 'indent-left' , 'indent-right' , 'list-bullet' , 'list-numbered' , 'strike' , 'underline' , 'table' , 'superscript' , 'subscript' , 'header' , 'h1' , 'h2' , 'paragraph' , 'link' , 'unlink' , 'quote-left' , 'quote-right' , 'code' , // Entypo 'link-alt' , 'code-alt' ,", "del_tokens": "'link' , 'code' ,", "commit_type": "add"}
{"commit_tokens": ["added", "x", "-", "browser", "domready", "event"], "add_tokens": "* $script . js v 1.1 scripts = { } , s = 'string' , f = false , domReady , readyList = [ ] , } , 25 ) ; setTimeout ( function ( ) { domReady = / loaded|complete / . test ( doc . readyState ) ? ! each ( readyList , function ( f ) { f ( ) ; } ) : ! setTimeout ( arguments . callee , 1 ) ; } , 1 ) ; $script . domReady = function ( fn ) { domReady ? fn ( ) : readyList . push ( fn ) ; } ; } ( window , document ) ) ;", "del_tokens": "* $script . js v 1.0 scripts = { } , s = 'string' , } , 30 ) ; } ( window , document ) ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "support", "for", "redis", "database", "and", "password"], "add_tokens": "const { name , port , host , db , password , options } = queueConfig ; redis : { port , host , db , password }", "del_tokens": "const { name , port , host , options } = queueConfig ; redis : { port , host }", "commit_type": "add"}
{"commit_tokens": ["Improved", "built", "-", "in", "site", "styles"], "add_tokens": "return fs . readFileSync ( __dirname + '/assets/default.jade' ) ; return fs . readFileSync ( __dirname + '/assets/post.jade' ) ;", "del_tokens": "return '' + '!!! 5\\n' + 'html(lang=\"en\")\\n' + ' head\\n' + ' title #{site.config.title}\\n' + ' link(href=\"/stylesheets/screen.css\", media=\"screen\", rel=\"stylesheet\", type=\"text/css\")\\n' + ' body\\n' + ' header#header\\n' + ' hgroup\\n' + ' h1 #{site.config.title}\\n' + ' h2 I promise to write regularly!\\n' + ' !{content}\\n' + ' footer\\n' + ' nav\\n' + ' h1 Related Sites\\n' + ' ul\\n' + ' li\\n' + ' a(href=\"http://popjs.com\") Powered by Pop\\n' + ' li\\n' + ' a(href=\"http://dailyjs.com\") Learn JavaScript\\n' + ' li\\n' + ' a(href=\"http://alexyoung.org\") Designed by Alex R. Young\\n' + ' p.copyright Content &copy; The Authors\\n' ; return '' + '!!! 5\\n' + 'html(lang=\"en\")\\n' + ' head\\n' + ' title #{post.title}\\n' + ' link(href=\"/stylesheets/screen.css\", media=\"screen\", rel=\"stylesheet\", type=\"text/css\")\\n' + ' body\\n' + ' header#header\\n' + ' hgroup\\n' + ' h1 #{site.config.title}\\n' + ' h2 I promise to write regularly!\\n' + ' !{hNews(post)}\\n' + ' footer\\n' + ' nav\\n' + ' h1 Related Sites\\n' + ' ul\\n' + ' li\\n' + ' a(href=\"http://popjs.com\") Powered by Pop\\n' + ' li\\n' + ' a(href=\"http://dailyjs.com\") Learn JavaScript\\n' + ' li\\n' + ' a(href=\"http://alexyoung.org\") Designed by Alex R. Young\\n' + ' p.copyright Content &copy; The Authors\\n' ;", "commit_type": "improve"}
{"commit_tokens": ["fix", "modules", "with", "async", "functions", "and", "other", "new", "goodies"], "add_tokens": "var magicString = transformAst ( source , { ecmaVersion : 9 , inputFilename : row . sourceFile } , function ( node ) {", "del_tokens": "var magicString = transformAst ( source , { inputFilename : row . sourceFile } , function ( node ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "metalsmith", "-", "register", "-", "helpers", "instead", "of", "defining", "helpers", "in", "gulpfile"], "add_tokens": "var msRegisterHelpers = require ( 'metalsmith-register-helpers' ) ; . use ( msRegisterHelpers ( { directory : 'docs/templates/helpers' } ) )", "del_tokens": "/ ** * Create Handlebars helper to generate relative links for navigation . * See https : //github.com/unstoppablecarl/metalsmith-navigation/blob/master/examples/generic/build.js * / var relativePathHelper = function ( current , target ) { // normalize and remove starting slash from path if ( ! current || ! target ) { return '' ; } current = path . normalize ( current ) . slice ( 0 ) ; target = path . normalize ( target ) . slice ( 0 ) ; current = path . dirname ( current ) ; return path . relative ( current , target ) . replace ( / \\\\ / g , '/' ) ; } ; Handlebars . registerHelper ( 'relative_path' , relativePathHelper ) ; / ** * Create Handlebars helper to create active class for navigation . * / var isActiveHelper = function ( current , target ) { // normalize and remove starting slash from path if ( ! current || ! target ) { return '' ; } current = path . normalize ( current ) . slice ( 0 ) ; target = path . normalize ( target ) . slice ( 0 ) ; return current === target ? 'active' : '' ; } ; Handlebars . registerHelper ( 'is_active' , isActiveHelper ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "explicit", "empty", "signatures", "as", "viable", "option"], "add_tokens": "var pattern = / ^(?:([a-zA-Z]+!?|\\.{3})(?:[:\\s]+([a-zA-Z]+)(?:(=)(@)?(.*))?))?$ / ; if ( result . type === false ) { } ) . filter ( function ( argument ) { return argument . type !== undefined ;", "del_tokens": "var pattern = / ([a-zA-Z]+!?|\\.{3})(?:[:\\s]+([a-zA-Z]+)(?:(=)(@)?(.*))?)? / ; if ( ! result . type ) {", "commit_type": "add"}
{"commit_tokens": ["move", "scraper", "dequeue", "to", "seperate", "module"], "add_tokens": "var utils = require ( './lib/utils' ) ; var fileUpload = require ( './lib/file-upload.js' ) , pubsub , scraper = require ( './lib/scraper.js' ) ;", "del_tokens": "var utils = require ( './lib/utils' ) , scraper = require ( './lib/scraper.js' ) ; var fileUpload = require ( './lib/file-upload.js' ) , pubsub ; setInterval ( function ( ) { var queuedLink = scraper . getQueuedLink ( function ( err , queuedLink ) { console . log ( 'scraping' , queuedLink ) ; scraper . scrapeLink ( queuedLink . uri , function ( err , res ) { console . log ( 'scraped' , err , res ? res . length : 'no content' ) ; } ) ; } ) ; } , 1000 ) ;", "commit_type": "move"}
{"commit_tokens": ["Added", "r", ".", "js", "builds", "to", "AMD", "demo"], "add_tokens": "// basic.js", "del_tokens": "// amd.js", "commit_type": "add"}
{"commit_tokens": ["Updated", "job", "-", "add", "-", "log", "tests"], "add_tokens": "// const jobFailed = require('./job-failed.spec') const jobAddLog = require ( './job-add-log.spec' ) return jobAddLog ( )", "del_tokens": "const jobFailed = require ( './job-failed.spec' ) // const jobAddLog = require('./job-add-log.spec') return jobFailed ( )", "commit_type": "update"}
{"commit_tokens": ["Added", "globals", ".", "js", "for", "handaling", "global", "variables"], "add_tokens": "var _private = rootRequire ( 'lib/privateFunctions.js' ) ; var _globals = rootRequire ( 'lib/globals.js' ) ; var apiAddress = _globals . apiAddress ;", "del_tokens": "var apiAddress = 'https://platform.api.onesky.io/' ; var _private = require ( __dirname + '/privateFunctions.js' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "facility", "for", "default", "hash"], "add_tokens": "this . _defaultHash = s ; var v = s [ i ] ; ts [ i ] = v ; var diff = AtomBinder . getClone ( this . _defaultHash || { } ) ; //diff.push({ key: k, value: v }); diff [ k ] = v ; //diff.push({ key:k, value: v }); diff [ k ] = v ; var da = [ ] ; for ( var k in diff ) { var v = diff [ k ] ; da . push ( { key : k , value : v } ) ; } var p = \"#\" + da . map ( function ( a ) { return a . key + \"=\" + encodeURIComponent ( a . value ) ; } ) . join ( \"&\" ) ; } ) ( WebAtoms . AtomDockPanel . prototype ) ;", "del_tokens": "ts [ i ] = s [ i ] ; var diff = [ ] ; diff . push ( { key : k , value : v } ) ; diff . push ( { key : k , value : v } ) ; var p = \"#\" + diff . map ( function ( a ) { return a . key + \"=\" + encodeURIComponent ( a . value ) ; } ) . join ( \"&\" ) ; } ) ( WebAtoms . AtomDockPanel . prototype ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "compatible", "with", "cordova", "lock", "down", "version"], "add_tokens": "var getElementId = require ( './tok' ) . getElementId var VIDEO_OPTIONS = require ( './tok' ) . VIDEO_OPTIONS this . element = containerElement this . subscriber = this . session . subscribe ( this . stream , getElementId ( this . element ) , VIDEO_OPTIONS , function ( err ) {", "del_tokens": "var VIDEO_OPTIONS = require ( './tok' ) . VIDEO_OPTIONS this . containerElement = containerElement this . subscriber = this . session . subscribe ( this . stream , this . containerElement , VIDEO_OPTIONS , function ( err ) {", "commit_type": "make"}
{"commit_tokens": ["Added", "test", "for", "regular", "rewrites"], "add_tokens": "/ ** * Module dependencies . * / var modRewrite = require ( '../' ) , sinon = require ( 'sinon' ) , chai = require ( 'chai' ) , expect = require ( 'chai' ) . expect ; / ** * Plugins . * / var sinonChai = require ( 'sinon-chai' ) ; chai . should ( ) ; chai . use ( sinonChai ) ; / ** * Specs . * / connection : { encrypted : false } , header : function ( ) { } , headers : { host : 'test.com' } , url : '/a' } ; var res = { writeHead : sinon . spy ( ) , end : sinon . spy ( ) var next = sinon . spy ( ) ; middleware ( req , res , next ) ; expect ( req . url ) . to . equal ( '/b' ) ;", "del_tokens": "var modRewrite = require ( '../' ) ; connection { encrypted : false } , header : function ( ) { } middleware ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "some", "handlebar", "vars", "in", "empty", "template", ".", "use", "slugcase", "."], "add_tokens": "it ( 'should import correctly' , function ( ) {", "del_tokens": "it ( 'should work' , function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "unit", "tests", "for", "ConditionalExpression"], "add_tokens": "if ( expression . left . type === 'DeclarativeExpression' || expression . left . type === \"Identifier\" ) { instrumentConditionalExpression ( expression . right ) ; if ( instrument ) { instrumentStatement ( expression ) } //parse[expression.test.left.type](expression.test.left, instrument); //parse[expression.test.right.type](expression.test.right, instrument); //parse[expression.consequent.type](expression.consequent, instrument); //parse[expression.alternate.type](expression.alternate, instrument);", "del_tokens": "if ( expression . left . type === 'DeclarativeExpression' ) { parse [ expression . test . left . type ] ( expression . test . left , instrument ) ; parse [ expression . test . right . type ] ( expression . test . right , instrument ) ; parse [ expression . consequent . type ] ( expression . consequent , instrument ) ; parse [ expression . alternate . type ] ( expression . alternate , instrument ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "output", ".", "library", "to", "webpack", "config"], "add_tokens": "( function webpackUniversalModuleDefinition ( root , factory ) { if ( typeof exports === 'object' && typeof module === 'object' ) module . exports = factory ( ) ; else if ( typeof define === 'function' && define . amd ) define ( \"jsonDeref\" , [ ] , factory ) ; else if ( typeof exports === 'object' ) exports [ \"jsonDeref\" ] = factory ( ) ; else root [ \"jsonDeref\" ] = factory ( ) ; } ) ( this , function ( ) { return /******/ ( function ( modules ) { // webpackBootstrap /******/ ] ) } ) ; ;", "del_tokens": "/******/ ( function ( modules ) { // webpackBootstrap // // export default deref // if (process.env.BABEL_ENV === \"node\") { // exports.default = deref // } else { // window.jsonDeref = deref // } /******/ ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "eresult", "property", "to", "disconnect", "error", "events"], "add_tokens": "var e = new Error ( msg ) ; e . eresult = body . eresult ; this . emit ( 'error' , e ) ;", "del_tokens": "this . emit ( 'error' , new Error ( msg ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "content", "size", "in", "default_app", "."], "add_tokens": "mainWindow = new BrowserWindow ( { width : 800 , height : 600 , 'use-content-size' : true , } ) ;", "del_tokens": "var height = 600 ; if ( process . platform == 'win32' ) height += 60 ; else if ( process . platform == 'linux' ) height += 30 ; mainWindow = new BrowserWindow ( { width : 800 , height : height } ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "check", "in", "the", "net", "module", "to", "ensure", "that", "the", "bwmNg", "monitor", "only", "fires", "once"], "add_tokens": "var nextOnce = _ . once ( next ) ; nextOnce ( ) ;", "del_tokens": "next ( ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "formatting", "with", "localized", "masks", ";", "add", "support", "for", "escaping", "while", "formatting"], "add_tokens": "RE_TOKEN = / (LTS?)|(L{1,4})|(Y{4}|Y{2})|(M{1,4})|(D{1,2})|(d{3}r|d{2}r)|(d{1,4})|(H{1,2})|(m{1,2})|(s{1,2})|(S{1,3}) / g , RE_TOKEN_ESCAPE = / (\\[[^\\]]+\\]) / g , RE_TOKEN_ESCAPED = / (\\$\\d\\d?) / g ; var escaped = [ ] , idx = 0 ; // Remove all escaped text (in [xxx]) mask = mask . replace ( RE_TOKEN_ESCAPE , function ( match ) { escaped . push ( match . slice ( 1 , - 1 ) ) ; return '$' + idx ++ ; } ) ; mask = mask . replace ( RE_TOKEN , function ( match ) { case 'LT' : case 'LTS' : case 'L' : case 'LL' : case 'LLL' : case 'LLLL' : return _this . _locale && _this . _locale . format && _this . _locale . format [ match ] ? _this . format ( _this . _locale . format [ match ] , daysFromNow ) : '[missing locale]' ; // Replace all escaped text if ( escaped . length ) { mask = mask . replace ( RE_TOKEN_ESCAPED , function ( match ) { return escaped [ match . slice ( 1 ) ] ; } ) ; } return mask ;", "del_tokens": "RE_TOKEN = / (Y{4}|Y{2})|(M{1,4})|(D{1,2})|(d{3}r|d{2}r)|(d{1,4})|(H{1,2})|(m{1,2})|(s{1,2})|(S{1,3}) / g ; console . log ( this ) ; return mask . replace ( RE_TOKEN , function ( match ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "missing", "deleteObject", "method", "fix", "tests"], "add_tokens": "expect ( data ) . to . not . exist ;", "del_tokens": "expect ( data ) . to . null ;", "commit_type": "fix"}
{"commit_tokens": ["Made", "it", "possible", "to", "load", "json", "."], "add_tokens": "import json from 'rollup-plugin-json' ; export const defaultPlugins = ( { cleanerConfig , resources , importStylesConfig , jsonConfig , htmlTemplateConfig , resolveConfig , progressConfig , tsConfig , commonjsConfig } ) => [ // Teaches Rollup how to import json files json ( { preferConst : true , compact : true , ... jsonConfig } ) ,", "del_tokens": "import path from \"path\" ; export const defaultPlugins = ( { cleanerConfig , resources , importStylesConfig , htmlTemplateConfig , resolveConfig , progressConfig , tsConfig , commonjsConfig } ) => [", "commit_type": "make"}
{"commit_tokens": ["Update", "built", "file", "with", "new", "changes"], "add_tokens": "\"editor.fontSize\" : \"14px\" , \"editor.quickInfo.enabled\" : true , \"editor.completions.enabled\" : true , \"editor.errors.slideOnFocus\" : true if ( eventName === \"CursorMoved\" && Config . getValue ( \"editor.quickInfo.enabled\" ) ) { else if ( eventName === \"CursorMovedI\" && Config . getValue ( \"editor.completions.enabled\" ) ) { const Config = __webpack_require__ ( 47 ) ; const errorDescription = Config . getValue ( \"editor.errors.slideOnFocus\" ) ? ( React . createElement ( \"div\" , { className : \"error\" } , React . createElement ( \"div\" , { className : \"text\" } , this . props . text ) ) ) : null ; errorDescription ,", "del_tokens": "\"editor.fontSize\" : \"14px\" if ( eventName === \"CursorMoved\" ) { else if ( eventName === \"CursorMovedI\" ) { React . createElement ( \"div\" , { className : \"error\" } , React . createElement ( \"div\" , { className : \"text\" } , this . props . text ) ) ,", "commit_type": "update"}
{"commit_tokens": ["Add", "mock", "support", "for", "cognito", "identity", "service", "provider"], "add_tokens": "* * / ** * Adds a mock for the cognito idp object to the mock represented by this * class . * * @ return { Object } A reference to this instance - can be used to chain * calls . * / addCognitoIdentityServiceProvider ( ) { this . _mock . _cognitoIdentityServiceProviderRef = { adminCreateUser : _sinon . spy ( ) , adminUpdateUserAttributes : _sinon . spy ( ) , listUsers : _sinon . spy ( ) } ; this . mock . CognitoIdentityServiceProvider = _sinon . stub ( ) . returns ( this . _mock . _cognitoIdentityServiceProviderRef ) ; return this ; }", "del_tokens": "* *", "commit_type": "add"}
{"commit_tokens": ["Made", "It", "Working", "And", "Supported", "KR", "and", "RU", "regions", "."], "add_tokens": "path : '/v2.5/league/by-summoner/' + summonerId var url = \"https://\" + region + ( region . toLowerCase ( ) != \"kr\" && region . toLowerCase ( ) != \"ru\" ? \"1\" : \"\" ) + \".api.riotgames.com/lol/champion-mastery/v3/champion-masteries/by-summoner/\" + String ( summonerId ) + \"/by-champion/\" + String ( championId ) + \"?api_key=\" + this . key ;", "del_tokens": "path : '/v2.4/league/by-summoner/' + summonerId var url = \"https://\" + region + \"1.api.riotgames.com/lol/champion-mastery/v3/champion-masteries/by-summoner/\" + String ( summonerId ) + \"/by-champion/\" + String ( championId ) + \"?api_key=\" + this . key ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "test", "for", "misc", "/", "randomString"], "add_tokens": "t . equal ( typeof res , 'object' , 'Json response' ) t . equal ( typeof res . random , 'string' , 'Has random string inside object' ) t . equal ( res . random . length , length , 'Random string is correct length' ) t . plan ( 4 )", "del_tokens": "t . equal ( typeof res , 'string' , 'String response' ) t . equal ( res . length , length , 'Is correct length' ) t . plan ( 3 )", "commit_type": "fix"}
{"commit_tokens": ["IMPROVED", ":", "added", "ability", "to", "setMask", "in", "invert", "mode"], "add_tokens": "* @ param { Boolean } exclude set to true to have the mask exclude portions of the drawing , in this case mask . color will be used setMask ( mask = null , exclude = false ) { if ( exclude && mask ) { mask . exclude = true ; } const mask = this . mask ; if ( mask . exclude ) { destCtx . save ( ) ; destCtx . fillStyle = mask . color || 'black' ; destCtx . fillRect ( x + mask . x , y + mask . y , mask . w , mask . h ) ; } else { destCtx . save ( ) ; destCtx . beginPath ( ) ; destCtx . rect ( x + mask . x , y + mask . y , mask . w , mask . h ) ; destCtx . clip ( ) ; }", "del_tokens": "setMask ( mask = null ) { destCtx . save ( ) ; destCtx . beginPath ( ) ; destCtx . rect ( x + this . mask . x , y + this . mask . y , this . mask . w , this . mask . h ) ; destCtx . clip ( ) ;", "commit_type": "improve"}
{"commit_tokens": ["Add", "support", "for", "Cross", "-", "fade", "and", "Replay", "Gain", "configuration"], "add_tokens": "\"change #single\" : \"single\" , \"change #replaygain\" : \"replaygain\" , \"change #crossfade\" : \"crossfade\" this . xfade = status . xfade ; if ( ! this . xfade ) { this . xfade = 0 ; } this . replayGainStatus = status . replayGainStatus ; $ ( \"#crossfade\" ) . val ( this . xfade ) ; $ ( \"#replaygain\" ) . val ( this . replayGainStatus ) . selectmenu ( \"refresh\" ) ; replaygain : function ( ) { var mode = $ ( \"#replaygain\" ) . val ( ) ; if ( config . isDirect ( ) ) { MPDClient . replayGainMode ( mode , function ( ) { console . log ( \"replaygain set to \" + mode ) ; } ) ; } else { this . setPlaybackOption ( \"replaygain\" , mode ) ; } } , crossfade : function ( ) { try { var crossfade = parseInt ( $ ( \"#crossfade\" ) . val ( ) ) ; if ( config . isDirect ( ) ) { MPDClient . crossfade ( crossfade , function ( ) { console . log ( \"crossfade set to \" + crossfade ) ; } ) ; } else { this . setPlaybackOption ( \"crossfade\" , crossfade ) ; } } catch ( e ) { } } ,", "del_tokens": "\"change #single\" : \"single\"", "commit_type": "add"}
{"commit_tokens": ["added", "throwNoDir", "option", "updated", "deps"], "add_tokens": "* @ property { boolean } [ throwNoDir = true ] - throw exception if require ' var files = [ ] ; try { files = fs . readdirSync ( absDir ) ; } catch ( e ) { if ( options . throwNoDir ) { throw e ; } } if ( typeof options . throwNoDir === 'undefined' ) options . throwNoDir = true ;", "del_tokens": "var files = fs . readdirSync ( absDir ) ;", "commit_type": "add"}
{"commit_tokens": ["made", "change", "to", "more", "functional", "approach", "with", "taskCollection"], "add_tokens": "let collection = TC . TaskCollection ( ) ;", "del_tokens": "let collection = TaskCollection ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "file", "protocol", "."], "add_tokens": "var ssl = false , local = false ; case ' file : ' local = true ; break ; // Load files off the local filesystem (file://) if ( local ) { if ( settings . method !== \"GET\" ) { throw \"XMLHttpRequest: Only GET method is supported\" ; } if ( settings . async ) { fs . readFile ( url . pathname , 'utf8' , function ( error , data ) { if ( error ) { self . handleError ( error ) ; } else { self . status = 200 ; self . responseText = data ; setState ( self . DONE ) ; } } ) ; } else { try { this . responseText = fs . readFileSync ( url . pathname , 'utf8' ) ; this . status = 200 ; setState ( self . DONE ) ; } catch ( e ) { this . handleError ( e ) ; } } return ; } if ( settings . async ) {", "del_tokens": "* @ todo SSL Support var ssl = false ; if ( ! settings . hasOwnProperty ( \"async\" ) || settings . async ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "tests", "to", "use", "grunt", "files", "option"], "add_tokens": "files : [ { cwd : 'test/fixtures' , expand : true , src : 'tizen-tiny-app/**' } ] ,", "del_tokens": "files : 'test/fixtures/tizen-tiny-app/**' , stripPrefix : 'test/fixtures' ,", "commit_type": "fix"}
{"commit_tokens": ["Removing", "circular", "reference", "between", "Model", "and", "data"], "add_tokens": "it ( 'should handle converting model type to json schema without using composition' ,", "del_tokens": "it ( 'should handle converting model type to json schema without using composition' ,", "commit_type": "remove"}
{"commit_tokens": ["Fix", "scss", "mixins", "by", "only", "namespacing", "in", "media", "atrules"], "add_tokens": "return hasParentRule ( rule ) || parentIsAllowedAtRule ( rule ) * Returns true if the parent rule is a not a media atrule function parentIsAllowedAtRule ( rule ) { ! / media$ / . test ( rule . parent . name )", "del_tokens": "return hasParentRule ( rule ) || parentIsKeyframes ( rule ) * Returns true if the parent rule is a keyframes atrule function parentIsKeyframes ( rule ) { / keyframes$ / . test ( rule . parent . name )", "commit_type": "fix"}
{"commit_tokens": ["add", "textsize", "to", "circle", "-", "timer"], "add_tokens": "drawText ( ctx , canvas , data . countDown , guiItem . textsize + ' ' + data . fontFamily , data . fontColor , 1 ) ; 'textsize' : 'gui-item.textsize' , } ) ;", "del_tokens": "drawText ( ctx , canvas , data . countDown , '200px ' + data . fontFamily , data . fontColor , 1 ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "some", "style", "and", "added", "eslint", "package"], "add_tokens": "'use strict' ; testGen : testGen } ;", "del_tokens": "testGen : testGen }", "commit_type": "fix"}
{"commit_tokens": ["remove", "console", ".", "log", "()"], "add_tokens": "//deb( parsed ) ; //deb( parsed ) ; //deb( parsed ) ;", "del_tokens": "deb ( parsed ) ; deb ( parsed ) ; deb ( parsed ) ;", "commit_type": "remove"}
{"commit_tokens": ["Update", "README", ".", "Considering", "deprecating", "fullWidth"], "add_tokens": "fullWidth : false , //window.innerWidth < 650, expanded : false", "del_tokens": "fullWidth : window . innerWidth < 650 , expanded : true", "commit_type": "update"}
{"commit_tokens": ["Upgrade", "for", "gltf", "-", "pipeline"], "add_tokens": "var fs = require ( 'fs-extra' ) ; module . exports = loadImage ; function loadImage ( imagePath , done ) { fs . readFile ( imagePath , function ( error , data ) { if ( error ) { throw ( error ) ;", "del_tokens": "var fs = require ( 'fs' ) ; module . exports = imageInfo ; function imageInfo ( imagePath , done ) { fs . readFile ( imagePath , function ( err , data ) { if ( err ) { throw ( err ) ;", "commit_type": "upgrade"}
{"commit_tokens": ["Added", "emote", ";", "Fixed", "waitlist", "functionality", ";", "Added", "updateCode", ";", "Other", "fixes", "."], "add_tokens": "function PlugAPI ( key , updateCode ) { this . updateCode = updateCode != undefined && updateCode . match ( / [0-9a-f]{6} / ) ? updateCode : 'fe940c' ; case 'emote' : _this . emit ( 'emote' , m ) ; break ; this . room . setDjs ( msg . data . djs ) ; return this . sendRPC ( 'room.join' , [ name , _this . updateCode ] , function ( data ) { this . historyID = data . room . historyID ; this . emit ( 'roomJoin' , data ) ;", "del_tokens": "function PlugAPI ( key ) { console . log ( \"Received message: \" , m ) ; // console.log(\"client on data: \", data); this . room . setDjs ( msg . data ) ; case 'waitListUpdate' : this . room . setWaitlist ( msg . data ) ; break ; return this . sendRPC ( 'room.join' , [ name ] , function ( data ) { // this.room.setWaitlist(data.room.waitList);", "commit_type": "add"}
{"commit_tokens": ["Adding", "more", "information", "to", "the", "documentation"], "add_tokens": "var readme = path . join ( __dirname , 'README.md' ) ; var index = path . join ( __dirname , 'index.js' ) ; return gulp . src ( [ readme , index , lib ] )", "del_tokens": "return gulp . src ( lib )", "commit_type": "add"}
{"commit_tokens": ["Add", ";", "to", "the", "end", "of", "index", ".", "js"], "add_tokens": "} ) . call ( this ) ;", "del_tokens": "} ) . call ( this )", "commit_type": "add"}
{"commit_tokens": ["added", "memberexpression", "(", "a", ".", "b", "and", "a", "[", "2", "]", ")"], "add_tokens": "\"jspeiFindInScopes,jspReplaceWith,jspeFunctionCall,\" + \"jspGetNamedVariable,jspGetNamedField,jspGetVarNamedField,\" + \"jsvNewWithFlags,\" + \"\" , 536871028 ] } ; var c = 'function f() { \"compiled\";a[2]; }' ; //var c = 'd=digitalWrite;function f() { \"compiled\";d(13,13); }'; //var c = 'function f() { \"compiled\";var a = 0; for (var i=0;i<1024;i++) a++; return a;}';", "del_tokens": "\"jspeiFindInScopes,jspReplaceWith,\" , 536871028 ] } ; //var c = 'function f() { \"compiled\";var a = 0; for (var i=0;i<10;i++) a++; return a;}'; var c = 'function f() { \"compiled\";x++; }' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "themes", "task", "to", "gulpfile"], "add_tokens": "runSequence ( 'compile' , 'test' , 'npm-package' , 'rollup-bundle' , 'themes' , cb ) ;", "del_tokens": "runSequence ( 'compile' , 'test' , 'npm-package' , 'rollup-bundle' , cb ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "process", "in", "Gruntfile", "update", "comment", "redefine", "line", "strokeStyle", "def"], "add_tokens": "strokeStyle : 'rgba(0, 0, 0, 0)' ,", "del_tokens": "strokeStyle : null ,", "commit_type": "add"}
{"commit_tokens": ["Removed", ":", "Module", "named", "methods"], "add_tokens": "hasPlugin : system . hasPlugin ,", "del_tokens": "hasModule : system . hasPlugin , getModule : system . pluginExportsOf ,", "commit_type": "remove"}
{"commit_tokens": ["Added", ".", "auth", ".", "jar", "and", ".", "cookie", "implementations", "along", "with", "corresponding", "tests"], "add_tokens": "t . isNumber ( body [ 0 ] . d ) ; t . isNumber ( body [ 0 ] . d ) ; t . isNumber ( body [ 0 ] . d ) ; t . isNumber ( body [ 0 ] . d ) ; t . isNumber ( body [ 0 ] . d ) ;", "del_tokens": "t . strictEqual ( body [ 0 ] . d , 1 ) ; t . strictEqual ( body [ 0 ] . d , 1 ) ; t . strictEqual ( body [ 0 ] . d , 1 ) ; t . strictEqual ( body [ 0 ] . d , 1 ) ; t . strictEqual ( body [ 0 ] . d , 1 ) ;", "commit_type": "add"}
{"commit_tokens": ["updated", "all", "tools", "to", "use", "simpleTool"], "add_tokens": "mouseMoveData . viewport . centerX += ( mouseMoveData . deltaPageX / mouseMoveData . viewport . scale ) ; mouseMoveData . viewport . centerY += ( mouseMoveData . deltaPageY / mouseMoveData . viewport . scale ) ; cornerstone . setViewport ( element , mouseMoveData . viewport ) ; function onMouseDown ( e ) { cornerstoneTools . onMouseDown ( e , mouseMove ) ; } cornerstoneTools . pan = cornerstoneTools . makeSimpleTool ( onMouseDown ) ;", "del_tokens": "var viewport = cornerstone . getViewport ( element ) ; viewport . centerX += ( mouseMoveData . deltaPageX / viewport . scale ) ; viewport . centerY += ( mouseMoveData . deltaPageY / viewport . scale ) ; cornerstone . setViewport ( element , viewport ) ; cornerstoneTools . pan = cornerstoneTools . makeSimpleTool ( mouseMove ) ;", "commit_type": "update"}
{"commit_tokens": ["update", "resolution", "validation", "to", "new", "resolutionSchema"], "add_tokens": "var resolutionSchema = require ( 'screener-runner/src/validate' ) . resolutionSchema ; resolution : resolutionSchema ,", "del_tokens": "resolution : Joi . string ( ) . regex ( / ^[0-9]{3,4}x[0-9]{3,4}$ / , 'resolution' ) ,", "commit_type": "update"}
{"commit_tokens": ["Make", "argument", "length", "check", "compatible", "with", "Handlebars", "v3"], "add_tokens": "// In order to keep compatibility, we remove the first argument from the list if we detect that more than 6 arguments are available. return \"require(\" + JSON . stringify ( loaderUtils . urlToRequest ( resourcePath ) ) + \").apply(null, Array.prototype.slice.call(arguments, arguments.length > 6))\" ;", "del_tokens": "// In order to keep compatibility, we remove the first argument from the list if we detect that more than 4 arguments are available. return \"require(\" + JSON . stringify ( loaderUtils . urlToRequest ( resourcePath ) ) + \").apply(null, Array.prototype.slice.call(arguments, arguments.length > 4))\" ;", "commit_type": "make"}
{"commit_tokens": ["Use", "basic", "-", "auth", "in", "express", "4"], "add_tokens": "statics = require ( 'serve-static' ) , basicAuth = require ( 'basic-auth' ) ; var auth = basicAuth ( function ( user , pass ) { if ( ! ( user === u && pass === p ) ) { res . set ( 'WWW-Authenticate' , 'Basic realm=Authorization Required' ) ; return res . send ( 401 ) ; } next ( ) ;", "del_tokens": "statics = require ( 'serve-static' ) var auth = express . basicAuth ( function ( user , pass ) { return user === u && pass === p", "commit_type": "use"}
{"commit_tokens": ["Use", "util", ".", "noop", "explicitly"], "add_tokens": "log : util . noop", "del_tokens": "log : new Function ( )", "commit_type": "use"}
{"commit_tokens": ["made", "more", "updates", "to", "get", "working"], "add_tokens": "module . exports = class TwigViewManager { onConfigureViewEngine ( container , next ) {", "del_tokens": "module . exports = class Twig { * @ param { Application } app onConfigureViewEngine ( container , consolidate , next ) {", "commit_type": "make"}
{"commit_tokens": ["Updated", "for", "use", "with", "YUIDoc"], "add_tokens": "* @ module f2 * @ main f2 * @ method guid * @ return { string } A random id * @ for F2 * @ method log * @ param { Object } args The object to be logged to the console * @ method inArray * @ param { object } value The value to search for * @ param { Array } array The array to search * @ method extend * @ method parse * @ method stringify", "del_tokens": "* @ namespace * @ param { object } The value to search for * @ param { Array } The array to search", "commit_type": "update"}
{"commit_tokens": ["Added", "s", "tests", "for", "src", "/", "es6", "version", "."], "add_tokens": "extend : function ( ... args ) { if ( args . length === 0 ) { var deep = sjl . extractBoolFromArrayStart ( args ) , args . forEach ( function ( arg ) { parts . forEach ( function ( key , i ) { if ( Object . getOwnPropertyDescriptor ) { propDescription = Object . getOwnPropertyDescriptor ( o , prop ) ;", "del_tokens": "extend : function ( ) { if ( arguments . length === 0 ) { var args = sjl . argsToArray ( arguments ) , deep = sjl . extractBoolFromArrayStart ( args ) , sjl . forEach ( args , function ( arg ) { sjl . forEach ( parts , function ( key , i ) { if ( getOwnPropertyDescriptor ) { propDescription = getOwnPropertyDescriptor ( o , prop ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "dropdown", "to", "change", "type", "of", "existing", "marker", "/", "line"], "add_tokens": "if ( ! utils . stripObject ( data , { id : \"number\" , lat : \"number\" , lon : \"number\" , name : \"string\" , colour : \"string\" , typeId : \"number\" , data : Object } ) ) if ( ! utils . stripObject ( data , { id : \"number\" , points : [ { lat : \"number\" , lon : \"number\" } ] , mode : \"string\" , colour : \"string\" , width : \"number\" , name : \"string\" , typeId : \"number\" , data : Object } ) )", "del_tokens": "if ( ! utils . stripObject ( data , { id : \"number\" , lat : \"number\" , lon : \"number\" , name : \"string\" , colour : \"string\" , data : Object } ) ) if ( ! utils . stripObject ( data , { id : \"number\" , points : [ { lat : \"number\" , lon : \"number\" } ] , mode : \"string\" , colour : \"string\" , width : \"number\" , name : \"string\" , data : Object } ) )", "commit_type": "add"}
{"commit_tokens": ["fixed", "function", "name", "getConstrains", "spell", "error", "update", "readme", "file", "with", "new", "option", ":", "constrains"], "add_tokens": "getConstrains : function ( ) { var constrainsH = this . getConstrains ( ) === 'horizontal' , constrainsV = this . getConstrains ( ) === 'vertical' ;", "del_tokens": "getContrains : function ( ) { var constrainsH = this . getContrains ( ) === 'horizontal' , constrainsV = this . getContrains ( ) === 'vertical' ;", "commit_type": "fix"}
{"commit_tokens": ["make", "sure", "we", "store", "subviews", "by", "name"], "add_tokens": "this . _parseSubview ( this . subviews [ item ] , item ) ; _parseSubview : function ( subview , name ) {", "del_tokens": "this . _parseSubview ( this . subviews [ item ] ) ; _parseSubview : function ( subview ) {", "commit_type": "make"}
{"commit_tokens": ["Added", "support", "for", "path", ".", "resolve", "when", "determining", "export", "target"], "add_tokens": "var pkg = require ( './package.json' ) , lib = require ( './lib' ) , program = require ( 'commander' ) , async = require ( 'async' ) , colors = require ( 'colors' ) , chalk = require ( 'chalk' ) , read = require ( 'read' ) , path = require ( 'path' ) ; console . log ( chalk . green ( '\\nDone! Find your new' , format , 'resume at:\\n' , path . resolve ( process . cwd ( ) , fileName ) ) ) ;", "del_tokens": "var pkg = require ( './package.json' ) ; var lib = require ( './lib' ) ; var program = require ( 'commander' ) ; var async = require ( 'async' ) ; var colors = require ( 'colors' ) ; var chalk = require ( 'chalk' ) ; var read = require ( 'read' ) ; console . log ( chalk . green ( '\\nDone! Find your new' , format , 'resume at' , process . cwd ( ) + '/' + fileName + format ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "static", "content", "for", "hello", "world", "instead", "of", "router", "."], "add_tokens": "alpha : true , // alpha compositing based on window content (Windows & Mac)", "del_tokens": "app . get ( '/' , function ( req , res , next ) { res . send ( \"Hello World!\" ) ; } ) ; alpha : false , // alpha compositing based on window content (Windows & Mac)", "commit_type": "use"}
{"commit_tokens": ["fix", "the", "build", "travis", "ci"], "add_tokens": "var noOps = { } ; noOps . precompile = function ( ) { } ; templateCompiler : noOps . precompile", "del_tokens": "templateCompiler : function ( ) { }", "commit_type": "fix"}
{"commit_tokens": ["changed", "isInstanceOf", "to", "accept", "multiple", "classes"], "add_tokens": "/ ** * * Converts an arguments object to an array * @ function * @ param { Arguments } args the arguments object to convert * @ memberOf comb * @ returns { Array } array version of the arguments object * / var argsToArray = comb . argsToArray = function ( args ) { return Array . prototype . slice . call ( args ) ; } ; comb . isUndefinedOrNull = function ( obj ) { var isInstance = function ( obj , clazz ) { if ( typeof clazz == \"function\" ) { return obj instanceof clazz ; } else { return false ; } } ; return argsToArray ( arguments ) . slice ( 1 ) . some ( function ( c ) { return isInstance ( obj , c ) ; } ) ;", "del_tokens": "comb . isUndefinedOrNull = function ( obj ) { if ( typeof clazz == \"function\" ) { return obj instanceof clazz ; } else { return false ; }", "commit_type": "change"}
{"commit_tokens": ["Add", "support", "for", "multiple", "outputs", "from", "a", "single", "entry"], "add_tokens": "add ( filePaths , entryName ) { if ( typeof filePaths === 'string' ) { filePaths = [ filePaths ] ; } for ( let index in filePaths ) { let filePath = filePaths [ index ] ; filePath = this . normalizePath ( filePath ) ; let original = filePath . replace ( / \\?.* / , '' ) ; original = original . replace ( path . basename ( original ) , entryName + path . extname ( original ) ) ; this . manifest [ original ] = filePath ; }", "del_tokens": "add ( filePath , entryName ) { filePath = this . normalizePath ( filePath ) ; let original = filePath . replace ( / \\?.* / , '' ) ; original = original . replace ( path . basename ( original ) , entryName + path . extname ( original ) ) ; this . manifest [ original ] = filePath ;", "commit_type": "add"}
{"commit_tokens": ["Move", "test", "grunt", "step", "below", "others"], "add_tokens": "grunt . loadNpmTasks ( 'grunt-jasmine-node-coverage' ) ; grunt . config ( 'jasmine_node' , { coverage : { options : { coverage : { } , forceExit : true , match : '.' , matchAll : false , specFolders : [ 'test' ] , extensions : 'js' , specNameMatcher : 'spec' , captureExceptions : true , junitreport : { report : false , savePath : './build/reports/jasmine/' , useDotNotation : true , consolidate : true } } , src : [ '**/*.js' ] } } ) ;", "del_tokens": "grunt . loadNpmTasks ( 'grunt-jasmine-node-coverage' ) ; grunt . config ( 'jasmine_node' , { coverage : { / *coverage: { }, options : { extensions : 'js' , specNameMatcher : '.*-spec' , captureExceptions : true } * / options : { coverage : { } , forceExit : true , match : '.' , matchAll : false , specFolders : [ 'test' ] , extensions : 'js' , specNameMatcher : '-spec' , captureExceptions : true , junitreport : { report : false , savePath : './build/reports/jasmine/' , useDotNotation : true , consolidate : true } } , src : [ 'src/*.js' ] } } ) ;", "commit_type": "move"}
{"commit_tokens": ["Make", "the", "Generic", "REST", "format", "more", "flexible"], "add_tokens": "function extractOne ( result ) { let extracted = { } ; for ( let arg of block . args ) { if ( arg . json_key ) extracted [ arg . name ] = result [ arg . json_key ] ; else extracted [ arg . name ] = result [ arg . name ] ; } return extracted ; } return parsed . map ( extractOne ) ; return [ extractOne ( parsed ) ] ;", "del_tokens": "return parsed ; return [ parsed ] ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "serverless", "deploy", "in", "vault"], "add_tokens": "console . log ( response . uri , response ) ; headers [ 'content-security-policy' ] = [ { key : 'Content-Security-Policy' , value : \"default-src 'none'; style-src 'self'; img-src 'self'; media-src 'self'; manifest-src 'self'; font-src 'self'; script-src blob: 'self'; connect-src 'self'\" , } ] ;", "del_tokens": "if ( response . uri === '/index.html' || response . uri === '/' ) { headers [ 'content-security-policy' ] = [ { key : 'Content-Security-Policy' , value : \"default-src 'none'; style-src 'self'; img-src 'self'; media-src 'self'; manifest-src 'self'; font-src 'self'; script-src blob: 'self'; connect-src 'self'\" , } ] ; } else { headers [ 'content-security-policy' ] = [ { key : 'Content-Security-Policy' , value : \"default-src 'none'\" , } ] ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "behavior", "to", "include", "option"], "add_tokens": "var tsconfig = { } ;", "del_tokens": "var tsconfig = { compilerOptions : { } } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "the", "lineBreak", "option", "keeping", "the", "selectors", "indent"], "add_tokens": "// 匹配换行符与空白 var reBLANK_LINE = / (\\r\\n|\\n|\\r)(\\s*?\\1)+ / gi var newSelector = customSelector . split ( \",\" ) . map ( function ( selector ) { } ) // 选择器不换行 if ( ! options . lineBreak && options . lineBreak === false ) { line_break = \" \" newSelector = newSelector . join ( \",\" + line_break ) } else { // 选择器换行，同时替换多个换行为一个 newSelector = newSelector . join ( \",\" + line_break + rule . before ) . replace ( reBLANK_LINE , line_break ) } return newSelector", "del_tokens": "//控制选择器是否换行 if ( ! options . lineBreak && options . lineBreak == false ) { line_break = ' ' } return customSelector . split ( \",\" ) . map ( function ( selector ) { } ) . join ( \",\" + line_break )", "commit_type": "fix"}
{"commit_tokens": ["fixing", "duplicate", "pipe", "in", "gulpfile", ".", "js"], "add_tokens": "// Prepare the min.css for production (with 2 pipes to be sure that \"theme.css\" == \"theme.min.css\")", "del_tokens": "// Prepare the min.css for production (with 2 pipes to be sure that \"child-theme.css\" == \"child-theme.min.css\") . pipe ( gulp . dest ( './css' ) ) ; . pipe ( gulp . dest ( './css' ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "TODO", "for", "further", "discussions"], "add_tokens": "// TODO: how do we implement this in NodeJS, like we did in Java, see https://github.com/julianghionoiu/tdl-client-java/commit/4475fc3b01bb3f6fbc2b2d423848f5dcec489461#diff-0672afec8f176ab43f4d558fe4023e5dR54 // Cucumber does not support .And() clause in NodeJS/JS", "del_tokens": "// TODO: see how this can be do different, read off config?", "commit_type": "add"}
{"commit_tokens": ["Added", "back", "missing", "redux", "-", "api", "-", "middleware"], "add_tokens": "import { apiMiddleware } from 'redux-api-middleware' ; return [ apiMiddleware ] ;", "del_tokens": "return [ ] ;", "commit_type": "add"}
{"commit_tokens": ["Use", "a", "real", "function", "for", "linting"], "add_tokens": "modulename . func ( ) ;", "del_tokens": "modulename . works ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "case", "of", "version", "property", "name"], "add_tokens": "{ version : '1.10.1' , url : 'https://github.com/OrchardCMS/Orchard/archive/1.10.1.zip' } , { version : '1.10' , url : 'https://github.com/OrchardCMS/Orchard/archive/1.10.zip' } , { version : '1.9.3' , url : 'https://github.com/OrchardCMS/Orchard/archive/1.9.3.zip' } ,", "del_tokens": "{ versioN : '1.10.1' , url : 'https://github.com/OrchardCMS/Orchard/archive/1.10.1.zip' } , { versioN : '1.10' , url : 'https://github.com/OrchardCMS/Orchard/archive/1.10.zip' } , { versioN : '1.9.3' , url : 'https://github.com/OrchardCMS/Orchard/archive/1.9.3.zip' } ,", "commit_type": "fix"}
{"commit_tokens": ["Use", "findHost", "to", "find", "app"], "add_tokens": "var findHost = require ( './lib/utils/find-host' ) ; var app = findHost ( this ) ;", "del_tokens": "var app = this . app ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "broken", "example", "in", "README", "and", "doc", "comment"], "add_tokens": "* var http = require ( 'http' ) ; * var livedb = require ( 'livedb' ) ; * var shareServer = require ( 'share' ) . server . createClient ( { * backend : livedb . client ( livedb . memory ( ) ) * } ) ; * shareServer . listen ( stream ) ;", "del_tokens": "* var http = require ( 'http' ) ; * var livedb = require ( 'livedb' ) ; * var share = require ( 'share' ) ; * share . server * . createClient ( { backend : livedb . client ( livedb . memory ( ) ) } ) * . listen ( stream ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "comment", "on", "some", "formats", "that", "Alexa", "does", "not", "support"], "add_tokens": "/ ** * Alexa does not support format 39 ** / / ** * Alexa does not support format 39 ** / / ** * Alexa does not support format us - state ** / \"word\" : \"2007/01/02\" , assert . equal ( speech . ssml ( ) , \"<speak><say-as interpret-as='date' format='ymd'>2007/01/02</say-as></speak>\" ) ; / ** * Alexa device does not support 24 hours format * / \"word\" : \"19:21:30\" , assert . equal ( speech . ssml ( ) , \"<speak><say-as interpret-as='time' format='hms24'>19:21:30</say-as></speak>\" ) ; / ** * Alexa device does not support 12 hours format * /", "del_tokens": "\"word\" : \"01/02/2007\" , assert . equal ( speech . ssml ( ) , \"<speak><say-as interpret-as='date' format='ymd'>01/02/2007</say-as></speak>\" ) ; it ( 'should build a sayAs interpret as time' , function ( ) { speech . sayAs ( { \"word\" : \"19:21:30.1\" , \"interpretParams\" : \"time\" } ) ; assert . equal ( speech . ssml ( ) , \"<speak><say-as interpret-as='time'>19:21:30.1</say-as></speak>\" ) ; } ) ; \"word\" : \"19:21:30.1\" , assert . equal ( speech . ssml ( ) , \"<speak><say-as interpret-as='time' format='hms24'>19:21:30.1</say-as></speak>\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "key", "to", "name", "for", "template", "names"], "add_tokens": "ltl . compile ( 'b #{text}' , { name : 'bold' } ) ; var temp = ltl . compile ( 'p\\n use common' , { name : 'temp' } ) ; ltl . compile ( 'b #{text}' , { name : 'common' } ) ; var temp = ltl . compile ( 'use base\\n set a\\n p A\\n set b\\n p B' , { name : 'temp' } ) ; var base = ltl . compile ( 'div\\n get a\\n get b' , { name : 'base' } ) ;", "del_tokens": "ltl . compile ( 'b #{text}' , { key : 'bold' } ) ; var temp = ltl . compile ( 'p\\n use common' , { key : 'temp' } ) ; ltl . compile ( 'b #{text}' , { key : 'common' } ) ; var temp = ltl . compile ( 'use base\\n set a\\n p A\\n set b\\n p B' , { key : 'temp' } ) ; var base = ltl . compile ( 'div\\n get a\\n get b' , { key : 'base' } ) ;", "commit_type": "change"}
{"commit_tokens": ["added", "stop", "()", "method", "to", "playemjs", "+", "removed", "old", "comments"], "add_tokens": "Player . prototype . stop = function ( vol ) { } ;", "del_tokens": "//this.element.pauseVideo(); //this.element.playVideo(); / *Player.prototype.stop = function(vol) { } ; * / //this.element.seekTo(pos); //(this.element||{}).setVolume && this.element.setVolume(vol * 100);", "commit_type": "add"}
{"commit_tokens": ["make", "root", "path", "file", "before", "contents"], "add_tokens": "return self . createRootPathFile ( ) return self . createContentsFile ( )", "del_tokens": "return self . createContentsFile ( ) return self . createRootPathFile ( ) if ( ! self . opts . dev ) { fs . removeSync ( self . stageDir ) }", "commit_type": "make"}
{"commit_tokens": ["Adds", "aria", "-", "hidden", "=", "true", "to", "cloned", "slides", ".", "Avoids", "duplicate", "content", "issue", ".", "Merges", "pull", "request", "457", "."], "add_tokens": "slider . container . append ( slider . slides . first ( ) . clone ( ) . addClass ( 'clone' ) . attr ( 'aria-hidden' , 'true' ) ) . prepend ( slider . slides . last ( ) . clone ( ) . addClass ( 'clone' ) . attr ( 'aria-hidden' , 'true' ) ) ;", "del_tokens": "slider . container . append ( slider . slides . first ( ) . clone ( ) . addClass ( 'clone' ) ) . prepend ( slider . slides . last ( ) . clone ( ) . addClass ( 'clone' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "by", "keeping", "in", "vars"], "add_tokens": "this . keyboardDidShowListener = Keyboard . addListener ( 'keyboardDidShow' , this . keyboardDidShow . bind ( this ) ) this . keyboardDidHideListener = Keyboard . addListener ( 'keyboardDidHide' , this . keyboardDidHide . bind ( this ) ) this . keyboardDidShowListener . remove ( ) this . keyboardDidHideListener . remove ( )", "del_tokens": "Keyboard . addListener ( 'keyboardDidShow' , this . keyboardDidShow . bind ( this ) ) Keyboard . addListener ( 'keyboardDidHide' , this . keyboardDidHide . bind ( this ) ) Keyboard . removeAllListeners ( 'keyboardDidShow' ) Keyboard . removeAllListeners ( 'keyboardDidHide' )", "commit_type": "fix"}
{"commit_tokens": ["Move", "set", "type", "checks", "to", "also", "cover", "setAll"], "add_tokens": "setSilent ( path , value ) ; notifyWatchersOnPaths ( paths ) ; } / ** * Set a store value at path / key to given value WITHOUT notifying watchers * * @ param { String } path * @ param { mixed } value * @ return null * / function setSilent ( path , value ) {", "del_tokens": "setSilent ( path , value ) ; notifyWatchersOnPaths ( paths ) ; } / ** * Set a store value at path / key to given value WITHOUT notifying watchers * * @ param { String } path * @ param { mixed } value * @ return null * / function setSilent ( path , value ) {", "commit_type": "move"}
{"commit_tokens": ["fixed", "issue", "with", "more", "then", "2", "dimensions", "."], "add_tokens": "function generateContent ( data , parentKey ) { var name , key ; for ( key in data ) { name = parentKey ? format ( parentKey + \"-\" + key , options . cssFormat ) : format ( key , options . cssFormat ) ; if ( typeof ( data [ key ] ) === \"object\" ) { generateContent ( data [ key ] , name ) ; content += pattern . replace ( '{{key}}' , name ) . replace ( '{{value}}' , data [ key ] ) ; generateContent ( data ) ;", "del_tokens": "var name , key ; function generateContent ( data , type , parent ) { for ( var key in data ) { if ( typeof ( data [ key ] ) === \"object\" ) { generateContent ( data [ key ] , type , key ) ; name = format ( key , options . cssFormat ) ; content += pattern . replace ( '{{key}}' , parent ? parent + \"-\" + name : name ) . replace ( '{{value}}' , data [ key ] ) ; generateContent ( data , type ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "huge", "text", "edge", "cases", "for", "*", "-", "alt", "placements", "."], "add_tokens": "// setup huge text tooltips $ . each ( [ 'north' , 'east' , 'south' , 'west' , 'north-west' , 'north-east' , 'south-west' , 'south-east' , 'north-west-alt' , 'north-east-alt' , 'south-west-alt' , 'south-east-alt' ] , function ( i , val ) { $ ( '.' + val ) . data ( 'powertip' , hugeText ) ; } ) ; // Huge text $ ( '#huge-text .north-west-alt' ) . powerTip ( { placement : 'nw-alt' } ) ; $ ( '#huge-text .north-east-alt' ) . powerTip ( { placement : 'ne-alt' } ) ; $ ( '#huge-text .south-west-alt' ) . powerTip ( { placement : 'sw-alt' } ) ; $ ( '#huge-text .south-east-alt' ) . powerTip ( { placement : 'se-alt' } ) ; $ ( '#huge-text-smart .north-west-alt' ) . powerTip ( { placement : 'nw-alt' , smartPlacement : true } ) ; $ ( '#huge-text-smart .north-east-alt' ) . powerTip ( { placement : 'ne-alt' , smartPlacement : true } ) ; $ ( '#huge-text-smart .south-west-alt' ) . powerTip ( { placement : 'sw-alt' , smartPlacement : true } ) ; $ ( '#huge-text-smart .south-east-alt' ) . powerTip ( { placement : 'se-alt' , smartPlacement : true } ) ;", "del_tokens": "// Huge text $ ( '.north, .east, .south, .west, .north-west, .north-east, .south-west, .south-east' ) . data ( 'powertip' , hugeText ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "browser", "detection", "into", "svg", "-", "utils"], "add_tokens": "var Utils = require ( './utilities' ) , _browser = 'unknown' ; // http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser if ( /*@cc_on!@*/ false || ! ! document . documentMode ) { // internet explorer _browser = 'ie' ; } else if ( typeof InstallTrigger !== 'undefined' ) { // firefox _browser = 'firefox' ; } if ( _browser === 'firefox' ) { if ( _browser === 'ie' && ! ! defs ) {", "del_tokens": "var Utils = require ( './utilities' ) ; if ( this . _browser === 'firefox' ) { if ( that . _browser === 'ie' && ! ! defs ) {", "commit_type": "move"}
{"commit_tokens": ["Add", "support", "to", "alpha", "transparency", "in", "hex", "RegExp"], "add_tokens": "var colorRegEx1 = / ^#[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])?([0-9a-fA-F][0-9a-fA-F])?$ / ;", "del_tokens": "var colorRegEx1 = / ^#[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])?$ / ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "connect", "()", "option", "imap", ".", "authTimeout", "default"], "add_tokens": "// support old connectTimeout config option. Remove in v2.0.0 // set default authTimeout options . imap . authTimeout = options . imap . hasOwnProperty ( 'authTimeout' ) ? options . imap . authTimeout : 2000 ;", "del_tokens": "options . imap . authTimeout = options . hasOwnProperty ( 'authTimeout' ) ? options . authTimeout : 2000 ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "global", "bitcoinprices", ".", "js"], "add_tokens": "var bitcoinprices = require ( \"bitcoinprices\" ) ;", "del_tokens": "var bitcoinprices = require ( \"../bitcoinprices/bitcoinprices.js\" ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "infinite", "loop", "in", "amd", "-", ">", "amd", "transform"], "add_tokens": "return this . traverse ( path ) ;", "del_tokens": "return this . visit ( path ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "the", "Promise", "option", "to", "lowdb", ".", "add", "writePromise", "()", "in", "disk", ".", "js", ".", "add", "db", ".", "savePromise", "()", "in", "index", ".", "js", ".", "These", "changes", "enables", "users", "to", "use", "promise", "(", "powered", "by", "Q", "module", ")", "with", "lowdb", "compatible", "with", "the", "original", "lowdb", "at", "the", "same", "time", "."], "add_tokens": "var Q = require ( 'q' ) async : true , promise : false if ( str === checksum ) { if ( options . promise ) { return Q . fcall ( function ( ) { return 'no changes' ; } ) } else { return } } if ( options . async ) { if ( options . promise ) { return disk . writePromise ( file , str ) } else { disk . write ( file , str ) } } else { disk . writeSync ( file , str ) } db . savePromise = function ( f ) { f = f ? f : file return disk . writePromise ( f , low . stringify ( db . object ) ) }", "del_tokens": "async : true if ( str === checksum ) return options . async ? disk . write ( file , str ) : disk . writeSync ( file , str )", "commit_type": "add"}
{"commit_tokens": ["changed", "relative", "moduleRoot", "to", "absolute", "to", "fix", "bugs"], "add_tokens": ", path = require ( 'path' ) makePackageReady ( moduleRoot + '/' + 'node_modules' + '/' + modulename , function ( err , pkg , m , u , v , l , p , b ) { var nextModuleRoot = moduleRoot + '/' + 'node_modules' + '/' + modulename fs . readdir ( nextModuleRoot , function ( err , nodes ) { npm . commands . install ( moduleRoot , [ modulename ] , fn ) ;", "del_tokens": ", moduleRoot = process . argv [ 2 ] || '../test_modules/foomodule' makePackageReady ( './' + 'node_modules' + '/' + modulename , function ( err , pkg , m , u , v , l , p , b ) { var path = '.' , moduleRoot = path + '/' + 'node_modules' + '/' + modulename fs . readdir ( moduleRoot , function ( err , nodes ) { npm . commands . install ( path , [ modulename ] , fn ) ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "NodeServiceTest", "and", "changed", "metamodel", "ready", "behaviour"], "add_tokens": "return this . _saveLoadPromise ;", "del_tokens": "return this . _saveLoadPromise ; } , / ** * Finalizes the Metamodel instance . * A Metamodel is only allowed to be used by one instance of an EntityManager * / finalize : function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "rule", "cp", "-", "macro", "-", "not", "-", "key"], "add_tokens": "/ ** * Checks if node is property value declaration in the object expression * * @ param { ASTNode } node * @ returns { boolean } * / function isPropertyValueDeclaration ( node ) { return obj . get ( node , \"parent.type\" ) === \"Property\" && obj . get ( node , \"parent.parent.type\" ) === \"ObjectExpression\" ; } cleanCaller : cleanCaller , isPropertyValueDeclaration : isPropertyValueDeclaration", "del_tokens": "cleanCaller : cleanCaller", "commit_type": "add"}
{"commit_tokens": ["add", "error", "message", "from", "NBA", "to", "errors", ";", "60s", "timeout", "on", "coverage"], "add_tokens": "err = new Error ( \"HTTP error: \" + resp . statusCode + \" \" + body . Message ) ;", "del_tokens": "err = new Error ( \"HTTP error: \" + resp . statusCode + \" \" + JSON . stringify ( resp . body ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "regex", "to", "pluckable", "function", "removing", "string", "literal"], "add_tokens": "// Regex escape function - allows variables with special characters in expression RegExp . escape = function ( s ) { return s . replace ( / [-\\/\\\\^$*+?.()|[\\]{}] / g , '\\\\$&' ) ; } ; // Patterns var pattern = { openingAndClosing : new RegExp ( RegExp . escape ( opening ) + '(.|\\n)*' + RegExp . escape ( closing ) , 'g' ) } ; // Module return str . match ( pattern . openingAndClosing ) ; // pluckable(str) { // // Returns true if both opening and closing delimiters are found // return delimiterStart(str) !== -1 && snippetEnd(str) !== -1; // }, // if(!this.pluckable(str)) return new Error('unpluckable input');", "del_tokens": "return delimiterStart ( str ) !== - 1 && snippetEnd ( str ) !== - 1 ; if ( ! this . pluckable ( str ) ) return new Error ( 'unpluckable input' ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "hand", ".", "palmDirection", "to", "hand", ".", "direction", "to", "match", "main", "API", ".", "Changed", "data", ".", "palmDirection", "to", "data", ".", "direction", "to", "match", "JSON", "."], "add_tokens": "* @ member Leap . Hand . prototype . direction this . direction = data . direction", "del_tokens": "* @ member Leap . Hand . prototype . palmDirection this . palmDirection = data . palmDirection", "commit_type": "change"}
{"commit_tokens": ["Make", "request", ".", "js", "a", "devDependency"], "add_tokens": "if ( this . useHttps ) { requestSettings . agent = new https . Agent ( requestSettings ) ; } var isJson = contentType && contentType . indexOf ( 'application/json' ) !== - 1 ; res . on ( 'data' , function ( chunk ) { offset += chunk . copy ( responseBuffer , offset ) ; res . on ( 'end' , function ( ) { req . end ( JSON . stringify ( message ) , 'utf8' ) ;", "del_tokens": "var isJson = false ; if ( contentType && contentType . indexOf ( 'application/json' ) != - 1 ) { res . setEncoding ( 'utf8' ) ; isJson = true ; } res . on ( 'data' , ( chunk ) => { if ( isJson ) { offset += responseBuffer . write ( chunk , offset , chunk . length ) ; } else { offset += chunk . copy ( responseBuffer , offset ) ; } res . on ( 'end' , ( ) => { req . write ( JSON . stringify ( message ) ) ; req . end ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Improve", "hasField", "to", "look", "for", "aliases", "first"], "add_tokens": "set . some ( ( { alias , name } ) => ( alias || name ) . value === name )", "del_tokens": "set . some ( ( { name : { value , } , } ) => value === name )", "commit_type": "improve"}
{"commit_tokens": ["change", "default", "public", "path", "=", ">", "/", "to", "fixes", "bundle", "url", "error", "in", "deep", "routes"], "add_tokens": "publicPath : '/'", "del_tokens": "publicPath : ''", "commit_type": "change"}
{"commit_tokens": ["Added", "debug", "mode", "and", "debug", "()", "method", "to", "control", "it"], "add_tokens": "var _debugState = false ; var _debugStyle = 'font-weight: bold; color: #00f;' ; if ( _debugState ) { console . log ( 'ServiceWorker registration successful with scope: %c' + registration . scope , _debugStyle ) ; } if ( _debugState ) { console . log ( 'ServiceWorker registration failed: %c' + err , _debugStyle ) ; } } , / ** * Turn on or off the output of debug messages to the console . * Don ' * * @ param { Boolean } [ newState = true ] - Turn on / off debug messages * @ method debug * / debug : function ( newState ) { if ( arguments . length > 0 ) { _debugState = ! ! newState ; } else { _debugState = true ; }", "del_tokens": "console . log ( 'ServiceWorker registration successful with scope: ' , registration . scope ) ; console . log ( 'ServiceWorker registration failed: ' , err ) ;", "commit_type": "add"}
{"commit_tokens": ["adding", "example", "reading", "from", "local", "file", "and", "tweaked", "other", "examples", "for", "readability"], "add_tokens": "function fetchFactory ( loader ) { return new loader . Module ( { code : this . name + \" is compiled\" } ) ;", "del_tokens": "function fetchFactory ( /*loader*/ ) { return new this . manager . Module ( { code : this . name + \" is compiled\" } ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "nicer", "looking", "error", "syntax"], "add_tokens": "throw res . error ( 401 , 'Cannot access restrictd field \"' + name + '\".' ) ; return ;", "del_tokens": "var err = new Error ( 'Field is restricted.' ) ; err . status = 401 ; throw err ; return res . error ( err . status , err . message ) ;", "commit_type": "use"}
{"commit_tokens": ["Changing", "npm", "install", "to", "production", "in", "gateway", "generator", "."], "add_tokens": "this . npmInstall ( [ 'express-gateway' ] , { save : true } ) ;", "del_tokens": "// TODO: Before going live, switch out the NPM install package name. // this.npmInstall(['express-gateway'], { save: true }); this . npmInstall ( [ 'git+ssh://git@github.com:ExpressGateway/express-gateway.git' ] , { save : true } ) ;", "commit_type": "change"}
{"commit_tokens": ["Change", "how", "we", "run", "tests", "so", "that", "it", "can", "use", "action", "-", "input", "."], "add_tokens": "import Engine from './display/Engine.js' import { RegexTemplates } from './style/Evaluators.js' import * as ThreeAdditions from './three/Additions.js' DisplayModeTracker , Engine , RegexTemplates , ThreeAdditions", "del_tokens": "import Engine from './Engine.js' Engine , DisplayModeTracker", "commit_type": "change"}
{"commit_tokens": ["adds", "support", "for", "since", "and", "until", "to", "messaging", "insights"], "add_tokens": "function get ( options ) { if ( ! options . metrics ) { 'qs' : { 'metric' : options . metrics . join ( ',' ) } if ( options . since ) request_options . qs . since = options . since ; if ( options . until ) request_options . qs . until = options . until ;", "del_tokens": "function get ( metrics ) { if ( ! metrics ) { 'qs' : { 'metric' : metrics . join ( ',' ) }", "commit_type": "add"}
{"commit_tokens": ["Remove", "jshint", "global", "exceptions", "from", "above"], "add_tokens": "/*jshint -W093 */ /*jshint +W093 */", "del_tokens": "/*jslint browser: true*/ /*jshint -W093 */", "commit_type": "remove"}
{"commit_tokens": ["Added", "a", "timestamp", "to", "logProbe", "/", "statProbe", "bundles"], "add_tokens": "/* monitor-min - v0.5.6 - 2013-07-19 */ * @ param model . bundle . timestamp { long } Timestamp of the stat bundle in milliseconds // Add timestamp as the first element var logElems = _ . toArray ( arguments ) ; logElems . splice ( 0 , 0 , Date . now ( ) ) ; t . queueItem . call ( t , logElems ) ; t . queueItem . call ( t , logElems ) ;", "del_tokens": "/* monitor-min - v0.5.5 - 2013-07-19 */ t . queueItem . call ( t , _ . toArray ( arguments ) ) ; t . queueItem ( logElems ) ;", "commit_type": "add"}
{"commit_tokens": ["Moved", "to", "optimist", ".", "Will", "prob", "move", "again", "to", "comander", "-", "_", "-"], "add_tokens": "'value proxy' : expandProxy", "del_tokens": "'value proxy' : function valueProxyFn ( val ) { // Expand normally var retVal = expandProxy . call ( this , val ) ; // If there is no value, warn the user if ( ! retVal ) { console . warn ( 'Non-existant doubleshot content, \"' + val + '\", being requested' ) ; } // Return the retVal return retVal ; }", "commit_type": "move"}
{"commit_tokens": ["make", "resource", "loading", "works", "but", "still", "have", "bugs"], "add_tokens": "if ( relnames . length === 0 ) { if ( finished ) { finished ( null ) ; } return ; } //console.log(\"check path: \" + dirname); if ( finished ) { finished ( err ) ; } if ( relnames . length === 0 ) { if ( finished ) { finished ( null ) ; } return ; } //console.log(\"check path: \" + name); //console.log(\"counter= \" + counter);", "del_tokens": "finished ( err ) ; console . log ( \"counter= \" + counter ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "new", "ProductID", "in", "uno", "for", "Freduino", "UNO", "compatibility"], "add_tokens": "productId : [ '0x0043' , '0x7523' , '0x0001' ] ,", "del_tokens": "productId : [ '0x0043' , '0x7523' ] ,", "commit_type": "add"}
{"commit_tokens": ["Use", "pg", ".", "Client", "()", "to", "fix", "race", "conditions", "and", "simplify"], "add_tokens": "this . _client = new pg . Pool ( { connectionString : conString , max : this . _options . pgstore . pgPoolSize || 10 } ) ; this . _client . connect ( function ( err , client ) { self . _client . done ( ) ;", "del_tokens": "pg . defaults . poolSize = this . _options . pgstore . pgPoolSize || 10 ; pg . connect ( conString , function ( err , client , done ) { self . _client = client ; self . _pgDone = done ; if ( ! this . _pgDone ) { this . _pgDone ( ) ; }", "commit_type": "use"}
{"commit_tokens": ["make", "value", "stream", "if", "it", "isn", "t", "mark", "async"], "add_tokens": "} , 2 , name , null , true ) ; parent => just ( val ) . pipe ( map ( val => parent . vnode ( parent . create ( type , val ) , parent ) ) ) , val , true", "del_tokens": "} , 2 , name ) ; parent => val . pipe ( map ( val => parent . vnode ( parent . create ( type , val ) , parent ) ) ) , val", "commit_type": "make"}
{"commit_tokens": ["add", "support", "for", "IE", "6", ".", "tar", "demo", "works", "in", "6", "-", "9"], "add_tokens": "// trying to set the responseType on IE 6 causes an error if ( jQuery . support . ajaxResponseType ) { if ( ! options . hasOwnProperty ( 'xhrFields' ) ) { options . xhrFields = { } ; } options . xhrFields . responseType = 'arraybuffer' ;", "del_tokens": "if ( ! options . hasOwnProperty ( 'xhrFields' ) ) { options . xhrFields = { } ; options . xhrFields . responseType = 'arraybuffer' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "more", "function", "parity", "to", "Response"], "add_tokens": "[ 'method' , 'url' ] . forEach ( function ( prop ) { [ 'headers' , 'statusCode' ] . forEach ( function ( prop ) {", "del_tokens": "[ 'headers' , 'method' , 'url' ] . forEach ( function ( prop ) { [ 'statusCode' ] . forEach ( function ( prop ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "grunt", "task", "for", "travis"], "add_tokens": "// Task to run build grunt . registerTask ( \"test\" , [ \"qunit\" , \"jshint\" , \"csslint\" ] ) ;", "del_tokens": "// Task to run tests", "commit_type": "add"}
{"commit_tokens": ["add", "util", ".", "debug", "method"], "add_tokens": "* Log utilities . var debug = process . env . DEVELOPMENT ? stamp . bind ( { method : \"log\" , color : \"magenta\" } ) : function ( ) { } ; exports . debug = debug ; / ** * Display a message with a date stamp . * / function stamp ( ) { var date = ( 0 , _dateformat2 [ \"default\" ] ) ( new Date ( ) , \"HH:MM:ss\" ) ; process . stdout . write ( \"[\" + _clor2 [ \"default\" ] [ this . color ] ( date ) + \"] \" ) ; console [ this . method ] . apply ( console , arguments ) ; }", "del_tokens": "* Log / Error a message with a time stamp . function stamp ( ) { var date = ( 0 , _dateformat2 [ \"default\" ] ) ( new Date ( ) , \"HH:MM:ss\" ) ; process . stdout . write ( \"[\" + _clor2 [ \"default\" ] [ this . color ] ( date ) + \"] \" ) ; console [ this . method ] . apply ( console , arguments ) ; }", "commit_type": "add"}
{"commit_tokens": ["Add", "IP", "addresses", "to", "linkify"], "add_tokens": "ipClause = '((\\\\d{1,3}\\\\.){3}\\\\d{1,3})' , portClause = '(:\\\\d{1,5})' , hostClause = '((' + domainBodyClause + '\\\\.' + tldClause + ')|(' + ipClause + portClause + '?))' , pathClause = '(\\\\/[\\\\/\\\\w\\\\.-]*)*' ,", "del_tokens": "hostClause = domainBodyClause + '\\\\.' + tldClause , pathClause = '([\\\\/\\\\w\\\\.-]*)*\\\\/?' ,", "commit_type": "add"}
{"commit_tokens": ["Fixed", "Safari", "port", "number", "on", "OSX", "."], "add_tokens": "setup : function ( app , done ) { fs . writeFile ( tempDir + '/testem.safari.html' , \"<script>window.location = 'http://localhost:\" + app . config . get ( 'port' ) + \"/'</script>\" , done ) } , args : function ( app ) { return [ tempDir + '/testem.safari.html' ] } ,", "del_tokens": "args : [ path . dirname ( __dirname ) + '/assets/safari_start.html' ] ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "readme", "to", "script", "."], "add_tokens": "export function hasKey ( obj , key ) { export function getKey ( obj , key ) { export function validateObject ( pkg , requiredFields , fileName ) { export function replace ( text , pkg ) {", "del_tokens": "function hasKey ( obj , key ) { function getKey ( obj , key ) { function validateObject ( pkg , requiredFields , fileName ) { function replace ( text , pkg ) { module . exports = { hasKey , getKey , validateObject , replace } ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "bugs", "with", "persistent", "views", "and", "sorts"], "add_tokens": "this . resultsdirty = true ; // newly sorted, if persistent we need to rebuild resultdata if ( this . sortFunction || this . sortColumn ) this . sortDirty = true ; if ( this . sortFunction || this . sortColumn ) this . sortDirty = true ;", "del_tokens": "if ( this . sortFunction || this . sortColumn ) sortDirty ; if ( this . sortFunction || this . sortColumn ) sortDirty ;", "commit_type": "fix"}
{"commit_tokens": ["fixing", "module", "declarition", "on", "index", ".", "d", ".", "ts"], "add_tokens": "* Generates a middleware function to serve static files . It is build on top of serveStatic . * It extends serveStatic with the capability to serve ( previously ) gziped files . For this * @ param { string } root : folder to staticly serve files from function expressStaticGzip ( root , options ) { let defaultStatic = serveStatic ( root , opts . serveStatic || null ) ; findAllCompressionFiles ( require ( \"fs\" ) , root ) ; var srcFilePath = filePath . replace ( root , \"\" ) . replace ( compression . fileExtension , \"\" ) ;", "del_tokens": "* Generates a middleware function to serve static files . It is build on top of the express . static middleware . * It extends the express . static middleware with the capability to serve ( previously ) gziped files . For this * @ param { string } rootFolder : folder to staticly serve files from function expressStaticGzip ( rootFolder , options ) { let defaultStatic = serveStatic ( rootFolder , opts . serveStatic || null ) ; findAllCompressionFiles ( require ( \"fs\" ) , rootFolder ) ; var srcFilePath = filePath . replace ( rootFolder , \"\" ) . replace ( compression . fileExtension , \"\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixes", "an", "issue", "when", "multiple", "handlers", "with", "the", "same", "constraints", "but", "for", "different", "types", "of", "requests", "are", "registered"], "add_tokens": "actionConstraints . handlerType = 'action' ; optionsConstraints . handlerType = 'options' ; debug ( 'dispatch could not find a handler' ) ; debug ( 'dispatching to handler' ) ; if ( constraints . handlerType === 'action' ) { // a payload that represents an action either has actions or submission defined if ( ! ( payload . actions || payload . submission ) ) { return false ; } // dialog submissions don't have an action defined, so an empty action is substituted for // the purpose of callback matching const action = payload . actions ? payload . actions [ 0 ] : { } ; if ( constraints . handlerType === 'options' ) { // a payload that represents an options request always has a name defined at the top level if ( ! ( 'name' in payload ) ) { return false ; }", "del_tokens": "const isAction = ! ! payload . actions ; const isOptions = ! isAction ; if ( isAction ) { const action = payload . actions [ 0 ] ; if ( isOptions ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "class", "to", "allow", "highlighting", "a", "domain"], "add_tokens": ". attr ( \"class\" , function ( d ) { var classname = \"graph-domain\" ; var date = new Date ( d ) ; switch ( self . options . domain ) { case \"hour\" : classname += \" h_\" + date . getHours ( ) ; case \"day\" : classname += \" d_\" + date . getDate ( ) ; case \"week\" : classname += \" w_\" + self . getWeekNumber ( date ) ; case \"month\" : classname += \" m_\" + date . getMonth ( ) ; case \"year\" : classname += \" y_\" + date . getFullYear ( ) ; } return classname ; } ) . attr ( \"class\" , \"domain-background\" )", "del_tokens": ". attr ( \"class\" , \"graph-domain\" )", "commit_type": "add"}
{"commit_tokens": ["adds", "tests", "on", "NS1", ".", "Monitor", ".", "regions", "()", "and", "NS1", ".", "Monitor", ".", "jobtypes", "()"], "add_tokens": "history ( args ) { return new NS1Request ( 'get' , ` ${ this . attributes . id } ` , args ) metrics ( args ) { return new NS1Request ( 'get' , ` ${ this . attributes . id } ` , args )", "del_tokens": "history ( ) { return new NS1Request ( 'get' , ` ${ this . attributes . id } ` ) metrics ( ) { return new NS1Request ( 'get' , ` ${ this . attributes . id } ` )", "commit_type": "add"}
{"commit_tokens": ["Added", "activate", "and", "deactivate", "motion", "detector", "methods"], "add_tokens": "/ ** * @ class : Entities . MotionDetector * @ classDesc : A generic base class which creates a motion detector for surrounding environments \\ n * Collaborator : Environment * @ desc : Test * @ public * / this . activate ( ) ; deactivate ( ) { this . _isActive = false ; } activate ( ) { this . _isActive = true ; }", "del_tokens": "//A generic base class which creates a motion detector for surrounding environments //Collaborator: Environment this . _isActive = true ;", "commit_type": "add"}
{"commit_tokens": ["Add", "morgan", ".", "compile", "(", "format", ")", "export"], "add_tokens": "module . exports . compile = compile * @ public", "del_tokens": "* @ private", "commit_type": "add"}
{"commit_tokens": ["Added", "s3path", "prop", ".", "Receive", "the", "path", "where", "the", "file", "should", "be", "uploaded", "."], "add_tokens": "scrubFilename : PropTypes . func , s3path : PropTypes . string } , s3path : '' scrubFilename : this . props . scrubFilename , s3path : this . props . s3path", "del_tokens": "scrubFilename : PropTypes . func } scrubFilename : this . props . scrubFilename", "commit_type": "add"}
{"commit_tokens": ["added", "top", "30", "searches", "in", "top", "30", "days"], "add_tokens": "////Parameters: array of key words, country as a string (optional) // tools.topRelated('dog') // .then(function(topRelated){ // console.log(\"here are the topRelated\", topRelated); // }) // .catch(function(err){ // console.log(\"there was an error\", err); // return err; // }); ////Parameters: takes a country as a string (optional) //Parameters: none tools . top30in30 ( ) . then ( function ( results ) { console . log ( \"these are the results\" , results ) ; } ) ;", "del_tokens": "//Parameters: array of key words, country as a string (optional) tools . topRelated ( 'dog' ) . then ( function ( topRelated ) { console . log ( \"here are the topRelated\" , topRelated ) ; } ) . catch ( function ( err ) { console . log ( \"there was an error\" , err ) ; return err ; } ) ; //Parameters: takes a country as a string (optional)", "commit_type": "add"}
{"commit_tokens": ["added", "error", "-", "maker", "dependency"], "add_tokens": "var make = require ( \"error-maker\" ) ; module . exports = make ( \"ArgpError\" ) ;", "del_tokens": "module . exports = function ( msg ) { var error = Error . call ( this , typeof msg === \"object\" ? msg . message : msg ) ; Error . captureStackTrace ( error , this . constructor ) ; Object . defineProperty ( error , \"name\" , { enumerable : false , value : \"ArgpError\" } ) ; return error ; } ;", "commit_type": "add"}
{"commit_tokens": ["added", "get", "-", "all", "example"], "add_tokens": "// Display the conversations indicating if they are unread (+) or starred(*) convo . label", "del_tokens": "// Display the conversations indicating if they have been read or starred and whether it's a text or voicemail convo . label . is ( 'voicemail' ) ? 'voicemail' : convo . label . is ( 'sms' ) ? 'sms' : ''", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "loading", "configuration", "from", "a", "file"], "add_tokens": "module . exports = { } , config : { description : 'Load configuration from a Javascript file, must export an object'", "del_tokens": "var optimist = require ( 'optimist' ) ; var optimistOptions = { exports . getArgv = function ( ) { return optimist . usage ( 'Usage: \\n ./drakov -f <path to blueprint> [-p <server port|3000>]' + '\\n\\nExample: \\n ' + './drakov -f ./*.md -p 3000' ) . options ( optimistOptions ) . demand ( 'f' ) . wrap ( 80 ) . argv ; } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "destroy", "and", "remove", "methods"], "add_tokens": "// utils import { generateUuid } from '../utils/uuid.js' import add from './entity/add.js' import destroy from './entity/destroy.js' import remove from './entity/remove.js' // methods Entity . prototype . destroy = destroy Entity . prototype . findFirst = findFirst Entity . prototype . on = on Entity . prototype . remove = remove", "del_tokens": "import add from './entity/add.js' // utils import { generateUuid } from '../utils/uuid.js' Entity . prototype . on = on Entity . prototype . findFirst = findFirst", "commit_type": "add"}
{"commit_tokens": ["Removed", "dependency", "on", "portfinder", "module"], "add_tokens": "import { createServer } from 'net' ; let port = await this . _getPort ( ) ; / ** * Gets an ephemeral port chosen by the system . * @ return { Promise < number > } A port that the server can listen on . * / async _getPort ( ) { return new Promise ( ( resolve , reject ) => { let server = createServer ( ) ; server . unref ( ) ; server . on ( 'error' , reject ) ; server . listen ( 0 , FastTransformer . DEFAULT_ADDRESS , ( ) => { let port = server . address ( ) . port ; server . close ( ( ) => resolve ( port ) ) ; } ) ; } ) ; }", "del_tokens": "import { getPortPromise as getPort } from 'portfinder' ; let port = await getPort ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Updated", "retweets", "to", "merge", "user", "data", "directly", "in", "to", "actual", "tweet", "and", "updated", "test", "page"], "add_tokens": "// twitterlib.js (c) 2011 Remy Sharp if ( tweet . retweetedby ) html += ' <span>retweeted by ' + tweet . retweetedby . screen_name + '</span>' ; } else if ( options . rts == true || options . rts == 't' || options . rts == 1 ) { // scan for native retweets and swap them in as real tweets i = tweets . length ; while ( i -- ) { if ( tweets [ i ] . retweeted_status ) { tweets [ i ] . retweeted_status . retweetedby = tweets [ i ] . user ; tweets [ i ] = tweets [ i ] . retweeted_status ; } }", "del_tokens": "// twitterlib.js (c) 2009 Remy Sharp", "commit_type": "update"}
{"commit_tokens": ["Fix", "wrong", "description", "in", "log", "message"], "add_tokens": "var err = parseError ( \"MeadCo.ScriptX.Print.printPdfAtServer\" , jqXhr , textStatus , errorThrown ) ;", "del_tokens": "var err = parseError ( \"MeadCo.ScriptX.Print.printHtmlAtServer\" , jqXhr , textStatus , errorThrown ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "version", "number", "to", "registered", "action", "name"], "add_tokens": "bench1 . run ( ) . then ( ( ) => bench2 . run ( ) ) . then ( ( ) => bench4 . run ( ) ) ;", "del_tokens": "bench1 . skip ( ) . then ( ( ) => bench2 . skip ( ) ) . then ( ( ) => bench4 . skip ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "prop", "up", "for", "dropdown"], "add_tokens": "propTypes : { up : React . PropTypes . bool } , / ** * Toggle the dopdown * @ param { Event } e ? * / / ** * Close the dropdown * / / ** * Bind a random click in the window to close the dropdown * / var className = classNames ( 'dropdown' , this . props . className , { 'dropup' : this . props . up } ) ; return < Button . Group { ... this . props } className = { className } >", "del_tokens": "// Toggle the dopdown // Close the dropdown return < Button . Group { ... this . props } className = { classNames ( 'dropdown' , this . props . className , { 'dropup' : this . props . dropup } ) } >", "commit_type": "add"}
{"commit_tokens": ["fix", "dep", "file", "with", "extra", "quotes", "bug"], "add_tokens": "requires . push ( subMod . name ) ;", "del_tokens": "requires . push ( \"'\" + subMod . name + \"'\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "simple", "object", "for", "utils"], "add_tokens": "exports . default = { } , } , } , } ;", "del_tokens": "class Utils { } } } } exports . Utils = Utils ;", "commit_type": "use"}
{"commit_tokens": ["update", "tests", "and", "update", "failure", "vs", "error", "emit"], "add_tokens": "self . emit ( 'failure' , self . queue , job , callbackError ) ; self . emit ( 'failure' , self . queue , job , callbackError ) ; self . emit ( 'failure' , self . queue , job , callbackError ) ;", "del_tokens": "self . emit ( 'error' , self . queue , job , callbackError ) ; self . emit ( 'error' , self . queue , job , callbackError ) ; self . emit ( 'error' , self . queue , job , callbackError ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "logging", "for", "all", "error", "responses", "in", "ParaClient"], "add_tokens": "var error = res . body || new Error ( \"ParaClient request failed.\" ) ; } else { err ( code + \" - \" + res . text ) ; var error = new Error ( \"ParaClient request failed.\" ) ; callback ( null , error ) ; reject ( error ) ; var error = new Error ( \"Request object is undefined.\" ) ; callback ( null , error ) ; reject ( error ) ;", "del_tokens": "var error = res . body ; callback ( null ) ; reject ( new Error ( \"ParaClient request failed.\" ) ) ; reject ( new Error ( \"Request object is undefined.\" ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "kick", "package", "protocol", "for", "hybisocket", "and", "compatible", "with", "siosocket", "kick", "protocol"], "add_tokens": "* @ param { Number } uid user id asscociated with the session * @ param { Function } cb callback function session . closed ( 'kick' ) ; * Closed callback for the session which would disconnect client in next tick . this . __socket__ . emit ( 'closing' , reason ) ; var self = this ; // give a chance to send disconnect message to client process . nextTick ( function ( ) { self . __socket__ . disconnect ( ) ; } ) ;", "del_tokens": "* @ param { Number } uid user id asscociated with the session * @ param { Function } cb callback function // xxx Protocol conflict for new/old version // compatible with old version: old version keep the old code // new version add a kick control package //session.__socket__.send({route: 'onKick'}); session . closed ( 'kick' ) ; * Closed callback for the session . this . __socket__ . disconnect ( ) ;", "commit_type": "add"}
{"commit_tokens": ["adding", "test", "and", "doc", "for", "delete", "*", "and", "setData"], "add_tokens": "[ ` ${ type } ` ] ( arg ) // eslint-disable-line . catch ( ( ) => resolve ( ) ) ; polyfill ( c . record , 'removeListedRecordP' , c . deleteListedRecordP ) ; // Alias, backward comp. deleteRecord : c . record . deleteRecordP , deleteList : c . record . deleteListP , removeListedRecord : c . record . deleteListedRecordP , // Alias, backward comp.", "del_tokens": "[ ` ${ type } ` ] ( arg ) . catch ( resolve ) ; delete : c . record . deleteP ,", "commit_type": "add"}
{"commit_tokens": ["Fixing", "some", "Postgres", "issues", "."], "add_tokens": "options . type = connection . QueryTypes . INSERT ; // TODO: Postgres does not have easy UPSERT syntax, the ON CONFLICT UPDATE requires specific columns var query = \"INSERT INTO \" + model . tableName + \" ([[COLUMNS]]) VALUES ([[VALUES]])\" ; queries . push ( query ) ;", "del_tokens": "var mysql = require ( \"mysql\" ) ; var query = \"INSERT OR REPLACE INTO \" + model . tableName + \" ([[COLUMNS]]) VALUES ([[VALUES]])\" ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "range", "param", "from", "setInlineStyle", "rename", "to", "setStyle"], "add_tokens": "if ( this . active ( pm ) ) pm . setStyle ( this . style , false ) else if ( this . dialog ) else pm . setStyle ( this . style , true )", "del_tokens": "if ( this . active ( pm ) ) { if ( sel . empty ) pm . setInlineStyle ( this . style , false ) else pm . apply ( pm . tr . removeStyle ( sel . from , sel . to , this . style . type ) ) } else if ( this . dialog ) { } else { if ( sel . empty ) pm . setInlineStyle ( this . style , true ) else pm . apply ( pm . tr . addStyle ( sel . from , sel . to , this . style ) ) }", "commit_type": "remove"}
{"commit_tokens": ["move", "test", "/", "cmdtest", "-", ">", "example", "/", "remote", ".", "js", "add", "to", "readme"], "add_tokens": "var fingerprints = { } fingerprints [ name ] = key . fingerprint ( ) var otherfinger = fingerprints [ name ] fingerprint : otherfinger , node . on ( 'connect' , function ( fingerprint ) { if ( fingerprint === otherfinger ) { console . log ( 'Tell ' + name + ' how you feel' ) } } ) node . send ( line , fingerprints [ name ] ) for ( var name in fingerprints ) { if ( fingerprints [ name ] === from ) { node . destroy ( exit ) var timeoutId = setTimeout ( exit , 5000 ) function exit ( ) { clearTimeout ( timeoutId ) if ( options . exit ) process . exit ( ) }", "del_tokens": "var pubKeys = { } pubKeys [ name ] = key . fingerprint ( ) fingerprint : pubKeys [ name ] , node . send ( line , pubKeys [ name ] ) for ( var name in pubKeys ) { if ( pubKeys [ name ] === from ) { node . destroy ( function ( ) { if ( options . exit ) process . exit ( err ? 1 : 0 ) } )", "commit_type": "move"}
{"commit_tokens": ["fix", "initializing", "indexed", "collection", "without", "content"], "add_tokens": "// v0.0.7 // 3bc7a7b (2014-04-12 00:52:56 +0100) if ( ! value ) { return value ; }", "del_tokens": "// v0.0.6-6-g853c628 // 853c628 (2014-04-12 00:51:52 +0100)", "commit_type": "fix"}
{"commit_tokens": ["fixed", "errant", "comma", "causing", "build", "error"], "add_tokens": "} ; } }", "del_tokens": "} } } ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "assertions", "for", "type", "and", "instanceof", "tests", "."], "add_tokens": "'Expected ' + this . describe ( ) + ' to be instance of ' + expected . name + ', actual prototype was ' + Object . getPrototypeOf ( this . value ) . constructor . name + '.' ) ; 'Expected ' + this . describe ( ) + ' to not be instance of ' + expected . name + '.' ) ; / ** Ensure that the subject value has the expected type. @ param { string } expected The name of the expected type . var ty = typeof ( this . value ) ; if ( ty !== expected ) { ', actual type was \"' + ty + '\".' ) ;", "del_tokens": "'Expected ' + this . describe ( ) + ' to be instance of ' + format ( expected ) + ' but was type ' + typeof ( this . value ) + '.' ) ; 'Expected type of ' + this . describe ( ) + ' to not be ' + format ( expected ) + '.' ) ; / ** Ensure that the subject value has exactly the expected type. @ param { Type } expected The expected type . if ( typeof ( this . value ) == expected ) { ' but was ' + typeof ( this . value ) + '.' ) ; // Strings: // .startsWith(str) // .endsWith(str) // Maps and Sets // .containsKey(value) // .doesNotContainKey(value) // .containsEntry(key, value)", "commit_type": "add"}
{"commit_tokens": ["Use", "last", "-", "char", "to", "get", "the", "last", "character"], "add_tokens": "// Dependencies var LastChar = require ( \"last-char\" ) ; var last = LastChar ( input ) ;", "del_tokens": "var last = input . slice ( - 1 ) ;", "commit_type": "use"}
{"commit_tokens": ["fixed", "observer", "issues", "in", "Safari"], "add_tokens": "this . slow ( 400 ) ;", "del_tokens": "this . slow ( 200 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "sure", "all", "token", "properties", "of", "a", "token", "type", "are", "filled"], "add_tokens": "var node = this . scanEndOfLine ( / ^doctype *([^\\n]*) / , 'doctype' ) ; if ( node && node . val . trim ( ) === '5' ) { tok . args = null ; tok . key = captures [ 2 ] || null ;", "del_tokens": "var node = this . scanEndOfLine ( / ^(?:doctype) *([^\\n]+)? / , 'doctype' ) ; if ( node && node . val && node . val . trim ( ) === '5' ) { } if ( tok . args ) { tok . key = captures [ 2 ] ;", "commit_type": "make"}
{"commit_tokens": ["Add", "pre", "-", "release", "patch", "support", "and", "maxScope"], "add_tokens": "/ ** * Perform the patch bump , either using . patch ( ) or . preRelease ( ) ( the latter if there ' * @ param { * } v - the versiony instance * / function performPatch ( v ) { if ( v . model . hasPreRelease ( ) ) { v . preRelease ( ) } else { v . patch ( ) } } const scope = utils . getScopeForPr ( pr , this . config . maxScope ) scope = utils . getScopeForPr ( pr , this . config . maxScope ) const v = versiony . from ( pkgJsonFile ) performPatch ( v ) v . newMinor ( ) const versionInfo = v . to ( pkgJsonFile ) . end ( { quiet : true } )", "del_tokens": "const scope = utils . getScopeForPr ( pr ) scope = utils . getScopeForPr ( pr ) const v = versiony . from ( pkgJsonFile ) . indent ( ' ' . repeat ( 2 ) ) v . patch ( ) v . minor ( ) . patch ( 0 ) const versionInfo = v . to ( pkgJsonFile ) . end ( )", "commit_type": "add"}
{"commit_tokens": ["fix", "url", "of", "voice", "manager", "update", "voice", "manager", "dep"], "add_tokens": "url : ( app . config . web . ssl == null ? 'http' : 'https' ) + '://127.0.0.1:' + app . config . web . port ,", "del_tokens": "url : 'http://127.0.0.1:3000' ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "check", "to", "see", "if", "page", "is", "open"], "add_tokens": "if ( task === phantomBase . openPage ) { if ( ! self . page ) { callback ( 'Page is not open' ) ; return ; } // removes any null elements from the list / ** * Private helper function to push a task * @ param task * @ param argument * @ param callback * @ private * / this . page = undefined ; this . phantom = undefined ;", "del_tokens": "if ( ! self . page ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "vulnerabilities", "by", "removing", "request", "dependency"], "add_tokens": "for ( var index = 0 ; index < inputKeys . length ; index ++ ) { if ( ! fns . isEmpty ( eventDispatcherResponse ) && typeof eventDispatcherResponse . then === 'function' ) { } ; delete map [ key ] ; } ;", "del_tokens": "for ( var index = 0 ; index < inputKeys . length ; index ++ ) { if ( typeof eventDispatcherResponse == \"object\" && ! eventDispatcherResponse . hasOwnProperty ( 'uri' ) ) { } delete map [ key ] }", "commit_type": "fix"}
{"commit_tokens": ["remove", "job", "from", "page", "on", "click"], "add_tokens": "clear ( ) ; function clear ( ) { $ ( '#content .job, ' ) . remove ( ) ;", "del_tokens": "removeJobs ( ) ; function removeJobs ( ) { $ ( '#content .job' ) . remove ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "iframe", ".", "js", "in", "dist", "."], "add_tokens": "minimifiedIframe : { src : 'dist/iframe.js' , dest : 'dist/iframe.min.js' } , iframe : { src : [ 'dist/urturn-expression-api.js' , 'lib/iframe.js' ] , dest : 'dist/iframe.js'", "del_tokens": "minimifiedApi : { src : 'dist/urturn-expression-api.js' , dest : 'dist/urturn-expression-api.min.js'", "commit_type": "add"}
{"commit_tokens": ["Added", "def", "()", "methods", "to", "constructor", ".", "Prevented", "static", "property", "inheritance", ".", "Added", "package", ".", "json"], "add_tokens": "// Always have the static 'extend' method on constructors child . extend = parent . extend ; // Ensure the mixes method is always copied child . mixes = parent . mixes ; // Ensure the def method is always copied child . def = parent . def ; return inherits ( this , protoProps , staticProps ) ; // Define a property on this constructor prototype (nicer shortcut to Object.defineProperty) // or staticly on the constructor if true is passed for isStatic Constructor . def = function ( property , definition , isStatic ) { // If property is an object use defineProperties if ( property === Object ( property ) ) { definition = property ; isStatic = definition ; if ( isStatic ) Object . defineProperties ( this , definition ) ; else Object . defineProperties ( this . prototype , definition ) ; return ; } if ( isStatic ) Object . defineProperty ( this , property , definition ) ; else Object . defineProperty ( this . prototype , property , definition ) ; } ;", "del_tokens": "// Inherit static properties from parent. extendObj ( child , parent ) ; var child = inherits ( this , protoProps , staticProps ) ; return child ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "multi", "-", "line", "string", "literals", "for", "defineMessages", "()"], "add_tokens": "( ts . isStringLiteral ( ip . initializer ) || ts . isNoSubstitutionTemplateLiteral ( ip . initializer ) ) ) {", "del_tokens": "ts . isStringLiteral ( ip . initializer ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "function", "to", "extract", "the", "extension", "from", "an", "url", "renamed", "website", ".", "js", "to", "extract", ".", "js", "and", "modified", "images", ".", "js", "now", "images", "scrap", "with", "gif", "as", "extension", "are", "rejected"], "add_tokens": "extract = require ( './util/extract' ) ; // hack to appear like a user-browser this . webname = extract . webname ( url ) ; var labelSite = label + '-' + this . webname ;", "del_tokens": "website = require ( './util/website' ) ; this . site = website . name ( url ) ; var labelSite = label + '-' + this . site ;", "commit_type": "add"}
{"commit_tokens": ["Added", "(", "missing?", ")", "test", "case", "for", "data", "-", "bind", "and", "a", "(", "failing?", ")", "test", "for", "overriding", "the", "destination"], "add_tokens": "'for a data-bound template' : common . createTest ( 'data-bind' , { \"name\" : \"data-bind\" } ) , 'for an overridden destination' : common . createTest ( 'attribute' , { \"url\" : [ \"data-bind\" , \"src\" ] } ) }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Allow", "glob", "patterns", "in", "the", "list", "of", "root", "module", "identifiers", "."], "add_tokens": "Cp . buildP = function ( config , sourceDir , outputDir , roots ) { ) . readMultiP ( context . expandIdsOrGlobsP ( roots ) ) var roots = options . args . slice ( 2 ) ; if ( roots . length === 0 ) roots . push ( \"**/*.\" + this . preferredFileExtension ) ; roots // root module identifiers or file globs", "del_tokens": "Cp . buildP = function ( config , sourceDir , outputDir , rootIds ) { ) . readMultiP ( rootIds ) options . args . slice ( 2 ) // root module identifiers", "commit_type": "allow"}
{"commit_tokens": ["fix", "auto", "-", "save", "interval", "delay", "under", "Mobx", "3", ".", "x"], "add_tokens": "// (ObservableMap keys no longer returning an Array is used to detect Mobx 4+, var asyncAutorun = Array . isArray ( store . dataChanges . keys ( ) ) ? _mobx . autorunAsync : function ( fn , delay ) { } ; // Mobx 4+ toJS() exports a Map, not an Object and toJSON is the 'legacy' method to export an Object", "del_tokens": "// (presence of toJSON method on an ObservableMap is used to detect Mobx 4+, var asyncAutorun = store . dataChanges . toJSON ? function ( fn , delay ) { } : _mobx . autorunAsync ; // Mobx 4+ toJS() exports a Map, not an Object and toJSON method was added to ObservableMaps in 4+ to export an Object", "commit_type": "fix"}
{"commit_tokens": ["fixing", "/", "revising", "$dataKey", "to", "be", "updated", "after", "saving", "new", "item", "using", "new", "uuidToKey", "()"], "add_tokens": "$dataKey : { value : this . constructor . uuidToKey ( _uuid ) , configurable : _uuid == null , } , / ** * Generates data key related to given UUID suitable for selecting related * record in datasource connected via current adapter . * * @ param { string } uuid UUID to be converted * @ returns { string } backend - compatible key for selecting related record there * / static uuidToKey ( uuid ) { return ` ${ this . name } ${ uuid == null ? \"%u\" : uuid } ` ; } Object . defineProperties ( this , { $dataKey : { value : this . constructor . uuidToKey ( uuid ) } , } ) ;", "del_tokens": "$dataKey : { value : ` ${ this . constructor . name } ${ _uuid == null ? \"%u\" : _uuid } ` } ,", "commit_type": "fix"}
{"commit_tokens": ["remove", "need", "for", "babel", "-", "plugin", "-", "transform", "-", "object", "-", "rest", "-", "spread"], "add_tokens": "} , Object . assign ( { } , ! ( container instanceof HTMLDocument ) && { root : container } ) ) ; } , Object . assign ( { } , ! ( container instanceof HTMLDocument ) && { root : container } ) ) ;", "del_tokens": "* todo : allow configuration . e . g . custom STICKY_SELECTOR } , { ... ! ( container instanceof HTMLDocument ) && { root : container , } , } ) ; } , { ... ! ( container instanceof HTMLDocument ) && { root : container , } , } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Update", "up", "to", "changes", "in", "es5", "-", "ext"], "add_tokens": ", assign = require ( 'es5-ext/object/assign' )", "del_tokens": ", assign = require ( 'es5-ext/object/assign-multiple' )", "commit_type": "update"}
{"commit_tokens": ["make", "torus", "not", "share", "the", "last", "ring"], "add_tokens": "var radialParts = radialSubdivisions + 1 ; var bodyParts = bodySubdivisions + 1 ; var numVertices = radialParts * bodyParts ; for ( var slice = 0 ; slice < bodyParts ; ++ slice ) { for ( var ring = 0 ; ring < radialParts ; ++ ring ) { var nextRingIndex = 1 + ring ; var nextSliceIndex = 1 + slice ; indices . push ( radialParts * slice + ring , radialParts * nextSliceIndex + ring , radialParts * slice + nextRingIndex ) ; indices . push ( radialParts * nextSliceIndex + ring , radialParts * nextSliceIndex + nextRingIndex , radialParts * slice + nextRingIndex ) ;", "del_tokens": "var numVertices = ( radialSubdivisions ) * ( bodySubdivisions ) ; for ( var slice = 0 ; slice < bodySubdivisions ; ++ slice ) { for ( var ring = 0 ; ring < radialSubdivisions ; ++ ring ) { var nextRingIndex = ( 1 + ring ) % radialSubdivisions ; var nextSliceIndex = ( 1 + slice ) % bodySubdivisions ; indices . push ( radialSubdivisions * slice + ring , radialSubdivisions * nextSliceIndex + ring , radialSubdivisions * slice + nextRingIndex ) ; indices . push ( radialSubdivisions * nextSliceIndex + ring , radialSubdivisions * nextSliceIndex + nextRingIndex , radialSubdivisions * slice + nextRingIndex ) ;", "commit_type": "make"}
{"commit_tokens": ["Allowed", "aggregated", "map", "keys", "to", "be", "nested", "scalar", "properties", "."], "add_tokens": "const keyPropNameParts = propDesc . keyPropertyName . split ( '.' ) ; let container = valueExprCtx . baseContainer ; let keyPropDesc ; for ( let propName of keyPropNameParts ) { if ( ! container ) throw invalidPropDef ( propDesc , 'key property path ' + propDesc . keyPropertyName + ' includes elements without nested properties.' ) ; if ( ! container . hasProperty ( propName ) ) throw invalidPropDef ( propDesc , 'invalid keyPropertyName attribute:' + ' no such property.' ) ; keyPropDesc = container . getPropertyDesc ( propName ) ; if ( ! keyPropDesc . isScalar ( ) || keyPropDesc . isCalculated ( ) || keyPropDesc . reverseRefPropertyName ) throw invalidPropDef ( propDesc , 'key property ' + propDesc . keyPropertyName + ' is not scalar, calculated or dependent.' ) ; container = keyPropDesc . nestedProperties ; } if ( keyPropDesc . table ||", "del_tokens": "const container = valueExprCtx . baseContainer ; if ( ! container . hasProperty ( propDesc . keyPropertyName ) ) throw invalidPropDef ( propDesc , 'invalid keyPropertyName attribute:' + ' no such property.' ) ; const keyPropDesc = container . getPropertyDesc ( propDesc . keyPropertyName ) ; if ( ! keyPropDesc . isScalar ( ) || keyPropDesc . isCalculated ( ) || keyPropDesc . table || keyPropDesc . reverseRefPropertyName ||", "commit_type": "allow"}
{"commit_tokens": ["added", "integration", "with", "mocha", "to", "run", "multiple", "tests"], "add_tokens": "waitForTestResult : websocket . waitForTestResult ,", "del_tokens": "done : websocket . done ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "with", "routing", "causing", "routes", "after", "matching", "route", "to", "evaluate", "incorrectly"], "add_tokens": "filtered = false , match = false ;", "del_tokens": "filtered , match ;", "commit_type": "fix"}
{"commit_tokens": ["added", "multibar", "stopOnComplete", "example", ";", "changed", "initialupdate", "threshold"], "add_tokens": "barIncompleteChar : '\\u2591' , clearOnComplete : false , stopOnComplete : true // progress bar running ? // check \"isActive\" property in case you've enabled \"stopOnComplete\" ! if ( multibar . isActive === false ) { //multibar.stop(); console . log ( 'Download complete!' ) } , 3 ) ;", "del_tokens": "barIncompleteChar : '\\u2591' // stop progress bar ? if ( downloadPending === false ) { multibar . stop ( ) ; } , 10 ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "broken", "export", "of", "default", "media", "query"], "add_tokens": "const DEFAULT_MEDIA_QUERY = '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)' ; module . exports . DEFAULT_MEDIA_QUERY = DEFAULT_MEDIA_QUERY ;", "del_tokens": "export const DEFAULT_MEDIA_QUERY = '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)' ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "depracated", "built", "files", "and", "tasks", "for", "those", "files", "."], "add_tokens": "* sjl - minimal . js Tue Mar 03 2015 21 : 56 : 31 GMT - 0500 ( EST )", "del_tokens": "* sjl - minimal . js Mon Mar 02 2015 15 : 20 : 50 GMT - 0500 ( Eastern Standard Time )", "commit_type": "remove"}
{"commit_tokens": ["use", "only", "one", "font", "detector", "instead", "of", "two"], "add_tokens": "// Version: 0.1.7 var browserData ; // Global user agent browser object. var fontDetective ; // Global font detective object. fontDetective = new Detector ( ) ; var version = \"ClientJS 0.1.7\" ; return fontDetective . detect ( font ) ; if ( fontDetective . detect ( fontArray [ i ] ) ) {", "del_tokens": "// Version: 0.1.6 // Global user agent browser object. var browserData ; var version = \"ClientJS 0.1.6\" ; var detective = new Detector ( ) ; return detective . detect ( font ) ; var detective = new Detector ( ) ; if ( detective . detect ( fontArray [ i ] ) ) {", "commit_type": "use"}
{"commit_tokens": ["use", "promise", "for", "schema", "check"], "add_tokens": "fs . writeFile ( dest , result . css , ( err ) => { console . error ( err ) ; } ) ;", "del_tokens": "fs . writeFile ( dest , result . css , function ( err ) { console . error ( err ) } )", "commit_type": "use"}
{"commit_tokens": ["Add", "filter", "by", "status", "possibility"], "add_tokens": "async tracked ( { minTime , filter } = { } ) { const filteredTodos = getFilteredTodos ( filter , store . todos ) ; const inSeconds = dashboard . trackedTime ( filteredTodos , { minTime } ) ; function getFilteredTodos ( filter , todos ) { if ( ! filter ) { return todos ; } const { status } = filter ; return dashboard . groupByStatus ( todos ) [ status ] || [ ] ; }", "del_tokens": "async tracked ( { minTime } = { } ) { const inSeconds = dashboard . trackedTime ( store . todos , { minTime } ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "run", ".", "silent", "(", "default", ":", "false", ")"], "add_tokens": "silent : false , // `true`: suppress output var silent = ( extra . silent !== false ) ; // Silent, unless explicitly passed `false` grunt . log . writeln ( 'DRY-RUN: would exec: ' + cmd ) ; var result = shell . exec ( cmd , { silent : silent } ) ; exec ( opts , 'grunt ' + task , { silent : opts . silent } ) ;", "del_tokens": "grunt . log . writeln ( 'Not actually running: ' + cmd ) ; var result = shell . exec ( cmd , { silent : true } ) ; exec ( opts , 'grunt ' + task ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "the", "bug", "which", "does", "not", "emit", "some", "modules", "as", "es", "module", "syntax", "into", "esm", "/", "."], "add_tokens": "const BABEL_PRD_TRANSFORMER_LIST = [ 'transform-es2015-block-scoping' ] ; '--plugins' , [ 'transform-es2015-modules-commonjs' , ... BABEL_PRD_TRANSFORMER_LIST ] . join ( ',' ) ,", "del_tokens": "const BABEL_PRD_TRANSFORMER_LIST = [ 'transform-es2015-modules-commonjs' , 'transform-es2015-block-scoping' ] . join ( ',' ) ; '--plugins' , BABEL_PRD_TRANSFORMER_LIST", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "the", "voice", "transmission", "end"], "add_tokens": "var options = { } ; try { options = { key : fs . readFileSync ( 'private.pem' ) , cert : fs . readFileSync ( 'public.pem' ) } ; } catch ( e ) { console . log ( 'Could not load private/public certificate files.' ) ; console . log ( 'Trying to connect without client certififcate' ) ; for ( var u in channel . users ) { var user = channel . users [ u ] ; tree += user . name + \", \" ; for ( var c in channel . children ) { buildChannelTree ( channel . children [ c ] , level + 1 ) ; connection . on ( 'voice-start' , function ( user ) { console . log ( 'User ' + user . name + ' started voice transmission' ) ; } ) ; connection . on ( 'voice-end' , function ( user ) { console . log ( 'User ' + user . name + ' ended voice transmission' ) ; } ) ;", "del_tokens": "var options = { key : fs . readFileSync ( 'private.pem' ) , cert : fs . readFileSync ( 'public.pem' ) for ( var key in channel . users ) { var user = channel . users [ key ] ; tree += user . name + \", \" for ( var key in channel . children ) { buildChannelTree ( channel . children [ key ] , level + 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Made", "glob", "async", "funtions", "promise", "friendly"], "add_tokens": "files ( patterns , options , callback ) { if ( ! callback ) { return new Promise ( function ( resolve , reject ) { self . files ( patterns , options , function ( error , data ) { error ? reject ( error ) : resolve ( data ) ; } ) ; } ) ; } callback ( error , self . match ( result , patterns , options ) ) ; filewalker ( s , callback ) { if ( ! callback ) { return new Promise ( function ( resolve , reject ) { self . filewalker ( s , function ( error , data ) { error ? reject ( error ) : resolve ( data ) ; } ) ; } ) ; } return callback ( error ) ; return callback ( null , results ) ; callback ( null , results ) ; callback ( null , results ) ;", "del_tokens": "files ( patterns , options , done ) { done ( error , self . match ( result , patterns , options ) ) ; filewalker ( s , done ) { return done ( error ) ; return done ( null , results ) ; done ( null , results ) ; done ( null , results ) ;", "commit_type": "make"}
{"commit_tokens": ["Use", "onBlur", "instead", "of", "onChange"], "add_tokens": "'mouseEvents-require-keyEvents' : require ( './lib/rules/mouseEvents-require-keyEvents' ) , 'use-onblur-not-onchange' : require ( './lib/rules/use-onblur-not-onchange' )", "del_tokens": "'mouseEvents-require-keyEvents' : require ( './lib/rules/mouseEvents-require-keyEvents' )", "commit_type": "use"}
{"commit_tokens": ["made", "sor", "-", "table", "example", "working", "on", "IE8", "too"], "add_tokens": "// es5 shim is broken function slice ( what , start ) { for ( var j = 0 , i = start || 0 , arr = [ ] ; i < what . length ; i ++ ) { arr [ j ++ ] = what [ i ] ; } return arr ; } slice ( tbody . querySelectorAll ( 'tr' ) , 1 ) . sort (", "del_tokens": "arr . sort . call ( arr . slice . call ( tbody . querySelectorAll ( 'tr' ) , 1 ) ,", "commit_type": "make"}
{"commit_tokens": ["Added", "body", "encoding", "errors", "refactored", "body", "encoders", "code"], "add_tokens": "[ 910 , 'Agent with name \"%agentName%\" already in the agents pool' ] , BODY_ENCODER_NOT_EXIST : [ 911 , 'Body encoder \"%bodyEncoder%\" does not exist' ] , BODY_INCORRECT_TYPE : [ 912 , 'Incorrect body type \"%type%\" for bodyEncoding method \"%bodyEncoder%\", \"%typeCorrect%\" expected' ]", "del_tokens": "[ 910 , 'Agent with name \"%agentName%\" already in the agents pool' ]", "commit_type": "add"}
{"commit_tokens": ["fix", "bug", "in", "self", "-", "closing", "tags", "in", "XML", "mode"], "add_tokens": "if ( ch == \">\" || ( ch == \"/\" && stream . eat ( \">\" ) ) ) {", "del_tokens": "if ( ch == \">\" || ( ch == \"/\" && eat ( \">\" ) ) ) {", "commit_type": "fix"}
{"commit_tokens": ["adding", "more", "tests", "to", "improve", "coverage"], "add_tokens": "provider . setStorageDriver ( 'somethingNotExpected' ) ; expect ( provider . getStorageDriver ( ) ) . toEqual ( 'local' ) ; provider . setNamespace ( '' ) ; expect ( provider . getNamespace ( ) ) . toEqual ( '' ) ; // expect( function () { // locker.put('someKey', ['foo']).toThrowError(\"quux\"); // } ) // var malformedArray = [{a:[{}]}]; // var result = locker.put('aKey', malformedArray).get('aKey'); // expect( result ).toBeDefined(); // console.log(result); // expect( angular.isArray(result) ).toBeFalsy(); it ( 'should catch the error when the browser reports storage is full' , inject ( function ( ) { var error = new Error ( ) ; error . name = 'QUOTA_EXCEEDED_ERR' ; spyOn ( localStorage , 'setItem' ) . and . throwError ( error ) ; spyOn ( console , 'warn' ) ; locker . put ( 'someKey' , [ 'foo' ] ) ; expect ( console . warn ) . toHaveBeenCalled ( ) ; } ) ) ; it ( 'should catch the error when an item couldn\\'t be added for some other reason' , inject ( function ( ) { spyOn ( localStorage , 'setItem' ) . and . throwError ( ) ; spyOn ( console , 'warn' ) ; locker . put ( 'someKey' , [ 'foo' ] ) ; expect ( console . warn ) . toHaveBeenCalled ( ) ; } ) ) ; expect ( all ) . toEqual ( jasmine . objectContaining ( { 'aKey12' : 'aVal12' } ) ) ;", "del_tokens": "// var malformedArray = [{a:[{}]}]; // var result = locker.put('aKey', malformedArray).get('aKey'); // expect( result ).toBeDefined(); // console.log(result); // expect( angular.isArray(result) ).toBeFalsy();", "commit_type": "add"}
{"commit_tokens": ["Fix", "app", "path", "on", "Windows"], "add_tokens": "this . _parsedXml . widget . content [ 0 ] . $ . src = this . _join ( 'app' , src ) ; this . _parsedXml . widget . content = [ { $ : { src : this . _join ( 'app' , 'package.json' ) } } ] ; _join ( ... segments ) { // segments of config.xml paths must be separated by forward slashes on all platforms return segments . join ( '/' ) ; }", "del_tokens": "const { join } = require ( 'path' ) ; this . _parsedXml . widget . content [ 0 ] . $ . src = join ( 'app' , src ) ; this . _parsedXml . widget . content = [ { $ : { src : 'app/package.json' } } ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "eulerGamma", "to", "constants", "."], "add_tokens": "epsilon : 1e-15 , // used for precision eulerGamma : 0.577215664901532860606512090082", "del_tokens": "epsilon : 1e-15 // used for precision", "commit_type": "add"}
{"commit_tokens": ["upgrade", "istanbul", "version", "so", "it", "can", "parse", "a", "/", "a"], "add_tokens": "const promisify = require ( '..' )", "del_tokens": "const promisify = require ( '.' )", "commit_type": "upgrade"}
{"commit_tokens": ["use", "URI", "parser", "to", "resolve", "schema", "IDs"], "add_tokens": ", uri = require ( '../../uri.js' ) var ref = uri . resolve ( config . resolutionScope ,", "del_tokens": ", jsonPointer = require ( '../../jsonPointer.js' ) var ref = jsonPointer . resolve ( config . resolutionScope , config . resolutionScope = ref ;", "commit_type": "use"}
{"commit_tokens": ["Added", "ok", "template", "to", "tape", "templates"], "add_tokens": "var okTemplate = 't.{{=it.assertionType}}(file.{{=it.assertionInput}}, \\'{{=it.assertionMessage}}\\') \\n' ; notDeepEqual : notDeepEqualTemplate , ok : okTemplate", "del_tokens": "notDeepEqual : notDeepEqualTemplate", "commit_type": "add"}
{"commit_tokens": ["Remove", "unused", "variable", "from", "test"], "add_tokens": "it ( 'gets status codes' , function ( ) {", "del_tokens": "it ( 'has status code properties' , function ( ) { var callCount = 0 ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "regression", "in", "tests", "."], "add_tokens": "var userPrefs = options . prefs || { } ;", "del_tokens": "var userPrefs = options . prefs ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "extra", "create", "method", "from", "helper", "test"], "add_tokens": "app . create ( 'foo' , { viewType : 'partial' , engine : 'tmpl' } ) ; app . foo ( 'a.tmpl' , { path : 'a.tmpl' , content : '<%= blah.bar %>' } ) ; app . bar ( 'b.tmpl' , { content : '<%= foo(\"a.tmpl\") %>' } )", "del_tokens": "app . create ( 'foo' , { engine : 'tmpl' } ) ; app . create ( 'foo' , { viewType : 'partial' } ) ; app . foo ( 'foo.tmpl' , { path : 'foo.tmpl' , content : '<%= blah.bar %>' } ) ; app . bar ( 'one.tmpl' , { content : '<%= foo(\"foo.tmpl\") %>' } )", "commit_type": "remove"}
{"commit_tokens": ["added", "options", "and", "depreciating", "imediateStart"], "add_tokens": "function createTask ( expression , func , options ) { // Added for immediateStart depreciation if ( typeof options === 'boolean' ) { console . warn ( 'DEPRECIATION: imediateStart is deprecated and will be removed soon in favor of the options param.' ) ; options = { scheduled : options } } if ( ! options ) { options = { scheduled : true } } var task = new Task ( expression , func ) ; return new ScheduledTask ( task , options ) ;", "del_tokens": "function createTask ( expression , func , immediateStart ) { var task = new Task ( expression , func ) ; return new ScheduledTask ( task , immediateStart ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "in", "utils", ".", "js", "getting", "rid", "of", "accidental", "oreo", "file", "fixing", "send", ".", "js", "and", "securing", "it", "as", "well", "against", "sending", "to", "accounts", "you", "dont", "control"], "add_tokens": "program . command ( 'send <amount> <fromIndex> <toIndex>' ) . action ( standard )", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Use", "modules", "loader", "for", "JS", "plugins"], "add_tokens": "var cordovaModules = loadModules ( [ 'argscheck' , 'utils' , 'modulemapper' , 'builder' , 'channel' , 'base64' , 'urlutil' ] , path . join ( CORDOVA_JS , 'common' ) ) ;", "del_tokens": "var cordovaModules = loadModules ( [ 'argscheck' , 'utils' , 'channel' , 'base64' , 'urlutil' ] , path . join ( CORDOVA_JS , 'common' ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Adding", "semi", "-", "colon", "because", "ocd"], "add_tokens": "locals . load = fmt ( 'analytics.load(%s);' , JSON . stringify ( locals . apiKey ) ) ;", "del_tokens": "locals . load = fmt ( 'analytics.load(%s)' , JSON . stringify ( locals . apiKey ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "baseUrl", "to", "included", "file", "instead", "of", "sourcePath"], "add_tokens": "let newBaseUrl = baseUrlFromRoot ( file , this . rootPath , this . baseUrlMap ) ;", "del_tokens": "let newBaseUrl = baseUrlFromRoot ( this . sourcePath , this . rootPath , this . baseUrlMap ) ;", "commit_type": "use"}
{"commit_tokens": ["Adding", "browserfy", "/", "node", "support", "."], "add_tokens": "} if ( typeof exports === 'object' ) { // Node etc. module . exports = Snackbar ;", "del_tokens": "console . log ( options ) ; console . log ( opt ) ;", "commit_type": "add"}
{"commit_tokens": ["move", "request", ".", "finalize", "()", "out", "of", "httpClient"], "add_tokens": "simpleHttp . request ( this . httpClient , request . finalize ( ) , function ( err , res ) {", "del_tokens": "simpleHttp . request ( this . httpClient , request , function ( err , res ) {", "commit_type": "move"}
{"commit_tokens": ["Add", "stats", "test", "data", "for", "Stats", "class", "test"], "add_tokens": "before ( ( done ) => { fs . readFile ( ` ${ process . cwd ( ) } ` , ( err , data ) => { statsTestData = data ; done ( ) ;", "del_tokens": "return stats ( ` ${ process . cwd ( ) } ` , statsConfig . stats ) . then ( ( statsData ) => { assert . notStrictEqual ( statsData , null ) ; } ) . catch ( ( err ) => { assert . strictEqual ( err , null ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "an", "error", "string", "."], "add_tokens": "user_privileges_exceeded : \"User does not have enough privileges.\" , missing_token : \"Authentication token not provided.\"", "del_tokens": "user_privileges_exceeded : \"User does not have enough privileges.\"", "commit_type": "add"}
{"commit_tokens": ["fix", "vector", "and", "numerical", "real", "function", "compilation"], "add_tokens": "_ . _s = function ( Code , lang ) { var c = this [ 0 ] . _s ( Code , lang ) ; var c_i = this [ i ] . _s ( Code , lang ) ;", "del_tokens": "_ . _s = function ( lang ) { var c = this [ 0 ] . _s ( lang ) ; var c_i = this [ i ] . _s ( lang ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "module", "packaging", "removed", "/", "excluded", "unneeded", "files", "."], "add_tokens": "export const libraryProperties = 'particle.json' ;", "del_tokens": "export const libraryProperties = 'library.properties' ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "to", "prevent", "canceling", "global", "click", "event", "on", "cart", "hide"], "add_tokens": "self . hide ( null ) ;", "del_tokens": "self . hide ( e ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "use", "of", "eval", "/", "toSource"], "add_tokens": "this . parts = ICAL . helpers . clone ( propval . parts , true ) ; this . by_data = ICAL . helpers . clone ( aRule . parts , true ) ;", "del_tokens": "//TODO: we should not use eval anywhere and // this only works in gecko (toSource) this . parts = eval ( propval . parts . toSource ( ) ) ; //TODO: we should not use eval anywhere and // this only works in gecko (toSource) this . by_data = eval ( aRule . parts . toSource ( ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Make", "pollers", "store", "a", "self", "-", "removal", "function"], "add_tokens": "// Append ready-to-use remove function pollers [ pin ] = function ( ) { poller . remove ( fd ) . close ( ) ; } debug ( 'remove listener for pin %d' , pin ) pollers [ pin ] ( )", "del_tokens": "pollers [ pin ] = { poller : poller , fd : fd } ; data = pollers [ pin ] data . poller . remove ( data . fd ) . close ( ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "some", "additional", "meta", "values", "in", "notificaiton"], "add_tokens": "correlationId : 'correlationId' , // optional correlationId : 'correlationId' , // optional, the command Id // aggregateId: 'meta.aggregate.id', // optional, if defined theses values will be copied from the event // eventId: 'meta.event.id', // optional, if defined theses values will be copied from the event // eventName: 'meta.event.name', // optional, if defined theses values will be copied from the event", "del_tokens": "//// correlationId: 'correlationId', // optional correlationId : 'correlationId' , // optional // aggregateId: 'meta.aggregate.id', // optional, if defined theses values will be copied from the event", "commit_type": "add"}
{"commit_tokens": ["Use", "isFinite", "instead", "of", "Number", ".", "isFinite", "for", "improved", "browser", "support"], "add_tokens": "if ( ! isFinite ( number ) )", "del_tokens": "if ( ! Number . isFinite ( number ) )", "commit_type": "use"}
{"commit_tokens": ["Fixed", "a", "bug", "related", "to", "tolerance"], "add_tokens": "} , position - Number ( options . guidelinesTolerance ) , position + Number ( options . guidelinesTolerance ) ) ;", "del_tokens": "} , position - options . guidelinesTolerance , position + options . guidelinesTolerance ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "message", "in", "benchmark", ".", "js"], "add_tokens": "console . log ( 'Parallel execution: ' + t2 . time ( ) + 'ms' + ( t2 . time ( ) < t1 . time ( ) ? ' - faster' : ' - slower' ) ) ;", "del_tokens": "console . log ( 'Parallel execution: ' + t2 . time ( ) + 'ms' ) ;", "commit_type": "add"}
{"commit_tokens": ["Made", "the", "defs", "an", "external", "XML", "file"], "add_tokens": "externalDefs : 'test/fixtures/externalDefs.xml'", "del_tokens": "defs : '<linearGradient id=\"customGradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"><stop offset=\"0%\" stop-color=\"#e1184b\"/><stop offset=\"50%\" stop-color=\"#f42d3c\"/><stop offset=\"100%\" stop-color=\"#fd8c79\"/></linearGradient>'", "commit_type": "make"}
{"commit_tokens": ["Add", "a", "constrain", "function", "to", "position"], "add_tokens": "import { constrain , equal , radianCircle } from \"@pencil.js/math\" ; / ** * * @ param { Vector } vector - * / constrain ( vector ) { this . set ( constrain ( this . x , vector . start . x , vector . end . x ) , constrain ( this . y , vector . start . y , vector . end . y ) ) ; }", "del_tokens": "import { equal , radianCircle } from \"@pencil.js/math\" ;", "commit_type": "add"}
{"commit_tokens": ["Improve", "docs", "and", "consistency", "in", "the", "events", "API", "."], "add_tokens": "t . equal ( listener . firstCall . args [ 0 ] . name , \"added\" ) ; t . equal ( listener . firstCall . args [ 0 ] . resource , store . find ( \"products\" , \"1\" ) ) ; t . equal ( listener . firstCall . args [ 0 ] . name , \"updated\" ) ; t . equal ( listener . firstCall . args [ 0 ] . resource , store . find ( \"products\" , \"1\" ) ) ; t . equal ( listener . firstCall . args [ 0 ] . name , \"removed\" ) ; t . equal ( listener . firstCall . args [ 0 ] . resource , null ) ;", "del_tokens": "t . equal ( listener . firstCall . args [ 0 ] . event , \"added\" ) ; t . equal ( listener . firstCall . args [ 0 ] . value , store . find ( \"products\" , \"1\" ) ) ; t . equal ( listener . firstCall . args [ 0 ] . event , \"updated\" ) ; t . equal ( listener . firstCall . args [ 0 ] . value , store . find ( \"products\" , \"1\" ) ) ; t . equal ( listener . firstCall . args [ 0 ] . event , \"removed\" ) ; t . equal ( listener . firstCall . args [ 0 ] . value , null ) ;", "commit_type": "improve"}
{"commit_tokens": ["Added", "support", "for", "the", "new", "file", "callback", "added", "to", "jsdox", ".", "generateForDir", ";", "this", "now", "allows", "the", "table", "of", "contents", "to", "display", "a", "files", "overview", "next", "to", "its", "entry", "in", "the", "table", "of", "contents"], "add_tokens": "jsdox . generateForDir ( folder . path , dest + '/' + folder . name , def . resolve , function ( file , fileData ) { folder . fileData [ file ] = fileData ; } ) ;", "del_tokens": "jsdox . generateForDir ( folder . path , dest + '/' + folder . name , def . resolve ) ; //jsdox.generateForDir(folder.path, dest +'/'+ folder.name, def.resolve, function(file, data) { folder.fileData[file] = data }); //soon...", "commit_type": "add"}
{"commit_tokens": ["Allowing", "arbitrary", "databases", "to", "be", "loaded", "also", "."], "add_tokens": "var loader = require ( '../loader' ) ; var databases = { mongoose : require ( './mongoose' ) } ; module . exports . load = loader ( 'mongoose' , databases ) ; module . exports . mongoose = databases . mongoose ;", "del_tokens": "// var loader = require('../loader'); // var databases = { mongoose: require('./mongoose') }; // module.exports.load = loader('mongoose', databases); module . exports . mongoose = require ( './mongoose' ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "extraction", "of", "ARN", "from", "error", "message"], "add_tokens": "var acct = ( err ? / (arn:.+) / . exec ( err . message ) [ 1 ] : userData . User . Arn ) . split ( ':' ) [ 4 ] ;", "del_tokens": "var acct = err ? / (arn:.+?) / . exec ( err . message ) [ 1 ] : userData . User . Arn . split ( ':' ) [ 4 ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "console", "and", "update", "yuilop", ".", "js"], "add_tokens": "send : function ( message ) { this . sendStanza ( message ) ; } , conducto = require ( '../node_modules/conducto' ) ; var exports = function ( url ) { } ; module . exports = exports ; window . Y = exports ;", "del_tokens": "conducto = require ( '../conducto' ) ; // var Y = conducto; var mo = function ( url ) { } module . exports = mo ; window . Y = mo ;", "commit_type": "add"}
{"commit_tokens": ["fix", "bug", "in", "encoding", "buffer", "values", "on", "update"], "add_tokens": "else parameters . push ( inputValue ( value ) )", "del_tokens": "else parameters . push ( value )", "commit_type": "fix"}
{"commit_tokens": ["Changed", "how", "the", "linting", "workes", "added", "editorconfig", "and", "new", "docs"], "add_tokens": "export function markdownSettings ( { info : { name } , metaObject , packageConfig } ) { console . log ( generateMarkdownDocumentation ( name , packageConfig , metaObject ) ) ;", "del_tokens": "export function markdownSettings ( { metaObject , packageConfig } ) { console . log ( generateMarkdownDocumentation ( packageConfig , metaObject ) ) ;", "commit_type": "change"}
{"commit_tokens": ["makes", "sure", "a", "zero", "line", "shows", "up", "when", "the", "y", "-", "domain", "crosses", "0"], "add_tokens": "//no legend or only one seriesgit var ticks = [ ] ; if ( domain [ 1 ] * domain [ 0 ] < 0 ) { //if the domain crosses zero, make sure there is a zero line var hasZero = false ; for ( var i = ticks . length - 1 ; i >= 0 ; i -- ) { //check if there is already a zero line if ( ticks [ i ] == 0 ) { hasZero = true ; } } ; if ( ! hasZero ) { ticks . push ( 0 ) } }", "del_tokens": "//no legend or only one series var ticks = [ ]", "commit_type": "make"}
{"commit_tokens": ["Updated", "dependencies", "fixed", "unused", "variables", "in", "tests"], "add_tokens": "function all ( ) { function remove ( ) { function once ( ) { live . on ( 'change' , function ( key , newValue ) {", "del_tokens": "function all ( key , newValue , oldValue ) { function remove ( key , newValue , oldValue ) { function once ( key , newValue , oldValue ) { live . on ( 'change' , function ( key , newValue , oldValue ) {", "commit_type": "update"}
{"commit_tokens": ["Add", "more", "detail", "to", "HTTP", "errors"], "add_tokens": "var error = new Error ( 'Unexpected HTTP error ' + res . statusCode ) ; error . detail = data ; error . code = res . statusCode ; errback ( error ) ;", "del_tokens": "errback ( new Error ( 'Unexpected HTTP error ' + res . statusCode ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "getError", "()", "function", "for", "error", "message", "formatting"], "add_tokens": "/ ** * Prefix for error messages . * @ type { string } * @ const * / var ERROR_MESSAGE_PREFIX = 'JSON Pointer: ' ; throw getError ( 'Pointer is not valid.' ) ; throw getError ( 'Implementation does not support \"-\" token.' ) ; throw getError ( 'Non-number tokens cannot be used in array context.' ) ; throw getError ( / ** * Returns Error instance for throwing . * @ param { string } message Error message . * @ returns { Error } * / function getError ( message ) { return new Error ( ERROR_MESSAGE_PREFIX + message ) ; }", "del_tokens": "throw new Error ( 'JSON Pointer is not valid.' ) ; throw new Error ( 'Implementation does not support \"-\" token.' ) ; throw new Error ( 'Non-number tokens cannot be used in array context.' ) ; throw new Error (", "commit_type": "add"}
{"commit_tokens": ["Remove", "more", "uneeded", "helper", "files"], "add_tokens": "/* global Blob tus */ var file = new Blob ( \"hello world\" . split ( \"\" ) ) ; var file = new Blob ( \"hello world\" . split ( \"\" ) ) ; var file = new Blob ( \"hello world\" . split ( \"\" ) ) ; var file = new Blob ( \"hello world\" . split ( \"\" ) ) ;", "del_tokens": "/* global FakeBlob tus */ var file = new FakeBlob ( \"hello world\" . split ( \"\" ) ) ; var file = new FakeBlob ( \"hello world\" . split ( \"\" ) ) ; var file = new FakeBlob ( \"hello world\" . split ( \"\" ) ) ; var file = new FakeBlob ( \"hello world\" . split ( \"\" ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Moved", "var", "declarations", "where", "they", "are", "used"], "add_tokens": "var c = new Color ( ) ; var h6 = h * 6.0 ; var r = clamp ( h6 - 4.0 , 0.0 , 1.0 ) - clamp ( h6 - 1.0 , 0.0 , 1.0 ) + 1.0 ; var g = clamp ( h6 , 0.0 , 1.0 ) - clamp ( h6 - 3.0 , 0.0 , 1.0 ) ; var b = clamp ( h6 - 2.0 , 0.0 , 1.0 ) - clamp ( h6 - 5.0 , 0.0 , 1.0 ) ;", "del_tokens": "var c ; c = new Color ( ) ; var b , g , h6 , r ; h6 = h * 6.0 ; r = clamp ( h6 - 4.0 , 0.0 , 1.0 ) - clamp ( h6 - 1.0 , 0.0 , 1.0 ) + 1.0 ; g = clamp ( h6 , 0.0 , 1.0 ) - clamp ( h6 - 3.0 , 0.0 , 1.0 ) ; b = clamp ( h6 - 2.0 , 0.0 , 1.0 ) - clamp ( h6 - 5.0 , 0.0 , 1.0 ) ;", "commit_type": "move"}
{"commit_tokens": ["fixed", "custom", "tags", "template", "to", "work", "with", "multi", "-", "line", "descriptions"], "add_tokens": "var matches = string . match ( / ({(.*?)})?([\\s\\S]*) / ) ;", "del_tokens": "var matches = string . match ( / ({(.*?)})?(.*) / ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "missing", "comma", "and", "updated", "shieldStyle", "parameter", "to", "be", "more", "descriptive"], "add_tokens": "shieldStyle : \"flat\" , var url = opts . shieldsHost + \"/badge/coverage-\" + report . overallPercent + \"%-\" + color + \".svg?style=\" + opts . shieldStyle ;", "del_tokens": "shieldType : \"flat\" var url = opts . shieldsHost + \"/badge/coverage-\" + report . overallPercent + \"%-\" + color + \".svg?style=\" + opts . shieldType ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "showing", "transform", "errors", "for", "non", "-", "jsx", "files"], "add_tokens": "if ( opts [ '--transform-errors' ] === 'always' || ( opts [ '--transform-errors' ] !== 'never' && hasExtension ) ) { console . error ( \"Error while transforming file \" + fileName + \"\\n\" , e . stack ) ;", "del_tokens": "// Only throw an error if this was definitely a jsx file. if ( hasExtension ) { console . error ( \"Error while transforming jsx in file \" + fileName + \"\\n\" , e . stack ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "CORS", "to", "support", "cross", "-", "origin", "requests"], "add_tokens": "var cors = require ( 'cors' ) ; this . app . use ( cors ( ) ) ; this . app . listen ( this . httpPort ) ; console . log ( \"hlc-server is listening on port \" + this . httpPort ) ;", "del_tokens": "this . app . listen ( this . httpPort , function ( ) { console . log ( \"hlc-server is listening on port \" + this . httpPort ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "scrollLeft", "/", "Top", "fix", "test", "/", "keys"], "add_tokens": "beforeEach ( function ( beforeDone ) { } ) ; window . setTitle ( 'disableAccKeys() #target' ) ; pageDone ( ) ; var elements = Array . prototype . slice . call ( document . querySelectorAll ( 'html, body, body *' ) ) , overlay = new PlainOverlay ( ) , saveElement1 , saveElement2 ; saveElement1 = target . removeChild ( window . insProps [ overlay . _id ] . elmOverlay ) ; saveElement2 = target . removeChild ( document . getElementById ( 'plainoverlay-builtin-face-defs' ) ) ; target . appendChild ( saveElement1 ) ; target . appendChild ( saveElement2 ) ; saveElement1 = target . removeChild ( window . insProps [ overlay . _id ] . elmOverlay ) ; saveElement2 = target . removeChild ( document . getElementById ( 'plainoverlay-builtin-face-defs' ) ) ; window . setTitle ( 'disableAccKeys() body' ) ; pageDone ( ) ;", "del_tokens": "beforeAll ( function ( beforeDone ) { } , 'disableAccKeys()' ) ; } ) ; afterAll ( function ( ) { pageDone ( ) ; var elements = Array . prototype . slice . call ( document . querySelectorAll ( 'html, body *' ) ) , overlay = new PlainOverlay ( ) ; target . removeChild ( window . insProps [ overlay . _id ] . elmOverlay ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "CLI", "to", "find", "devices", "based", "on", "model", "and", "type"], "add_tokens": "return reg => reg . id === filter || reg . address === filter || reg . model === filter || reg . type === filter ;", "del_tokens": "return reg => reg . id === filter || reg . address === filter ;", "commit_type": "allow"}
{"commit_tokens": ["add", "a", "new", "panel", "mapMask", "to", "register", "geometryEvents", "to", "prevent", "conflicts", "with", "UIContainer"], "add_tokens": "var dom = map . _panels . mapMask ; dom = map . _panels . canvasContainer ; dom = map . _panels . mapMask ; if ( dom ) { Z . DomUtil . on ( dom , this . EVENTS , this . _identifyGeometryEvents , this ) ; var dom = map . _panels . mapMask ; dom = map . _panels . canvasContainer ; dom = map . _panels . mapMask ;", "del_tokens": "// return; var canvasContainer ; canvasContainer = map . _panels . canvasLayerContainer ; canvasContainer = map . _panels . mapWrapper ; if ( canvasContainer ) { Z . DomUtil . on ( canvasContainer , this . EVENTS , this . _identifyGeometryEvents , this ) ; //之所以取消在map上的监听, 是因为map事件在geometry事件之前发生, 会导致一些互动上的问题 // map.on('_mousedown _mouseup _mousemove _click _dblclick _contextmenu', this._identifyGeometryEvents, this); / ** map . off ( 'mousedown mouseup mousemove click dblclick contextmenu' , this . _identifyGeometryEvents , this ) ; * / var dom ; dom = map . _panels . canvasLayerContainer ; dom = map . _panels . mapWrapper ; // map.off('_mousedown _mouseup _mousemove _click _dblclick _contextmenu', this._identifyGeometryEvents, this);", "commit_type": "add"}
{"commit_tokens": ["Move", "image", "filenames", "to", "AnimationLoader", "."], "add_tokens": "function loadImagesFromManifest ( imageLoader , manifest ) { for ( var key in manifest ) { if ( manifest . hasOwnProperty ( key ) ) { var info = manifest [ key ] ; if ( info . strip !== undefined ) { imageLoader . load ( key , info . strip ) ; } else if ( info . prefix !== undefined ) { for ( var i = 1 ; i <= info . frames ; i ++ ) { var name = info . prefix + i + info . suffix ; imageLoader . load ( key + i , name ) ; } } } } } loadImagesFromManifest ( imageLoader , manifest ) ; function makeAnimationFromManifest ( images , key , manifestEntry ) { var img = images . get ( key ) ; var img = images . get ( key + i ) ; animations [ key ] = makeAnimationFromManifest ( images , key , info ) ;", "del_tokens": "this . totalAnimations = 0 ; this . loadedAnimation = 0 ; function makeAnimationFromManifest ( images , manifestEntry ) { var img = images . get ( manifestEntry . strip ) ; var img = images . get ( manifestEntry . prefix + i ) ; animations [ key ] = makeAnimationFromManifest ( images , info ) ;", "commit_type": "move"}
{"commit_tokens": ["fix", "themeEngine", "config", "with", "a", "default", "config"], "add_tokens": "var config = { app : 'we-theme-site-wejs' , admin : 'we-theme-admin-default' } ;", "del_tokens": "var config = { } ; // project plugin config file not found throw new Error ( 'Theme config not found in :' , p ) ;", "commit_type": "fix"}
{"commit_tokens": ["Change", "amigen", "service", "path", "link", "www", "site", "up", "to", "production", "service"], "add_tokens": "//var perfectapi = require('perfectapi'); var perfectapi = require ( '../../perfectapi/api.js' ) ;", "del_tokens": "var perfectapi = require ( 'perfectapi' ) ; //var perfectapi = require('../../perfectapi/api.js');", "commit_type": "change"}
{"commit_tokens": ["Add", "rollup", "-", "plugin", "-", "serve", "for", "the", "examples"], "add_tokens": "const serve = require ( \"rollup-plugin-serve\" ) boolean : [ \"min\" , \"es\" , \"serve\" ] if ( options . serve ) { plugins . push ( serve ( { open : true , contentBase : \"examples\" } ) ) }", "del_tokens": "boolean : [ \"min\" , \"es\" ]", "commit_type": "add"}
{"commit_tokens": ["Adding", "simplified", "browser", "names", "in", "the", "status", "page", "."], "add_tokens": "content . push ( '<table><tr><th style=\"width:150px;\">Browser</th><th style=\"width:300px;\">User agent</th><th style=\"width:150px;\">Address</th><th>Test</th></tr>' ) ; content . push ( '<td>' , curSlave . displayName , '</td>' ) ;", "del_tokens": "content . push ( '<table><tr><th style=\"width:300px;\">User agent</th><th style=\"width:150px;\">Address</th><th>Test</th></tr>' ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "for", "invalid", "lines", "and", "fix", "error"], "add_tokens": "if ( ! line || ! line [ 0 ] || line [ 0 ] . indexOf ( '#' ) === 0 ) {", "del_tokens": "if ( ! line || line [ 0 ] . indexOf ( '#' ) === 0 ) {", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "user", "chaining", "webpack", "main", "process", "config"], "add_tokens": "const mainProcessChain = pluginOptions . chainWebpackMainProcess || ( config => config ) const bundle = webpack ( mainProcessChain ( mainConfig ) . toConfig ( ) ) const bundle = webpack ( mainProcessChain ( mainConfig ) . toConfig ( ) )", "del_tokens": "const bundle = webpack ( mainConfig . toConfig ( ) ) const bundle = webpack ( mainConfig . toConfig ( ) )", "commit_type": "add"}
{"commit_tokens": ["Use", "lodash", ".", "set", "to", "support", "nested", "properties", "for", "the", "requestProperty", "option"], "add_tokens": "import set from 'lodash.set' ; requestProperty = \"user\" , set ( request , requestProperty , decodedAccessToken ) ;", "del_tokens": "key = \"user\" , request [ key ] = decodedAccessToken ;", "commit_type": "use"}
{"commit_tokens": ["Add", "callback", "to", ".", "exec"], "add_tokens": "/// `cmd.exec([print], [callback])` /// 2. `[callback]` *(Function)*: Execution is asynchronous. The callback is called once the /// command's stdout has cloesd. command_stream . exec = function ( print , callback ) { // Parse arguments if ( typeof arguments [ 0 ] === 'function' ) { callback = arguments [ 0 ] ; } // Setup callback if ( typeof callback === 'function' ) { child . stdout . on ( 'end' , callback ) ; } tee . _transform = function ( chunk , enc , done ) { process . nextTick ( done ) ; stream . _transform = function ( file , enc , done ) { process . nextTick ( done ) ;", "del_tokens": "/// `cmd.exec([print])` command_stream . exec = function ( print ) { tee . _transform = function ( chunk , enc , callback ) { process . nextTick ( callback ) ; stream . _transform = function ( file , enc , callback ) { process . nextTick ( callback ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "predefined", "functions", "support", "."], "add_tokens": "jazz = require ( 'jazz' ) , path = require ( 'path' ) ; Engine . prototype . _predefined = function ( params ) { var that = this ; return { 'include' : function ( file , cb ) { var data = fs . readFileSync ( path . join ( that . options . partials , file ) , that . options . encoding ) ; jazz . compile ( data ) . eval ( params , cb ) ; } } ; } ; var layoutParams = { fn : that . _predefined ( layoutParams ) , body : data , params : that . options . params } ; layout . eval ( layoutParams , cb ) ;", "del_tokens": "jazz = require ( 'jazz' ) ; layout . eval ( { body : data , params : that . options . params } , cb ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "failing", "deps", "intallation", "enable", "voice", "command", "with", "command", "line", "flag"], "add_tokens": "if ( req . connection . remoteAddress === '127.0.0.1' || else if ( header ) { checkHeaderKnownDevice ( ) }", "del_tokens": "if ( header ) { checkHeaderKnownDevice ( ) } else if ( req . connection . remoteAddress === '127.0.0.1' ||", "commit_type": "fix"}
{"commit_tokens": ["Allow", "an", "array", "to", "be", "used", "as", "an", "argument", "for", "include", "/", "exclude"], "add_tokens": "import _isArray from 'lodash/isArray' if ( ! _isArray ( include ) ) { include = [ include ] if ( ! _isArray ( exclude ) ) { exclude = [ exclude ] include = include . map ( i => { if ( _isString ( i ) ) { return new RegExp ( ` ${ i } ` ) } else if ( ! _isRegExp ( i ) ) { return / . / } return i } ) exclude = exclude . map ( e => { if ( _isString ( e ) ) { return new RegExp ( ` ${ e } ` ) } else if ( ! _isRegExp ( e ) ) { return / [^a-zA-Z0-9] / } return e } )", "del_tokens": "if ( _isString ( include ) ) { include = new RegExp ( ` ${ include } ` ) } else if ( ! _isRegExp ( include ) ) { include = / . / if ( _isString ( exclude ) ) { exclude = new RegExp ( ` ${ exclude } ` ) } else if ( ! _isRegExp ( exclude ) ) { exclude = / [^a-zA-Z0-9] /", "commit_type": "allow"}
{"commit_tokens": ["fixed", "getSelector", "on", "on", ".", "added", "ietrident", "to", "modernizer", "added", "append", ".", "remove", "append", ".", "create", ".", "Fixed", "setClass", "to", "avoid", "classList", "in", "ie11"], "add_tokens": "Modernizr . addTest ( 'ietrident' , function ( ) { var ua = navigator . userAgent , rv ; var re = new RegExp ( 'Trident/.*rv:([0-9]{1,}[\\\\.0-9]{0,})' ) ; if ( re . exec ( ua ) != null ) { rv = parseFloat ( RegExp . $1 ) ; return rv ; } } ) ; Modernizr . add ( 'dom-addeventlistener' , ! Modernizr . ietrident && ! ! document . addEventListener ) ; Modernizr . addTest ( 'ietrident' , function ( ) { var ua = navigator . userAgent , rv ; var re = new RegExp ( 'Trident/.*rv:([0-9]{1,}[\\\\.0-9]{0,})' ) ; if ( re . exec ( ua ) != null ) { rv = parseFloat ( RegExp . $1 ) ; return rv ; } } ) ;", "del_tokens": "Modernizr . add ( 'dom-addeventlistener' , ! ! document . addEventListener ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "cache", "-", "path", "key", "to", "be", "passed", "to", "cefclient", "."], "add_tokens": "keys = [ 'url' , 'name' , 'width' , 'height' , 'minwidth' , 'minheight' , 'ico' , 'cache-path' ] ;", "del_tokens": "keys = [ 'url' , 'name' , 'width' , 'height' , 'minwidth' , 'minheight' , 'ico' ] ;", "commit_type": "allow"}
{"commit_tokens": ["Allow", "to", "send", "groupchat", "messages"], "add_tokens": "job . object . content , job . target [ '@type' ] === 'room'", "del_tokens": "job . object . content", "commit_type": "allow"}
{"commit_tokens": ["Adding", "in", "-", "memory", "storage", "option"], "add_tokens": "", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "some", "tests", "and", "add", "install", "to", "Makefile"], "add_tokens": "const serverUrl = Client . getUrl ( ) ; Client . setUrl ( 'notarealurl' ) ; Client . setUrl ( serverUrl ) ;", "del_tokens": "const DEFAULT_SERVER = 'http://localhost:8065' ; Client . setUrl ( 'https://google.com/fake/url' ) ; TestHelper . basicClient . setUrl ( DEFAULT_SERVER ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "update", "user", "password", "action"], "add_tokens": "export function updateUserPassword ( userId , currentPassword , newPassword ) { return async ( dispatch , getState ) => { dispatch ( { type : UserTypes . UPDATE_USER_REQUEST } , getState ) ; try { await Client4 . updateUserPassword ( userId , currentPassword , newPassword ) ; } catch ( error ) { dispatch ( { type : UserTypes . UPDATE_USER_FAILURE , error } , getState ) ; return null ; } const actions = [ { type : UserTypes . UPDATE_USER_SUCCESS } ] ; const profile = getState ( ) . entities . users . profiles [ userId ] ; if ( profile ) { actions . push ( { type : UserTypes . RECEIVED_PROFILE , data : Object . assign ( { } , profile , { last_password_update_at : new Date ( ) . getTime ( ) } ) } ) ; } dispatch ( batchActions ( actions ) , getState ) ; return true ; } ; } updateUserMfa , updateUserPassword", "del_tokens": "updateUserMfa", "commit_type": "add"}
{"commit_tokens": ["remove", "warning", "for", "ignore", "files"], "add_tokens": "return Promise . resolve ( ) ;", "del_tokens": "throw Error ( ` ${ fileMeta . filename } ` ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "start", "/", "stop", "api"], "add_tokens": "import { Image , ScrollView , Text , View } from 'react-native' ; import backwardsCompatibleAnimWrapper from './animations/backwardsCompatibleAnimWrapper' ; decay : backwardsCompatibleAnimWrapper ( decay , DecayAnimation ) , timing : backwardsCompatibleAnimWrapper ( timing , TimingAnimation ) , spring : backwardsCompatibleAnimWrapper ( spring , SpringAnimation ) ,", "del_tokens": "import { Image , Text , View , ScrollView } from 'react-native' ; function backwardsCompatibleAnim ( node , AnimationClass ) { return ( clock , state , config ) => { if ( config !== undefined ) { return node ( clock , state , config ) ; } // reassign to match spec of old Animated lib where first arg was value // and second arg was animation config const value = clock ; config = state ; return { start : ( ) => { value . animate ( new AnimationClass ( config ) ) ; } , } ; } ; } decay : backwardsCompatibleAnim ( decay , DecayAnimation ) , timing : backwardsCompatibleAnim ( timing , TimingAnimation ) , spring : backwardsCompatibleAnim ( spring , SpringAnimation ) ,", "commit_type": "add"}
{"commit_tokens": ["added", "more", "cased", "for", "addElement", "required", "fields"], "add_tokens": "if ( dbField . Null === 'NO' && dbField . Default === '' && dbField . Extra !== 'auto_increment' && dbField . Extra . search ( 'on update' ) === - 1 ) {", "del_tokens": "if ( dbField . Null === 'NO' && dbField . Extra !== 'auto_increment' ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "layer", "matching", "and", "state", "capture"], "add_tokens": "// \"Capture\" state as it will be set to null when layer is disposed const { state } = this ; drawType , numIndices , gl . UNSIGNED_SHORT , 0 , state . numInstances drawType , 0 , numVertices / 3 , state . numInstances return ( ) => gl . drawArrays ( drawType , 0 , state . numInstances ) ;", "del_tokens": "drawType , numIndices , gl . UNSIGNED_SHORT , 0 , this . state . numInstances drawType , 0 , numVertices / 3 , this . state . numInstances return ( ) => gl . drawArrays ( drawType , 0 , this . state . numInstances ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "checkerboard", "background", "to", "Demo"], "add_tokens": "import styles from './Demo.scss' ; render ( ) { const Component = getRegisteredComponentType ( this . props . component ) ; return ( < div className = { styles . root } > { this . renderSelectList ( ) } < Component { ... this . selectedPresetProps ( ) } / > < / div > ) ; } onSelectPreset = e => { const selectedPreset = parseInt ( e . target . value ) ; this . setState ( { ... this . state , selectedPreset } ) ; } ;", "del_tokens": "onSelectPreset = e => { const selectedPreset = parseInt ( e . target . value ) ; this . setState ( { ... this . state , selectedPreset } ) ; } ; render ( ) { const Component = getRegisteredComponentType ( this . props . component ) ; return ( < div > { this . renderSelectList ( ) } < Component { ... this . selectedPresetProps ( ) } / > < / div > ) ; }", "commit_type": "add"}
{"commit_tokens": ["add", "version", "to", "twitterlib", "and", "move", "to", "http", ".", "request", "in", "node", "version"], "add_tokens": "var twitterlib = require ( '../twitterlib' ) ; console . log ( twitterlib . version ) ;", "del_tokens": "var twitterlib = require ( 'twitterlib' ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "minor", "bug", "in", "recreate", "function"], "add_tokens": "'matreshka_dir/matreshka-array/recreate' , 'matreshka_dir/matreshka-array/indexof' ] , function ( sym , MK , processRendering , triggerModify , recreate , indexOf ) { } ) ;", "del_tokens": "'matreshka_dir/matreshka-array/recreate' ] , function ( sym , MK , processRendering , triggerModify , recreate ) { } ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "elasticsearch", "dashboard", "for", "multi", "process", "express", "example"], "add_tokens": "// metrics.reporter.carbon.reportEvent(event) metrics . reporter . elasticsearch . reportEvent ( event )", "del_tokens": "metrics . reporter . carbon . reportEvent ( event )", "commit_type": "add"}
{"commit_tokens": ["Changed", "no", "results", "back", "to", "empty", "map", "made", "it", "so", "that", "category", "filtering", "gets", "cloned", "into", "the", "modal", "window", "fixed", "missing", "geocode", ".", "js", "in", "dist"], "add_tokens": "'dist/js/handlebars.min.js' : 'libs/handlebars/*.js' , 'dist/js/geocode.min.js' : 'src/js/geocode.js'", "del_tokens": "'dist/js/handlebars.min.js' : 'libs/handlebars/*.js'", "commit_type": "change"}
{"commit_tokens": ["changed", "verification", "for", "property", "existence", "."], "add_tokens": "if ( ! ( name in values ) ) {", "del_tokens": "if ( ! values . hasOwnProperty ( name ) ) {", "commit_type": "change"}
{"commit_tokens": ["Fixed", "the", "dispatcher", "lint", "errors"], "add_tokens": "var Bluebird = require ( 'bluebird' ) ; this . asanaBaseUrl = options . asanaBaseUrl || 'https://app.asana.com/' ; * @ return { Promise } The response for the request return new Bluebird ( function ( resolve , reject ) { * @ return { Promise } The response for the request * @ return { Promise } The response for the request * @ return { Promise } The response for the request * @ return { Promise } The response for the request", "del_tokens": "var BPromise = require ( 'bluebird' ) ; this . asanaBaseUrl = options . asanaBaseUrl || 'https://app.asana.com/' * @ return { BPromise } The response for the request return new BPromise ( function ( resolve , reject ) { * @ return { BPromise } The response for the request * @ return { BPromise } The response for the request * @ return { BPromise } The response for the request * @ return { BPromise } The response for the request", "commit_type": "fix"}
{"commit_tokens": ["fix", "custom", "config", "command", "test"], "add_tokens": "TestBase . prototype . runDefaultCommandTests = function ( ) { var commandTests = [ this . run ( commandTests ) ; TestBase . prototype . run = function ( commandTests ) { async . eachSeries ( commandTests , function ( commandTest , callback ) { commandTest . command . config = self . config ; self . runTest ( index , commandTest , callback ) ;", "del_tokens": "TestBase . prototype . runDefaultCommands = function ( ) { var commands = [ this . run ( commands ) ; TestBase . prototype . run = function ( commands ) { async . eachSeries ( commands , function ( command , callback ) { command . config = self . config ; self . runTest ( index , command , callback ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "output", "headings", "to", "writer"], "add_tokens": "var headings , retailer_list ; headings = [ { reference : 'References' } , { quantity : 'Qty' } , { description : 'Description' } , { partNumbers : 'Part Number' } ] ;", "del_tokens": "var retailer_list ;", "commit_type": "add"}
{"commit_tokens": ["move", "ValidationError", "class", "to", "own", "file"], "add_tokens": "var ValidationError = require ( '../../validation-error' ) ; Rule . ValidationError = ValidationError ;", "del_tokens": "/ ** * Register rule * * @ static * @ class * @ constructor * @ param { ! String } ruleName * @ param { * } ruleParams * @ param { ? Number } [ index ] * @ property { String } name = \"ValidationError\" * @ property { * } params * @ property { ? Number } index * * @ returns { Rule . ValidationError } * * / Rule . ValidationError = function ValidationError ( ruleName , ruleParams , index ) { if ( ! ( this instanceof Rule . ValidationError ) ) { return new Rule . ValidationError ( ruleName , ruleParams , index ) ; } if ( ! ruleName || typeof ruleName !== 'string' ) { throw new TypeError ( 'invalid ruleName, must be non-empty string' ) ; } Error . call ( this ) ; this . name = 'ValidationError' ; this . rule = ruleName ; this . params = _ . cloneDeep ( ruleParams ) ; this . index = typeof index === 'number' && ! _ . isNaN ( index ) ? index : null ; return this ; } ; extend ( Rule . ValidationError , Error ) ;", "commit_type": "move"}
{"commit_tokens": ["fixing", "and", "adding", "first", "tests"], "add_tokens": "return snippets ;", "del_tokens": "return { chunks : chunks , lines : script . split ( '\\n' ) } ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "alias", "type", "."], "add_tokens": "describe ( 'alias' , function ( ) { var SO = new SchemaObject ( { state : String , region : { type : 'alias' , index : 'state' } , regionTransform : { type : 'alias' , index : 'state' , transform : function ( value ) { if ( value === 'test' ) { value = value . toUpperCase ( ) ; } return value ; } } } ) ; it ( 'should allow alias to be used to set values' , function ( ) { var o = new SO ( ) ; o . region = 'CA' ; o . region . should . be . a ( 'string' ) ; o . region . should . equal ( 'CA' ) ; o . state . should . be . a ( 'string' ) ; o . state . should . equal ( 'CA' ) ; } ) ; it ( 'should allow alias to pre-transform values' , function ( ) { var o = new SO ( ) ; o . regionTransform = 'test' ; o . regionTransform . should . be . a ( 'string' ) ; o . regionTransform . should . equal ( 'TEST' ) ; o . state . should . be . a ( 'string' ) ; o . state . should . equal ( 'TEST' ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "Cache", "and", "Deprecated", "fields"], "add_tokens": "var value = NgindoxUtil . RouteMetaFields [ key ] ;", "del_tokens": "var value = NgindoxUtil . RouteFields [ key ] ;", "commit_type": "fix"}
{"commit_tokens": ["Moving", "office", "-", "js", "-", "helpers", "to", "archive"], "add_tokens": "const timeout = 10000 ;", "del_tokens": "const timeout = 2000 ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "infinite", "-", "scroll", "-", "immediate", "-", "check", "behavior"], "add_tokens": "/* ng-infinite-scroll - v1.2.0 - 2015-12-02 */ var changeContainer , checkInterval , checkWhenEnabled , container , handleInfiniteScrollContainer , handleInfiniteScrollDisabled , handleInfiniteScrollDistance , handleInfiniteScrollUseDocumentBottom , handler , height , immediateCheck , offsetTop , pageYOffset , scrollDistance , scrollEnabled , throttle , unregisterEventListener , useDocumentBottom , windowElement ; checkInterval = false ; if ( checkInterval ) { $interval . cancel ( checkInterval ) ; } return checkInterval = $interval ( ( function ( ) { } ) , 0 ) ;", "del_tokens": "/* ng-infinite-scroll - v1.2.0 - 2015-02-14 */ var changeContainer , checkWhenEnabled , container , handleInfiniteScrollContainer , handleInfiniteScrollDisabled , handleInfiniteScrollDistance , handleInfiniteScrollUseDocumentBottom , handler , height , immediateCheck , offsetTop , pageYOffset , scrollDistance , scrollEnabled , throttle , unregisterEventListener , useDocumentBottom , windowElement ; return $interval ( ( function ( ) { } ) , 0 , 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "for", "app", "shortcuts"], "add_tokens": "const appHasFocus = focusedWin !== null && focusedWin . isVisible ( ) ; debug ( registeringWindowHasFocus , win && win === ANY_WINDOW ? 'ANY_WINDOW' : win . getTitle ( ) , focusedWin && focusedWin . getTitle ( ) ) ; debug ( JSON . stringify ( { registeringAppShortcut , appHasFocus , registeringWindowHasFocus } ) ) ;", "del_tokens": "const appHasFocus = focusedWin !== null ; debug ( { registeringAppShortcut , appHasFocus , registeringWindowHasFocus } ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "demos", "await", "web", ".", "js", ";", "fix", "loading", "state"], "add_tokens": "async function runKeyguard ( RequestApiClass ) { // expose KeyStore to mockup overwrites self . KeyStore = KeyStore ; await Nimiq . WasmHelper . doImportBrowser ( ) ;", "del_tokens": "function runKeyguard ( RequestApiClass ) {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "the", "update", "of", "lat", "/", "lng", "not", "being", "handled"], "add_tokens": "polylineController : 'google-map/polyline' , polylineViewClass : 'google-map/polyline' ,", "del_tokens": "polylineController : 'google-map/polyline' , polylineViewClass : 'google-map/polyline' ,", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "possible", "memory", "leak"], "add_tokens": "let handler = ( ) => this . close ( ) . subscribe ( ) ; this . _minifier . on ( 'end' , handler ) . on ( 'error' , handler ) ;", "del_tokens": "let handler = ( ) => this . close ( ) . subscribe ( ) ; this . _minifier . once ( 'end' , handler ) . once ( 'error' , handler ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "get", "userUsedPercent", "of", "cpuUsage", "is", "NaN"], "add_tokens": "usage . userUsedPercent = Math . round ( ( usage . user / total ) * 100 ) ;", "del_tokens": "usage . userUsedPercent = Math . round ( ( usage . use / total ) * 100 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "sprite", "options", "to", "the", "plugin"], "add_tokens": "const _sprite = Symbol ( ) ; * @ param { Object } options . sprite - svg sprite options { startX , startY , deltaX , deltaY , iconHeight } sprite = { } , this [ _sprite ] = sprite ; store [ spritePath ] . generate ( this [ _sprite ] ) ;", "del_tokens": "store [ spritePath ] . generate ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "calling", "fake", "Date", "as", "function"], "add_tokens": "var date = ( argsArray . length === 0 ) ? new OriginalDate ( Date . now ( ) ) : makeOriginalDateFromArgs . apply ( undefined , argsArray ) ; if ( ! ( this instanceof FakeDate ) ) { return date . toString ( ) ; } this . _date = date ;", "del_tokens": "this . _date = ( argsArray . length === 0 ) ? new OriginalDate ( Date . now ( ) ) : makeOriginalDateFromArgs . apply ( undefined , argsArray ) ; this . _date = ( argsArray . length === 0 ) ? new OriginalDate ( Date . now ( ) ) : makeOriginalDateFromArgs . apply ( undefined , argsArray ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "blockScroll", "mouseProperty", "(", "to", "prevent", "scrolling", "when", "the", "user", "zooms", ")"], "add_tokens": "blockScroll : false if ( self . p [ 'blockScroll' ] ) { if ( event . preventDefault ) { event . preventDefault ( ) ; } else { event . returnValue = false ; } }", "del_tokens": "stopScrolling : false , stopDragging : false self . p [ 'stopDragging' ] && event . stopPropagation ( ) ; return self . p [ 'stopDragging' ] ; self . p [ 'stopDragging' ] && event . stopPropagation ( ) ; return self . p [ 'stopDragging' ] ; self . p [ 'stopDragging' ] && event . stopPropagation ( ) ; return self . p [ 'stopDragging' ] ; self . p [ 'stopScrolling' ] && event . stopPropagation ( ) ; return self . p [ 'stopScrolling' ] ;", "commit_type": "add"}
{"commit_tokens": ["Improve", "resolver", "target", "property", "names"], "add_tokens": "member , trgPath , trgName : resName , objPath , ? ` ${ aName } ${ a . trgName } ` const bText = ` ${ bName } ${ b . trgName } `", "del_tokens": "member : member , type : trgPath , name : resName , path : objPath , ? ` ${ aName } ${ a . name } ` const bText = ` ${ bName } ${ b . name } `", "commit_type": "improve"}
{"commit_tokens": ["added", "toUuid", "array", "lookup", "to", "events", "api", "and", "converted", "_id", "to", "id"], "add_tokens": "$or : [ { fromUuid : uuid } , { uuid : uuid } , { devices : { $in : [ uuid , \"all\" ] } } ] eventdata [ i ] . id = eventdata [ i ] . _id delete eventdata [ i ] . _id ;", "del_tokens": "$or : [ { fromUuid : uuid } , { uuid : uuid } ]", "commit_type": "add"}
{"commit_tokens": ["Remove", "unused", "option", "from", "BASE", "lookup", "."], "add_tokens": "var BASE = { \"0x\" : 16 , \"0\" : 8 } ;", "del_tokens": "var BASE = { \"0x\" : 16 , \"0\" : 8 , \"X\" : 10 } ;", "commit_type": "remove"}
{"commit_tokens": ["Update", "property", "and", "test", "it"], "add_tokens": "* @ param { number } time position ( in seconds ) on timeline", "del_tokens": "* @ param { string } time position ( in seconds ) on timeline", "commit_type": "update"}
{"commit_tokens": ["Added", "functions", "to", "create", "generic", "servers", "and", "clients"], "add_tokens": "return client . makeProtobufClientConstructor ( value ) ; exports . buildServer = server . makeProtobufServerConstructor ; exports . makeGenericClientConstructor = client . makeClientConstructor ; exports . makeGenericServerConstructor = server . makeServerConstructor ;", "del_tokens": "return client . makeClientConstructor ( value ) ; exports . buildServer = server . makeServerConstructor ;", "commit_type": "add"}
{"commit_tokens": ["Added", "get", "level", "tests", "for", "falsey", "values", "in", "path", "values"], "add_tokens": "if ( cache === null || ( cache . $type && cache . $type !== $ref ) || ( typeof cache !== 'object' ) ) {", "del_tokens": "if ( cache === null || ( cache . $type && cache . $type !== $ref ) || ( typeof cache !== 'object' ) ) {", "commit_type": "add"}
{"commit_tokens": ["Allow", "passing", "handler", "via", "handler", "prop"], "add_tokens": "current . handler !== undefined && current . path !== undefined , var handler = page ? page . handler : notFound ? notFound . handler : return this . transferPropsTo ( component ( null , handler ( match ) ) ) ; function Route ( props , handler ) { typeof props . handler === 'function' || typeof handler === 'function' , \"Route handler should be a template\" ) ; return { path : props . path , handler : props . handler || handler } ; function NotFound ( props , handler ) { typeof props . handler === 'function' || typeof handler === 'function' , \"NotFound handler should be a template\" ) ; return { path : null , handler : props . handler || handler } ;", "del_tokens": "current . children !== undefined && current . path !== undefined , var children = page ? page . children : notFound ? notFound . children : return this . transferPropsTo ( component ( null , children ( match ) ) ) ; function Route ( props , children ) { typeof children === 'function' , \"Route children should be a template\" ) ; return { path : props . path , children : children } ; function NotFound ( _props , children ) { typeof children === 'function' , \"NotFound children should be a template\" ) ; return { path : null , children : children } ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "travis", "config", "register", "datasources"], "add_tokens": "tag ( 'StyleName' , 'style-' + i ) +", "del_tokens": "tag ( 'Stylename' , 'style-' + i ) +", "commit_type": "add"}
{"commit_tokens": ["adding", "more", "error", "handling", "in", "routed", "methods", "and", "implementing", "interfaces", "using", "promises"], "add_tokens": "} ; Server . onConnectionJoin = function ( connection , roomName , deferred ) { InstanceManager . register ( roomName ) . then ( function ( instance ) { instance . addConnection ( connection ) ; deferred . resolve ( instance ) ; } ) . fail ( function ( error ) { deferred . reject ( error ) ; } ) ;", "del_tokens": "} Server . onConnectionJoin = function ( connection , roomName , callback ) { var instance = InstanceManager . register ( roomName ) ; if ( instance ) { // Instance was created successfully, or already existed instance . addConnection ( connection ) ; callback ( { success : true } ) ; } else { // instance will be an error object callback ( { success : false , error : instance } ) ; }", "commit_type": "add"}
{"commit_tokens": ["Remove", "default", "socket", "timeout", "and", "make", "sure", "connection", "errors", "yield", "a", "disconnected", "client"], "add_tokens": "var callbackCalled = false ; var t ; if ( self . _isConnected ) { self . _isConnected = false ; self . _client . disconnect ( function ( ) { if ( callbackCalled ) { return ; } clearTimeout ( t ) ; callbackCalled = true ; if ( emit ) { self . emit ( 'error' , LibrdKafkaError . create ( err ) ) ; } next ( err ) ; return ; } ) ; // don't take too long. this is a failure, after all t = setTimeout ( function ( ) { if ( callbackCalled ) { return ; } callbackCalled = true ; if ( emit ) { self . emit ( 'error' , LibrdKafkaError . create ( err ) ) ; } next ( err ) ; return ; } , 10000 ) . unref ( ) ; // We are connected so we need to disconnect", "del_tokens": "// Enforce a default timeout if ( ! globalConf . hasOwnProperty ( 'socket.timeout.ms' ) ) { globalConf [ 'socket.timeout.ms' ] = 250 ; } if ( emit ) { self . emit ( 'error' , LibrdKafkaError . create ( err ) ) ; self . _isConnected = false ; next ( err ) ; return ;", "commit_type": "remove"}
{"commit_tokens": ["added", "a", "callback", "for", "end", "of", "line~"], "add_tokens": "// ramp to value // onStop callback var bla = 0 ; line . inlets [ 0 ] . message ( '0 700' ) ; line . onStop ( function ( ) { bla = 999 ; } ) ; line . dspTick ( ) ; equal ( bla , 0 ) ; line . dspTick ( ) ; equal ( bla , 999 ) ;", "del_tokens": "// jump to value console . log ( line ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "issues", "with", "riak", "client"], "add_tokens": "client . client [ fn ] ( ... args , returnResult ) ;", "del_tokens": "/ ** * Whether or not this cluster is connected * @ type { boolean } * @ private * / this . _isConnected = false ; this . _isConnected = true ; // if (args[0].key) { // req += `bucket/${args[0].key} `; // } if ( ! self . _isConnected ) { // We are connected so lets execute function client . client [ fn ] ( ... args , returnResult ) ; return ; } // we need to wait for connection // set timeout for taking too long to connect let timer = setTimeout ( checkIsConnected , self . config . connectTimeout ) ; / ** * Listen to state change and run function * on connection * / let checkConnectState = function ( ) { // We are running if ( client . client . cluster . state == Riak . Cluster . State . RUNNING ) { // Set to connected self . _isConnected = true ; // clear timeout clearTimeout ( timer ) ; // Remove listener client . client . cluster . removeListener ( 'stateChange' , checkConnectState ) ; // call the function client . client [ fn ] ( ... args , returnResult ) ; } } ; // Listen to state changes self . client . cluster . on ( 'stateChange' , checkConnectState ) ; checkConnectState ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "matching", "multiple", "message", "types"], "add_tokens": "if ( ! Array . isArray ( obj . type ) ) { obj . type = obj . type . split ( \",\" ) ; } let matchType = obj . type . indexOf ( message . type ) > - 1 ;", "del_tokens": "let matchType = obj . type === message . type ;", "commit_type": "allow"}
{"commit_tokens": ["fixed", ":", "lists", "not", "rendered", "correctly"], "add_tokens": ". replace ( / ^(\\n?(\\*|\\+|-)(.*))+$ / gm , _createUnorderedList ) . replace ( / ^(\\n?([0-9]+\\.)(.*))+$ / gm , _createOrderedList )", "del_tokens": ". replace ( / (\\n?(\\*|\\+|-)(.*))+$ / gm , _createUnorderedList ) . replace ( / (\\n?([0-9]+\\.)(.*))+$ / gm , _createOrderedList )", "commit_type": "fix"}
{"commit_tokens": ["Add", "copy", "option", "for", "JSON", "input", "data", "."], "add_tokens": "import { field , identity , isFunction , isObject } from 'vega-util' ; var prop = ( format && format . property ) ? field ( format . property ) : identity ; return isObject ( data ) && ! isBuffer ( data ) ? parseJSON ( prop ( data ) ) : prop ( JSON . parse ( data ) ) ; } function parseJSON ( data , format ) { return ( format && format . copy ) ? JSON . parse ( JSON . stringify ( data ) )", "del_tokens": "import { field , isFunction , isObject } from 'vega-util' ; data = isObject ( data ) && ! isBuffer ( data ) ? data : JSON . parse ( data ) ; return ( format && format . property ) ? field ( format . property ) ( data )", "commit_type": "add"}
{"commit_tokens": ["Updated", "TestAppCordova", "for", "previous", "commit"], "add_tokens": "var minimumReportInterval = this . minimumReportInterval ; if ( options . frequency < minimumReportInterval ) { options . frequency < minimumReportInterval ; } var thisAcc = this ; var minimumReportInterval = this . minimumReportInterval ; if ( options . frequency < minimumReportInterval ) { options . frequency < minimumReportInterval ; } var thisComp = this ;", "del_tokens": "var thisAcc = this ; var thisComp = this ;", "commit_type": "update"}
{"commit_tokens": ["Move", "plugin", "file", "to", "src", "add", "wrapper", "index", ".", "js", "."], "add_tokens": "var useTranspiled = true ; // eslint-disable-line no-var try { require . resolve ( \"./lib\" ) ; } catch ( e ) { useTranspiled = false ; if ( useTranspiled ) { module . exports = require ( \"./lib\" ) ; } else { require ( \"babel/register\" ) ; module . exports = require ( \"./src\" ) ; }", "del_tokens": "const UglifyJS = require ( \"uglify-js\" ) ; function uglify ( ast , options , mangle ) { let uAST = UglifyJS . AST_Node . from_mozilla_ast ( ast ) ; uAST . figure_out_scope ( ) ; uAST = uAST . transform ( UglifyJS . Compressor ( options ) ) ; // eslint-disable-line new-cap if ( mangle ) { uAST . figure_out_scope ( ) ; uAST . compute_char_frequency ( ) ; uAST . mangle_names ( ) ; } return uAST . to_mozilla_ast ( ) ; module . exports = function ( uglifyOpts , mangle ) { uglifyOpts = uglifyOpts || { } ; return function ( override , transform ) { transform ( \"constructBundle\" , function ( bundleAst ) { return uglify ( bundleAst , uglifyOpts , mangle ) ; } ) ; } ; } ;", "commit_type": "move"}
{"commit_tokens": ["add", "more", "tests", "for", "mentions"], "add_tokens": "arr : [ '@justin' , '@-megusta-' ] , { str : 'te@st' , expected : false } , { str : '@(test)' , expected : false } , { str : '@-/~test/' , expected : false } ,", "del_tokens": "arr : [ '@justin' ] ,", "commit_type": "add"}
{"commit_tokens": ["add", "notFound", "handler", "to", "findTargetObjects", "method"], "add_tokens": "serverError : reject , // this isn't perfect, since it returns a 500 error instead of a 404 error // but it is better than crashing the app when a record doesn't exist notFound : reject", "del_tokens": "serverError : reject", "commit_type": "add"}
{"commit_tokens": ["remove", "productOptions", "from", "routes", "/", "order", ".", "js"], "add_tokens": "", "del_tokens": "let productOptions = '' ; if ( result . options !== { } ) { productOptions = result . options ; } productOptions : productOptions ,", "commit_type": "remove"}
{"commit_tokens": ["Updated", "host", "-", "utils", "to", "automatically", "include", "SPA", "base"], "add_tokens": "const skyPagesConfigUtil = require ( '../config/sky-pages/sky-pages.config' ) ; let host = skyPagesConfig . host . url ; // Trim leading slash since getAppBase adds it if ( url && url . charAt ( 0 ) === '/' ) { url = url . substring ( 1 ) ; } // Trim trailing slash since geAppBase adds it if ( host && host . charAt ( host . length - 1 ) === '/' ) { host = host . slice ( 0 , - 1 ) ; } const base = skyPagesConfigUtil . getAppBase ( skyPagesConfig ) ; const resolved = ` ${ host } ${ base } ${ url } ${ delimeter } ${ encoded } ` ;", "del_tokens": "const resolved = ` ${ skyPagesConfig . host . url } ${ url } ${ delimeter } ${ encoded } ` ;", "commit_type": "update"}
{"commit_tokens": ["Updated", "glob", "to", "support", "found", "pattern", "result"], "add_tokens": "var foundPattern = self . isMatch ( p , null , options ) ; if ( foundPattern ) { matches . push ( { match : p , pattern : foundPattern } ) ; return null ; return patterns [ i ] ; return null ;", "del_tokens": "if ( self . isMatch ( p , null , options ) ) { matches . push ( p ) ; return false ; return true ; return false ;", "commit_type": "update"}
{"commit_tokens": ["added", "screenshots", "in", "wdio", "config", "file"], "add_tokens": "", "del_tokens": "// rework", "commit_type": "add"}
{"commit_tokens": ["make", "sure", "addr", "is", "string"], "add_tokens": "params . web3 . eth . getBalance ( \"\" + addr , ( error , balance ) => {", "del_tokens": "params . web3 . eth . getBalance ( addr , ( error , balance ) => {", "commit_type": "make"}
{"commit_tokens": ["Use", "received", "Constructor", "instead", "of", "Regular"], "add_tokens": "Router . _Base = options ; const Component = Router . _Base ; const Component = Router . _Base ; const Component = Router . _Base ; const Component = Router . _Base ;", "del_tokens": "Router . _Regular = Regular ; const Component = Router . _Regular ; const Component = Router . _Regular ; const Component = Router . _Regular ; const Component = Router . _Regular ;", "commit_type": "use"}
{"commit_tokens": ["Added", "support", "for", "profile", "-", "level", "configuration"], "add_tokens": "* profile : { } , // Profile configuration values (overrides defaults) * Configuration values are searched in the following order : * 1. Environment variables * 2. Current working director ( ` ` ) , * 3. Home folder ( ` ` ) , and * 4. System config ( ` ` ) * 5. Default value from ` ` * 6. Default value from ` ` profile : { } , // Load default values from profile cfg . overrides ( options . profile ) ;", "del_tokens": "* If ` ` is given , configuration will be loaded from folders in the * following order : * * 1. Current working director ( ` ` ) , * 2. Home folder ( ` ` ) , and * 3. System config ( ` ` ) *", "commit_type": "add"}
{"commit_tokens": ["Add", "num", "failures", ";", "add", "to", "npm", "test"], "add_tokens": "var numFails = 0 ; numFails += 1 ; numFails += 1 ; console . log ( \"%s test failures.\" , numFails ) ; process . exit ( numFails > 0 ? 1 : 0 ) ;", "del_tokens": "exitCode = 1 ; exitCode = 1 ; process . exit ( exitCode ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "opening", "/", "selecting", "in", "recursive", "filebrowser"], "add_tokens": "return this . editor . renderer . onResize ( true ) ;", "del_tokens": "this . filebrowser . onResize ( ) ; var _ref3 ; this . editor . renderer . onResize ( true ) ; return ( _ref3 = this . filebrowser ) != null ? _ref3 . onResize ( ) : void 0 ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "dependency", "and", "updated", "code", "style"], "add_tokens": "if ( ! result [ locale . name ] ) { result [ locale . name ] = { } ; }", "del_tokens": "if ( ! result [ locale . name ] ) { result [ locale . name ] = { } ; }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "problem", "with", "CSS", "file", "compilation"], "add_tokens": "", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["Fix", "emission", "of", "terminal", "focus&blur", "events"], "add_tokens": "this . element . onfocus = function ( ) { self . emit ( 'focus' , { terminal : this } ) ; } ; this . element . onblur = function ( ) { self . emit ( 'blur' , { terminal : this } ) ; } ;", "del_tokens": "this . emit ( 'focus' , { terminal : this } ) ; this . emit ( 'blur' , { terminal : this } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "read", "method"], "add_tokens": "Stream . Duplex . call ( this , { readableObjectMode : true } ) ; callback ( ) ; if ( this . _state === WAITING_FOR_HEADER ) { this . push ( frame ) ;", "del_tokens": "Stream . Duplex . call ( this ) ; return null ; / ** * Add data into the receiver . * @ method Receiver # write * @ param { Buffer } buffer The received data . * @ param { String } [ encoding ] The encoding of the data . * @ param { Function } [ callback ] The callback function . * / buffer = new Buffer ( buffer ) ; callback ( null ) ; if ( this . _state == WAITING_FOR_HEADER ) { this . emit ( 'data' , frame ) ;", "commit_type": "add"}
{"commit_tokens": ["removing", "unused", "plugins", "from", "browser"], "add_tokens": "if ( require . extensions ) { require . extensions [ '.k' ] = function ( module , filename ) { var fs = require ( 'fs' ) , input = fs . readFileSync ( filename , 'utf8' ) , content = ( new Kaffeine ( ) ) . compile ( input ) module . filename = \"#{filename} (compiled)\" module . _compile ( content , module . filename ) } }", "del_tokens": "", "commit_type": "remove"}
{"commit_tokens": ["Updated", "tests", "to", "include", "non", "-", "object", "edge", "cases"], "add_tokens": "// Undefined component tests ent . removeAll ( ) ent . set ( 'invalid' , { a : 'test' } ) assert ( ent . get ( 'invalid' ) . a === 'test' ) ent . set ( 'invalid' , { b : 'test2' } ) assert ( ent . get ( 'invalid' ) . a === undefined ) assert ( ent . get ( 'invalid' ) . b === 'test2' ) ent . set ( 'invalid2' , 5 ) assert ( ent . get ( 'invalid2' ) === 5 ) ent . set ( 'invalid2' , 'test' ) assert ( ent . get ( 'invalid2' ) === 'test' ) ent . set ( 'invalid2' , [ 'test' ] ) assert ( ent . get ( 'invalid2' ) [ 0 ] === 'test' )", "del_tokens": "ent . set ( 'invalid' , { a : 'test' } ) assert ( ent . get ( 'invalid' ) . a === 'test' ) ent . set ( 'invalid' , { b : 'test2' } ) assert ( ent . get ( 'invalid' ) . a === undefined ) assert ( ent . get ( 'invalid' ) . b === 'test2' )", "commit_type": "update"}
{"commit_tokens": ["Added", "tests", "for", "reselection", "events"], "add_tokens": "describe ( \"multi-select collection: toggleSelectAll\" , function ( ) { it ( \"should trigger a select:all event\" , function ( ) { it ( \"should not trigger a select:all event\" , function ( ) { it ( \"should trigger a select:all event\" , function ( ) { it ( \"should trigger a select:none event\" , function ( ) { it ( \"should not trigger a select:none event\" , function ( ) {", "del_tokens": "describe ( \"multi-select collection toggle\" , function ( ) { it ( \"should trigger 'all' selected event\" , function ( ) { it ( \"should not trigger 'all' selected event\" , function ( ) { it ( \"should trigger 'all' selected event\" , function ( ) { it ( \"should trigger 'none' selected event\" , function ( ) { it ( \"should not trigger 'none' selected event\" , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["added", "config", ".", "cliOption", "syntax"], "add_tokens": ". cliOption ( 'zip' , [ 'zip' , 'zipcode' ] , 'customerZipCode' ) . cliOption ( 'version' , [ 'v' , 'version' ] ) . cliOption ( 'exclusion' , 'x' , 'exclude this customer from lists' , false ) . cliOption ( 'outputFilename' , 'o' ) . cliOption ( 'default' , 'd' , 'Default value to use' , 'a-default' ) . cliOption ( 'json' , [ 'j' , 'json' ] ) . cliParse ( )", "del_tokens": ". useCommandLineArguments ( [ { path : 'zip' , options : [ 'zip' , 'zipcode' ] } , { path : 'version' , options : [ 'v' , 'version' ] } , { path : 'exclusion' , options : 'x' } , { path : 'outputFilename' , options : 'o' } ] )", "commit_type": "add"}
{"commit_tokens": ["Improve", ":", "Add", "files", ".", "*", "event", "on", "open", "close", "read", "write"], "add_tokens": "var events = imports . events ; var service = new FilesService ( vfs , events ) ;", "del_tokens": "var service = new FilesService ( vfs ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fixed", "typo", "on", "toString", "function", "when", "parsing", "the", "CFList"], "add_tokens": "if ( p . CFList . length === 16 ) { msg += \" FreqCh4 = \" + asHexString ( that . getCFListFreqChFour ( ) ) + \"\\n\" ; msg += \" FreqCh5 = \" + asHexString ( that . getCFListFreqChFive ( ) ) + \"\\n\" ; msg += \" FreqCh6 = \" + asHexString ( that . getCFListFreqChSix ( ) ) + \"\\n\" ; msg += \" FreqCh7 = \" + asHexString ( that . getCFListFreqChSeven ( ) ) + \"\\n\" ; msg += \" FreqCh8 = \" + asHexString ( that . getCFListFreqChEight ( ) ) + \"\\n\" ; }", "del_tokens": "if ( p . CFList . length === 15 ) { msg += \" FreqCh4 = \" + asHexString ( that . getCFListFreqChFour ) + \"\\n\" ; msg += \" FreqCh5 = \" + asHexString ( that . getCFListFreqChFive ) + \"\\n\" ; msg += \" FreqCh6 = \" + asHexString ( that . getCFListFreqChSix ) + \"\\n\" ; msg += \" FreqCh7 = \" + asHexString ( that . getCFListFreqChSeven ) + \"\\n\" ; msg += \" FreqCh8 = \" + asHexString ( that . getCFListFreqChEight ) + \"\\n\" ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "in", "the", "ability", "to", "get", "the", "test", "results", "for", "any", "specific", "build", "."], "add_tokens": "var TEST_REPORT = '%s/job/%s/%s/testReport' + API ; test_result : function ( jobname , number , callback ) { / * Get the test results for the build number of a job * / request ( { method : 'GET' , url : build_url ( TEST_REPORT , jobname , number ) } , function ( error , response , body ) { if ( error || response . statusCode !== 200 ) { callback ( error || true , response ) ; return ; } var data = JSON . parse ( body . toString ( ) ) ; callback ( null , data ) ; } ) ; } ,", "del_tokens": "var TEST_REPORT = '%s/job/%s/lastSuccessfulBuild/testReport' + API ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "spelling", "of", "META_DESC", ".", "configurable"], "add_tokens": "configurable : false ,", "del_tokens": "confgurable : false ,", "commit_type": "fix"}
{"commit_tokens": ["Updated", "with", "generatedMeasurementUnits", "and", "System"], "add_tokens": "const generatedMeasurementUnits = staticData . generatedMeasurementUnits ; const generatedMeasurementSystem = staticData . generatedMeasurementSystem ; measurementUnits , generatedMeasurementUnits , generatedMeasurementSystem", "del_tokens": "measurementUnits", "commit_type": "update"}
{"commit_tokens": ["Changing", "PlainMarkdownEditor", "component", "interface", "."], "add_tokens": "import PlainMarkdownEditor from '../PlainMarkdownEditor' ; value : PropTypes . string , autocompletes : PropTypes . array value : '' , autocompletes : [ ] constructor ( props ) { super ( props ) ; this . state = { value : this . props . value } ; } onChange = ( value ) => { this . setState ( { } ) ; this . props . onChange ( value ) ; } ; render ( ) { < PlainMarkdownEditor onChange = { this . onChange } value = { this . state . value } autocompletes = { this . props . autocompletes } / >", "del_tokens": "value : PropTypes . string value : '' render ( ) { const { onChange , } = this . props ; { value }", "commit_type": "change"}
{"commit_tokens": ["Add", "an", "implicit", "group", "parser", "use", "with", "sizing"], "add_tokens": "// Parses an implicit group, which is a group that starts where you want it, and // ends right before a higher explicit group ends, or at EOL. It is used for // functions that appear to affect the current style, like \\Large or \\textrm, // where instead of keeping a style we just pretend that there is an implicit // grouping after it until the end of the group. Parser . prototype . parseImplicitGroup = function ( pos , mode ) { // Since parseExpression already ends where we want it to, we just need to // call that and it does what we want. var expression = this . parseExpression ( pos , mode ) ; return new ParseResult ( new ParseNode ( \"ordgroup\" , expression . result , mode ) , expression . position ) ; } ; var group = this . parseImplicitGroup ( nucleus . position , mode ) ; return new ParseResult ( new ParseNode ( \"sizing\" , { size : \"size\" + ( utils . indexOf ( sizeFuncs , nucleus . type ) + 1 ) , value : group . result } , mode ) , group . position ) ;", "del_tokens": "var group = this . parseGroup ( nucleus . position , mode ) ; if ( group ) { return new ParseResult ( new ParseNode ( \"sizing\" , { size : \"size\" + ( utils . indexOf ( sizeFuncs , nucleus . type ) + 1 ) , value : group . result } , mode ) , group . position ) ; } else { throw new ParseError ( \"Expected group after '\" + nucleus . text + \"'\" , this . lexer , nucleus . position ) ; }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "incorrect", "handling", "of", "queryParam", "in", "urlQueryEncoder"], "add_tokens": "const encoded = encode ( { foo : 137 , bar : 'str' } ) ; expect ( encoded ) . toEqual ( { fooInUrl : '137' , bar : 'str' } ) ;", "del_tokens": "const encoded = encode ( { fooInUrl : 137 , bar : 'str' } ) ; expect ( encoded ) . toEqual ( { foo : '137' , bar : 'str' } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "extracting", "this", ".", "gettext", "calls"], "add_tokens": "( node . callee . name === self . options . markerName || ( node . callee . property && node . callee . property . name === self . options . markerName ) ) &&", "del_tokens": "node . callee . name === self . options . markerName &&", "commit_type": "add"}
{"commit_tokens": ["add", "new", "ruler", ".", "offset", "(", "point", "dx", "dy", ")", "method"], "add_tokens": "return this . offset ( p , Math . cos ( a ) * dist , Math . sin ( a ) * dist ) ; } , / ** * Returns a new point given easting and northing offsets ( in ruler units ) from the starting point . * * @ param { Array < number > } p point [ longitude , latitude ] * @ param { number } dx easting * @ param { number } dy northing * @ returns { Array < number > } point [ longitude , latitude ] * @ example * var point = ruler . offset ( [ 30.5 , 50.5 ] , 10 , 10 ) ; * //=point * / offset : function ( p , dx , dy ) { p [ 0 ] + dx / this . kx , p [ 1 ] + dy / this . ky", "del_tokens": "p [ 0 ] + Math . cos ( a ) * dist / this . kx , p [ 1 ] + Math . sin ( a ) * dist / this . ky", "commit_type": "add"}
{"commit_tokens": ["Fix", "https", ":", "//", "github", ".", "com", "/", "JustZisGuy", "/", "wildling", "/", "issues", "/", "1"], "add_tokens": "const variants = [ ] ; let workString = options . string ; let index = 0 ; do { if ( workString . substr ( index , 2 ) === \"\\\\,\" ) { index += 2 ; } else if ( workString [ index ] === \",\" ) { variants . push ( workString . substr ( 0 , index ) ) ; workString = workString . substr ( index + 1 ) ; index = 0 ; } else { index += 1 ; } } while ( index < workString . length ) ; variants . push ( workString ) ; options . variants = variants . map ( variant => variant . replace ( \"\\\\,\" , \",\" ) ) ;", "del_tokens": "options . variants = options . string . split ( \",\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "GPT", "detection", "when", "the", "protective", "MBR", "has", "more", "than", "one", "partition"], "add_tokens": "function adopt ( value ) { return value instanceof P ? value : new P ( function ( resolve ) { resolve ( value ) ; } ) ; } function step ( result ) { result . done ? resolve ( result . value ) : adopt ( result . value ) . then ( fulfilled , rejected ) ; } exports . getPartitions = exports . get = exports . PartitionNotFound = void 0 ; if ( partitions . length >= 1 && partitions [ 0 ] . type === GPT_PROTECTIVE_MBR ) {", "del_tokens": "function step ( result ) { result . done ? resolve ( result . value ) : new P ( function ( resolve ) { resolve ( result . value ) ; } ) . then ( fulfilled , rejected ) ; } if ( partitions . length === 1 && partitions [ 0 ] . type === GPT_PROTECTIVE_MBR ) {", "commit_type": "fix"}
{"commit_tokens": ["Moved", "new", "inventory", "screen", "to", "appear", "on", "the", "inventory", "listing", "screen", "."], "add_tokens": "this . resource ( 'inventory.new' , { path : \"/new\" } ) ;", "del_tokens": "this . route ( 'new' ) ;", "commit_type": "move"}
{"commit_tokens": ["fixed", "a", "small", "issue", "with", "circuit", "breaker", "-", "will", "be", "decoupled", "soon"], "add_tokens": "} ( typeof CircuitRoot === \"undefined\" ? this : CircuitRoot , function ( root , exports ) {", "del_tokens": "} ( this , function ( root , exports ) {", "commit_type": "fix"}
{"commit_tokens": ["moved", "es", "and", "ingest", "-", "csv", "modules", "here", "from", "sat", "-", "api"], "add_tokens": "api : require ( './libs/api.js' ) , es : require ( './libs/es.js' ) , ingestcsv : require ( './libs/ingest-csv.js' )", "del_tokens": "api : require ( './libs/api.js' )", "commit_type": "move"}
{"commit_tokens": ["Updated", "CI", "browser", "list", "for", "Karma", "runner"], "add_tokens": "\"MicrosoftEdge\" : { \"20.10240\" : [ \"Windows 10\" ] } , \"dev\" : [ \"Windows 7\" , \"OS X 10.10\" , \"Linux\" ] , \"beta\" : [ \"Windows 7\" , \"OS X 10.10\" , \"Linux\" ] , \"\" : [ \"Windows 7\" , \"OS X 10.10\" , \"Linux\" ] \"dev\" : [ \"Windows 7\" , \"OS X 10.10\" , \"Linux\" ] , \"beta\" : [ \"Windows 7\" , \"OS X 10.10\" , \"Linux\" ] , \"\" : [ \"Windows 7\" , \"OS X 10.10\" , \"Linux\" ] \"9.0\" : [ \"OS X 10.11\" ] , \"5.1\" : [ \"Windows 7\" ] \"5.1\" : [ \"Linux\" ] , \"9.2\" : [ \"OS X 10.10\" ] , \"8.4\" : [ \"OS X 10.10\" ] ,", "del_tokens": "\"dev\" : [ \"Windows 7\" , \"OS X 10.9\" , \"Linux\" ] , \"beta\" : [ \"Windows 7\" , \"OS X 10.9\" , \"Linux\" ] , \"\" : [ \"Windows 7\" , \"OS X 10.9\" , \"Linux\" ] \"dev\" : [ \"Windows 7\" , \"OS X 10.8\" , \"Linux\" ] , \"beta\" : [ \"Windows 7\" , \"OS X 10.8\" , \"Linux\" ] , \"\" : [ \"Windows 7\" , \"OS X 10.8\" , \"Linux\" ] \"5.1\" : [ \"OS X 10.6\" , \"Windows 7\" ] \"8.1\" : [ \"OS X 10.10\" ] ,", "commit_type": "update"}
{"commit_tokens": ["Allow", "do", "blocks", "confined", "to", "a", "single", "line", "."], "add_tokens": "var blockLevel = parser . currentColumnNumber ; var doLevel = blockLevel ; if ( block . argCount ( ) > 0 && block . parent !== null && block . parent . id ( ) === '<line>' ) { var lineLevel = block . parent . block . level ; if ( blockLevel < lineLevel ) { block . block . level = lineLevel ; blockSymbolBlock . handleNewLine ( parser , firstChar ) ; return ; } } parser . currentBlock . block . level = blockLevel ;", "del_tokens": "var doLevel = parser . currentColumnNumber ; parser . currentBlock . block . level = doLevel ;", "commit_type": "allow"}
{"commit_tokens": ["allow", "to", "trigger", "specific", "links", "in", "a", "slot"], "add_tokens": "* @ param { Number } link_id [ optional ] in case you want to trigger and specific output link in a slot LGraphNode . prototype . triggerSlot = function ( slot , param , link_id ) var id = links [ k ] ; if ( link_id != null && link_id != id ) //to skip links continue ; link_info . _last_time = LiteGraph . getTime ( ) ; var tmp = ctx . globalAlpha ; ctx . globalAlpha = tmp * f ; this . renderLink ( ctx , start_node_slotpos , end_node_slotpos , link , true , f , \"white\" , start_dir , end_dir ) ; ctx . globalAlpha = tmp ;", "del_tokens": "LGraphNode . prototype . triggerSlot = function ( slot , param ) link_info . _last_time = LiteGraph . getTime ( ) ; var color = \"rgba(255,255,255, \" + f . toFixed ( 2 ) + \")\" ; this . renderLink ( ctx , start_node_slotpos , end_node_slotpos , link , true , f , color , start_dir , end_dir ) ;", "commit_type": "allow"}
{"commit_tokens": ["removed", "questions", "one", "on", "one", "on", "prompt"], "add_tokens": "const { type , name , path } = await inquirer . prompt ( questions )", "del_tokens": "const { type , name , path } = await inquirer . prompt ( [ questions [ 0 ] , questions [ 1 ] , questions [ 2 ] ] )", "commit_type": "remove"}
{"commit_tokens": ["Implement", "REAL", "flatMap", "()", "&", "tests", "."], "add_tokens": "it ( 'map' , function ( ) { it ( 'map' , function ( ) {", "del_tokens": "it ( 'bind' , function ( ) { it ( 'bind' , function ( ) {", "commit_type": "implement"}
{"commit_tokens": ["Added", "option", "to", "prevent", "enabling", "CDN"], "add_tokens": "config = this . data , enableCdn = config . enableCdn !== false ; createContainer ( upload . container , enableCdn , function ( err , container ) { else if ( container && ! container . cdnEnabled && enableCdn ) { function createContainer ( containerName , enableCdn , callback ) { if ( enableCdn ) { container . enableCdn ( function ( err , container ) { if ( err ) { return callback ( err ) ; } callback ( err , container ) ; } ) ; } else { }", "del_tokens": "config = this . data ; createCdnEnabledContainer ( upload . container , function ( err , container ) { else if ( container && ! container . cdnEnabled ) { function createCdnEnabledContainer ( containerName , callback ) { container . enableCdn ( function ( err , container ) { if ( err ) { return callback ( err ) ; } } ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "Growl", "notifications", "on", "success", "an", "option"], "add_tokens": "logErrors : false , // Growl notification when tests pass. growlOnSuccess : true if ( options . growlOnSuccess ) { growl ( okMsg , { image : asset ( 'growl/ok.png' ) , title : okMsg , priority : 3 } ) ; }", "del_tokens": "logErrors : false growl ( okMsg , { image : asset ( 'growl/ok.png' ) , title : okMsg , priority : 3 } ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "unexpected", "closed", "socket", "connection"], "add_tokens": "res . status ( err . status || 500 ) . end ( ) ;", "del_tokens": "res . status ( 500 ) . end ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "dest", "option", "in", "files"], "add_tokens": "cwd : f . orig . cwd , dest : f . orig . dest tempDestPath = correctedDestination + ( tempPath . charAt ( 0 ) === \"/\" ? tempPath . slice ( 1 ) : tempPath ) , destPath = fileObject . dest ? correctedDestination + fileObject . dest : tempDestPath ;", "del_tokens": "cwd : f . orig . cwd destPath = correctedDestination + ( tempPath . charAt ( 0 ) === \"/\" ? tempPath . slice ( 1 ) : tempPath ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "unnecessary", "packages", "from", "the", "default", "dependency", "list"], "add_tokens": "'gconf2' , 'libgtk2.0-0' , 'libudev0 | libudev1' ,", "del_tokens": "'git' , 'gconf2' , 'libgtk2.0-0' , 'libudev0 | libudev1' , 'python' ,", "commit_type": "remove"}
{"commit_tokens": ["Updating", "events", "example", "and", "package", "version"], "add_tokens": "var projectId = process . env . ASANA_PROJECT_ID ; var client = asana . Client . create ( ) . useBasicAuth ( apiKey ) ;", "del_tokens": "var Promise = require ( 'bluebird' ) ; var args = process . argv . slice ( 2 ) ; var projectId = args [ 0 ] ; var client = asana . Client . basicAuth ( apiKey ) ; var sync_token ;", "commit_type": "update"}
{"commit_tokens": ["Remove", "lib", "folder", "and", "update", "permissions"], "add_tokens": "import { registerApp , connectApp } from './connection-handler.js' ; export default { registerApp , connectApp } ;", "del_tokens": "export { registerApp , connectApp } from './connection-handler.js' ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "error", "in", "IE8", "because", "Document", "type", "is", "undefined"], "add_tokens": "* @ preserve jquery . fullscreen 1.1 .3 if ( e . ownerDocument ) doc = e . ownerDocument ; doc = e ; e = doc . documentElement ;", "del_tokens": "* @ preserve jquery . fullscreen 1.1 .2 if ( e instanceof Document ) doc = e ; e = doc . documentElement ; doc = e . ownerDocument ;", "commit_type": "fix"}
{"commit_tokens": ["use", "current", "host", "/", "port"], "add_tokens": "var socket = io . connect ( window . location . origin ) ;", "del_tokens": "var socket = io . connect ( 'http://localhost:1947' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "stdout", "and", "change", "tab", "to", "space", "."], "add_tokens": "var file = null ; // Try to get output file. try { // read processed image data in file file = FS . readFile ( \"/output.png\" ) ; } catch ( e ) { // Cleaning up input png from MEMFS FS . unlink ( \"/input.png\" ) ; return new Error ( \"No output file: \" + stderr ) ; } // Cleanup files from FS . unlink ( \"/output.png\" ) ; FS . unlink ( \"/input.png\" ) ; return { \"data\" : file , \"stdout\" : stdout , \"stderr\" : stderr } ; module . exports = optipng ; optipng . call ( this ) ;", "del_tokens": "var file = null ; // Try to get output file. try { // read processed image data in file file = FS . readFile ( \"/output.png\" ) ; } catch ( e ) { // Cleaning up input png from MEMFS FS . unlink ( \"/input.png\" ) ; return new Error ( \"No output file: \" + stderr ) ; } // Cleanup files from FS . unlink ( \"/output.png\" ) ; FS . unlink ( \"/input.png\" ) ; return { \"data\" : file , \"stdout\" : stdout , \"stderr\" : stderr } ; module . exports = optipng ; optipng . call ( this ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixing", "jslint", "errors", "in", "test", ".", "js"], "add_tokens": "} ) ; } ) ;", "del_tokens": "} ) } )", "commit_type": "fix"}
{"commit_tokens": ["Add", "date", "format", "in", "generator", "and", "remove", "email", "url", "number", "date", "angularjs", "validate"], "add_tokens": "//console.log(varsGenerate);", "del_tokens": "console . log ( varsGenerate ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "validation", "for", "Tracery", "JSON", "plus", "auto", "-", "detection", "and", "parsing", "of", "Wiki", "Messenger", "JSON"], "add_tokens": "+ \" -e '\" + lhs + \"'\" )", "del_tokens": "+ \" '\" + lhs + \"'\" )", "commit_type": "add"}
{"commit_tokens": ["adds", "code", "to", "create", "_posts", "directory", "when", "its", "unavailable"], "add_tokens": "var stat = fs . statSync ( '_posts' ) ; if ( ! stat . isDirectory ( ) ) { return fs . mkdirAsync ( '_posts' ) . then ( function ( ) { return processBlogPosts ( ) ; } ) ; } else { return processBlogPosts ( ) ; }", "del_tokens": "return processBlogPosts ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "double", "quotes", "from", "--", "exclude", "param"], "add_tokens": "args . push ( item ) ;", "del_tokens": "args . push ( '\"' + item + '\"' ) ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", "issue", "with", "afterdefine", "Function", "not", "being", "run", "at", "the", "correct", "time", "for", "singletons"], "add_tokens": "class_config . singleton || process_after ( Constructor ) ; process_after ( Constructor ) ;", "del_tokens": "process_after ( Constructor ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "function", "from", "function", "expression", "to", "function", "statement", "."], "add_tokens": "function escapeRegexString ( unescapedString , escapeCharsRegex ) { / ** * Define a read - only property on the function object to contain default RegExp pattern . * This allows the user to utilize the pattern for his or her own purpose . * / Object . defineProperty ( escapeRegexString , 'defaultEscapeCharsRegex' , { configurable : false , enumerable : true , value : defaultEscapeCharsRegex , writable : false } ) ; / ** * Expose escape - regex - string * / module . exports = escapeRegexString ;", "del_tokens": "var escapeRegexString = function ( unescapedString , escapeCharsRegex ) {", "commit_type": "change"}
{"commit_tokens": ["fixing", "issue", "when", "user", "has", "a", "custom", "domain", "which", "causes", "a", "redirect", "from", "whatever", ".", "tumblr", ".", "com", "to", "whatever", ".", "com"], "add_tokens": "qs = require ( 'querystring' ) . stringify , url = require ( 'url' ) ; if ( res . statusCode === 301 ) { var redirect = url . parse ( res . headers . location ) , hostname = redirect . hostname , pathname = redirect . pathname ; Request ( type , hostname , pathname , query , fn ) ; } else if ( res . statusCode === 200 || res . statusCode === 201 ) {", "del_tokens": "qs = require ( 'querystring' ) . stringify ; if ( res . statusCode === 200 || res . statusCode === 201 ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "sorting", "by", "file", "name"], "add_tokens": "//it('Navigation Replacement', () => //{ // const filePath = path.resolve(__dirname, `../fixture/docs/index.html`); // const indexHTML = fs.readFileSync(filePath, 'utf-8'); // // assert(indexHTML.includes('<input type=\"checkbox\" name=\"group-0\" id=\"group-0\" checked><label for=\"group-0\" class=\"nav-header\">Local Source</label>')); // assert(indexHTML.includes('<input type=\"checkbox\" name=\"group-1\" id=\"group-1\"><label for=\"group-1\" class=\"nav-header\">JSPM Managed Source</label>')); // assert(indexHTML.includes('<input type=\"checkbox\" name=\"folder-1\" id=\"folder-1\" checked><label for=\"folder-1\" class=\"nav-dir-path\" data-ice=\"dirPath\" data-scm-link=\"https://github.com/typhonjs-backbone-parse/backbone-parse-es6/tree/master/src\" data-scm-type=\"github\">src</label>')); //});", "del_tokens": "it ( 'Navigation Replacement' , ( ) => { const filePath = path . resolve ( __dirname , ` ` ) ; const indexHTML = fs . readFileSync ( filePath , 'utf-8' ) ; assert ( indexHTML . includes ( '<input type=\"checkbox\" name=\"group-0\" id=\"group-0\" checked><label for=\"group-0\" class=\"nav-header\">Local Source</label>' ) ) ; assert ( indexHTML . includes ( '<input type=\"checkbox\" name=\"group-1\" id=\"group-1\"><label for=\"group-1\" class=\"nav-header\">JSPM Managed Source</label>' ) ) ; assert ( indexHTML . includes ( '<input type=\"checkbox\" name=\"folder-1\" id=\"folder-1\" checked><label for=\"folder-1\" class=\"nav-dir-path\" data-ice=\"dirPath\" data-scm-link=\"https://github.com/typhonjs-backbone-parse/backbone-parse-es6/tree/master/src\" data-scm-type=\"github\">src</label>' ) ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "bug", "for", "non", "-", "default", "responses", "that", "do", "not", "have", "schema", "but", "do", "have", "default"], "add_tokens": "} else if ( ! enforcers . hasOwnProperty ( code ) && enforcers [ 'default' ] ) {", "del_tokens": "} else if ( enforcers [ 'default' ] ) {", "commit_type": "fix"}
{"commit_tokens": ["fixed", "cache", "generation", "when", "epoc", "s", "are", "not", "created", "squencally"], "add_tokens": "exports . getSeed = function ( seed , begin , end ) {", "del_tokens": "exports . getSeed = function ( end , begin , seed ) { if ( ! begin ) seed = ethUtil . zeros ( 32 )", "commit_type": "fix"}
{"commit_tokens": ["fixed", "bug", "of", "nested", "array", ":", "add", "button", "doesn", "t", "work", "for", "outer", "array"], "add_tokens": "items : items . concat ( [ getDefaultFormState ( schema . items , undefined , definitions ) ] )", "del_tokens": "items : items . concat ( getDefaultFormState ( schema . items , undefined , definitions ) )", "commit_type": "fix"}
{"commit_tokens": ["add", "signed", "type", "to", "parser", "and", "use", "for", "locator"], "add_tokens": "type : \"signed\" , type : \"signed\" ,", "del_tokens": "type : \"number\" , type : \"number\" ,", "commit_type": "add"}
{"commit_tokens": ["Add", "this", "context", "for", "encoding", "expressions", "."], "add_tokens": "export default function context ( df , transforms , encode ) { return new Context ( df , transforms , encode ) ; function Context ( df , transforms , encode ) { this . encode = encode ;", "del_tokens": "export default function context ( df , transforms ) { return new Context ( df , transforms ) ; function Context ( df , transforms ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "bug", "where", "server", "was", "watching", "twice"], "add_tokens": "// log log ( 'Starting Sketchpad Reload...' ) console . log ( '\\nSettings:\\n' ) logBullet ( 'host' , settings . host ) logBullet ( 'root' , root ) logBullet ( 'mode' , settings . usePolling ? 'polling' : 'watching' ) console . log ( '\\nFolders:\\n' ) paths . forEach ( p => logBullet ( p . replace ( root , '' ) ) ) console . log ( ) // server const server = livereload . createServer ( { start : true } ) // watch configured paths", "del_tokens": "// watch // log log ( 'Starting Sketchpad Reload...' ) console . log ( '\\nSettings:\\n' ) logBullet ( 'host' , settings . host ) logBullet ( 'root' , root ) logBullet ( 'mode' , settings . usePolling ? 'polling' : 'watching' ) console . log ( '\\nFolders:\\n' ) paths . forEach ( p => logBullet ( p . replace ( root , '' ) ) ) console . log ( ) // start const server = livereload . createServer ( { start : true } ) server . watch ( '' )", "commit_type": "fix"}
{"commit_tokens": ["update", "gulp", "file", "and", "read", "me"], "add_tokens": "} ) ;", "del_tokens": "var tsc = require ( 'gulp-tsc' ) ; var paths = { src : 'src/**/*.ts' , dest : 'lib/' } ; var tscopts = { out : 'index.js' , module : 'commonjs' , declaration : true , sourcemap : true } ; gulp . task ( 'compile' , function ( ) { return gulp . src ( paths . src ) . pipe ( tsc ( tscopts ) ) . pipe ( gulp . dest ( paths . dest ) ) ; } ) ; } ) ; gulp . task ( 'default' , [ 'compile' ] ) ;", "commit_type": "update"}
{"commit_tokens": ["Fixed", "bug", "where", "tests", "were", "trying", "to", "read", "sensor", "data", "before", "the", "adapter", "was", "ready", "fixed", "bug", "involving", "the", "request", "counter", "not", "being", "formatted", "correctly", "added", "motor", "support", "to", "the", "ev3", "adapter"], "add_tokens": "var requestId = this . _getRequestCounter ( ) ; //TODO: have some sort of timeout system in place to constantly read sensor", "del_tokens": "var requestId = this . requestCounter ++ ; //TODO: have some sort of timeout system in place", "commit_type": "fix"}
{"commit_tokens": ["Allow", "views", "to", "have", "child", "views"], "add_tokens": "this . childViews = [ ] ; this . renderChildViews ( ) ; this . startChildViews ( ) ; this . stopChildViews ( ) ; } , addChildView : function ( view , options ) { if ( typeof view === 'function' ) { view = new view ( options ) ; } this . childViews . push ( view ) ; } , removeChildView : function ( view ) { var index = _ . indexOf ( this . childViews , view ) ; if ( index >= 0 ) { this . childViews . splice ( index , 1 ) ; } } , renderChildViews : function ( ) { _ . invoke ( this . childViews , 'render' ) ; } , startChildViews : function ( ) { _ . invoke ( this . childViews , 'start' ) ; } , stopChildViews : function ( ) { _ . invoke ( this . childViews , 'stop' ) ;", "del_tokens": "// no-op // no-op", "commit_type": "allow"}
{"commit_tokens": ["Adding", "muted", "non", "normal", "test", "results", "to", "the", "list", "reporter", "output"], "add_tokens": "+ Colors . wrap ( Colors . white , ' %s: ' ) + '%s' } else if ( test . type !== Test . TYPE . ROOT ) { format = Colors . wrap ( Colors . intenseBlack , ' ' + BaseReporter . SYMBOLS . OK + ' %s: %s' ) writer . write ( format , test . fullTitle ( '/' ) , ms ( test . duration ) )", "del_tokens": "+ Colors . wrap ( Colors . intenseBlack , ' %s: ' ) + '%s'", "commit_type": "add"}
{"commit_tokens": ["Add", "cancel", "method", "to", "README", "&", "add", "test", "cases"], "add_tokens": "if ( evt . key === 'Escape' ) { draggable . on ( 'drag:start' , ( ) => {", "del_tokens": "if ( evt . key == \"Escape\" ) { draggable . on ( \"drag:start\" , ( evt ) => { document . addEventListener ( 'keyup' , triggerMouseUpOnESC ) ; } ) ; draggable . on ( \"drag:start\" , ( evt ) => {", "commit_type": "add"}
{"commit_tokens": ["Made", "monitoring", "code", "use", "yaml", "config"], "add_tokens": "if ( options . conf . monitoring && options . conf . monitoring . statdsHost ) { this . timer = new util . Timer ( options . conf . monitoring . statdsHost ) ; } if ( this . timer ) { var statName = match . sortKey + \".\" + req . method ; this . timer . start ( statName ) ; } if ( self . timer ) { if ( item . status >= 500 ) { self . timer . count ( statName ) ; } self . timer . stop ( statName ) ; if ( self . timer ) { self . timer . stop ( statName ) ; }", "del_tokens": "this . timer = new util . Timer ( \"127.0.0.1:8989\" ) ; var statName = match . sortKey + \".\" + req . method ; this . timer . start ( statName ) ; if ( item . status >= 500 ) { self . timer . count ( statName ) ; self . timer . stop ( statName ) ; self . timer . stop ( statName ) ;", "commit_type": "make"}
{"commit_tokens": ["add", "for", "update", "support", "in", "mysql"], "add_tokens": "as_struct_val : asStructVal , columns , distinct , from , for_sys_time_as_of : forSystem = { } , for_update : forUpdate , groupby , having , limit , options , orderby , parentheses_symbol : parentheses , top , window : windowInfo , with : withInfo , where , clauses . push ( toUpper ( forUpdate ) )", "del_tokens": "as_struct_val : asStructVal , columns , distinct , from , for_sys_time_as_of : forSystem = { } , groupby , having , limit , options , orderby , parentheses_symbol : parentheses , top , window : windowInfo , with : withInfo , where ,", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "default", "options", "within", "the", "influxdb", "scope", "so", "you", "can", "have", "multiple", "influx", "clients", "in", "the", "same", "process", "."], "add_tokens": "var defaultOptions = { hosts : [ ] , disabled_hosts : [ ] , username : 'root' , password : 'root' , port : 8086 , depreciatedLogging : ( process . env . NODE_ENV === undefined || 'development' ) ? console . log : false , failoverTimeout : 60000 , requestTimeout : null , maxRetries : 2 } ; module . exports . InfluxDB = InfluxDB ;", "del_tokens": "var defaultOptions = { hosts : [ ] , disabled_hosts : [ ] , username : 'root' , password : 'root' , port : 8086 , depreciatedLogging : ( process . env . NODE_ENV === undefined || 'development' ) ? console . log : false , failoverTimeout : 60000 , requestTimeout : null , maxRetries : 2 } ; module . exports . InfluxDB = InfluxDB ;", "commit_type": "make"}
{"commit_tokens": ["Add", "example", "of", "custom", "ok"], "add_tokens": "const json = await res . json ( ) ; return new Response ( JSON . stringify ( { ... json , foo : 'bar' } ) , { // Example of custom `res.ok` status : json . error ? 500 : 200 , headers : { 'Content-Type' : 'application/json' } ) ;", "del_tokens": "const customJson = { ... ( await res . json ( ) ) , foo : 'bar' } ; return new Response ( JSON . stringify ( customJson ) , { status : 200 , headers : { 'Content-Type' : 'application/json' } ) ;", "commit_type": "add"}
{"commit_tokens": ["ADD", ":", "create", "multiple", "objects", "at", "once"], "add_tokens": "var result = null ; if ( Array . isArray ( req . body ) ) { var items = Array . prototype . slice . call ( arguments , 1 ) ; if ( exclude ) { result = [ ] ; for ( var i = 0 ; i < items . length ; ++ i ) { result . push ( filterItem ( items [ i ] , model , exclude ) ) ; } } else { result = items ; } } else { result = exclude ? filterItem ( item , model , exclude ) : item ; } res . send ( usingExpress ? JSON . stringify ( result ) : result ) ;", "del_tokens": "if ( exclude ) { item = filterItem ( item , model , exclude ) ; } res . send ( usingExpress ? JSON . stringify ( item ) : item ) ; //TODO: PUT (update) doesn't make a lot of sense here unless it can be used // to update multiple documents at one time", "commit_type": "add"}
{"commit_tokens": ["Added", "fix", "so", "migration", "records", "are", "being", "added", "in", "the", "correct", "format"], "add_tokens": "this . driver . addMigrationRecord ( migration . name , onComplete ) ;", "del_tokens": "this . driver . runSql ( 'INSERT INTO migrations (name, run_on) VALUES (?, ?)' , [ migration . name , new Date ( ) ] , onComplete ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "actual", "value", "to", "stringPattern", "and", "stringContains", "messages"], "add_tokens": "return this . makeError ( \"stringPattern\" , pattern , value ) ; return this . makeError ( \"stringContains\" , schema . contains , value ) ;", "del_tokens": "return this . makeError ( \"stringPattern\" , pattern ) ; return this . makeError ( \"stringContains\" , schema . contains ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "itemSize", "=", "undefined", "support", "to", "ListLayout"], "add_tokens": "var itemSize ; // Determine item-size or use true=size if ( ( options . itemSize === true ) || ! options . hasOwnProperty ( 'itemSize' ) ) { itemSize = true ; } else { itemSize = ( options . itemSize === undefined ) ? size [ direction ] : options . itemSize ; } nodeSize = ( itemSize === true ) ? context . resolveSize ( node , size ) [ direction ] : itemSize ;", "del_tokens": "nodeSize = options . itemSize || context . resolveSize ( node , size ) [ direction ] ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "old", "-", "style", "[", "?", "]", "accessor", "name", "."], "add_tokens": "var newZoom = Math . max ( map . getZoom ( ) - 4 , 0 ) ;", "del_tokens": "var newZoom = Math . max ( map . get_zoom ( ) - 4 , 0 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "additional", "error", "logging", "stuff", "to", "help", "the", "user", "debug", "when", "using", "window", ".", "DEV_MODE", "=", "strict", "."], "add_tokens": "var squelch = false ; / ** * Used to squelch the log / throw functions . This allows existing functions to be re - used * when creating explicit functions to override expected behaviors . * @ param { boolean } [ bool ] * @ returns { boolean } * / squelch : function ( bool ) { if ( typeof bool === 'boolean' ) { squelch = bool ; } return squelch ; } , } ) ;", "del_tokens": "} ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "partial", "editing", "of", "documents"], "add_tokens": "function clone ( obj ) { return JSON . parse ( JSON . stringify ( obj ) ) ; } self [ key ] = clone ( data [ key ] ) ; self [ builder . datakey ] [ key ] = clone ( data [ key ] ) ; self [ key ] = clone ( self [ datakey ] [ key ] ) ; data [ key ] = clone ( self [ '$' + key ] ) ; data [ datakey ] [ key ] = clone ( self [ key ] ) ;", "del_tokens": "self [ key ] = data [ key ] ; self [ builder . datakey ] [ key ] = data [ key ] ; self [ key ] = self [ datakey ] [ key ] ; data [ key ] = self [ '$' + key ] ; data [ datakey ] [ key ] = self [ key ] ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "sameSite", ":", "true", "to", "work", "with", "draft", "-", "7", "clients"], "add_tokens": "str += '; SameSite=Strict' ;", "del_tokens": "str += '; SameSite' ;", "commit_type": "fix"}
{"commit_tokens": ["Implementing", "N", "-", "table", "join", "where", "N", ">", "2", "."], "add_tokens": "'Join step must have exactly 2 children.' ) ;", "del_tokens": "// TODO(dpapad): Figure out how to deal with cases where there are more than // 2 relations. 'Only joins of 2 relations are currently supported.' ) ;", "commit_type": "implement"}
{"commit_tokens": ["Adding", "pos", "var", "in", "outputTextBlock", "."], "add_tokens": "* @ param { String } pos The position to start adding suffixes to ( useful for generating links or pagination ) var outputTextBlock = function ( block , pos , ctx , callback ) { formats [ block . format ] ( block , pos , ctx , callback ) ; section : function ( input , pos , ctx , callback ) { var tmp = input . blocks . map ( function ( block , index , array ) { return { index : index , block : block } ; } ) ; async . reduce ( tmp , '' , outputTextBlock ( item . block , pos + \"_\" + item . index , ctx , function ( err , val ) {", "del_tokens": "var outputTextBlock = function ( block , ctx , callback ) { formats [ block . format ] ( block , ctx , callback ) ; section : function ( input , ctx , callback ) { async . reduce ( input . blocks , '' , outputTextBlock ( item , ctx , function ( err , val ) {", "commit_type": "add"}
{"commit_tokens": ["implement", "model", "property", "option", "persistent"], "add_tokens": "var scheme = self . _validation [ key ] if ( scheme . persistent === false ) return ! scheme . serverOnly", "del_tokens": "! self . _validation [ key ] . serverOnly var scheme = self . _validation [ key ]", "commit_type": "implement"}
{"commit_tokens": ["updating", "tests", "to", "handle", "functions", "that", "are", "not", "called", "automatically"], "add_tokens": "equal ( compute ( ) ( ) , 'Justin' ) ; QUnit . equal ( scope . peek ( \"scope.vars.age\" ) ( ) , \"30\" , \"scope.vars.age === 30\" ) ;", "del_tokens": "equal ( compute ( ) , 'Justin' ) ; QUnit . equal ( scope . peek ( \"scope.vars.age\" ) , \"30\" , \"scope.vars.age === 30\" ) ;", "commit_type": "update"}
{"commit_tokens": ["fix", "no", "more", "forced", "layouts"], "add_tokens": "this . screen . render ( ) ; Dashboard . prototype . _showLayout = function ( id ) { if ( this . currentLayout === id ) {", "del_tokens": "this . _showLayout ( this . currentLayout , true ) ; Dashboard . prototype . _showLayout = function ( id , forced ) { if ( this . currentLayout === id && ! forced ) {", "commit_type": "fix"}
{"commit_tokens": ["use", "hyperdiscovery", "instead", "of", "hyperdrive", "-", "archive", "-", "swarm"], "add_tokens": "var createSwarm = require ( 'hyperdiscovery' )", "del_tokens": "var createSwarm = require ( 'hyperdrive-archive-swarm' )", "commit_type": "use"}
{"commit_tokens": ["making", "the", "package", "use", "the", "same", "db", "connection", "that", "the", "modules", "use", "and", "require", "package", "for", "settings", "on", "moduleLoad", "event", "(", "refactor", "needed", ")"], "add_tokens": "var database = container . get ( 'database' ) ; // Load the package module for mongoose require ( '../modules/package' ) ( database ) ; if ( path . indexOf ( '.' + ext ) == - 1 ) return ; return string . charAt ( 0 ) . toUpperCase ( ) + string . slice ( 1 ) ;", "del_tokens": "// Load the package module for mongoose require ( '../modules/package' ) ; if ( path . indexOf ( '.' + ext ) == - 1 ) return ; return string . charAt ( 0 ) . toUpperCase ( ) + string . slice ( 1 ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "async", "tests", "and", "failing", "tests"], "add_tokens": "it . skip ( \"sync fail\" , function ( ) { assert ( false , \"ok\" ) } ) it . skip ( \"leaks globals\" , function ( ) { bad_global = \"OOPS\" } ) it ( \"sync pass\" , function ( ) { it ( \"async pass\" , function ( done ) { process . nextTick ( function ( ) { assert ( true , \"ok\" ) done ( ) } ) console . log ( \"passing to next tick\" ) } )", "del_tokens": "it ( \"should pass\" , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Changed", ";", "make", "sure", "to", "clean", "up", "client", "prior", "to", "emission", "of", "disconnection", "events", "."], "add_tokens": "this . log . debug ( 'destroying dispatcher for' , id ) ; this . clients [ id ] . destroy ( ) ; this . clients [ id ] = null ;", "del_tokens": "this . clients [ id ] . destroy ( ) ; this . clients [ id ] = null ; this . log . debug ( 'destroying dispatcher for' , id ) ;", "commit_type": "change"}
{"commit_tokens": ["Adding", "tests", "for", "substring", "etc", "."], "add_tokens": "var merge = R . merge = _ ( function ( list1 , list2 ) { if ( isEmpty ( list1 ) ) { return clone ( list2 ) ; } else { return list1 . concat ( list2 ) ; } } ) ; aliasFor ( \"merge\" ) . is ( \"concat\" ) ; // A substring of a String: // // substring(2, 5, \"abcdefghijklm\"); //=> \"cde\" // The trailing substring of a String starting with the nth character: // // substringFrom(8, \"abcdefghijklm\"); //=> \"ijklm\" var substringFrom = R . substringFrom = flip ( substring ) ( undef ) ; // The leading substring of a String ending before the nth character: // // substringTo(8, \"abcdefghijklm\"); //=> \"abcdefgh\"", "del_tokens": "// var merge = R.merge = _(function(list1, list2) { // if (isEmpty(list1)) { // return clone(list2); // } else { // return list1.concat(list2); // } // }); // aliasFor(\"merge\").is(\"concat\"); var concat = R . concat = invoker ( \"concat\" , Array . prototype ) ; aliasFor ( \"concat\" ) . is ( \"merge\" ) ; // A substring of a String, `substring(2, 5, \"abcdefghijklm\"); //=> \"cde\"` // The trailing substring of a String starting with character `n`: `substringFrom(8, \"abcdefghijklm\"); //=> \"ijklm\"` var substringFrom = R . substringFrom = function ( n , str ) { return substring ( n , undef , str ) ; } ; // The leading substring of a String ending before character `n`: `substringTo(8, \"abcdefghijklm\"); //=> \"abcdefgh\"`", "commit_type": "add"}
{"commit_tokens": ["Add", "possibility", "to", "load", "events", "with", "a", "function"], "add_tokens": "events_source : 'events.json.php' ,", "del_tokens": "events_url : 'events.json.php' ,", "commit_type": "add"}
{"commit_tokens": ["fixing", "detection", "of", "existing", "properties", "due", "to", "current", "definition", "of", "model"], "add_tokens": "// implement getter/setter for every defined attribute Object . defineProperties ( DefinedModel . prototype , compileGettersAndSetters ( DefinedModel . prototype , attributes , computeds ) ) ; function compileGettersAndSetters ( context , attributes , computeds ) { if ( ! context || typeof context !== \"object\" || Array . isArray ( context ) ) { throw new TypeError ( \"invalid context for defining attributes and computeds\" ) ; } if ( ! Model . prototype . hasOwnProperty ( name ) && ! context . hasOwnProperty ( name ) ) { if ( ! Model . prototype . hasOwnProperty ( computedName ) && ! context . hasOwnProperty ( computedName ) && ! definition . hasOwnProperty ( computedName ) ) {", "del_tokens": "function compileGettersAndSetters ( attributes , computeds ) { if ( ! Model . prototype . hasOwnProperty ( name ) ) { if ( ! Model . prototype . hasOwnProperty ( computedName ) && ! definition . hasOwnProperty ( computedName ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "autplay", "config", "to", "plyr"], "add_tokens": "if ( url . match ( / (youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+) / ) || url . match ( / youtu\\.be\\/([a-zA-Z0-9\\-_]+) / ) || url . match ( / (youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+) / ) ) { if ( this . settings . autoplayVideos ) { playerConfig . autoplay = true ; playerConfig . vimeo . autoplay = true ; playerConfig . youtube . autoplay = true ; }", "del_tokens": "if ( url . match ( / (youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+) / ) || url . match ( / youtu\\.be\\/([a-zA-Z0-9\\-_]+) / ) || url . match ( / (youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+) / ) ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "--", "lenient", "option", "to", "JSDoc", "call"], "add_tokens": "var jsdoc_options = \"--explain --lenient --recurse\" ; cmd = getJSDocCommand ( ) + \" \" + jsdoc_args . join ( ' ' ) + \" \" + jsdoc_options ;", "del_tokens": "cmd = getJSDocCommand ( ) + \" \" + jsdoc_args . join ( ' ' ) + \" --explain --recurse\" ;", "commit_type": "add"}
{"commit_tokens": ["added", "branch", ".", "createPullRequest", "()"], "add_tokens": ", ref : 'refs/heads/' + name console . log ( error ) ; Branch . prototype . createPullRequest = function ( base , title , body , callback ) { this . gh . pullRequests . create ( { user : this . gh . user , repo : this . gh . repo , title : title , body : body , head : this . ref . split ( '/' ) . pop ( ) , base : base . ref . split ( '/' ) . pop ( ) } , callback ) ; } ;", "del_tokens": ", ref : 'heads/' + name", "commit_type": "add"}
{"commit_tokens": ["add", "X", "-", "Correlation", "-", "Id"], "add_tokens": "let requestID = req . headers [ \"x-request-id\" ] ; if ( req . headers [ \"x-correlation-id\" ] ) requestID = req . headers [ \"x-correlation-id\" ] ;", "del_tokens": "const requestID = req . headers [ \"x-request-id\" ] ;", "commit_type": "add"}
{"commit_tokens": ["remove", "debug", "logging", "+", "old", "comments"], "add_tokens": "if ( brushPixelStart < x ) { /* end-test-code-not-included-in-build */", "del_tokens": "if ( brushPixelStart < x ) { // add a buffer of 5 pixels for user error /* end-test-code-not-included-in-build */", "commit_type": "remove"}
{"commit_tokens": ["updated", "and", "standardised", "error", "messages"], "add_tokens": "callback ( this . error ( 'no EXIF data' , result ) , result ) ; return callback ( this . error ( 'can\\'t resolve datetime: no EXIF datetimes and fallback_ctime=false' , metadata ) ) ; return callback ( this . error ( 'path not found' , result ) ) ; return callback ( this . error ( 'path must be a file, not a directory' , result ) ) ; return callback ( this . error ( 'path is not a valid file' , result ) ) ;", "del_tokens": "callback ( this . error ( 'EXIF data not found' , result ) , result ) ; return callback ( this . error ( 'Cannot resolve datetime: no EXIF datetimes and fallback_ctime=false' , metadata ) ) ; return callback ( this . error ( 'path not found: ' + filepath , result ) ) ; return callback ( this . error ( 'path cannot be a directory: ' + filepath , result ) ) ; return callback ( this . error ( 'path is not a valid file:' + filepath , result ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Remove", "a", "table", "member", "when", "set", "to", "nil", "."], "add_tokens": "if ( this [ key ] === undefined && mt && mt . __newindex ) { if ( value === undefined ) { delete this [ key ] ; } else { this [ key ] = value ; }", "del_tokens": "if ( this [ key ] == undefined && mt && mt . __newindex ) { this [ key ] = value ;", "commit_type": "remove"}
{"commit_tokens": ["made", "iteration", "counter", "more", "predictable"], "add_tokens": "for ( var i = 1 ; i < iterations ; i ++ ) fn ( i ) ; for ( var i = 1 ; i <= this . _iterations ; i ++ ) fn ( i , done )", "del_tokens": "while ( iterations -- > 0 ) fn ( iterations ) ; var i = iterations while ( -- i >= 0 ) fn ( i , done )", "commit_type": "make"}
{"commit_tokens": ["use", "gulp", "-", "load", "-", "plugins", "instead", "of", "gulp", "-", "load", "-", "tasks"], "add_tokens": "plugins = require ( 'gulp-load-plugins' ) ( ) , plugins . concat ( 'concat.js' ) , plugins . concat ( 'concat.css' ) ,", "del_tokens": "tasks = require ( 'gulp-load-tasks' ) ( ) , tasks . concat ( 'concat.js' ) , tasks . concat ( 'concat.css' ) ,", "commit_type": "use"}
{"commit_tokens": ["Implement", "failureFlash", "option", "to", "authenticate", "()", "."], "add_tokens": "} if ( options . failureFlash && challenge ) { var option = options . failureFlash ; if ( typeof option == 'string' ) { option = { type : 'error' , message : option } ; } option . type = option . type || 'error' ; var type = option . type || challenge . type || 'error' ; var msg = option . message || challenge . message || challenge ; if ( typeof msg == 'string' ) { req . flash ( type , msg ) ; } } if ( options . failureRedirect ) {", "del_tokens": "} else if ( options . failureRedirect ) {", "commit_type": "implement"}
{"commit_tokens": ["Fixing", "to", "new", "naming", "conventions"], "add_tokens": "$ ( '.page-header h3' ) . text ( this . getTitle ( ) ) ; var calendar = $ ( '#calendar' ) . calendar ( options ) ; calendar . setOptions ( { first_day : $ ( this ) . val ( ) } ) ;", "del_tokens": "$ ( '.page-header h3' ) . text ( this . title ( ) ) ; var calendar = $ ( '#calendar' ) . calendar ( options ) ; calendar . set_options ( { first_day : $ ( this ) . val ( ) } ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "references", "to", "new", "repo", "location", "&", "minor", "cleanup"], "add_tokens": "* [ locales ] ( https : //github.com/nodeca/charlatan/tree/master/lib)", "del_tokens": "* [ locales ] ( https : //github.com/shkuropat/Charlatan/tree/master/lib)", "commit_type": "fix"}
{"commit_tokens": ["Added", "ability", "to", "specify", "item", "template", "url", ".", "Dramatically", "updated", "readme", ".", "md", "including", "a", "full", "API", "reference", "."], "add_tokens": "angular . module ( 'ea.treeview' ) . directive ( 'eaTreeView' , function ( eaTreeViewFactory ) { link : { pre : function ( scope ) { eaTreeViewFactory . setItemTemplateUrl ( scope . itemTemplateUrl ) ; } , post : function ( scope , element , attributes ) { scope . branchName = scope . branchName || 'items' ; scope . callback = scope . callback ( ) ; } items : '=' , itemTemplateUrl : '@'", "del_tokens": "angular . module ( 'ea.treeview' ) . directive ( 'eaTreeView' , function ( ) { link : function ( scope ) { scope . branchName = scope . branchName || 'items' ; scope . callback = scope . callback ( ) ; items : '='", "commit_type": "add"}
{"commit_tokens": ["Fix", "memory", "leak", "in", "initializer"], "add_tokens": "test ( 'Route#setupController sets the contextRoute on the controller' , function ( assert ) { RouteAliasInitializer . initialize ( application ) ; var route = Ember . Route . create ( { routeName : 'testy-mctesterton' } ) ; var controller = Ember . Controller . create ( { } ) ; assert . notOk ( controller . get ( 'contextRoute' ) , 'contextRoute is empty to start' ) ; route . setupController ( controller ) ; assert . equal ( controller . get ( 'contextRoute' ) , 'testy-mctesterton' , 'contextRoute is set after setup' ) ; } ) ;", "del_tokens": "setupController : Ember . Route . proto ( ) . setupController , Ember . Route . proto ( ) . setupController = originals . setupController ; setupController : Ember . Route . proto ( ) . setupController , assert . notEqual ( originals . setupController , replacements . setupController , 'Ensure that Route#setupController is replaced.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["make", "active", "respect", "same", "route", "but", "new", "props"], "add_tokens": "if ( ! active [ i ] . params ) { return true ; } return paramsAreActive ( active [ i ] . params , this . props ) ; function paramsAreActive ( params , props ) { for ( var key in params ) { if ( props [ key ] !== params [ key ] ) { return false ; } } return true ; }", "del_tokens": "return true ;", "commit_type": "make"}
{"commit_tokens": ["Added", "ability", "to", "configure", "log", "name"], "add_tokens": "this . name = options . name || 'Log' ; name : this . name , name : this . name , name : this . name , name : this . name , name : this . name , name : this . name , name : this . name , name : this . name ,", "del_tokens": "name : 'Log' , name : 'Log' , name : 'Log' , name : 'Log' , name : 'Log' , name : 'Log' , name : 'Log' , name : 'Log' ,", "commit_type": "add"}
{"commit_tokens": ["Adding", "a", "generator", "example", "will", "remove", "later"], "add_tokens": "require ( \"babel-core/polyfill\" ) ; // SERIVCE LEVEL CALLS generatorExample ( ) { var iter = { } iter [ Symbol . iterator ] = function * ( ) { \"use strict\" ; for ( var i = 1 ; i <= 100 ; i ++ ) { yield i } } return iter } module . exports = inst", "del_tokens": "module . exports = inst", "commit_type": "add"}
{"commit_tokens": ["Adds", "support", "for", "sass", "maps", "generation", "via", "a", "useSassMaps", "boolean", "property", "."], "add_tokens": "} , sass_maps_options : function ( test ) { test . expect ( 2 ) ; var files = { // scss maps sassMaps : [ grunt . file . read ( \"tmp/configMaps.scss\" ) , grunt . file . read ( \"test/expected/configMaps.scss\" ) ] , sassMaps1 : [ grunt . file . read ( \"tmp/configMaps1.scss\" ) , grunt . file . read ( \"test/expected/configMaps1.scss\" ) ] } ; test . equal ( files . sassMaps [ 0 ] , files . sassMaps [ 1 ] , \"SASS Maps (configMaps.scss) should be equal.\" ) ; test . equal ( files . sassMaps1 [ 0 ] , files . sassMaps1 [ 1 ] , \"SASS Maps (configMaps1.scss) should be equal.\" ) ; test . done ( ) ; } ,", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["fix", "app", "manifest", "remote", "fetch", "response", "control"], "add_tokens": "if ( err ) { } else if ( res . statusCode !== 200 ) {", "del_tokens": "if ( res . statusCode !== 200 ) { } else if ( err ) {", "commit_type": "fix"}
{"commit_tokens": ["Create", "tunnel", "s", "default", "."], "add_tokens": "result . tunneled = typeof data . tunneled !== 'undefined' ? data . tunneled : true ;", "del_tokens": "result . tunneled = data . tunneled !== null ? data . tunneled : true ;", "commit_type": "create"}
{"commit_tokens": ["Update", "host", "in", "config", ".", "json"], "add_tokens": "\"host\" : process . env . HOST || \"www.reportr.io\" ,", "del_tokens": "\"host\" : process . env . HOST || \"reportr.io\" ,", "commit_type": "update"}
{"commit_tokens": ["fix", "bug", "with", "domain", "extraction"], "add_tokens": "that . driver . config . set ( corbel . Iam . IAM_DOMAIN , corbel . jwt . decode ( response . data . accessToken ) . domainId ) ;", "del_tokens": "that . driver . config . set ( corbel . Iam . IAM_DOMAIN , corbel . jwt . decode ( response . data . accessToken ) . domain ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "LN10", "configurable", ".", "Reduce", "LN10", "default", "precision"], "add_tokens": "toExpPos : 21 , // 0 to MAX_E // The natural logarithm of 10. // 415 digits //LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286248633409525465082806756666287369098781689482907208325554680843799894826233198528393505308965377732628846163366222287698219886746543667474404243274365155048934314939391479619404400222105101714174800368808401264708068556774321622835522011480466371565912137345074785694768346361679210180644507064800027' // 115 digits LN10 : '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286' if ( sd > Ctor . LN10 . sd ( ) ) { return round ( new Ctor ( Ctor . LN10 ) , sd ) ; ps = [ 'precision' , 'rounding' , 'toExpNeg' , 'toExpPos' , 'LN10' ] ; if ( ( v = obj [ p = 'LN10' ] ) !== void 0 ) { if ( v == Math . LN10 ) this [ p ] = new this ( v ) ; else throw Error ( invalidArgument + p + ': ' + v ) ; } // Internal constant. module . exports = Decimal . default = Decimal . Decimal = Decimal ;", "del_tokens": "// The natural logarithm of 10 (415 digits). LN10 = '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286248633409525465082806756666287369098781689482907208325554680843799894826233198528393505308965377732628846163366222287698219886746543667474404243274365155048934314939391479619404400222105101714174800368808401264708068556774321622835522011480466371565912137345074785694768346361679210180644507064800027' , toExpPos : 21 // 0 to MAX_E LN10_PRECISION = LN10 . length - 1 , if ( sd > LN10_PRECISION ) { return round ( new Ctor ( LN10 ) , sd ) ; ps = [ 'precision' , 'rounding' , 'toExpNeg' , 'toExpPos' ] ; // Internal constants. LN10 = new Decimal ( LN10 ) ; module . exports = Decimal ;", "commit_type": "make"}
{"commit_tokens": ["Add", "fiber", "shim", "to", "spawned", "node", "processes"], "add_tokens": "var fs = require ( 'fs' ) , path = require ( 'path' ) ; // Shim child_process.spawn to shim any spawned Node instances var fibersRoot = path . dirname ( require . resolve ( './src/fibers' ) ) ; var cp = require ( 'child_process' ) ; cp . spawn = function ( spawn ) { return function ( command , args , options ) { if ( command === process . execPath ) { options = Object . create ( options || { } ) ; options . env = Object . create ( options . env || { } ) ; options . env . FIBER_SHIM = '1' ; if ( process . platform === 'linux2' ) { options . env . LD_PRELOAD = fibersRoot + '/coroutine.so' ; } else if ( process . platform === 'darwin' ) { options . env . DYLD_INSERT_LIBRARIES = fibersRoot + '/coroutine.dylib' ; options . env . DYLD_FORCE_FLAT_NAMESPACE = '1' ; options . env . DYLD_LIBRARY_PATH = fibersRoot ; } else { throw new Error ( 'Unknown platform!' ) ; } } return spawn ( command , args , options ) ; } ; } ( cp . spawn ) ;", "del_tokens": "var fs = require ( 'fs' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "isTypedArray", "in", "environments", "without", "Symbol", ".", "toStringTag"], "add_tokens": "return ( isUint8Array ( value ) || isUint8ClampedArray ( value ) || isUint16Array ( value ) || isUint32Array ( value ) || isInt8Array ( value ) || isInt16Array ( value ) || isInt32Array ( value ) || isFloat32Array ( value ) || isFloat64Array ( value ) || isBigInt64Array ( value ) || isBigUint64Array ( value ) ) ;", "del_tokens": "return ObjectToString ( value ) === '[object TypedArray]' ;", "commit_type": "fix"}
{"commit_tokens": ["moved", "loading", "-", "image", "to", "own", "element", "instead", "of", "background"], "add_tokens": "var isIE8 = false ; var loadingImgSrc ; // path to loading image // set loading-image if ( ! opt || opt && ! isset ( opt . loadingImgSrc ) ) { loadingImgSrc = 'img/jslghtbx-loading.gif' ; } else { loadingImgSrc = opt . loadingImgSrc ; } if ( ! opt || opt && opt . loadingImg || opt && ! isset ( opt . loadingImg ) ) { this . opt [ 'loadingImg' ] = true ; var el = document . createElement ( 'img' ) ; el . setAttribute ( 'src' , loadingImgSrc ) ; addClass ( el , 'jslghtbx-loading-img' ) ; this . box . appendChild ( el ) ; if ( this . opt . loadingImg && ! isIE8 ) {", "del_tokens": "var isIE8 = false ; // set loading-gif if ( ! opt || opt && opt . loadingGif || opt && ! isset ( opt . loadingGif ) ) { this . opt [ 'loadingGif' ] = true ; if ( this . opt . loadingGif && ! isIE8 ) {", "commit_type": "move"}
{"commit_tokens": ["Updated", ".", "listeners", "()", "method"], "add_tokens": "* @ version 2.0 .1 var _list = _listeners . call ( this , event , true ) ; var _list = _listeners . call ( this , event , true ) ; var _list = _listeners . call ( this , event , false ) ; return ! ! ( _list && _list . length ) ; var _list = _listeners . call ( this , event , false ) ; return ! ! ( _list && ~ _list . indexOf ( fn ) ) ; var _list = this . _callbacks ; function _listeners ( event , addMode ) { , _list = _callbacks [ _type ] || addMode && ( _callbacks [ _type ] = [ ] ) || [ ]", "del_tokens": "* @ version 2.0 .0 var _list = _listeners . call ( this , event ) ; var _list = _listeners . call ( this , event ) ; return ! ! _listeners . call ( this , event ) . length ; var _list = _listeners . call ( this , event ) ; return ! ! ~ _list . indexOf ( fn ) ; _list function _listeners ( event ) { , _list = _type == '*' ? _callbacks : _callbacks [ _type ] || ( _callbacks [ _type ] = [ ] )", "commit_type": "update"}
{"commit_tokens": ["Add", "originalId", "to", "v2", ".", "ErrorResponse", ".", "CodeErrors"], "add_tokens": "errorCode : Codes . Timeout , originalId : null errorCode : Codes . Cancelled , originalId : null errorCode : Codes . Busy , originalId : null errorCode : Codes . Declined , originalId : null errorCode : Codes . UnexpectedError , originalId : null errorCode : Codes . BadRequest , originalId : null errorCode : Codes . ProtocolError , originalId : null", "del_tokens": "errorCode : Codes . Timeout errorCode : Codes . Cancelled errorCode : Codes . Busy errorCode : Codes . Declined errorCode : Codes . UnexpectedError errorCode : Codes . BadRequest errorCode : Codes . ProtocolError", "commit_type": "add"}
{"commit_tokens": ["Added", "route", "config", "file", "existance", "check"], "add_tokens": "const fs = require ( 'fs' ) if ( fs . existsSync ( routesPath ) ) { let routeConfig = config . util . parseFile ( routesPath ) config . util . extendDeep ( config . routes , routeConfig ) }", "del_tokens": "const routeConfig = config . util . parseFile ( routesPath ) config . util . extendDeep ( config . routes , routeConfig ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "react", "-", "native", "base", "extends"], "add_tokens": "require . resolve ( './base/index' ) ,", "del_tokens": "require . resolve ( './rules/base' ) ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "skip", "-", "dependencies", "and", "skip", "-", "all", "-", "dependencies", "options", "to", "extract"], "add_tokens": "if ( options . skipAllDependencies ) { return ; } let excludedDependencies = options . skipDependencies || [ ] ; if ( module === addon || excludedDependencies . indexOf ( module ) > - 1 ) {", "del_tokens": "if ( module === addon ) {", "commit_type": "add"}
{"commit_tokens": ["Removed", "implicit", "switch", "to", "model", "-", "sharing", "mode"], "add_tokens": "var enableInitialSelection , enableSelectIfRemoved , autoSelectIndex ; Backbone . Select . One . applyTo ( hostObject , models , options ) ;", "del_tokens": "var enableInitialSelection , enableSelectIfRemoved , enableModelSharing , autoSelectIndex ; enableModelSharing = options . enableModelSharing || enableInitialSelection || enableSelectIfRemoved ; Backbone . Select . One . applyTo ( hostObject , models , _ . extend ( { } , options , { enableModelSharing : enableModelSharing } ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Make", "percy", "wait", "1s", "for", "codepen"], "add_tokens": "await page . waitFor ( 1000 ) ;", "del_tokens": "await page . waitFor ( 'body' ) ;", "commit_type": "make"}
{"commit_tokens": ["Make", "escape", "codes", "option", "a", "part", "of", "colors", "option"], "add_tokens": "colors : true , // (0|false)|(1|true)|2", "del_tokens": "colors : true ,", "commit_type": "make"}
{"commit_tokens": ["fixing", "problem", "when", "adding", "nodes", "to", "existing", "graph", "that", "was", "loaded", "from", "file"], "add_tokens": "node . id = ++ this . last_node_id ; else if ( this . last_node_id < node . id ) this . last_node_id = node . id ;", "del_tokens": "node . id = this . last_node_id ++ ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "test", "component", "for", "async", "/", "await", "support"], "add_tokens": "var Stories = require ( './Stories' ) < img width = \"500\" src = { require ( './large.png' ) } / > < Stories / >", "del_tokens": "< img src = { require ( './large.png' ) } / >", "commit_type": "add"}
{"commit_tokens": ["Improve", "support", "for", "default", "parse", "rules"], "add_tokens": "var failed = false , parseOptionsJSON = { } ; parseOptionsJSON = JSON . parse ( fs . readFileSync ( options . parseOptions ) ) ; failed = true ; else if ( options . parseOptions === undefined || failed ) { parseOptionsJSON = JSON . parse ( fs . readFileSync ( __dirname + \"/panino/defaultParseRules.json\" ) ) ; }", "del_tokens": "var parseOptionsJSON = JSON . parse ( fs . readFileSync ( options . parseOptions ) ) ; return parser ; else return parser ;", "commit_type": "improve"}
{"commit_tokens": ["Added", "script", "to", "set", "WK_WEB_VIEW_IS_USED", "preprocessor", "macro", "depending", "on", "the", "presence", "of", "the", "cordova", "-", "plugin", "-", "wkwebview", "-", "engine", "."], "add_tokens": "iosWKWebViewEngineSupport = require ( './lib/iosWKWebViewEngineSupport.js' ) , // apply iOS-specific stuff iosWKWebViewEngineSupport . setWKWebViewEngineMacro ( ctx ) ;", "del_tokens": "// if we are building for iOS - apply backwards capability hack", "commit_type": "add"}
{"commit_tokens": ["Changed", "some", "naming", "conventions", "probably", "need", "to", "diverge", "from", "main", "project", "after", "this", "change"], "add_tokens": "var queryOptions = { protected : [ \"page\" , \"perPage\" , \"sort\" , \"populate\" , \"select\" ] , current : { } } ; if ( queryOptions . current . page ) { query . skip ( queryOptions . current . page ) ; if ( queryOptions . current . perPage ) { query . limit ( queryOptions . current . perPage ) ;", "del_tokens": "var queryOptions = { protected : [ \"skip\" , \"limit\" , \"sort\" , \"populate\" , \"select\" ] , current : { } } ; if ( queryOptions . current . skip ) { query . skip ( queryOptions . current . skip ) ; if ( queryOptions . current . limit ) { query . limit ( queryOptions . current . limit ) ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "whitespace", "within", "core", "stick", "to", ".", "editorconfig"], "add_tokens": "if ( document . readyState === 'complete' ) { objectFit . init ( args ) ; } else { // Otherwise attach event listeners if ( window . addEventListener ) { window . addEventListener ( 'load' , function ( ) { objectFit . init ( args ) ; } , false ) ; } else { window . attachEvent ( 'onload' , function ( ) { objectFit . init ( args ) ; } ) ; } }", "del_tokens": "if ( document . readyState === 'complete' ) { objectFit . init ( args ) ; } else { // Otherwise attach event listeners if ( window . addEventListener ) { window . addEventListener ( 'load' , function ( ) { objectFit . init ( args ) ; } , false ) ; } else { window . attachEvent ( 'onload' , function ( ) { objectFit . init ( args ) ; } ) ; } }", "commit_type": "fix"}
{"commit_tokens": ["Use", "reference", "for", "parsing", "instead", "of", "concat"], "add_tokens": "this . _passDecode ( parserFactory ( paddingAt ) , values * @ param { int [ ] } values Values read pixelParser , values", "del_tokens": "lastPassValues , lastPassValues = this . _passDecode ( parserFactory ( paddingAt ) values = values . concat ( lastPassValues ) ; * @ return { int [ ] } List of values read pixelParser values = [ ] , return values ;", "commit_type": "use"}
{"commit_tokens": ["Use", "private", "scope", "instead", "of", "replacing", "global", "object"], "add_tokens": "var Url = window . URL || window . webkitURL ; var src = Url . createObjectURL ( resource . data ) ; Url . revokeObjectURL ( src ) ;", "del_tokens": "window . URL = window . URL || window . webkitURL ; var src = URL . createObjectURL ( resource . data ) ; URL . revokeObjectURL ( src ) ;", "commit_type": "use"}
{"commit_tokens": ["make", "source", "field", "always", "available", "provide", "block", "source", "as", "well", "as", "tag", "one"], "add_tokens": "var source_str = source . map ( function ( line ) { return line . value ; } ) . join ( '\\n' ) . replace ( / ^\\s+|\\s+$ / g , '' ) ; tag_node . line = Number ( tag . line ) ; tag_node . source = tag . value ; description : description . value , source : source_str", "del_tokens": "tag_node . line = Number ( tag . line ) ; if ( opts . raw_value ) { tag_node . value = tag . value ; } description : description . value", "commit_type": "make"}
{"commit_tokens": ["Fixed", ":", "Better", "format", "on", "code", "generated", "try", "statements"], "add_tokens": "buffer . concat ( \"try \" ) ; buffer . concat ( \"\\n\" ) ; buffer . concat ( \"\\n\" ) ;", "del_tokens": "buffer . concat ( \"try\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "fetching", "to", "current", "branches"], "add_tokens": "grunt . log . subhead ( 'Fetching ' + options . branch + ' history from ' + options . remote + '.' ) ; // `--update-head-ok` allows fetch on the current branch shelljs . exec ( 'git fetch --tags --verbose --update-head-ok ' + options . remote + ' ' + options . branch + ':' + options . branch ) ; // Fetch changes from remote branch if it exists // TODO: Instead of checking if the remote exists, it would be better to // - check if remote is ahead of local // - check if remote is a ff merge // and if so, gitFetch(). Otherwise throw helpful, descriptive errors // Possible references: // - http://stackoverflow.com/questions/3258243/git-check-if-pull-needed if ( shelljs . exec ( 'git ls-remote --exit-code ' + options . remote + ' ' + options . branch , { silent : true } ) . code === 0 ) { gitFetch ( ) ; }", "del_tokens": "grunt . log . subhead ( 'Fetching remote branch ' + options . branch + '.' ) ; shelljs . exec ( 'git fetch --tags --verbose ' + options . remote + ' ' + options . branch + ':' + options . branch ) ; // Fetch changes from remote branch if it exists if ( shelljs . exec ( 'git ls-remote --exit-code ' + options . remote + ' ' + options . branch , { silent : true } ) . code === 0 ) { gitFetch ( ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "array", "-", "filter", "optimization"], "add_tokens": "* arr . map ( f ) ; // call with 1 argument will get compiled * arr . map ( f , this ) ; // call with 2 arguments won't get compiled", "del_tokens": "* arr . map ( f ) ; // valid call with 1 argument * arr . map ( f , this ) ; // valid call with 2 arguments", "commit_type": "implement"}
{"commit_tokens": ["fixed", "merge", "adding", "sticky", "arguments"], "add_tokens": "var unFlattenStickyArguments = Array . prototype . map . call ( arguments , function ( adapter ) { return adapter . _stickyArguments ( ) ; } ) ; var stickyArguments = Array . prototype . concat . apply ( functions , unFlattenStickyArguments ) return _occamsrazor ( adapterFuncs , stickyArguments ) ; occamsrazor . _stickyArguments = function _stickyArguments ( ) { return stickyArguments ; } ;", "del_tokens": "return _occamsrazor ( adapterFuncs ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "detecting", "feature", "and", "font", "support"], "add_tokens": "Han . support = Hyu . support Han . detectFont = Hyu . detectFont $ . extend ( Han . fn , { initCond : function ( ) { Han . Hyu . initCond ( this . selector ) return this } } )", "del_tokens": "// Bind the Farr methods onto Han constructor Han . fn . initCond = function ( ) { Han . Hyu . initCond ( this . selector ) return this }", "commit_type": "add"}
{"commit_tokens": ["Fix", "pin", "mapping", "for", "modes"], "add_tokens": "'1' : null , '2' : null , '3' : 0 , '4' : null , '5' : 1 , '6' : null , '7' : 4 , '8' : 14 , '9' : null , '10' : 15 , '11' : 17 , '12' : 18 , '13' : 21 , '14' : null , '15' : 22 , '16' : 23 , '17' : null , '18' : 24 , '19' : 10 , '20' : null , '21' : 9 , '22' : 25 , '23' : 11 , '24' : 8 , '25' : null , '26' : 7", "del_tokens": "// @todo Map any other useful pins '0' : 17 , '1' : 18 , '2' : 21 , '3' : 22 , '4' : 23 , '5' : 24 , '6' : 25 , '7' : 4", "commit_type": "fix"}
{"commit_tokens": ["Fix", "a", "bug", ":", "package", ".", "json", "settings", "are", "not", "applied"], "add_tokens": "default : utils . createDefaultOptions ( process . cwd ( ) ) ,", "del_tokens": "var pkg = require ( './package.json' ) ; var objectAssign = require ( 'object-assign' ) ; var defaultOptions = objectAssign ( { } , { dirname : 'test' , extensions : 'js,es,es6,es7,coffee,ts' , force : false , omission : null , root : process . cwd ( ) , template : path . join ( process . cwd ( ) , 'mocha-automatic-coffeemaker-template.js' ) } , pkg [ 'mocha-automatic-coffeemaker' ] || { } ) ; default : defaultOptions ,", "commit_type": "fix"}
{"commit_tokens": ["Remove", "CJS", "build", ";", "use", "UMD", "build", "on", "Node"], "add_tokens": "const WaveFile = require ( './dist/wavefile.umd.js' ) ;", "del_tokens": "const WaveFile = require ( './dist/wavefile.cjs.js' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "react", "prop", "mutation", "in", "pushToAndClause"], "add_tokens": "export function pushToAndClause ( reactProp , component ) { const react = Object . assign ( { } , reactProp ) ;", "del_tokens": "export function pushToAndClause ( react , component ) {", "commit_type": "fix"}
{"commit_tokens": ["Make", "it", "so", "the", "current", "channel", "reset", "the", "count", "but", "does", "not", "update", "the", "last", "view", "at", "when", "markin", "the", "channel", "as", "read"], "add_tokens": "const { channels , myMembers } = state . entities . channels ; const channelMember = myMembers [ channelId ] ; last_viewed_at : channelMember . last_viewed_at ,", "del_tokens": "const { channels } = state . entities . channels ; last_viewed_at : new Date ( ) . getTime ( ) ,", "commit_type": "make"}
{"commit_tokens": ["implement", "and", "test", "persistent", "context", "+", "Array<types", ">"], "add_tokens": "* @ param { Array < ContextConstructor > } [ test . context ] Any context constructors for the test to be evaluated . * @ param { Array < ContextConstructor > } [ test . persistentContext ] Any context constructors for the test that are managed by the test suite . * @ prop { Array < ContextConstructor > } [ context ] Any context constructors for the test to be evaluated . * @ prop { Array < ContextConstructor > } [ persistentContext ] Any context constructors for the test that are managed by the test suite .", "del_tokens": "* @ param { ContextConstructor [ ] } [ test . context ] Any context constructors for the test to be evaluated . * @ prop { ContextConstructor [ ] } [ context ] Any context constructors for the test to be evaluated .", "commit_type": "implement"}
{"commit_tokens": ["Fix", "prop", "-", "type", "issues", ":"], "add_tokens": "APP : { } , 'ember-prop-types' : { spreadProperty : 'options' , throwErrors : true , validateOnUpdate : true }", "del_tokens": "APP : { }", "commit_type": "fix"}
{"commit_tokens": ["Use", "JSONStore", ".", "create", "()", "instead", "of", "JSONStore", ".", "insert", "()"], "add_tokens": "store . create ( 'user' , newUser . preferredUsername , newUser , function ( err , value ) {", "del_tokens": "store . insert ( 'user' , newUser . preferredUsername , newUser , function ( err , value ) {", "commit_type": "use"}
{"commit_tokens": ["adds", "tests", "to", "demonstrate", "usage", "with", "react", "-", "router", "adds", "example", "to", "readme"], "add_tokens": "var newFile = file ; newFile . contents = renderToString ( file . path , opts . props ? opts . props : { } ) ; } else newFile . contents = renderToStaticMarkup ( file . path , opts . props ? opts . props : { } ) ; } newFile . path = _gulpUtil2 . default . replaceExtension ( file . path , '.html' ) ; this . push ( newFile ) ; }", "del_tokens": "file . contents = renderToString ( file . path , opts . props ? opts . props : { } ) ; } else file . contents = renderToStaticMarkup ( file . path , opts . props ? opts . props : { } ) ; } file . path = _gulpUtil2 . default . replaceExtension ( file . path , '.html' ) ; this . push ( file ) ; }", "commit_type": "add"}
{"commit_tokens": ["upgraded", "to", "new", "deletion", "module"], "add_tokens": "// si.replicate(fs.createReadStream('test/stress-test-backup.gz'), function (err) { // if (err) console.log('oops') // console.log('index replicated') var batch = require ( './breakyBatch.json' ) si . close ( function ( err ) { require ( '../' ) ( { indexPath : indexPath } , function ( err , sia ) { sia . add ( batch , { } , function ( err ) { console . log ( 'batch added' ) if ( err ) { console . log ( 'error indexing ' + err ) } else { console . log ( 'batch indexed' ) } return // })", "del_tokens": "si . replicate ( fs . createReadStream ( 'test/stress-test-backup.gz' ) , function ( err ) { console . log ( 'index replicated' ) var batch = require ( './breakyBatch.json' ) si . close ( function ( err ) { require ( '../' ) ( { indexPath : indexPath } , function ( err , sia ) { if ( err ) console . log ( 'oops' ) sia . add ( batch , { } , function ( err ) { console . log ( 'batch added' ) if ( err ) { console . log ( 'error indexing ' + err ) } else { console . log ( 'batch indexed' ) } return } )", "commit_type": "upgrade"}
{"commit_tokens": ["Adding", "abillity", "to", "multiple", "stub", "calls", "."], "add_tokens": "obj . stub ( 'foo' ) . it . should_be . called . exactly ( 1 ) . times ; obj . stub ( 'foo' ) . it . should_be . called . any . number . of . times ;", "del_tokens": "var stub = obj . stub ( 'foo' ) . it . should_be . called . exactly ( 1 ) . times ; stub . should_be . called . any . number . of . times ;", "commit_type": "add"}
{"commit_tokens": ["Added", "test", "for", "pushing", "unpushable", "file", "and", "fixing", "errorlogging"], "add_tokens": "} , ( error , response , body ) => { process . exit ( 1 ) ; } ) ; console . log ( ` ` ) ;", "del_tokens": "} , ( error , response , body ) => { } ) ; console . log ( ` ` ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "(", "undocumented", ")", "dependency"], "add_tokens": "return class TabView { tab . id = tab . dataset . id = id ;", "del_tokens": "return class Home { tab . dataset . id = id ;", "commit_type": "remove"}
{"commit_tokens": ["change", "that", "the", "first", "click", "opens", "the", "tab"], "add_tokens": "var editTab = new Tab ( entity . editTab ( ) ) ; cmsMain . tabs . closeById ( EntityModel . createTab ( ) . id ) ; cmsMain . tabs . open . call ( cmsMain , editTab , e ) ;", "del_tokens": "var tab = new Tab ( entity . editTab ( ) ) ; cmsMain . tabs . open . call ( cmsMain , tab , e ) ; // make new edit tab active cmsMain . tabs . select . call ( cmsMain , tab , e ) ;", "commit_type": "change"}
{"commit_tokens": ["make", "_design", "/", "part", "of", "design", "document", "name"], "add_tokens": "url : ` ${ baseUrl } ${ encodeURIComponent ( dbName ) } ${ encodeURIComponent ( docId ) } ${ encodeURIComponent ( name ) } ` ,", "del_tokens": "url : ` ${ baseUrl } ${ encodeURIComponent ( dbName ) } ${ encodeURIComponent ( docId ) } ${ encodeURIComponent ( name ) } ` ,", "commit_type": "make"}
{"commit_tokens": ["Adding", "new", "page", "in", "Main", "articles"], "add_tokens": "var filePath = path . normalize ( raneto . config . content_dir + ( ! ! req . body . category ? req . body . category + '/' : '' ) + req . body . name + '.md' ) ;", "del_tokens": "var filePath = path . normalize ( raneto . config . content_dir + req . body . category + '/' + req . body . name + '.md' ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "strategy", "-", "use", "passport", "-", "openid"], "add_tokens": ", OpenIDStrategy = require ( 'passport-openid' ) . Strategy", "del_tokens": ", OpenIDStrategy = require ( 'passport-openid-node6support' ) . Strategy", "commit_type": "update"}
{"commit_tokens": ["removed", "statements", "and", "added", "csp", "in", "dialect", "loader"], "add_tokens": "require ( \"sugarlisp-csp\" ) ;", "del_tokens": "require ( \"sugarlisp-statements\" ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "bug", "deleting", "a", "one", "way", "relationship", "did", "not", "work"], "add_tokens": "if ( relationships . data ) { updatedRecord [ name ] = relationships . data . id ; } else { updatedRecord [ name ] = null ; }", "del_tokens": "updatedRecord [ name ] = relationships . data . id ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "chaining", "method", "in", "Athena", "contexts", "."], "add_tokens": "args . resultsHandler ( context . __hlog , results ) ; args . resultsHandler ( context . __hlog , results ) ; this . __hlog = httpLog ( hlog ) ; this . __hlog = httpLog . chain ( this . __hlog , hlog ) ; if ( ! iterator . fn || _break || context . __hlog . failed ) args [ 0 ] = context . __hlog || httpLog . none ;", "del_tokens": "args . resultsHandler ( context . previous || httpLog . none , results ) ; args . resultsHandler ( context . previous || httpLog . none , results ) ; this . previous = hlog ; hlog = httpLog ( hlog ) ; if ( hlog !== httpLog . none ) { hlog . previous = this . previous ; this . previous = hlog ; } if ( ! iterator . fn || _break || ( context . previous && context . previous . failed ) ) args [ 0 ] = context . previous || httpLog . none ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "for", "long", "-", "standing", "memory", "leak", "with", "CallStatement", "in", "asmjs"], "add_tokens": "var output = _node ( this . base , env , ctx , tctx ) ; if ( this . base . getType ( ctx ) . _type !== 'primitive' ) { output = 'gcderef(' + output + ')' ; } tctx . write ( output + ';' ) ;", "del_tokens": "tctx . write ( _node ( this . base , env , ctx , tctx ) + ';' ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "try", "/", "catch", "around", "body", "so", "that", "all", "exceptions", "go", "through", "callback"], "add_tokens": "var _functionTemplate = new Template ( function _t ( ) { { var __ = _ ; try { body ; } catch ( __err ) { return _ ( __err ) ; } } node . type = BLOCK ; //node.children.splice(0, 0, _functionVarTemplate.generate(true)); node = _functionTemplate . generate ( true , { body : node } ) ; node . type = SCRIPT ;", "del_tokens": "var _functionVarTemplate = new Template ( function _t ( ) { var __ = _ ; node . children . splice ( 0 , 0 , _functionVarTemplate . generate ( true ) ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "prompt", "message", "when", "asking", "column", "name"], "add_tokens": "let messageAddentum , defaultValue ; if ( this . field . columnName !== undefined ) { messageAddentum = '(currently : ' + this . field . columnName + ')' ; defaultValue = this . field . columnName ; } else { messageAddentum = '' ; defaultValue = this . field . fieldName ; } message : 'What column name do you want for field \"' + this . field . fieldName + '\" ? ' + messageAddentum , default : defaultValue", "del_tokens": "// TODO check if the column field has already been added to this.fields // TODO display current field AND if present column name when asking for a new column name // TODO set default as column name value message : 'What column name do you want for field \"' + this . field . fieldName + '\" ?' , default : this . field . fieldName", "commit_type": "update"}
{"commit_tokens": ["Fixed", ":", "Use", "the", "same", "prior", "node", "list", "when", "the", "parent", "node", "is", "the", "same", "as", "current", "node"], "add_tokens": "// Here we push 3 things to a stack. The node, override type and an array that can keep track of prior nodes on this level. // The current node is also pushed to the last prior array. // Special case when node is the same as the parent node. This happends when using an override type when walking the AST // The same prior list is then used instead of a new empty one. length = nodePriorStack . length , lastPriorList = length ? nodePriorStack [ length - 1 ] : null , lastNode = length ? this . nodeStack [ length - 1 ] : null ; if ( lastPriorList ) { if ( lastNode !== node ) { // If not the same node push the node lastPriorList . push ( node ) ; } // Use the last prior list if it is the same node nodePriorStack . push ( lastNode === node ? lastPriorList : [ ] ) ;", "del_tokens": "length = nodePriorStack . length ; if ( length ) { var lastList = nodePriorStack [ length - 1 ] ; lastList . push ( node ) ; nodePriorStack . push ( [ ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "notes", "about", "sieve", "in", "readme", "and", "change", "sieve", "style", "a", "bit"], "add_tokens": "if ( this . composites . hasOwnProperty ( candidate ) === false ) { break ; if ( this . composites . hasOwnProperty ( pq ) ) { this . composites [ pq ] . push ( prime ) ; } else { this . composites [ pq ] = [ prime ] ; return this . candidate ;", "del_tokens": "if ( typeof this . composites [ candidate ] === \"undefined\" ) { return candidate ; if ( typeof this . composites [ pq ] === \"undefined\" ) { this . composites [ pq ] = [ ] ; this . composites [ pq ] . push ( prime ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "more", "complex", "method", "to", "request", "pages", "it", "uses", "the", "request", "HTTP", "client", "."], "add_tokens": "scraper : null , rqMethod : null return this . get ( ) ; } , get : function ( ) { var length = this . promises . length , last = this . promises [ length - 1 ] ; if ( length && last ) { last . rqMethod = function ( url ) { last . scraper . get ( url ) ; } ; return this ; } else { throw new ScraperError ( '' ) ; } } , request : function ( options ) { var length = this . promises . length , last = this . promises [ length - 1 ] ; if ( length && last ) { last . rqMethod = function ( url ) { options . uri = url ; last . scraper . request ( options ) ; } ; return this ; } else { throw new ScraperError ( '' ) ; } scraperPromise = promiseObj . scraper , reqMethod = promiseObj . rqMethod ; console . log ( promiseObj ) ; reqMethod ( url ) ;", "del_tokens": "scraper : null return this ; scraperPromise = promiseObj . scraper ; scraperPromise . get ( url ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "trailing", "comma", "in", "MochiKit"], "add_tokens": "\"iterateNextIter\"", "del_tokens": "\"iterateNextIter\" ,", "commit_type": "remove"}
{"commit_tokens": ["added", "system", "for", "adding", "in", "query", "parameters", "too"], "add_tokens": "var setParam = require ( 'mout/queryString/setParam' ) ; /** Set a bunch of local variables, formatted and templated **/ // Method, always lowercased // The URL endpoint. Query parameters allowed from here. var url = substitute ( config . url , params ) ; // Add query parameters intelligently, without conflicting from query parameters // already specified in the URL. if ( _ . isObject ( config . query ) ) { _ . each ( config . query , function ( value , key ) { url = setParam ( url , substitute ( value , params ) ) ; } ) ; } // Post/put/delete data var data = ( method === 'get' ) ? substitute ( config . query || { } , params ) : substitute ( config . data || { } , params ) ;", "del_tokens": "// Set a bunch of local variables, formatted and templated var url = substitute ( config . url , params ) ; var data = ( method === 'get' ) ? substitute ( config . query || { } , params ) : substitute ( config . data || { } , params ) ;", "commit_type": "add"}
{"commit_tokens": ["removed", "menu", "command", "-", "handled", "by", "presentation"], "add_tokens": "if ( ! contains ( [ 'Stub' , 'Presentation' , 'Function' , 'Procedure' ] , this . type ) ) throw new Error ( 'Invalid command type: ' + this . type ) ; self . _emitEvent ( 'Error' , e ) ; function ProcedureEvents ( event , obj ) { self . _emitEvent ( 'Error' , obj ) ;", "del_tokens": "if ( ! contains ( [ 'Stub' , 'Menu' , 'Presentation' , 'Function' , 'Procedure' ] , this . type ) ) throw new Error ( 'Invalid command type: ' + this . type ) ; case 'Menu' : if ( ! ( this . contents instanceof Array ) ) throw new Error ( 'contents must be array of menu items' ) ; if ( ! this . contents . length ) throw new Error ( 'contents must be array of menu items' ) ; for ( i in this . contents ) { if ( this . contents . hasOwnProperty ( i ) ) if ( typeof this . contents [ i ] != 'string' && ! ( this . contents [ i ] instanceof Command ) ) throw new Error ( 'contents must be array of menu items' ) ; } break ; self . _emitEvent ( 'Error' , e ) ; function ProcedureEvents ( event , obj ) { self . _emitEvent ( 'Error' , obj ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixing", "objUtils", "and", "adding", "tests"], "add_tokens": "var dataValue = getNestedValue ( data , key ) ; if ( vals . indexOf ( dataValue ) < 0 ) {", "del_tokens": "if ( vals . indexOf ( data [ key ] ) < 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "better", "exception", "call", "stack", "."], "add_tokens": "var errStack = trimErrorStack ( new Error ( ) . stack ) ; var fiber = Fiber ( function future ( ) { } catch ( e ) { e . stack += errStack ; throw e ; if ( result instanceof Error ) { result . stack += \"\\nat \" + new Error ( ) . stack ; throw result ; } else { return result ; } if ( result instanceof Error ) { result . stack += \"\\nat \" + new Error ( ) . stack ; throw result ; } else { return result ; } function trimErrorStack ( stack ) { var index = stack . indexOf ( \"\\n\" , stack . indexOf ( \"\\n\" , stack . indexOf ( \"\\n\" ) + 1 ) + 1 ) ; return stack . substring ( index ) ; }", "del_tokens": "var fiber = Fiber ( function ( ) { if ( result instanceof Error ) throw result ; else return result ; if ( result instanceof Error ) throw result ; else return result ;", "commit_type": "add"}
{"commit_tokens": ["fix", "bug", "in", "previous", "patch"], "add_tokens": "if ( domPos != domEnd || pos != to ) { changedLines += Math . abs ( to - pos ) ; patchDisplay ( updates ) ; // TODO called twice at start. find out why function patchDisplay ( updates ) {", "del_tokens": "if ( domPos < domEnd || pos < to ) { changedLines += to - pos ; patchDisplay ( updates , from , to ) ; function patchDisplay ( updates , from , to ) {", "commit_type": "fix"}
{"commit_tokens": ["fixed", "missing", "docCount", "on", "incremental", "calibration"], "add_tokens": "console . log ( value + ' documents searchable' ) ; countDocuments ( indexesMultiply , function ( msg ) { indexesMultiply . put ( tf , function ( err ) { callback ( '[success] incremental calibration complete' ) } ) ; } ) ;", "del_tokens": "// console.log(value + ' documents searchable'); indexesMultiply . put ( tf , function ( err ) { callback ( '[success] incremental calibration complete' ) } )", "commit_type": "fix"}
{"commit_tokens": ["Use", "debuglog", "for", "test", "client"], "add_tokens": "var debuglog = require ( 'debuglog' ) ; var log = debuglog ( 'hodor-net-client' ) ; log ( 'unexpected error' , error . message ) ; log ( 'unexpected end before connection' ) ; log ( 'unexpected response' , JSON . stringify ( data ) ) ; log ( 'expected finish before end' ) ;", "del_tokens": "console . log ( 'unexpected error' , error . message ) ; console . log ( 'unexpected end before connection' ) ; console . log ( 'unexpected response' , data ) ; console . log ( 'expected finish before end' ) ;", "commit_type": "use"}
{"commit_tokens": ["made", "widget", "so", "it", "handles", "array", "for", "values", "and", "joystick", "working"], "add_tokens": "if ( Array . isArray ( this . value ) ) { for ( let v in this . value ) { for ( let filter of this . __prefilters ) value = filter ( v ) for ( let filter of this . filters ) value = filter ( v ) for ( let filter of this . __postfilters ) value = filter ( v ) } } else { for ( let filter of this . __prefilters ) value = filter ( value ) for ( let filter of this . filters ) value = filter ( value ) for ( let filter of this . __postfilters ) value = filter ( value ) } if ( this . __value !== this . __prevValue || Array . isArray ( this . __value ) ) { //looks like this should handle arrays, not tested } ,", "del_tokens": "for ( let filter of this . __prefilters ) value = filter ( value ) for ( let filter of this . filters ) value = filter ( value ) for ( let filter of this . __postfilters ) value = filter ( value ) if ( this . __value !== this . __prevValue ) { }", "commit_type": "make"}
{"commit_tokens": ["Fix", "transaction", "infinite", "loop", "bug"], "add_tokens": "var fns , res ; fns = this . buffer ; fns . forEach ( function ( fn ) { return fn ( ) ; } ) ;", "del_tokens": "var b , j , len1 , ref , res ; ref = this . buffer ; for ( j = 0 , len1 = ref . length ; j < len1 ; j ++ ) { b = ref [ j ] ; b ( ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "hybrid", "layer", "to", "MapQuest", "provider"], "add_tokens": "url : 'http://otile{s}.mqcdn.com/tiles/1.0.0/{type}/{z}/{x}/{y}.{ext}' , type : 'map' , ext : 'jpg' , type : 'sat' , } , HybridOverlay : { options : { type : 'hyb' , ext : 'png' , opacity : 0.9 }", "del_tokens": "url : 'http://otile{s}.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.jpeg' , url : 'http://oatile{s}.mqcdn.com/tiles/1.0.0/sat/{z}/{x}/{y}.jpg' ,", "commit_type": "add"}
{"commit_tokens": ["added", "plural", "feature", "for", "i18n"], "add_tokens": "* @ param [ num ] for plural or singular * @ param key translation key var key = args . shift ( ) , isPlural ; if ( rAppid . _ . isNumber ( key ) ) { isPlural = key !== 1 ; key = args . shift ( ) ; } if ( isPlural ) { key += \"_plural\" ; }", "del_tokens": "* @ key translation key var key = args . shift ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "nesting", "of", "footnote", "definition", "fragments"], "add_tokens": "if ( node . children && node . children . length === 1 && node . children [ 0 ] . type === 'paragraph' ) { node . children [ 0 ] . children . unshift ( { type : 'textNode' , value : ` ${ node . identifier } ` , } ) ; } /* package the prefix inside the first child */", "del_tokens": "< span key = 'id' > { ` ${ node . identifier } ` } < / span >", "commit_type": "fix"}
{"commit_tokens": ["moving", "connect", "to", "stream", "server", "to", "the", "onOpen", "to", "see", "if", "it", "fixes", "the", "400", "error", "."], "add_tokens": "// client.stream.on('open', onOpen); client . connectToStreamServer ( ) ;", "del_tokens": "client . connectToStreamServer ( ) ; client . stream . on ( 'open' , onOpen ) ;", "commit_type": "move"}
{"commit_tokens": ["Upgrade", "url", "-", "pattern", "and", "support", "optional", "patterns", "."], "add_tokens": "current . pattern = current . pattern || pattern . newPattern ( current . path ) ;", "del_tokens": "current . pattern = current . pattern || pattern ( current . path ) ;", "commit_type": "upgrade"}
{"commit_tokens": ["Added", "extra", "exception", "handling", "around", "calling", "handlers"], "add_tokens": "try { return handler ( err , data ) ; } catch ( err ) { console . error ( \"Error calling cache handler\" , err . stack ) ; } try { return handler ( err , null ) ; } catch ( err ) { return console . error ( \"Error calling cache handler\" , err . stack ) ; }", "del_tokens": "handler ( err , data ) ; handler ( err , null ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "spacing", "in", "nice", "error", "message"], "add_tokens": "err . message = 'package: '", "del_tokens": "err . message = 'package:'", "commit_type": "fix"}
{"commit_tokens": ["move", "rbush", ".", "js", "to", "index", ".", "js"], "add_tokens": "var rbush = typeof require !== 'undefined' ? require ( '..' ) : rbush ;", "del_tokens": "var rbush = typeof require !== 'undefined' ? require ( '../rbush.js' ) : rbush ;", "commit_type": "move"}
{"commit_tokens": ["Fixed", "observableLike", "to", "default", "to", "returning", "false"], "add_tokens": "ok ( typeReflections . isObservableLike ( { } ) === false , \"Object\" ) ; ok ( typeReflections . isObservableLike ( [ ] ) === false , \"Array\" ) ;", "del_tokens": "ok ( ! typeReflections . isObservableLike ( { } ) , \"Object\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "full", "path", "to", "node", "-", "gyp"], "add_tokens": "var gyp = exec ( 'node-gyp configure' ) ;", "del_tokens": "var gyp = exec ( '/usr/local/bin/node-gyp configure' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Adding", "array", "support", "for", "masks"], "add_tokens": "var output = { } , k , i , l ; if ( Array . isArray ( def ) ) { if ( ! Array . isArray ( object ) ) return object ; output = [ ] ; for ( i = 0 , l = object . length ; i < l ; i ++ ) { output . push ( applyMask ( object [ i ] , def [ 0 ] ) ) ; } return output ; } // TODO: optimize function call here? for ( k in def ) {", "del_tokens": "var output = { } ; for ( var k in def ) {", "commit_type": "add"}
{"commit_tokens": ["add", "name", "property", "for", "rule"], "add_tokens": "console . error ( 'validation rule ' + rule . name + ' call callback ' + _doneCounter + ' times' ) ; done ( new ValidationError ( rule . name , rule . params , index ) ) ;", "del_tokens": "console . error ( 'validation rule ' + rule . _$ruleName + ' call callback ' + _doneCounter + ' times' ) ; done ( new ValidationError ( rule . _$ruleName , rule . params , index ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "more", "deflate", "benchmarks", "+", "inflate", "benchmarks"], "add_tokens": "var deflateSync = require ( './node-zlib' ) . deflateSync ; exports . run = function ( data , level ) { return deflateSync ( data . typed , { level : level } ) ;", "del_tokens": "var deflate = require ( './deflate' ) ; exports . run = function ( data ) { return deflate ( data . typed ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "a", "length", "to", "be", "specified"], "add_tokens": "const _deepIndex = ( vs , v ) => _ . findIndex ( vs , p => _ . isEqual ( p , v ) ) ; return _deepIndex ( existing , value ) > - 1 ; let x = _deepIndex ( xs , value ) ; if ( _deepIndex ( xs , value ) === - 1 ) { / ** * / const ensure_namespace = ( key , namespace ) => key . indexOf ( ':' ) === - 1 ? ` ${ namespace } ${ key } ` : key ; ensure_namespace : ensure_namespace ,", "del_tokens": "return existing . indexOf ( value ) > - 1 ; var x = xs . indexOf ( value ) ; if ( xs . indexOf ( value ) === - 1 ) {", "commit_type": "allow"}
{"commit_tokens": ["Removed", "semicolons", "per", "npm", "style"], "add_tokens": "const contractDefinition = artifacts . require ( './ListingsRegistry.sol' ) let str = err . toString ( ) return str . includes ( \"revert\" ) var owner = accounts [ 0 ] var notOwner = accounts [ 1 ] var instance instance = await contractDefinition . new ( { from : owner } ) } ) let contractOwner = await instance . owner_address ( ) assert . equal ( contractOwner , owner ) } ) let listingCount = await instance . listingsLength ( ) assert . equal ( listingCount , 5 ) } ) } ) } ) } ) } )", "del_tokens": "const contractDefinition = artifacts . require ( './ListingsRegistry.sol' ) ; let str = err . toString ( ) ; return str . includes ( \"revert\" ) ; var owner = accounts [ 0 ] ; var notOwner = accounts [ 1 ] ; var instance ; instance = await contractDefinition . new ( { from : owner } ) ; } ) ; let contractOwner = await instance . owner_address ( ) ; assert . equal ( contractOwner , owner ) ; } ) ; let listingCount = await instance . listingsLength ( ) ; assert . equal ( listingCount , 5 ) ; } ) ; } ) ; } ) ; } ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["use", "error", "callback", "instead", "of", "throwing", "when", "authenticating"], "add_tokens": "User . findById ( id , done ) ; return done ( err ) ; console . log ( \"error saving user\" , err ) ; return done ( err ) ; console . log ( \"error saving user\" , err ) ; return done ( err ) ; return done ( err ) ;", "del_tokens": "User . findById ( id , function ( err , user ) { done ( err , user ) ; } ) ; throw err ; console . log ( \"error saving user\" ) ; console . log ( err ) ; throw err ; console . log ( \"error saving user\" ) ; console . log ( err ) ; throw err ; throw err ;", "commit_type": "use"}
{"commit_tokens": ["Added", "test", "for", ":", "should", "be", "able", "to", "access", "shieldUtils", "WebExtensions", "API", "from", "the", "extension", "page", "for", "tests"], "add_tokens": "//runOnce(); // run things here via tests instead // required for right context to be available to selenium const createData = { type : \"detached_panel\" , url : \"extension-page-for-tests/index.html\" , width : 500 , height : 500 , } ; const creating = browser . windows . create ( createData ) ;", "del_tokens": "runOnce ( ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "pseudo", "constructor", "init"], "add_tokens": "expect ( render ( el ( Foo ) ) ) . to . eql ( '<div>foo</div>' ) ; } ) ; it ( 'should render a stateful component with pseudo constructor' , ( ) => { const Foo = define ( { init ( props ) { this . state = { foo : 'foo' } ; } , render ( props , state ) { return el ( 'div' , { } , state . foo ) ; } } ) ; expect ( Foo . __isStateless ) . to . equal ( undefined ) ; expect ( render ( el ( Foo ) ) ) . to . eql ( '<div>foo</div>' ) ; init ( props , context ) { this . bar = context . data . bar ; return el ( 'span' , { } , this . bar ) ;", "del_tokens": "expect ( render ( el ( Foo , { text : 'foo' } ) ) ) . to . eql ( '<div>foo</div>' ) ; state : { bar : 'bar' return el ( 'span' , { } , context . data . bar ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "error", "check", "in", "rule", "-", "contains", "test"], "add_tokens": "verr : { rule : 'contains' , params : [ 123 , 234 , 345 ] } verr : { rule : 'contains' , params : [ 123 , 234 , 345 ] }", "del_tokens": "expect : false expect : false", "commit_type": "add"}
{"commit_tokens": ["add", "native", "http", "proxy", "support"], "add_tokens": "// client.doSocket({hashname:\"7aac3b2a72bce56d88b0f88b946d2b5167142d2c\", listen:2001, to:\"127.0.0.1:2010\"}, function(err){ // console.log(\"SOCKET\",err); // }) client . doProxy ( { hashname : \"7aac3b2a72bce56d88b0f88b946d2b5167142d2c\" , path : \"/\" } , function ( err , res , body ) { console . log ( \"PROXY\" , err , res , body . toString ( ) ) ;", "del_tokens": "client . doSockProxy ( { hashname : \"7aac3b2a72bce56d88b0f88b946d2b5167142d2c\" , listen : 2001 , to : \"127.0.0.1:2010\" } , function ( err ) { console . log ( \"SOCKPROXY\" , err ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "documentation", "and", "jsdoc", "output"], "add_tokens": "* @ return { string } the AST for the tree parsed back into a string /** @return {string} a runtime constant denoting the Query type */ /** @return {string} a runtime constant denoting the Mutation type */", "del_tokens": "* @ return { [ type ] } [ description ] /** @type {string} QUERY a runtime constant denoting the Query type */ /** @type {string} QUERY a runtime constant denoting the Mutation type */", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "that", "would", "cause", "ArcGIS", "extents", "to", "fail", "to", "parse", "when", "a", "value", "is", "0"], "add_tokens": "if ( typeof arcgis . xmin === \"number\" && typeof arcgis . ymin === \"number\" && typeof arcgis . xmax === \"number\" && typeof arcgis . ymax === \"number\" ) {", "del_tokens": "if ( arcgis . xmin && arcgis . ymin && arcgis . xmax && arcgis . ymax ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "the", "ability", "to", "register", "to", "window", ".", "onerror", "."], "add_tokens": "tsResult . js . pipe ( sourcemaps . write ( '/' ) )", "del_tokens": "tsResult . js . pipe ( sourcemaps . write ( ) )", "commit_type": "add"}
{"commit_tokens": ["added", "word", "count", "example", "using", "mongodb"], "add_tokens": "#!/usr/local/bin/node var words = { } , finished = 0 ; grid . init_cb ( function ( ) { } ) ;", "del_tokens": "#!/usr/local/bin/node --harmony var co = require ( 'co' ) ; co ( function * ( ) { var words = { } , finished = 0 ; yield grid . init ( ) ; } ) ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "url", "token", "in", "CSS"], "add_tokens": "Prism . languages . css = { comment : / \\/\\*[\\w\\W]*?\\*\\/ / g , atrule : / @[\\w-]+?(\\s+.+)?(?=\\s*{|\\s*;) / gi , url : / url\\((?:'|\")?(.+?)(?:'|\")?\\) / gi , selector : / [^\\{\\}\\s][^\\{\\}]*(?=\\s*\\{) / g , property : / (\\b|\\B)[a-z-]+(?=\\s*:) / ig , important : / \\B!important\\b / gi , ignore : / &(lt|gt|amp); / gi , punctuation : / [\\{\\};:] / g } ;", "del_tokens": "Prism . languages . css = { comment : / \\/\\*[\\w\\W]*?\\*\\/ / g , atrule : / @[\\w-]+?(\\s+.+)?(?=\\s*{|\\s*;) / gi , selector : / [^\\{\\}\\s][^\\{\\}]*(?=\\s*\\{) / g , property : / (\\b|\\B)[a-z-]+(?=\\s*:) / ig , important : / \\B!important\\b / gi , ignore : / &(lt|gt|amp); / gi , punctuation : / [\\{\\};:] / g } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "replaceReducer", "to", "work", "on", "the", "unlifted", "store"], "add_tokens": "function unliftStore ( liftedStore , reducer ) { } , getReducer ( ) { return reducer ; } , replaceReducer ( nextReducer ) { liftedStore . replaceReducer ( liftReducer ( nextReducer ) ) ; const store = unliftStore ( liftedStore , reducer ) ;", "del_tokens": "function unliftStore ( liftedStore ) { const store = unliftStore ( liftedStore ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "remaining", "methods", "to", "BrokerInfoServiceClient"], "add_tokens": "subscriber . onComplete ( new ProteusSocket ( this . _config , transport ) ) ; class ProteusSocket < D , M > implements ReactiveSocket < D , M > {", "del_tokens": "/ ** * ProteusClient : A client in an RSocket connection that will communicates with * the peer via the given transport client . Provides methods for establishing a * connection and initiating the RSocket interactions : * - fireAndForget ( ) * - requestResponse ( ) * - requestStream ( ) * - requestChannel ( ) * - metadataPush ( ) * / _cancel : ? ( ) => void ; _socket : ? ProteusClientSocket < D , M > ; this . _cancel = null ; this . _socket = null ; subscriber . onComplete ( new ProteusClientSocket ( this . _config , transport ) , ) ; class ProteusClientSocket < D , M > implements ReactiveSocket < D , M > {", "commit_type": "add"}
{"commit_tokens": ["Add", ":", "Undefined", "property", "generator"], "add_tokens": "array_prop ; // An undefined property is simply an unvalidated property // with a getter and setter interface. undefined_prop = function ( ) { // Place the actual value within a private and // unreachable scope for integrity. var prop = { value : undefined , type : \"undefined\" } ; return function ( val ) { if ( val === undefined ) { return prop . value ; } prop . value = val ; // Add the option for fluid interface by returning // the current context. return this ; } ; } ;", "del_tokens": "array_prop , object_prop ;", "commit_type": "add"}
{"commit_tokens": ["Add", "the", "bootstrap", "to", "the", "templates", "as", "well"], "add_tokens": "import { FlowManager , AbstractRegistrableComponent } from 'vue-transition-component' ; extends : AbstractRegistrableComponent ,", "del_tokens": "import { FlowManager } from 'vue-transition-component' ;", "commit_type": "add"}
{"commit_tokens": ["Use", "karam", "-", "sinon", "framewrok", "more", "jshint", "options"], "add_tokens": "/*jslint node:true*/ frameworks : [ 'jasmine' , 'sinon' ] ,", "del_tokens": "frameworks : [ 'jasmine' ] , // Test files 'test/sinon-1.9.1.js' , 'test/sinon-ie-1.9.1.js' , // for fake XHR in IE", "commit_type": "use"}
{"commit_tokens": ["fixed", "bug", "where", "$t", "was", "pulled", "to", "top", "level", "when", "it", "was", "an", "object", "."], "add_tokens": "if ( ( ( typeof obj [ o ] ) === 'object' ) && ! ( o === '$t' ) ) {", "del_tokens": "if ( ( typeof obj [ o ] ) == 'object' && ( ! o === '$t' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Adding", "support", "for", "generating", "font", "files", "with", "opentype", "ligatures", "."], "add_tokens": "var addLigatures = options . ligatures === true ; if ( addLigatures ) { args . push ( '--ligatures' ) ; } fontSrc2 . push ( 'url(\"' + relativeFontPath + fontName + '.svg?#' + fontBaseName + '\") format(\"svg\")' ) ; glyphs : glyphs , ligatures : addLigatures iconsStyles : false || ! plainCss , ligatures : addLigatures plainCss : plainCss , ligatures : addLigatures", "del_tokens": "fontSrc2 . push ( 'url(\"' + relativeFontPath + fontName + '.svg?#webfont\") format(\"svg\")' ) ; glyphs : glyphs iconsStyles : false || ! plainCss plainCss : plainCss", "commit_type": "add"}
{"commit_tokens": ["Add", "check", "for", "minimum", "jQuery", "version"], "add_tokens": "test . expect ( 3 ) ; test . deepEqual ( lintHtml ( utf8Fixture ( 'jquery/old-url.html' ) ) , [ \"Found what might be an outdated version of jQuery; Bootstrap requires jQuery v1.9.0 or higher\" ] , 'should complain about old version of jQuery based on URL' ) ;", "del_tokens": "test . expect ( 2 ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "getCacheFilePath", "take", "cachePath", "as", "argument"], "add_tokens": "function getCacheFilePath ( fn , args , opt , cachePath ) { return path . join ( cachePath , opt . cacheId , hash ) var filePath = getCacheFilePath ( fn , args , optExt , options . cachePath )", "del_tokens": "function getCacheFilePath ( fn , args , opt ) { return path . join ( options . cachePath , opt . cacheId , hash ) var filePath = getCacheFilePath ( fn , args , optExt )", "commit_type": "make"}
{"commit_tokens": ["adding", "location", "to", "passedProps", "before", "returning", "component"], "add_tokens": "passedProps . location = match ( routes , getCurrentPath ( ) || path ) ; const CurrentComponent = passedProps . location . component ; return < CurrentComponent { ... passedProps } / > ;", "del_tokens": "const matchedRoute = match ( routes , getCurrentPath ( ) || path ) ; const CurrentComponent = matchedRoute . component ; return < CurrentComponent { ... { ... passedProps , location : matchedRoute } } / > ;", "commit_type": "add"}
{"commit_tokens": ["adding", "pdf", "format", "and", "consolidating", "files"], "add_tokens": "var uid = uuid . v4 ( ) . replace ( '-' , \"\" ) . substring ( 0 , 10 ) ; global . buildContent = function ( uid , file ) { var path = global . buildPath ( uid , file ) ; try { return fs . readFileSync ( path ) ; } catch ( err ) { console . log ( err ) } return \"FILE NOT LOADED\" ; }", "del_tokens": "var uid = uuid . v4 ( ) ;", "commit_type": "add"}
{"commit_tokens": ["updating", "how", "the", "meta", "-", "data", "schema", "gets", "generated"], "add_tokens": "var schemaNames = _ . map ( schemasToGenerate , 'name' ) ; var nameRequiredForCommon = [ 'schema' , 'response' , 'header' ] ; Object . keys ( operationSchema . definitions ) . forEach ( function ( definitionName ) { if ( schemaNames . indexOf ( definitionName ) < 0 ) { return ; } var customisedSchema = _ . cloneDeep ( require ( '../lib/schemas/' + _ . kebabCase ( definitionName ) . toLowerCase ( ) + '.json' ) ) ; delete customisedSchema . definitions ; delete customisedSchema . $schema ; delete customisedSchema . id ; if ( nameRequiredForCommon . indexOf ( definitionName ) >= 0 ) { delete customisedSchema . properties . name ; if ( customisedSchema . required ) { _ . remove ( customisedSchema . required , function ( propertyName ) { return propertyName === 'name' ; } ) ; if ( customisedSchema . required . length === 0 ) { delete customisedSchema . required ; } } } operationSchema . definitions [ definitionName ] = customisedSchema ; } ) ;", "del_tokens": "", "commit_type": "update"}
{"commit_tokens": ["add", "type", "and", "cardinality", "remove", "from", "properties", "."], "add_tokens": "session : { relativeSize : 'number' } , type : { deps : [ 'geo' , 'hashed' , 'text' ] , fn : function ( ) { if ( this . geo ) { return 'geospatial' ; } if ( this . hashed ) { return 'hashed' ; } if ( this . text ) { return 'text' ; } return 'regular' ; } } , cardinality : { deps : [ 'single' ] , fn : function ( ) { return this . single ? 'single' : 'compound' ; } } , deps : [ 'unique' , 'sparse' , 'partial' , 'ttl' ] , var props = [ 'unique' , 'sparse' , 'partial' , 'ttl' ] ; 'unique' : 1 , 'sparse' : 2 , 'partial' : 3 , 'ttl' : 4", "del_tokens": "deps : [ 'unique' , 'sparse' , 'partial' , 'ttl' , 'compound' , 'single' ] , var props = [ 'unique' , 'sparse' , 'partial' , 'ttl' , 'compound' , 'single' ] ; 'single' : 1 , 'compound' : 2 , 'unique' : 3 , 'sparse' : 4 , 'partial' : 5 , 'ttl' : 6", "commit_type": "add"}
{"commit_tokens": ["Add", "cache", "test", "for", "_getNearPositions"], "add_tokens": "export { _getInitialBoard , _getNearPositions , defaultBoardSize , defaultBoardConf , getCleanBoard , getInitialBoard , getBoardConf , getBoardWhereCanIGo , getColorStartEndRow , getEmptyNearPositions , getJumpPosition , getNearPositions , getNotEmptyNearPositions , getPosition , getPositionsWhereCanIGo , printBoard , printBoardCurried , printUnicodeBoard , printXAndYBoard , whereCanIJump , setPieceOnBoard , setPosition , removePieceOnBoard , hasPosition , hasPositionByBoardSize } ;", "del_tokens": "// tslint:disable-next-line:variable-name export { defaultBoardSize , defaultBoardConf , getCleanBoard , getInitialBoard , getBoardConf , getBoardWhereCanIGo , getColorStartEndRow , getEmptyNearPositions , getJumpPosition , getNearPositions , getNotEmptyNearPositions , getPosition , getPositionsWhereCanIGo , printBoard , printBoardCurried , printUnicodeBoard , printXAndYBoard , whereCanIJump , setPieceOnBoard , setPosition , removePieceOnBoard , hasPosition , hasPositionByBoardSize } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "gulp", "default", "task", "as", "a", "git", "pre", "-", "commit", "hook", "."], "add_tokens": "path . join ( __dirname , '*.js' ) , . pipe ( jshint . reporter ( 'jshint-stylish' ) ) . pipe ( jshint . reporter ( 'fail' ) ) ;", "del_tokens": "path . join ( __dirname , 'index.js' ) , . pipe ( jshint . reporter ( 'default' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "name", "of", "docs", "/", "index", ".", "md", "to", "docs", "/", "README", ".", "md"], "add_tokens": ". pipe ( concat ( 'README.md' ) )", "del_tokens": ". pipe ( concat ( 'index.md' ) )", "commit_type": "change"}
{"commit_tokens": ["adding", "better", "logging", "to", "require"], "add_tokens": "// Log the error, to provide more information log . error ( target , 'missing required property' , properties [ i ] . toString ( ) ) ; throw new Error ( 'Target does not contain all required properties.' ) ; log . error ( target , 'unable to satisfy required properties' , properties ) ; throw new Error ( 'Target does not contain any of the required properties.' ) ;", "del_tokens": "console . log ( fn ) ; throw new Error ( \"Target does not contain all required properties.\" ) ; throw new Error ( \"Target does not contain any of the required properties.\" ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "standalone", "server", "and", "first", "port", "of", "locks", "code", "from", "SabreDAV"], "add_tokens": "return [ ] ;", "del_tokens": "return { } ;", "commit_type": "fix"}
{"commit_tokens": ["added", "a", "workaround", "for", "node_modules", "-", ">", "~"], "add_tokens": "const webpack_assets = options . webpack_assets_file_path = options . webpack_assets_file_path || 'webpack-assets.json' options . webpack_stats_file_path = options . webpack_stats_file_path || 'webpack-stats.json' if ( typeof clusion !== 'string' }", "del_tokens": "const webpack_assets = options . webpack_assets_file_path = options . webpack_assets_file_path || 'webpack-assets.json' options . webpack_stats_file_path = options . webpack_stats_file_path || 'webpack-stats.json' if ( typeof clusion !== 'string' // replaces inner node_modules with ~ export function webpack_path ( asset_path ) { // webpack has a shortcut from \"node_modules\" if ( starts_with ( asset_path , './node_modules/' ) ) { asset_path = asset_path . replace ( './node_modules/' , './~/' ) } return asset_path } }", "commit_type": "add"}
{"commit_tokens": ["Use", "listener", "-", "tracker", "module", "for", "tracking", "listeners"], "add_tokens": "var listenerTracker = require ( 'listener-tracker' ) ; this . _subscriptions = tracker = listenerTracker . createTracker ( ) ; tracker . removeAllListeners ( ) ;", "del_tokens": "var SubscriptionTracker = require ( 'raptor-util/SubscriptionTracker' ) ; this . _subscriptions = tracker = new SubscriptionTracker ( this ) ; tracker . unsubscribeAll ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixing", "undefined", "error", "by", "ensuring", "that", "pkg", ".", "scripts", "is", "created", "in", "all", "cases", "."], "add_tokens": "if ( ! pkg [ 'scripts' ] ) {", "del_tokens": "if ( ! pkg [ 'scripts' ] && options [ 'themePath' ] ) {", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "boolean", ".", "true", "/", "falseValues"], "add_tokens": "function castBoolean ( format , value , options = { } ) { if ( ( options . trueValues || _TRUE_VALUES ) . includes ( value ) ) { } else if ( ( options . falseValues || _FALSE_VALUES ) . includes ( value ) ) { const _TRUE_VALUES = [ 'true' , 'True' , 'TRUE' , '1' ] const _FALSE_VALUES = [ 'false' , 'False' , 'FALSE' , '0' ]", "del_tokens": "function castBoolean ( format , value ) { if ( _TRUE_VALUES . includes ( value ) ) { } else if ( _FALSE_VALUES . includes ( value ) ) { const _TRUE_VALUES = [ 'yes' , 'y' , 'true' , 't' , '1' ] const _FALSE_VALUES = [ 'no' , 'n' , 'false' , 'f' , '0' ]", "commit_type": "implement"}
{"commit_tokens": ["fixed", "toolbar", "style", "and", "z", "-", "index"], "add_tokens": "$toolbar . css ( { 'top' : relativeOffset + 'px' } ) ; $toolbar . css ( { 'top' : 0 } ) ; $toolbar . css ( { 'top' : relativeOffset + 'px' } ) ;", "del_tokens": "$toolbar . css ( { 'top' : relativeOffset + 'px' , 'z-index' : 2000 } ) ; $toolbar . css ( { 'top' : 0 , 'z-index' : 500 } ) ; $toolbar . css ( { 'top' : relativeOffset + 'px' , 'z-index' : 2000 } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "slice", "instead", "of", "splice", "and", "remove", "extra", "period", "."], "add_tokens": "failuresToOutput = allFailures . slice ( 0 , options . reportLimit ) } ) . join ( ', ' ) ;", "del_tokens": "var ignoreFailureStart = options . reportLimit ; failuresToOutput = allFailures . splice ( ignoreFailureStart , ignoreFailureCount ) } ) . join ( ', ' ) + '.' ;", "commit_type": "use"}
{"commit_tokens": ["added", "default", "messages", "for", "validators", "add", "yuidoc"], "add_tokens": "* Validator Mixin to be used on a DS . Model .", "del_tokens": "* Validator Mixin to be used on Serializers .", "commit_type": "add"}
{"commit_tokens": ["Using", "path", ".", "resolve", "to", "build", "path", "Uris", "instead", "of", "string", "concatenation"], "add_tokens": "fileBytes = fs . readFileSync ( path . resolve ( '/..' , SignTest1File ) ) ; var filename = './' + accountId + '_' + envelopeId + '_' + documentId + '.pdf' ; var tempFile = path . resolve ( '/..' , filename ) ; fileBytes = fs . readFileSync ( path . resolve ( '/..' , SignTest1File ) ) ; fileBytes = fs . readFileSync ( path . resolve ( '/..' , SignTest1File ) ) ;", "del_tokens": "fileBytes = fs . readFileSync ( path . resolve ( __filename + '/..' + SignTest1File ) ) ; var tempFile = path . resolve ( __filename + '/../' + accountId + '_' + envelopeId + '_' + documentId + '.pdf' ) ; fileBytes = fs . readFileSync ( path . resolve ( __filename + '/..' + SignTest1File ) ) ; fileBytes = fs . readFileSync ( path . resolve ( __filename + '/..' + SignTest1File ) ) ;", "commit_type": "use"}
{"commit_tokens": ["make", "async", "timeout", "callback", "more", "determinant"], "add_tokens": "// if the output file has not already been removed if ( self . exists ( outputFile ) ) { error = ! fs . existsSync ( outputFile ) ; // if we're done right now, finish callback ( error ? false : undefined ) ;", "del_tokens": "// if the output file has not already been removed and it doesn't exist if ( self . exists ( outputFile ) && ! fs . existsSync ( outputFile ) ) { error = true ; // if we're done right now, finish as error callback ( false ) ;", "commit_type": "make"}
{"commit_tokens": ["Make", "optimization", "opt", "-", "in"], "add_tokens": "const environment = this . app . env const config = this . pkg [ 'ember-test-utils' ] || { } const excludeFromEnvironments = config . excludeFromEnvironments || [ ] if ( excludeFromEnvironments . indexOf ( environment ) !== - 1 ) { return null return this . _super . treeForAddon . call ( this , tree )", "del_tokens": "// Only include code in build for test environment if ( this . app . env === 'test' ) { return this . _super . treeForAddon . call ( this , tree ) return null", "commit_type": "make"}
{"commit_tokens": ["Fix", "textboxes", "impossible", "to", "type", "in", "."], "add_tokens": "controls . width . value = animation . width ; controls . height . value = animation . height ; controls . offsetX . value = animation . spriteOffsetX ; controls . offsetY . value = animation . spriteOffsetY ; controls . running . checked = running ;", "del_tokens": "console . log ( \"init\" ) ; controls . width . value = entity . width ; controls . height . value = entity . height ; controls . offsetX . value = entity . spriteOffsetX ; controls . offsetY . value = entity . spriteOffsetY ; controls . running . checked = running ;", "commit_type": "fix"}
{"commit_tokens": ["Making", "sure", "the", "refresh", "object", "gets", "an", "updated", "expiration", "."], "add_tokens": "self . set ( key , response , data . lifeSpan , data . refresh , noop ) ;", "del_tokens": "self . set ( key , response , data . lifeSpan ) ;", "commit_type": "make"}
{"commit_tokens": ["allow", "display", "of", "returned", "error", "messages", "without", "json", "wrapping", "in", "cli", "mode", "by", "setting", "methodResponse", "to", "nojson", "on", "error", "callbacks"], "add_tokens": "if ( methodResp === 'nojson' ) process . stdout . write ( 'Error: ' + errorSummary . error + '\\n' ) ; else process . stdout . write ( safeJSON ( errorSummary ) ) ;", "del_tokens": "process . stdout . write ( safeJSON ( errorSummary ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "basic", "functionality", "of", "faking", "Date", "object", "."], "add_tokens": "Zurvan . startTime ( ) . then ( done , done ) ;", "del_tokens": "Zurvan . startTime ( ) . then ( done ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "empty", "rules", "after", "expander"], "add_tokens": "// /** optimize css */ discardComments ( { removeAll : false } ) , elementExpander ( { elements , aliases } ) , discardEmpty ( )", "del_tokens": "import discardUnused from 'postcss-discard-unused' /** optimize css */ discardComments ( ) , discardUnused ( ) , elementExpander ( { elements , aliases } )", "commit_type": "remove"}
{"commit_tokens": ["Added", "caching", "per", "ahocevar", "recommendation"], "add_tokens": "++ stylesLength ; var cache_key = paint [ 'circle-radius' ] + '.' + paint [ 'circle-stroke-color' ] + '.' + paint [ 'circle-color' ] ; style = iconImageCache [ cache_key ] ; if ( ! style ) { style = new ol . style . Style ( { image : new ol . style . Circle ( { radius : paint [ 'circle-radius' ] ( zoom ) , stroke : new ol . style . Stroke ( { color : colorWithOpacity ( paint [ 'circle-stroke-color' ] ( zoom ) , opacity ) } ) , fill : new ol . style . Stroke ( { color : colorWithOpacity ( paint [ 'circle-color' ] ( zoom ) , opacity ) } ) } ) ; }", "del_tokens": "style = new ol . style . Style ( { image : new ol . style . Circle ( { radius : paint [ 'circle-radius' ] ( zoom ) , stroke : new ol . style . Stroke ( { color : colorWithOpacity ( paint [ 'circle-stroke-color' ] ( zoom ) , opacity ) } ) , fill : new ol . style . Stroke ( { color : colorWithOpacity ( paint [ 'circle-color' ] ( zoom ) , opacity ) } ) } ) ; ++ stylesLength ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "Editor", "options", "not", "showing", "the", "first", "value", "in", "list", "."], "add_tokens": "var options = array . map ( v , function ( item ) { opt = setText ( append . create ( 'option' ) , value ) ; return opt ; } ) ; array . forEach ( options , function ( opt ) { node . add ( opt ) ; } ) ; setTimeout ( function ( ) { self . domNode . value = self . domNode . value ;", "del_tokens": "array . forEach ( v , function ( item ) { opt = setText ( append ( node , 'option' ) , value ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "test", "/", "debug", "utilities"], "add_tokens": "'test/spec/**/*.coffee' , 'test/*.js'", "del_tokens": "'test/spec/**/*.coffee'", "commit_type": "add"}
{"commit_tokens": ["Use", "provided", "style", "alias", "within", "App", "file"], "add_tokens": "require ( 'styles/normalize.css' ) ; require ( 'styles/main.css' ) ;", "del_tokens": "require ( '../../styles/normalize.css' ) ; require ( '../../styles/main.css' ) ;", "commit_type": "use"}
{"commit_tokens": ["Allow", "inline", "mode", "to", "be", "set", "inside", "the", "config", "file"], "add_tokens": "if ( argv [ \"inline\" ] || options . inline ) {", "del_tokens": "if ( argv [ \"inline\" ] ) {", "commit_type": "allow"}
{"commit_tokens": ["Implement", "default", "empty", "retailer", "fields"], "add_tokens": "var newLine = { row : i + 1 , retailers : { Digikey : '' , RS : '' , Mouser : '' , Farnell : '' , Newark : '' } } ;", "del_tokens": "var newLine = { row : i + 1 , retailers : { } } ;", "commit_type": "implement"}
{"commit_tokens": ["Add", "stringify", "indentation", "and", "test"], "add_tokens": "* @ hideconstructor * @ param { Set < string > | null } [ allowedVariables = null ] * @ param { Object } [ context = { } ] * @ param { Function } [ replacer ] * @ param { number } [ indent ] static stringify ( objectTemplate , replacer , indent ) { return jsonStringifyExtended ( objectTemplate , replacer , indent ) ;", "del_tokens": "* @ param { Set < string > | null } [ allowedVariables ] * @ param { Object } [ context ] static stringify ( objectTemplate ) { return jsonStringifyExtended ( objectTemplate ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "up", "to", "3x", "max_daily_basal"], "add_tokens": "maxSafeBasal = Math . min ( profile_data . max_basal , 3 * profile_data . max_daily_basal , 4 * profile_data . current_basal ) ;", "del_tokens": "maxSafeBasal = Math . min ( profile_data . max_basal , 2 * profile_data . max_daily_basal , 4 * profile_data . current_basal ) ;", "commit_type": "allow"}
{"commit_tokens": ["Made", "sure", "it", "removes", "all", "connections", "even", "if", "it", "doesn", "t", "them", "in", "the", "connections", "array"], "add_tokens": "if ( position !== - 1 ) if ( connection . readyState && connection . readyState !== 'closed' && connection . end ) connection . end ( ) ; var save = [ ] , connection ; while ( this . connections . length ) { connection = this . connections . shift ( ) ; if ( save . length < keep && this . isAvailable ( this . connection [ 0 ] ) ) { save . push ( connection ) ; this . remove ( connection ) ;", "del_tokens": "if ( position !== - 1 ) { if ( connection . readyState !== 'closed' && connection . end ) connection . end ( ) ; } var save = [ ] , i = this . connections . length ; while ( i -- ) { if ( save . length < keep && this . isAvailable ( this . connections [ i ] ) ) { save . push ( this . connections [ i ] ) ; this . remove ( this . connections [ i ] ) ;", "commit_type": "make"}
{"commit_tokens": ["Adding", "args", "as", "an", "expectation", "in", "stub", "."], "add_tokens": "throw new Error ( this . error ( 'main' , {", "del_tokens": "throw new Error ( this . error ( this . mode , {", "commit_type": "add"}
{"commit_tokens": ["Added", "more", "gltexture", "effects", "(", "tonemapping", "glow", "lens", "aberration", ")", ".", "\\", "nNow", "nodes", "can", "control", "the", "execution", "priority", "."], "add_tokens": "var l = L . length ; for ( var i = 0 ; i < l ; ++ i ) L [ i ] . order = i ; //sort now by priority L = L . sort ( function ( A , B ) { var Ap = A . constructor . priority || A . priority || 0 ; var Bp = B . constructor . priority || B . priority || 0 ; if ( Ap == Bp ) return A . order - B . order ; return Ap - Bp ; } ) ; //save order number in the node, again... for ( var i = 0 ; i < l ; ++ i ) function on_mouse_wheel ( e ) { var pos = parseInt ( root . style . top ) ; root . style . top = ( pos + e . deltaY * 0.1 ) . toFixed ( ) + \"px\" ; e . preventDefault ( ) ; return true ; } root . addEventListener ( \"wheel\" , on_mouse_wheel , true ) ; root . addEventListener ( \"mousewheel\" , on_mouse_wheel , true ) ;", "del_tokens": "for ( var i = 0 ; i < L . length ; ++ i )", "commit_type": "add"}
{"commit_tokens": ["Fix", "crash", "in", "d", "-", "figure"], "add_tokens": "Figure . marginObserver . unobserve ( this ) ;", "del_tokens": "this . marginObserver . unobserve ( this ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "1", "-", "second", "delay", "between", "reconnect", "attempts", "when", "Steam", "is", "down"], "add_tokens": "this . emit ( 'debug' , 'Log on response: ' + ( body . eresult == Steam . EResult . ServiceUnavailable ? \"ServiceUnavailable\" : \"TryAnotherCM\" ) ) ; setTimeout ( function ( ) { this . logOn ( true ) ; } , 1000 ) ;", "del_tokens": "this . logOn ( true ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "a", "possible", "require", "analyze", "bug"], "add_tokens": "// if(node instanceof UglifyJS.AST_String && call_expression && obj_expression === null){ // moduleName = node.getValue(); // }", "del_tokens": "if ( node instanceof UglifyJS . AST_String && call_expression && obj_expression === null ) { moduleName = node . getValue ( ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Updated", "the", "README", "contents", "."], "add_tokens": "var params = { } ; if ( user ) { params . User = user ; }", "del_tokens": "var params = { 'User' : user } ;", "commit_type": "update"}
{"commit_tokens": ["fix", "one", "-", "to", "-", "one", "insanity"], "add_tokens": "! Array . isArray ( linked [ field ] [ inverseField ] ) && update . id !== linked [ field ] [ inverseField ] ) if ( record [ field ] !== null && record [ field ] !== update [ field ] && id !== record [ field ] )", "del_tokens": "! Array . isArray ( linked [ field ] [ inverseField ] ) ) if ( record [ field ] !== null && record [ field ] !== update [ field ] )", "commit_type": "fix"}
{"commit_tokens": ["Upgrade", "to", "html", "-", "parse", "-", "stringify2", "to", "solve", "some", "tag", "parsing", "issues", "around", "quotation", "marks", "in", "attr", "values", "."], "add_tokens": "import parse from 'html-parse-stringify2/lib/parse' ;", "del_tokens": "import parse from 'html-parse-stringify/lib/parse' ;", "commit_type": "upgrade"}
{"commit_tokens": ["Remove", "production", "no", "-", "op", "ing", "of", "makeInterfaceValidator", ".", "Require", "consumers", "to", "remove", "usages", "of", "this", "from", "production", "."], "add_tokens": "// return a function that validates it's argument has all the properties in the interfacePropArrays function makeInterfaceValidator ( interfacePropArrays ) {", "del_tokens": "// initialize as no-op functions so no overhead is introduced in production mode var makeInterfaceValidator = function ( ) { return function ( ) { return undefined ; } } ; //!steal-remove-start makeInterfaceValidator = function ( interfacePropArrays ) { //!steal-remove-end", "commit_type": "remove"}
{"commit_tokens": ["Remove", "defaultLanguage", "from", "params", "."], "add_tokens": "if ( defaultLanguage ) defaultLanguage . $defaultLanguage = defaultLanguage ; legacy . $defaultLanguage = legacy . defaultLanguage ; delete legacy . defaultLanguage ;", "del_tokens": "if ( defaultLanguage ) defaultLanguage . $defaultLanguage = defaultLanguage ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "parsing", "of", "optional", "combinator", "arguments"], "add_tokens": "const argument = arguments [ i ] if ( argument === undefined && arg . optional && arg . type !== undefined ) continue composition [ arg . _ ] = this . task ( arg . optional ? argument || null : argument ) if ( argument === null || Array . isArray ( argument ) ) throw new ComposerError ( 'Invalid argument' , argument )", "del_tokens": "const argument = arg . optional ? arguments [ i ] || null : arguments [ i ] composition [ arg . _ ] = composer . task ( argument ) if ( ! isObject ( argument ) ) throw new ComposerError ( 'Invalid argument' , argument )", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "CI", "of", "all", "e2e", "tests"], "add_tokens": "testLib . KAFKA_BROKER_URL = 'kafka:9092' ;", "del_tokens": "// stream: {write: function() {}}, // testLib.KAFKA_SCHEMA_REGISTRY_URL = 'http://schema-registry-confluent.internal.dev.waldo.photos'; testLib . KAFKA_BROKER_URL = 'localhost:9092' ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "config", "validation", "in", "testrail", "reporter", ".", "Fixed", "reference", "to", "browser", "name"], "add_tokens": "'use strict' ; me . validateConfig ( config ) ; Reporter . prototype . validateConfig = function ( config ) { var valid = true ; [ 'host' , 'username' , 'password' ] . forEach ( function ( param ) { if ( ! config [ param ] ) { console . error ( 'TestRailReporter requires \"' + param + '\" as a parameter.' ) ; valid = false ; } } ) ; return valid ; } ; comment = [ '# Mimik Feature Results #' ] , browserName = report . driver . getBrowserName ( ) ; if ( browserName ) { comment . push ( 'Agent: ' + browserName ) ; } comment = [ '# Mimik Scenario Results #' ] , browserName = report . driver . getBrowserName ( ) ; if ( browserName ) { comment . push ( 'Agent: ' + browserName ) ; }", "del_tokens": "comment = [ '# Mimik Feature Results #' ] ; comment . push ( 'Agent: ' + me . getAgent ( report . profile ) ) ; comment = [ '# Mimik Scenario Results #' ] ; comment . push ( 'Agent: ' + me . getAgent ( report . profile ) ) ; Reporter . prototype . getAgent = function ( profile ) { return profile . desiredCapabilities . browserName ; } ;", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "max", "bounds", "on", "tile", "layers"], "add_tokens": "this . setMaxBounds ( tileOptions . bounds ) ; this . setView ( L . latLng ( tileOptions . center ) , tileOptions . zoom , { reset : true } ) ; } this . setMaxBounds ( tileOptions . bounds ) ;", "del_tokens": "this . setView ( L . latLng ( tileOptions . center ) , tileOptions . zoom , { reset : true } ) ; }", "commit_type": "add"}
{"commit_tokens": ["Added", "node", "-", "sass", "."], "add_tokens": "import ts from \"@wessberg/rollup-plugin-ts\" ; import autoprefixer from \"autoprefixer\" ; import { gzip } from \"./rollup-plugins/rollup-plugin-gzip\" ;", "del_tokens": "import autoprefixer from \"autoprefixer\" ; import ts from \"@wessberg/rollup-plugin-ts\" ; import { gzip } from \"./rollup-plugins/rollup-plugin-gzip\" ; import scss from \"@csstools/postcss-sass\" ; scss ( ) ,", "commit_type": "add"}
{"commit_tokens": ["adding", "hackey", "way", "to", "do", "lists"], "add_tokens": "object : function ( objContract , options ) { // todo: how should this interact with frozen objects? if ( options && options . immutable ) { // fail if attempting to set an immutable object blame ( that . pos , this . oc , obj ) ; } if ( options && options . initPredicate && ! options . initPredicate ( obj ) ) { blame ( this . pos , this . oc , obj ) ; } } ) , List : combinators . object ( { length : combinators . flat ( function ( x ) { return typeof ( x ) === \"number\" ; } , \"Number\" ) } , { immutable : true , initPredicate : function ( obj ) { var i = 0 ; for ( ; i < obj . length ; i ++ ) { if ( obj [ i ] === undefined ) return false ; } return true ; } } )", "del_tokens": "object : function ( objContract ) { } )", "commit_type": "add"}
{"commit_tokens": ["Add", "clarity", "around", "what", "I", "want", "to", "refactor"], "add_tokens": "* TODO : refactor for clarity . eg : class name , ( class | instance ) methods", "del_tokens": "* TODO : refactor", "commit_type": "add"}
{"commit_tokens": ["removed", "unfreeze", "on", "resize", "menu", "option", "."], "add_tokens": "showTableView : false var appMenuToggleOptions = [ 'maxDepthSticky' , 'showFullNames' , 'showTableView' ] ;", "del_tokens": "showTableView : false , unfreezeOnResize : true var appMenuToggleOptions = [ 'maxDepthSticky' , 'showFullNames' , 'showTableView' , 'unfreezeOnResize' ] ; case 'unfreezeOnResize' : appOptions . unfreezeOnResize = ! appOptions . unfreezeOnResize ; break ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "support", "for", "having", "tr", "s", "or", "td", "s", "as", "component", "template", "containers", "."], "add_tokens": "function createFragment ( ) { var template = arguments . length <= 0 || arguments [ 0 ] === undefined ? '' : arguments [ 0 ] ; template = template . trim ( ) ; var parent = 'div' ; var $node ; if ( template . indexOf ( '<tr' ) === 0 ) { // table row parent = 'tbody' ; } else if ( template . indexOf ( '<td' ) === 0 ) { // table column parent = 'tr' ; } $node = document . createElement ( parent ) ; $node . innerHTML = template ; if ( $node . children . length !== 1 ) { throw new Error ( 'Component template must have a single parent node.' , template ) ; return $node . firstElementChild ; } function addComponentId ( template , id ) { var $comp = createFragment ( componentHtml ) ;", "del_tokens": "function addComponentId ( template , id ) { // in the browser throw an error if the component template // doesn't have a single parent. if ( typeof window !== 'undefined' ) { var div = document . createElement ( 'div' ) ; div . innerHTML = template ; if ( div . children . length !== 1 ) { throw new Error ( 'Component template must have a single parent node.' , template ) ; } var $comp = document . createElement ( 'div' ) ; $comp . innerHTML = componentHtml ; $comp = $comp . firstElementChild ;", "commit_type": "add"}
{"commit_tokens": ["adds", "unit", "tests", "for", "slash", "commands"], "add_tokens": "const responseUrlBase = 'https://interactive-buttons.slack-mock' nock ( responseUrlBase ) data . response_url = ` ${ responseUrlBase } ${ ++ commandNumber } ` function reply ( path , requestBody ) { url : ` ${ responseUrlBase } ${ path } ` ,", "del_tokens": "nock ( 'https://slack-mock/interactive-buttons' ) data . response_url = ` ${ ++ commandNumber } ` function reply ( uri , requestBody ) { url : ` ${ uri } ` ,", "commit_type": "add"}
{"commit_tokens": ["Updated", "grunt", "groc", "config", "the", "documented", "way", "of", "listing", "files", "didn", "t", "work"], "add_tokens": "docs : { options : { \"out\" : \"./docs/\" , \"glob\" : [ \"README.md\" , \"config.js\" , \"app.js\" , \"core/ghost.js\" , \"core/admin/assets/js/*.js\" , \"core/admin/assets/js/**/*.js\" , \"core/admin/controllers/*.js\" , \"core/frontend/**/*.js\" , \"core/lang/i18n.js\" , \"core/shared/**/*.js\" , \"core/shared/*.js\" , \"core/test/**/*.js\" , \"core/test/ghost.js\" ] }", "del_tokens": "application : [ \"README.md\" , \"config.js\" , \"app.js\" , \"core/ghost.js\" , \"core/admin/assets/js/*.js\" , \"core/admin/assets/js/models/*.js\" , \"core/admin/assets/js/views/*.js\" , \"core/admin/controllers/*.js\" , \"core/frontend/controllers/*.js\" , \"core/frontend/filters/*.js\" , \"core/frontend/helpers/*.js\" , \"core/lang/i18n.js\" , \"core/shared/models/*.js\" , \"core/shared/permissions/*.js\" , \"core/shared/*.js\" , \"core/test/ghost/*.js\" , \"core/test/ghost.js\" ] , options : { \"out\" : \"./docs/\"", "commit_type": "update"}
{"commit_tokens": ["Fixing", "up", "_recursivelyAddLayer", "to", "work", "correctly", ".", "This", "supports", "adding", "markers", "to", "existing", "clusters", "better", "."], "add_tokens": "return ; //TODO FIXME OBV position = this . _topClusterLevel . _recursivelyAddLayer ( layer , this . _topClusterLevel . _zoom ) ;", "del_tokens": "return ; //FIXME OBV position = this . _topClusterLevel . _recursivelyAddLayer ( layer ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "Function", "instead", "of", "eval"], "add_tokens": "var func = new Function ( compiler . compile ( this . tmplSrc , this . env ) ) ; var props = func ( ) ;", "del_tokens": "var src = compiler . compile ( this . tmplSrc , this . env ) ; var props = eval ( src ) ;", "commit_type": "use"}
{"commit_tokens": ["fixed", "test", "for", "map", "names", "."], "add_tokens": "name ,", "del_tokens": "name : { name } ,", "commit_type": "fix"}
{"commit_tokens": ["removed", "initial", "conersion", "effort", "files", "finished", "join", "clauses", "started", "JSONRaw", "to", "JSON", "parsing", "re", "-", "write"], "add_tokens": "return new this . relationQEntityConstructor ( this . relationQEntityConstructor , this . relationEntityConstructor , this . entityName , Relation_1 . QRelation . getNextChildJoinPosition ( this . q ) , this . fieldName , joinType ) ;", "del_tokens": "return new this . relationQEntityConstructor ( this . relationQEntityConstructor , this . relationEntityConstructor , this . entityName , this . q . getNextChildJoinPosition ( ) , this . fieldName , joinType ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "Useful", "techniques", "section", "to", "README"], "add_tokens": "if ( args [ i ] . length && args [ i ] . every ( function ( item ) {", "del_tokens": "if ( args [ i ] . every ( function ( item ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "bug", "that", "didn", "t", "allow", "callbacks", "to", "set", "a", "property"], "add_tokens": "if ( this . $textbox . val ( ) != this . model . get ( 'value' ) ) {", "del_tokens": "if ( ! this . user_invoked_update ) { this . user_invoked_update = true ; this . user_invoked_update = false ; this . user_invoked_update = true ; this . user_invoked_update = false ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "jshint", "happy", ":", "remove", "argument", "that", "is", "not", "used", "because", "we", "have", "arguments"], "add_tokens": "return function convertedJasmineMatcher ( ) {", "del_tokens": "return function convertedJasmineMatcher ( expected ) {", "commit_type": "make"}
{"commit_tokens": ["update", "how", "we", "deal", "with", "this", "/", "self"], "add_tokens": "'bart' : { 'surname' : 'simpson' , 'role' : 'clown' , 'siblings' : [ 'lisa' ] } ,", "del_tokens": "'bart' : { 'surname' : 'simpson' , 'role' : 'clown' } ,", "commit_type": "update"}
{"commit_tokens": ["Moved", "a", "few", "more", "functions", "from", "ToDo", "to", "src"], "add_tokens": "'../core/SPServices.utils' , constants , utils", "del_tokens": "'../src/core/SPServices.utils' , utils , constants", "commit_type": "move"}
{"commit_tokens": ["added", "extra", "context", "for", "templates"], "add_tokens": "mixin ( options , res . app . get ( 'stormpathTemplateContext' ) ) ; app . set ( 'stormpathSocial' , opts . social || JSON . parse ( process . env . STORMPATH_SOCIAL || '{}' ) || { } ) ; // Template data app . set ( 'stormpathTemplateContext' , opts . templateContext || JSON . parse ( process . env . STORMPATH_TEMPLATE_CONTEXT || '{}' ) || { } ) ;", "del_tokens": "app . set ( 'stormpathSocial' , opts . social || JSON . parse ( process . env . STORMPATH_SOCIAL || '{}' ) || { } )", "commit_type": "add"}
{"commit_tokens": ["Move", "source", "directory", "files", "to", "project", "root"], "add_tokens": ". concat ( require ( '../exceptions' ) . map ( ret ( 'EXCEPTION' ) ) )", "del_tokens": ". concat ( require ( '../source/exceptions' ) . map ( ret ( 'EXCEPTION' ) ) )", "commit_type": "move"}
{"commit_tokens": ["Add", "Base#precompile", "into", "server", "example"], "add_tokens": "app . use ( function ( req , res , next ) { // make sure our assets were compiled, so their `digestPath` // will be 100% correct, otherwise first request will produce // wrong digestPath. That's not a big deal, as assets will be // served anyway, but to keep everything correct, we use this // precompilation, which is similar to using manifest, but // without writing files on disk. // // See [[Base#precompile]] for details, environment . precompile ( [ 'app.js' , 'app.css' ] , function ( err ) { if ( err ) { next ( err ) ; return ; res . end ( view ( { // dummy `asset_path` helper asset_path : function ( pathname ) { return '/assets/' + environment . findAsset ( pathname ) . digestPath ; } } ) ) ; } ) ;", "del_tokens": "app . use ( function ( req , res ) { res . end ( view ( { // dummy `asset_path` helper asset_path : function ( pathname ) { return '/assets/' + environment . findAsset ( pathname ) . digestPath ; } ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "crash", "when", "trying", "to", "get", "/", "set", "power", "state"], "add_tokens": "this . hub . getCurrentActivity ( ) . then ( function ( currentActivity ) { callback ( currentActivity === self . id ) ; } ) . catch ( function ( err ) { setPowerState : function ( state ) { this . hub . startActivity ( self . id ) // callback(); onRead : function ( callback ) { self . getPowerState ( callback ) } ,", "del_tokens": "hub . getCurrentActivity ( ) . then ( function ( currentActivity ) { callback ( currentActivity . id === self . id ) ; } ) . except ( function ( err ) { setPowerState : function ( state , callback ) { // Activity id -1 is turn off all devices var id = state ? this . id : - 1 ; this . hub . startActivity ( id ) callback ( ) ; callback ( err ) ; callback ( ) ; onRead : self . getPowerState , module . exports . accessory = LogitechHarmonyAccessory ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "check", "to", "see", "if", "url", "contains", "http", "if", "not", "assume", "the", "wsdl", "is", "a", "local", "file", "and", "read", "it", ".", "Minor", "white", "-", "space", "fixes", "."], "add_tokens": "http = require ( './http' ) , fs = require ( 'fs' ) ; else if ( ! / ^http / . test ( url ) ) { fs . readFile ( url , 'ascii' , function ( err , data ) { if ( err ) { callback ( err ) } else { wsdl = new WSDL ( data ) ; _wsdlCache [ url ] = wsdl ; callback ( null , wsdl ) ; } } ) } this . _username = username ; this . _password = password ; \"<wsse:UsernameToken>\" + \"<wsse:Username>\" + this . _username + \"</wsse:Username>\" + \"<wsse:Password>\" + this . _password + \"</wsse:Password>\" + \"</wsse:UsernameToken>\" + \"</wsse:Security>\"", "del_tokens": "http = require ( './http' ) ; this . _username = username ; this . _password = password ; \"<wsse:UsernameToken>\" + \"<wsse:Username>\" + this . _username + \"</wsse:Username>\" + \"<wsse:Password>\" + this . _password + \"</wsse:Password>\" + \"</wsse:UsernameToken>\" + \"</wsse:Security>\"", "commit_type": "add"}
{"commit_tokens": ["Add", "jitGrunt", "mapping", "for", "npm", "publish"], "add_tokens": "coveralls : 'grunt-karma-coveralls' , 'npm-publish' : 'grunt-npm' ,", "del_tokens": "coveralls : 'grunt-karma-coveralls'", "commit_type": "add"}
{"commit_tokens": ["Added", "setting", "to", "turn", "automatic", "highlighting", "off", "and", "to", "set", "a", "default", "language"], "add_tokens": "|| [ , _ . defaultLanguage ] ) [ 1 ] , _ . defaultLanguage = script . getAttribute ( 'data-default-language' ) || null ; if ( ! script . hasAttribute ( 'data-manual' ) ) { if ( document . addEventListener ) { document . addEventListener ( 'DOMContentLoaded' , _ . highlightAll ) ; } else if ( window . attachEvent ) { attachEvent ( 'onload' , _ . highlightAll ) ; }", "del_tokens": "|| [ ] ) [ 1 ] , if ( document . addEventListener ) { document . addEventListener ( 'DOMContentLoaded' , _ . highlightAll ) ; } else if ( window . attachEvent ) { attachEvent ( 'onload' , _ . highlightAll ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "path", "instead", "of", "string", "concat"], "add_tokens": "const path = require ( 'path' ) const { graphql : config } = require ( path . join ( process . cwd ( ) , 'package.json' ) ) const schema = require ( path . join ( process . cwd ( ) , config . schema || 'package.json' ) )", "del_tokens": "const { graphql : config } = require ( ` ${ process . cwd ( ) } ` ) const schema = require ( config . schema || ` ${ process . cwd ( ) } ` )", "commit_type": "use"}
{"commit_tokens": ["Added", "some", "more", "range", "examples"], "add_tokens": "* range ( 3 , 7 ) // => [3, 4, 5, 6] * range ( 3 ) // => [0, 1, 2] * range ( ) // => [] * range ( NaN ) // => TypeError: Arguments should be Numbers", "del_tokens": "* const test = range ( 3 , 7 ) // => [3, 4, 5, 6] * const test = range ( 3 ) // => [0, 1, 2]", "commit_type": "add"}
{"commit_tokens": ["Implement", "infinite", "scrolling", "/", "autoplay", "carousel", "."], "add_tokens": "stage -- ; el . addEventListener ( 'touchend' , handleTouchEnd ) ;", "del_tokens": "stage = 0 ; el . addEventListener ( 'touchmove' , handleTouchMove ) ;", "commit_type": "implement"}
{"commit_tokens": ["Fixed", "EADDRINUSE", "issue", "when", "running", "sails", "debug"], "add_tokens": "var execArgs = process . execArgv . slice ( 0 ) ; if ( execArgs . indexOf ( '--debug' ) !== - 1 ) { execArgs . splice ( execArgs . indexOf ( '--debug' ) , 1 ) } stdio : 'pipe' , execArgv : execArgs", "del_tokens": "stdio : 'pipe'", "commit_type": "fix"}
{"commit_tokens": ["Remove", "storage", "of", "API", "events", "in", "flight", "recorder"], "add_tokens": "// Do not publish into the flight recorder // This needs to be re-established once performance issues are fixed //data = serializer.serialize(data); //agent.nativeEmit(topic, String(data));", "del_tokens": "data = serializer . serialize ( data ) ; agent . nativeEmit ( topic , String ( data ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Use", "utfx", "-", "embeddable", "for", "utf8", "encoding"], "add_tokens": "asc += b > 32 && b < 127 ? String . fromCharCode ( b ) : '.' ;", "del_tokens": "asc += b > 32 && b < 127 ? String . fromCodePoint ( b ) : '.' ;", "commit_type": "use"}
{"commit_tokens": ["updating", "for", "improved", "HomeStar", "API"], "add_tokens": "transporter . put ( { transporter . put ( {", "del_tokens": "transporter . update ( { transporter . update ( {", "commit_type": "update"}
{"commit_tokens": ["Updated", "user", "-", "agent", "string"], "add_tokens": "var USER_AGENT = exports . USER_AGENT = 'Avanza/se.avanza.iphone (2.12.0 - (#64); iOS 10.0.2)' ;", "del_tokens": "var USER_AGENT = exports . USER_AGENT = 'Avanza/se.avanza.iphone (2.6.2 - (#165); iOS 9.3.1)' ;", "commit_type": "update"}
{"commit_tokens": ["added", "more", "of", "the", "demo", "files"], "add_tokens": "open : 'http://localhost:<%= connect.options.port %>/index.html'", "del_tokens": "open : 'http://localhost:<%= connect.options.port %>/demo/tree-control.html'", "commit_type": "add"}
{"commit_tokens": ["Fixed", "some", "template", "weirdness", "."], "add_tokens": "return swig . compileFile ( 'login.html' ) . render ( { var view = swig . compileFile ( 'chat.html' ) . render ( { 'media_url' : self . config . media_url ,", "del_tokens": "this . template = ( function ( ) { // Template cache helper var cache = { } ; return function ( file ) { if ( ! cache [ file ] || config . debug == true ) { cache [ file ] = swig . compileFile ( file ) ; } return cache [ file ] ; } ; } ( ) ) ; return self . template ( 'login.html' ) . render ( { 'sitename' : self . config . sitename , var view = self . template ( 'chat.html' ) . render ( { 'media_url' : self . config . media_url , 'sitename' : self . config . sitename , 'page_title' : 'Development' , // 'js_templates': self.template('js-templates.html'),", "commit_type": "fix"}
{"commit_tokens": ["Added", "updateRefs", ".", "js", "."], "add_tokens": "const paths = require ( '../paths' ) ; const { resolveModulePath } = common ; const contextFilePath = ast . _filePath ; moduleSource = moduleSource . replace ( / \\.[jt]sx?$ / , '' ) ; if ( moduleSource && resolveModulePath ( contextFilePath , _ . get ( node , 'source.value' ) ) !== resolveModulePath ( contextFilePath , moduleSource ) ) return ; oldModuleSource = oldModuleSource . replace ( / \\.[jt]sx?$ / , '' ) ; newModuleSource = newModuleSource . replace ( / \\.[jt]sx?$ / , '' ) ; if ( ! newModuleSource . startsWith ( '.' ) ) newModuleSource = paths . relativeModuleSource ( ast . _filePath , newModuleSource ) ; const contextFilePath = ast . _filePath ; if ( node . source && resolveModulePath ( contextFilePath , node . source . value ) === resolveModulePath ( contextFilePath , oldModuleSource ) ) {", "del_tokens": "if ( moduleSource && _ . get ( node , 'source.value' ) !== moduleSource ) return ; if ( node . source && node . source . value === oldModuleSource ) {", "commit_type": "add"}
{"commit_tokens": ["Remove", "event", "triggers", "from", "DOMBars", ".", "In", "reality", "I", "don", "t", "know", "when", "it", "d", "be", "used", "(", "though", "it", "would", "be", "cool", ")", ".", "Let", "s", "just", "stick", "to", "features", "that", "people", "need", "for", "now", "."], "add_tokens": "/ ** * Return the current timestamp integer . * * @ return { Number } * / / ** * Keep local references to the timeout functions . This stops utilities like * Sinon . js from breaking the implementation . * * @ type { Function } * /", "del_tokens": "", "commit_type": "remove"}
{"commit_tokens": ["Fix", "for", "attribute", ".", "isIndexed", "and", "workaround", "for", "z", "===", "0", "issue"], "add_tokens": "// Ensure that fields are present before Object.seal() target : undefined , isIndexed : false , // Reserved for application userData : { } ,", "del_tokens": "// Reserved for application userData : { } , // buffer type target : undefined ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "for", "bug", "with", "server", "preprocessing"], "add_tokens": "var me = this ; serverPreProcessing : me . getServerPreProcessing ( request , reply ) , // if no rendered page, it means request was handled earlier somewhere (ex. serverPreprocess redirect) if ( ! renderedPage ) { return ; }", "del_tokens": "serverPreProcessing : getServerPreProcessing ( request , reply ) ,", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "bug", "-", "was", "no", "deep", "props", "copy"], "add_tokens": "//var assign = require('mini-assign'); var deepAssign = require ( 'mini-deep-assign' ) ; //if (Object.assign) { // Object.assign(target, source); //} else { deepAssign ( target , source ) ; //}", "del_tokens": "var object_assign = require ( 'mini-assign' ) ; if ( Object . assign ) { Object . assign ( target , source ) ; } else { object_assign ( target , source ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Added", "src", "items", "to", "index", "for", "exposing", "from", "the", "main", "module"], "add_tokens": "import DisposableStack from './src/DisposableStack' ; import PureView from './src/PureView' ; import Store from './src/Store' ; import View from './src/View' ; Dispatcher , DisposableStack , PureView , Store , View } ;", "del_tokens": "Dispatcher : Dispatcher } ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "formular", "for", "the", "logistic", "regression", "vectorized", "cost", "function", "fixing", "issue", "with", "regularization", "parameter", "inclusion"], "add_tokens": "* J ( Θ) 1 / m og( 1 / ( 1 + e ^ - X Θ)) ' y + log(1-(1/1+e^-XΘ))'(1- y ) ] d a g(Θ) λ )' Θ /2 m * J ( Θ) 1 / m og( s igmoid) ' y + log(1-sigmoid)'( 1 - y ) d iag( Θ )λ ) 'Θ / 2 . multiply ( theta ) . div ( 2 * m ) . e ( 1 , 1 ) ;", "del_tokens": "* J ( Θ) 1 / m log( 1 / ( 1 + e ^ - X Θ)) + ( - y ) l o g(1 - ( 1 / 1 + e ^ - X Θ )) ] d a g(Θ) λ )' Θ /2 m * J ( Θ) 1 / m log( s igmoid) 1 - y ) l og( 1 - s igmoid) d iag( Θ )λ ) 'Θ / 2 . multiply ( theta ) . div ( 2 * m ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "option", "for", "line", "width", "refactoring"], "add_tokens": "ctx . lineWidth = options . lineWidth ;", "del_tokens": "//if (rightNodes){ //} //if (rightNodes){ //} //aboveNodes = VTree.get(ll); //if (aboveNodes){ //}", "commit_type": "add"}
{"commit_tokens": ["Fix", "interpolate", "example", "on", "Android"], "add_tokens": "const transX = new Value ( 0 ) ;", "del_tokens": "const transX = new Value ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "typo", "in", "test", "leading", "to", "global", "leak", "."], "add_tokens": "var form ;", "del_tokens": "var from ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "stdin", "and", "stdout", "dependencies"], "add_tokens": "const args = require ( 'argh' ) . argv ; const gatherStream = require ( 'gather-stream' ) ; readFileStdin ( input , function ( error , data ) { writeFileStdout ( output , result . css ) ; function readFileStdin ( file , callback ) { if ( 'function' == typeof file ) callback = file , file = null ; const stream = file ? fs . createReadStream ( file ) : process . stdin ; stream . pipe ( gatherStream ( callback ) ) ; } function writeFileStdout ( file , contents ) { if ( 1 === arguments . length ) contents = file , file = null ; // eslint-disable-next-line no-sync if ( file ) return fs . writeFileSync ( file , contents ) ; process . stdout . write ( contents ) ; }", "del_tokens": "const read = require ( 'read-file-stdin' ) ; const write = require ( 'write-file-stdout' ) ; const args = require ( 'argh' ) . argv ; read ( input , function ( error , data ) { write ( output , result . css ) ;", "commit_type": "remove"}
{"commit_tokens": ["moved", "test", "from", "app", "to", "interface"], "add_tokens": "", "del_tokens": "λ: , var λ unction ) } ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "require", "paths", "that", "were", "broken", "by", "plugin", "id", "changes"], "add_tokens": "Camera = require ( 'org.apache.cordova.core.camera.Camera' ) , CameraPopoverHandle = require ( 'org.apache.cordova.core.camera.CameraPopoverHandle' ) ;", "del_tokens": "Camera = require ( 'org.apache.cordova.core.CameraLauncher.Camera' ) , CameraPopoverHandle = require ( 'org.apache.cordova.core.CameraLauncher.CameraPopoverHandle' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Create", "AsyncError", "and", "wrap", "domain", "error", "in", "it", ".", "Move", "error", "logging", "to", "error", "handler", "."], "add_tokens": "* a . k . a . the routes , logic , etc . of your web application . * Simply setup the application exactly as you would when using express directly .", "del_tokens": "* a . k . a . the routes , logic , etc . of your web application", "commit_type": "create"}
{"commit_tokens": ["Use", "CLI_TOOLKIT_SUPPRESS_HELP", "for", "test", "env", "."], "add_tokens": "if ( process . env . CLI_TOOLKIT_SUPPRESS_HELP ) {", "del_tokens": "if ( process . env . NODE_ENV === 'test' && ! process . env . DEBUG ) {", "commit_type": "use"}
{"commit_tokens": ["Add", "support", "for", "multiple", "markup"], "add_tokens": "cssPath = require . resolve ( 'github-markdown-css' ) , convert = require ( './convert' ) ; var info = path . parse ( filename ) ; var text = fs . readFileSync ( filename , 'utf8' ) , type = info . ext . substr ( 1 ) , content = convert ( type , text ) ; var html = tplText . substr ( 0 ) ; html = html . replace ( '{{filename}}' , info . base ) ;", "del_tokens": "markdown = require ( 'marked' ) , cssPath = require . resolve ( 'github-markdown-css' ) ; var html = tplText . substr ( 0 ) ; html = html . replace ( '{{filename}}' , path . basename ( filename ) ) ; var content = markdown ( fs . readFileSync ( filename , 'utf8' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "the", "regex", "in", "expected", "body"], "add_tokens": "var spclIn = er . content . indexOf ( spcl ) , isSpcl = true ;", "del_tokens": "var spclIn = er . content . indexOf ( spcl ) , isSpcl = ( spclIn !== - 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "content", "type", "integration", "test"], "add_tokens": "'order' : 'name' , 'sys.id[in]' : 'cat,dog,human'", "del_tokens": "'order' : 'name'", "commit_type": "fix"}
{"commit_tokens": ["Added", "component", "generator", "for", "entire", "folder", "."], "add_tokens": "this . generated = \"window.\" + name + \" = (function(window,baseType){\\n\\n window.Templates.jsonML[\\\"\" + name + \".template\\\"] = \\n \" + result + \";\\n\\n (function(window,WebAtoms){\\n \" + tags . toScript ( ) + \"\\n }).call(WebAtoms.PageSetup,window,WebAtoms);\\n\\n return classCreatorEx({\\n name: \\\"\" + name + \"\\\",\\n base: baseType,\\n start: function(e){\\n \" + startScript + \"\\n },\\n methods:{},\\n properties:{}\\n })\\n })(window, \" + type + \".prototype);\\r\\n\" ; node . compile ( ) ;", "del_tokens": "this . generated = \"window.\" + name + \" = (function(window,baseType){\\n\\n window.Templates.jsonML[\\\"\" + name + \".template\\\"] = \\n \" + result + \";\\n\\n (function(window,WebAtoms){\\n \" + tags . toScript ( ) + \"\\n }).call(WebAtoms.PageSetup,window,WebAtoms);\\n\\n return classCreatorEx({\\n name: \\\"\" + name + \"\\\",\\n base: baseType,\\n start: function(e){\\n \" + startScript + \"\\n },\\n methods:{},\\n properties:{}\\n })\\n })(window, \" + type + \".prototype)\" ;", "commit_type": "add"}
{"commit_tokens": ["allowing", "array", "for", "hasChild", "index"], "add_tokens": "var child = Array . isArray ( index ) ? deepChild ( node , index ) : node . children [ index ] ; assert ( typeof child !== 'undefined' , 'child does not exist at the given index ' + index ) ; / ** * Retrieve a deep child via an input array ` ` of indices to traverse . * * @ param { Object } node The virtual node to traverse . * @ param { Array : Number } path The path to traverse . * @ return { Object } * / function deepChild ( root , path ) { return path . reduce ( function ( node , index , x ) { assert ( index in node . children , 'child does not exist at the given deep index ' + path . join ( '.' ) ) ; return node . children [ index ] ; } , root ) ; }", "del_tokens": "assert ( typeof index === 'number' , 'provided index is not a number' ) ; assert ( index >= 0 , 'provided index cannot be negative' ) ; var child = node . children [ index ] ; assert ( typeof child !== 'undefined' , 'child does not exist at the given index' ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "code", "to", "work", "in", "Edge"], "add_tokens": "el . parentNode . replaceChild ( textNode , el ) ;", "del_tokens": "el . replaceWith ( textNode ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "complexity", "to", "Action", "methods", "."], "add_tokens": "'dummy_bastof_nr_members' : function ( nr ) { return nr } , 'dummy_nr_teams_xpto_str' : function ( nr , arg1 , arg2 , str ) { return { 'nr' : nr , 'arg1' : arg1 , 'arg2' : arg2 , 'str' : str 'xone_stuff' : function ( stuff , req , next ) {", "del_tokens": "'dummy_nr_members' : function ( nr ) { return nr } , 'dummy_nr_teams' : function ( nr , arg1 , arg2 ) { return { 'nr' : nr , 'arg1' : arg1 , 'arg2' : arg2 'xone_stuff' : function ( req , next ) {", "commit_type": "add"}
{"commit_tokens": ["allows", "html", "updates", "to", "be", "queued", "multiple", "times", "within", "a", "batch"], "add_tokens": "function updateNodeList ( data , frag , nodeListUpdatedByFn ) { if ( data . nodeList . isUnregistered !== true ) { // We need to keep oldNodes up to date with the last fragment so if this // function runs again, we can replace the oldNodes with frag var newChildren = canReflect . toArray ( childNodes ( frag ) ) ; nodeLists . update ( data . nodeList , newChildren , data . oldNodes ) ; var oldNodes = data . oldNodes ; data . oldNodes = newChildren ; data . oldNodes = nodeLists . unregisterChildren ( nodes , true ) ; queues . domUIQueue . enqueue ( updateNodeList , null , [ data , frag , nodeListUpdatedByFn ] , meta ) ; data . oldNodes = nodeLists . update ( nodes , childNodes ( frag ) ) ; nodeLists . replace ( data . oldNodes , frag ) ;", "del_tokens": "function updateNodeList ( oldNodes , nodes , frag , nodeListUpdatedByFn ) { if ( nodes . isUnregistered !== true ) { nodeLists . update ( nodes , childNodes ( frag ) , oldNodes ) ; var oldNodes ; oldNodes = nodeLists . unregisterChildren ( nodes , true ) ; queues . domUIQueue . enqueue ( updateNodeList , null , [ oldNodes , nodes , frag , nodeListUpdatedByFn ] , meta ) ; oldNodes = nodeLists . update ( nodes , childNodes ( frag ) ) ; nodeLists . replace ( oldNodes , frag ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "freeze", "feature", "and", "configs"], "add_tokens": ". opt ( ) . name ( 'freeze' ) . title ( 'Freeze' ) . short ( 'f' ) . long ( 'freeze' ) . def ( 'yes' ) . val ( function ( f ) { return ( f == 'yes' || f == 'no' ) ? f : 'yes' ; } ) . end ( ) var t = opts . tech , tech ; t = PATH . basename ( t ) === t ? PATH . join ( __dirname , 'techs' , t + '.js' ) : PATH . resolve ( t ) ; tech = new ( require ( t ) . Tech ) ( opts ) ; return tech . createFile ( opts . input )", "del_tokens": ". val ( function ( t ) { t = / ^[^.][^\\/]*$ / g . test ( t ) ? PATH . join ( __dirname , 'techs' , t + '.js' ) : PATH . resolve ( t ) ; return new ( require ( t ) . Tech ) ( ) } ) return opts . tech . createFile ( opts . input )", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "the", "lib", "works", "with", "a", "name", "property"], "add_tokens": "if ( body . name && body . url && body . standard ) { name : body . name , name : 'NPG Home' ,", "del_tokens": "if ( body . url && body . standard ) {", "commit_type": "make"}
{"commit_tokens": ["Fixed", "misplaced", "tab", "in", "fetchAsObject", "method"], "add_tokens": "fetchAsObject : function ( ) { xmla_cells . nextCell ( ) ; } ,", "del_tokens": "fetchA sObject : function ( ) { xmla_cells . nextCell ( ) ; } ,", "commit_type": "fix"}
{"commit_tokens": ["fixing", "liquid", "-", "if", "context"], "add_tokens": "liquidParent : this , contextBinding : 'liquidParent.context'", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["Fix", "kss", "task", "test", "."], "add_tokens": "options : { homepage : 'homepage.md' , verbose : true } , src : [ 'node_modules/kss/demo' ] , dest : 'test/tmp_dist' } ;", "del_tokens": "files : { // dest : src 'test/tmp_dist' : [ 'test/fixtures' ] } } ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "ordering", "work", "for", "commands"], "add_tokens": "// Sort items alphabetically items . sort ( ( a , b ) => { const isCmd = kind == 'commands' let first = isCmd ? a . usage : a . usage [ 1 ] , second = isCmd ? b . usage : b . usage [ 1 ] if ( first < second ) return - 1 if ( first > second ) return 1 return 0 } ) // Before doing that, make a copy of the original array const longest = items . slice ( ) . sort ( ( a , b ) => {", "del_tokens": "const longest = items . sort ( ( a , b ) => { items . sort ( ( a , b ) => { let first = a . usage . split ( '-' ) [ 3 ] , second = b . usage . split ( '-' ) [ 3 ] if ( first < second ) return - 1 if ( first > second ) return 1 return 0 } )", "commit_type": "make"}
{"commit_tokens": ["made", "flex", "set", "as", "simple", "property"], "add_tokens": "set : function ( v ) { this . _setProperty ( 'flex' , v ) ; } , get : function ( ) { return this . getPropertyValue ( 'flex' ) ; } ,", "del_tokens": "var shorthandParser = require ( '../parsers' ) . shorthandParser ; var shorthandSetter = require ( '../parsers' ) . shorthandSetter ; var shorthandGetter = require ( '../parsers' ) . shorthandGetter ; var shorthand_for = { 'flex-grow' : require ( './flexGrow' ) , 'flex-shrink' : require ( './flexShrink' ) , 'flex-basis' : require ( './flexBasis' ) , } ; module . exports . isValid = function isValid ( v ) { return shorthandParser ( v , shorthand_for ) !== undefined ; } ; set : shorthandSetter ( 'flex' , shorthand_for ) , get : shorthandGetter ( 'flex' , shorthand_for ) ,", "commit_type": "make"}
{"commit_tokens": ["Removes", "all", "any", "types", "for", "stricter", "ones"], "add_tokens": "* If the middleware function does not declare receiving the ` ` callback * assume that it ' * completion will stall . * the ` ` callback function .", "del_tokens": "* If the middleware function does declare receiving the ` ` callback * assume that it ' * completion will stall * the ` ` callback function", "commit_type": "remove"}
{"commit_tokens": ["Make", "object", "inspector", "width", "draggable"], "add_tokens": "classNameBindings : [ 'inactive:app_state_inactive' , 'controller.inspectorExpanded:app_inspector_expanded' , 'controller.isDragging:app_state_dragging' ] , } , inspectorStyle : function ( ) { if ( this . get ( 'controller.inspectorExpanded' ) ) { return 'width: ' + this . get ( 'controller.inspectorWidth' ) + 'px;' ; } else { return '' ; } } . property ( 'controller.inspectorWidth' , 'controller.inspectorExpanded' )", "del_tokens": "classNameBindings : [ 'inactive:app_state_inactive' , 'controller.inspectorExpanded:app_inspector_expanded' ] , }", "commit_type": "make"}
{"commit_tokens": ["Update", "to", "AGI", "(", "channel", "command", "commandId", ")", "to", "set", "the", "correct", "channel", "variables", "removed", "Conference", "and", "ChannelID", "as", "I", "have", "no", "idear", "where", "they", "should", "come", "from"], "add_tokens": "this . set ( 'Command' , command ) ; this . set ( 'CommandID' , commandId ) ;", "del_tokens": "this . set ( 'Conference' , conference ) ; this . set ( 'ChannelID' , channelId ) ;", "commit_type": "update"}
{"commit_tokens": ["Using", "a", "prefix", "for", "CSS", "classes", "and", "ids", "(", "category", "was", "missing", "the", "prefix", ")", "."], "add_tokens": "{ ftid : \"turn-1\" , description : \"turn-1-desc\" , begin : 8 , end : 59 , evidence : { type : \"ECO:0000218\" , source : { ref : \"23\" } } } , { ftid : \"turn-2\" , description : \"turn-2-desc\" , begin : 18 , end : 69 , evidence : { type : \"ECO:0000203\" , source : { dbReferenceType : \"MIM\" , dbReferenceId : \"123\" } } } , { ftid : \"turn-3\" , description : \"turn-3-desc\" , begin : 28 , end : 79 , evidence : { type : \"ECO:0000203\" , source : { dbReferenceType : \"MIM\" , dbReferenceId : \"123\" } } }", "del_tokens": "{ ftid : \"turn-1\" , description : \"turn-1-desc\" , begin : 8 , end : 59 }", "commit_type": "use"}
{"commit_tokens": ["fix", "bug", "in", "#eachFragment", "helper"], "add_tokens": "var p = hbp ( pattern ) ; frame = p ? frame : pattern ; var rg = selectFragments ( p , this ) ;", "del_tokens": "pattern = hbp ( pattern ) ; frame = pattern ? frame : pattern ; var rg = selectFragments ( pattern , this ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "typo", "exists", "in", "help", "command", "changed", "to", "exits"], "add_tokens": ". description ( \"Exits instance of Vantage.\" )", "del_tokens": ". description ( \"Exists instance of Vantage.\" )", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "Google", "service", "accounts", "."], "add_tokens": "var jwt = require ( 'jsonwebtoken' ) ; if ( options && options . service ) { if ( ! options . scope || ! options . privateKey || ! options . user ) { throw new Error ( 'Options \"scope\", \"privateKey\" and \"user\" are required for service account!' ) ; } var serviceRequestTimeout = Math . min ( Math . max ( Number ( this . options . serviceRequestTimeout ) || 0 , 0 ) , 3600 ) ; this . options . serviceRequestTimeout = serviceRequestTimeout || 5 * 60 ; } var urlOptions ; if ( this . options . service ) { // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount var iat = Math . floor ( Date . now ( ) / 1000 ) ; // unix time var token = jwt . sign ( { iss : this . options . service , scope : this . options . scope , sub : this . options . user , aud : this . options . accessUrl , iat : iat , exp : iat + this . options . serviceRequestTimeout , } , this . options . privateKey , { algorithm : 'RS256' } ) ; urlOptions = { grant_type : 'urn:ietf:params:oauth:grant-type:jwt-bearer' , assertion : token } ; } else { // web app - https://developers.google.com/identity/protocols/OAuth2WebServer urlOptions = { }", "del_tokens": "var urlOptions = {", "commit_type": "add"}
{"commit_tokens": ["Updated", "connector", "to", "work", "with", "latest", "loopback", "-", "datasource", "-", "juggler", "node", "-", "sqlite3", "."], "add_tokens": "SQLiteDB . prototype . all = function all ( model , filter , options , callback ) { if ( callback === undefined && options === undefined && typeof filter === 'function' ) { callback = filter ; filter = [ ] ; options = { } ; } if ( callback === undefined && typeof options === 'function' ) { callback = options ; options = { } ; } if ( self . current_order . indexOf ( filter . where . id . inq [ i ] ) < 0 ) self . current_order . push ( filter . where . id . inq [ i ] ) ;", "del_tokens": "SQLiteDB . prototype . all = function all ( model , filter , callback ) { self . current_order . push ( filter . where . id . inq [ i ] )", "commit_type": "update"}
{"commit_tokens": ["add", "title", "to", "server", "start", "message"], "add_tokens": "title : 'Start ' + packageName + ' ' + programVersion , host : ( process . env . SPM_REPORTED_HOSTNAME || os . hostname ( ) ) , message : 'Start ' + packageName + ' ' + programVersion + ' / ' + ' on ' + ( process . env . SPM_REPORTED_HOSTNAME || os . hostname ( ) ) ,", "del_tokens": "message : info ,", "commit_type": "add"}
{"commit_tokens": ["Add", "download", "button", "for", "history", "graph"], "add_tokens": "this . svg_g . attr ( \"transform\" , \"translate(\" + ( - bbox . x + 5 ) + \", \" + ( - bbox . y + 5 ) + \")\" ) ; . attr ( \"width\" , bbox . width + 10 ) . attr ( \"height\" , bbox . height + 10 )", "del_tokens": "this . svg_g . attr ( \"transform\" , \"translate(\" + ( - bbox . x ) + \", \" + ( - bbox . y ) + \")\" ) ; . attr ( \"width\" , bbox . width ) . attr ( \"height\" , bbox . height )", "commit_type": "add"}
{"commit_tokens": ["added", "SQL", "hook", "implementation", "at", "the", "model", "level"], "add_tokens": "var tableName , tableKey , id , done ; if ( ! this . enabled ) { return done && done ( new Error ( 'Crux.cache is disabled' ) ) ; } if ( ! this . enabled ) { return done && done ( new Error ( 'Crux.cache is disabled' ) ) ; } if ( ! this . enabled ) { return done ( new Error ( 'Crux.cache is disabled' ) ) ; }", "del_tokens": "var self = this , tableName , tableKey , id , done ;", "commit_type": "add"}
{"commit_tokens": ["adding", "the", "watch", "option", "for", "tests"], "add_tokens": "grunt . loadNpmTasks ( 'grunt-mocha-test' ) ; grunt . loadNpmTasks ( 'grunt-contrib-watch' ) ; grunt . initConfig ( { mochaTest : { test : { options : { reporter : 'spec' } , src : [ 'test/**/*.js' ] } } , watch : { files : [ 'src/**/*.js' , 'test/**/*.js' ] , tasks : [ 'mochaTest' ] } , } ) ; grunt . registerTask ( 'default' , 'mochaTest' ) ;", "del_tokens": "grunt . loadNpmTasks ( 'grunt-mocha-test' ) ; grunt . initConfig ( { mochaTest : { test : { options : { reporter : 'spec' } , src : [ 'src/**/*.js' , 'test/**/*.js' ] } } } ) ; grunt . registerTask ( 'default' , 'mochaTest' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "sine", ".", "Also", "added", "some", "debugging", "stuff", "since", "the", "parser", "has", "a", "lot", "of", "bugs", "."], "add_tokens": "var sys = require ( 'util' ) ;", "del_tokens": "var sys = require ( 'sys' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Moved", "the", "configuration", "files", "to", "a", "dedicated", "folder"], "add_tokens": "out : join ( __dirname , '../doc/api' )", "del_tokens": "out : join ( __dirname , 'api' )", "commit_type": "move"}
{"commit_tokens": ["Added", "the", "ability", "to", "pass", "options", "to", "LDClient", ".", "initialize", "()"], "add_tokens": "exports . default = function ( clientSideId , reduxStore , user , options ) { window . ldClient = _ldclientJs2 . default . initialize ( clientSideId , user , options ) ;", "del_tokens": "exports . default = function ( clientSideId , reduxStore , user ) { window . ldClient = _ldclientJs2 . default . initialize ( clientSideId , user ) ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "unused", "selectors", "from", "prepare", "layout", "function"], "add_tokens": "sidebarSlimScroll : true , var sidebar_height = $ ( \".sidebar\" ) . height ( ) ; $ ( \".content-wrapper, .right-side\" ) . css ( 'min-height' , window_height - neg ) ; $ ( \".content-wrapper, .right-side\" ) . css ( 'min-height' , sidebar_height ) ;", "del_tokens": "sidebarSlimScroll : false , var sidebar_height = $ ( \".main-sidebar, .left-side\" ) . height ( ) ; $ ( \".content-wrapper, .main-sidebar, .left-side, .right-side\" ) . css ( 'min-height' , window_height - neg ) ; $ ( \".content-wrapper, .main-sidebar, .left-side, .right-side\" ) . css ( 'min-height' , sidebar_height ) ;", "commit_type": "remove"}
{"commit_tokens": ["made", "done", "in", "test", "optional"], "add_tokens": "done && done ( ) ;", "del_tokens": "done ( ) ;", "commit_type": "make"}
{"commit_tokens": ["add", "a", "flow", "after", "upload", "file", "success"], "add_tokens": "owner . request ( 'after-send-file' , [ file , ret , headers ] , function ( ) { file . setStatus ( Status . COMPLETE ) ; owner . trigger ( 'uploadComplete' , file ) ; tr . destroy ( ) ; } ) . fail ( function ( reason ) { tr . trigger ( 'error' , reason ) ; } ) ;", "del_tokens": "file . setStatus ( Status . COMPLETE ) ; owner . trigger ( 'uploadComplete' , file ) ; tr . destroy ( ) ;", "commit_type": "add"}
{"commit_tokens": ["updated", ":", "restored", "the", "wip", "keyword", "for", "the", "compiler", "in", "the", "lib", "folder"], "add_tokens": "* The riot - compiler WIP * @ version WIP version : 'WIP'", "del_tokens": "* The riot - compiler v2 .5 .0 * @ version v2 .5 .0 version : 'v2.5.0'", "commit_type": "update"}
{"commit_tokens": ["Fix", "up", "popover", "and", "add", "simple", "scrollspy", "."], "add_tokens": "var layout = el . data ( 'layout' ) || 'tooltip' , region = el . region ( ) , popoverContent = layout == 'tooltip' ? el . data ( 'tooltip' ) : '<h3 class=\"popover-title\">' + el . data ( 'title' ) + '</h3><div class=\"popover-content\">' + el . data ( 'tooltip' ) + '</div>' , tooltip = nwt . node . create ( '<div class=\"' + layout + ' fade ' + placement + ' in\" style=\"display:block;\"><div class=\"arrow ' + layout + '-arrow\"></div><div class=\"' + layout + '-inner\">' + popoverContent + '</div></div>' ) , case 'left' : top = region . top + ( region . height - tipRegion . height ) / 2 top = region . top + ( region . height - tipRegion . height ) / 2", "del_tokens": "var region = el . region ( ) , tooltip = nwt . node . create ( '<div class=\"tooltip fade ' + placement + ' in\" style=\"display:block;\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\">' + el . data ( 'tooltip' ) + '</div></div>' ) , case 'left' : top = region . top - ( region . height / 2 ) top = region . top - ( region . height / 2 )", "commit_type": "fix"}
{"commit_tokens": ["fixing", "small", "introduced", "bugs", "and", "a", "bit", "of", "documentation"], "add_tokens": "if ( y instanceof Array || y instanceof Float64Array ) {", "del_tokens": "if ( y instanceof Array ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "programtransformer", "&", "test", ".", "html"], "add_tokens": "return ClassTransformer . transform ( this . reporter_ , tree ) ;", "del_tokens": "return ClassTransformer . transform ( this . reporter_ , this . project_ , tree ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "getIdentifier", "to", "getIdentifierName", "added", "a", "few", "specs"], "add_tokens": "var name = Breakneck . getIdentifierName ( fn [ 0 ] ) , * Gets the name of whatever identifier is associated with this node ( if any ) . Breakneck . getIdentifierName = function ( node ) { case 'Identifier' : return node . name ; case 'AssignmentExpression' : return Breakneck . getIdentifierName ( node . left ) ; case 'MemberExpression' : return Breakneck . getIdentifierName ( node . property ) ; case 'FunctionDeclaration' : return node . id . name ; case 'VariableDeclaration' : return node . declarations [ 0 ] . id . name ; case 'VariableDeclarator' : return node . id . name ; case 'ExpressionStatement' : return Breakneck . getIdentifierName ( node . expression ) ;", "del_tokens": "var name = Breakneck . getIdentifier ( fn [ 0 ] ) . name , * Gets an identifier from a node . Breakneck . getIdentifier = function ( node ) { case 'Identifier' : return node ; case 'MemberExpression' : return Breakneck . getIdentifier ( node . property ) ; case 'FunctionDeclaration' : return node . id ;", "commit_type": "update"}
{"commit_tokens": ["added", "incremental", "values", "for", "NumberController"], "add_tokens": "var amt ; ( arguments [ 4 ] != null ) ? amt = arguments [ 4 ] : amt = ( max - min ) * .01 ; if ( amt == 0 ) amt = 1 ; ( inc >= max ) ? inc = max : inc += amt ; ( inc <= min ) ? inc = min : inc -= amt ;", "del_tokens": "( inc >= max ) ? inc = max : inc ++ ; ( inc <= min ) ? inc = min : inc -- ;", "commit_type": "add"}
{"commit_tokens": ["Add", "tricks", "to", "handle", "class", "-", "defining", "functions"], "add_tokens": "}", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["add", "a", "test", "for", "planned", "async", "assertion"], "add_tokens": "ava ( function ( a ) { ava ( function ( a ) { test ( 'planned async assertion' , function ( t ) { ava ( function ( a ) { a . plan ( 1 ) ; setTimeout ( function ( ) { a . pass ( ) ; } , 100 ) ; } ) . run ( function ( err ) { t . error ( err ) ; t . end ( ) ; } ) ; } ) ;", "del_tokens": "ava ( 'foo' , function ( a ) { ava ( 'foo' , function ( a ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "babel", "polyfill", "and", "fix", "compilation", "errors", "for", "babel", "example"], "add_tokens": "export const hello = ( event , context , cb ) => { const p = new Promise ( ( resolve , reject ) => { resolve ( 'success' ) ; } ) ; p . then ( r => cb ( null , { message : 'Go Serverless Webpack (Babel) v1.0! Your function executed successfully!' , event , } ) ) . catch ( e => cb ( e ) ) ; } ;", "del_tokens": "export const hello = ( event , context , cb ) => cb ( null , { message : 'Go Serverless Webpack (Babel) v1.0! Your function executed successfully!' , event } ) ;", "commit_type": "add"}
{"commit_tokens": ["Moved", "test", "to", "demo", "added", "tests", "and", "fixed", "code", "."], "add_tokens": ". replace ( / ''' / g , '\\u2034' ) // triple prime . replace ( / '' / g , '\\u2033' ) // double prime var TEXT_NODE = Element . TEXT_NODE || 3 ; if ( node . nodeType === TEXT_NODE ) {", "del_tokens": ". replace ( / ''' / g , '\\u2034' ) // triple prime . replace ( / (\"|'') / g , '\\u2033' ) // double prime if ( node . nodeType === Element . TEXT_NODE ) {", "commit_type": "move"}
{"commit_tokens": ["fixed", "path", "to", "inmem", "storage", "for", "doccu"], "add_tokens": "'lib/storage/inMemory/storage.js' ] ,", "del_tokens": "'storage/inMemory/storage.js' ] ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "callback", "management", "when", "exception", "occurs"], "add_tokens": "telegramLink . connect ( function ( e ) { if ( e ) { console . log ( 'Connection error: %s' , e ) ; done ( ) ; return ; } if ( ex ) { console . log ( 'Authorization KO: %s' , ex ) ; telegramLink . end ( ) ; } else { console . log ( 'Authorization OK' ) ; telegramLink . end ( ) ; } ( ! ex ) . should . be . true ; done ( ) ;", "del_tokens": "telegramLink . connect ( function ( ) { if ( ex ) console . log ( 'Authorization KO: %s' , ex ) ; else console . log ( 'Authorization OK' ) ; telegramLink . end ( function ( ex ) { if ( ex ) console . log ( ex ) ; done ( ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "end", "event", "on", "watch"], "add_tokens": "should ( watch . isRunning ( ) ) . be . true ; should ( watch . updateTime ( ) ) . be . undefined ; // make tests run fast var called = { } ; called . error = true ; called . cancel = true ; called . change = true ; watch . on ( 'end' , function ( ) { called . should . have . property ( 'cancel' , true ) ; called . should . have . property ( 'change' , true ) ; called . should . have . property ( 'error' , true ) ; done ( ) ; } ) ;", "del_tokens": "done ( ) ; should ( watch . isRunning ( ) ) . be . true ; should ( watch . updateTime ( ) ) . be . undefined ;", "commit_type": "add"}
{"commit_tokens": ["Add", "install", "&", "release", "scripts"], "add_tokens": "! ~ process . argv . indexOf ( '--version' ) && console . log ( `", "del_tokens": "console . log ( `", "commit_type": "add"}
{"commit_tokens": ["remove", "dead", "variable", "from", "Logger", ".", "makeRecord"], "add_tokens": "makeRecord : function makeRecord ( name , level , msg ) { return new Record ( name , level , msg ) ; var record = this . makeRecord ( this . _name , level , args ) ;", "del_tokens": "makeRecord : function makeRecord ( name , level , msg , args ) { return new Record ( name , level , msg , args ) ; var record ; record = this . makeRecord ( this . _name , level , args ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "standard", "errors", "in", "test", "/", "vec3"], "add_tokens": "if ( handledMethods . indexOf ( name ) === - 1 ) {", "del_tokens": "if ( handledMethods . indexOf ( name ) == - 1 ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "the", "viewModel", "-", ">", "ViewModel", "warning"], "add_tokens": "// Define the ViewModel arg : \"ViewModel\" , \"\\tvar ViewModel = __interop(typeof ViewModel !== 'undefined' ? ViewModel : undefined);\\n\" + \"\\t\\tViewModel: ViewModel,\\n\" +", "del_tokens": "// Define the viewModel arg : \"viewModel\" , \"\\tvar viewModel = __interop(typeof viewModel !== 'undefined' ? viewModel : undefined);\\n\" + \"\\t\\tviewModel: viewModel,\\n\" + \"\\t\\tviewModel: viewModel\\n\" +", "commit_type": "fix"}
{"commit_tokens": ["Updated", "service", "url", "and", "commented", "out", "variation", "for", "now", "."], "add_tokens": "// addCategory(CategoryFactory.createCategory(d.variants, 'variant', fv));", "del_tokens": "addCategory ( CategoryFactory . createCategory ( d . variants , 'variant' , fv ) ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "events", "for", "all", "types"], "add_tokens": "this . emit ( 'callback' , timeline ) this . emit ( 'callback' , timeline ) this . emit ( 'callback' , timeline ) this . emit ( 'callback' , timeline )", "del_tokens": "if ( this . callback ) { this . callback ( timeline ) } if ( this . callback ) { this . callback ( timeline ) } if ( this . callback ) { this . callback ( timeline ) } if ( this . callback ) { this . callback ( timeline ) }", "commit_type": "fix"}
{"commit_tokens": ["fix", "internal", "forOf", "helper", "on", "entries", "and", "primitives"], "add_tokens": "if ( entries ) { assertObject ( value ) ; return fn ( value [ 0 ] , value [ 1 ] ) ; } return fn ( value ) ;", "del_tokens": "return entries ? fn ( value [ 0 ] , value [ 1 ] ) : fn ( value ) ;", "commit_type": "fix"}
{"commit_tokens": ["removed", "non", "-", "conforming", "text", "position", "command"], "add_tokens": "var newRow , rowHeaderCell , p , cx , cy , cellHeight , cornerCell , y , x , c , h , w , s , end ; ctx . textBaseline = 'alphabetic' ; cy - style [ cellStyle + 'PaddingBottom' ] + style . cellHeight ) ;", "del_tokens": "var newRow , t , rowHeaderCell , p , cx , cy , cellHeight , cornerCell , y , x , c , h , w , s , end ; ctx . textBaseline = 'hanging' ; t = ctx . measureText ( val ) ; cy - t . alphabeticBaseline - style [ cellStyle + 'PaddingBottom' ] ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "object", "passing", "to", "request"], "add_tokens": "this . setParam ( i , ( _ . isObject ( o [ i ] ) ) ? ObjectToXml ( o [ i ] ) : o [ i ] ) ;", "del_tokens": "this . setParam ( i , ( _ . isObject ( o [ i ] ) ) ? convertToXml ( o [ i ] ) : o [ i ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "test", "cases", "and", "fix", "bug", "with", "globalStorage", "which", "would", "throw", "when", "accessing", "an", "undefined", "key"], "add_tokens": "api . get = function ( key ) { return storage [ key ] && storage [ key ] . value }", "del_tokens": "api . get = function ( key ) { return storage [ key ] . value }", "commit_type": "add"}
{"commit_tokens": ["Remove", "font", "-", "icon", "generation", "from", "build", "timing", "out", "too", "often"], "add_tokens": "files : { 'app/public/styles/main.css' : [ 'app/public/styles/less/main.less' ] , 'app/public/styles/index.css' : [ 'app/public/styles/less/index.less' ] , 'app/public/styles/launchTest.css' : [ 'app/public/styles/less/launchTest.less' ] , 'app/public/styles/results.css' : [ 'app/public/styles/less/results.less' ] grunt . registerTask ( 'icons' , [ 'less' , grunt . registerTask ( 'build' , [ 'jshint' , 'less' ] ) ;", "del_tokens": "icons : { files : { 'app/public/styles/main.css' : [ 'app/public/styles/less/main.less' ] , 'app/public/styles/index.css' : [ 'app/public/styles/less/index.less' ] , 'app/public/styles/launchTest.css' : [ 'app/public/styles/less/launchTest.less' ] , 'app/public/styles/results.css' : [ 'app/public/styles/less/results.less' ] } grunt . registerTask ( 'build' , [ 'jshint' , 'less:icons' ,", "commit_type": "remove"}
{"commit_tokens": ["Change", "GitHub", "links", "from", "commit", "hashes", "to", "tags"], "add_tokens": "* See https : //github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211 // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259 // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155 // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177 // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431 * See https : //github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340", "del_tokens": "* See https : //github.com/angular/angular.js/blob/55848a9139/src/ng/directive/ngRepeat.js#L211 // See https://github.com/angular/angular.js/blob/55848a9139/src/ng/directive/ngRepeat.js#L259 // See https://github.com/angular-ui/bootstrap/blob/0d4c2e21c3/src/typeahead/typeahead.js#L162 // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/1529ab4bbc/src/typeahead/typeahead.js#L172 // See https://github.com/ivaynberg/select2/blob/70873abe9d/select2.js#L1431 * See https : //github.com/angular-ui/bootstrap/blob/d0024931de/src/typeahead/typeahead.js#L352", "commit_type": "change"}
{"commit_tokens": ["Fix", "weird", "blanket", "bug", "/", "typo", "in", "the", "cli", "helper"], "add_tokens": "'data-cover-never' : [ 'node_modules' ] ,", "del_tokens": "'data-cover-never' : [ 'node_modules' , 'test' ] ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "sally", "as", "logging", "middle", "for", "express", "."], "add_tokens": "this . digest = undefined ; SallyWriter . prototype . onLog = function ( audit ) { this . digest = this . sally . sign ( audit , this . digest ) ; digest : this . digest this . digest = this . sally . sign ( cycle , this . digest ) ; digest : this . digest this . digest = this . sally . sign ( cycle , this . digest ) ; digest : this . digest this . digest = undefined ;", "del_tokens": "SallyWriter . prototype . onLog = function ( audit , digest ) { digest : digest digest : this . sally . _sign ( cycle ) digest : this . sally . _sign ( cycle )", "commit_type": "add"}
{"commit_tokens": ["Add", "constants", "exponential", "function", "and", "random", "function"], "add_tokens": "var constants = require ( './src/constants.js' ) ; var arithmetic = require ( './src/arithmetic.js' ) ; var algebra = require ( './src/algebra.js' ) ; var calculus = require ( './src/calculus.js' ) ; var statistics = require ( './src/statistics.js' ) ; /* CONSTANTS */ module . exports . E = constants . E ; module . exports . PI = constants . PI ; module . exports . TAU = constants . TAU ; module . exports . exp = arithmetic . exp ; module . exports . random = arithmetic . random ;", "del_tokens": "var arithmetic = require ( './src/arithmetic.js' ) ; var algebra = require ( './src/algebra.js' ) ; var calculus = require ( './src/calculus.js' ) ; var statistics = require ( './src/statistics.js' ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "policy", "and", "adapter", "classes", "-", "nascent", "and", "non", "-", "functional", "for", "now", "but", "going", "the", "right", "direction", "."], "add_tokens": "var debug = require ( 'debug' ) ( 'amqp10-test_amqpclient' ) ,", "del_tokens": "var debug = require ( 'debug' ) ( 'amqp10-test_connection' ) ,", "commit_type": "add"}
{"commit_tokens": ["Update", "to", "conform", "new", "CoG", "."], "add_tokens": "cog : { external : [ 'angular' ] , } , media : { sounds : 'sounds/*.mp3' , unit : { tests : 'test/**/*_spec.js' , lib : [ 'jasmine' , 'angular-mock' ] , css : [ 'jasmine' ] }", "del_tokens": "build : { external : [ 'angular' , 'jasmine' , 'angular-mock' ] , sounds : [ 'sounds/*.mp3' ] , unit : 'test/**/*_spec.js'", "commit_type": "update"}
{"commit_tokens": ["Add", "Short", "time", "units", "for", "English"], "add_tokens": "module . exports = [ 'ar' , 'az' , 'az' , 'be' , 'bg' , 'bs' , 'ca' , 'cs' , 'cy' , 'da' , 'de' , 'dv' , 'el' , 'en' , 'en_short' , 'es' , 'et' , 'eu' , 'fa' , 'fi' , 'fr' , 'gl' , 'he' , 'hr' , 'hu' , 'hy' , 'id' , 'in_ID' , 'is' , 'it' , 'ja' , 'jv' , 'ko' , 'ky' , 'lt' , 'lv' , 'mk' , 'ml' , 'nl' , 'no' , 'pl' , 'pt' , 'pt_BR' , 'ro' , 'rs' , 'ru' , 'rw' , 'si' , 'sk' , 'sl' , 'sr' , 'sv' , 'th' , 'tr' , 'uk' , 'uz' , 'vi' , 'zh_CN' , 'zh_TW' ] ;", "del_tokens": "module . exports = [ 'ar' , 'az' , 'az' , 'be' , 'bg' , 'bs' , 'ca' , 'cs' , 'cy' , 'da' , 'de' , 'dv' , 'el' , 'en' , 'es' , 'et' , 'eu' , 'fa' , 'fi' , 'fr' , 'gl' , 'he' , 'hr' , 'hu' , 'hy' , 'id' , 'in_ID' , 'is' , 'it' , 'ja' , 'jv' , 'ko' , 'ky' , 'lt' , 'lv' , 'mk' , 'ml' , 'nl' , 'no' , 'pl' , 'pt' , 'pt_BR' , 'ro' , 'rs' , 'ru' , 'rw' , 'si' , 'sk' , 'sl' , 'sr' , 'sv' , 'th' , 'tr' , 'uk' , 'uz' , 'vi' , 'zh_CN' , 'zh_TW' ] ;", "commit_type": "add"}
{"commit_tokens": ["Moved", "the", "QUnit", "toolbar", "inline", "."], "add_tokens": "} var toolbar = id ( \"qunit-testrunner-toolbar\" ) ; if ( toolbar ) {", "del_tokens": "var toolbar = document . createElement ( \"div\" ) ; toolbar . className = \"qunit-testrunner-toolbar\" ; userAgent . parentNode . insertBefore ( toolbar , userAgent ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "parallel", "test", "runs", "use", "dots", "reporter", "for", "karma"], "add_tokens": "return gulp . src ( [ \"test/setup/node.js\" , \"test/unit/**/*.js\" ] )", "del_tokens": "gulp . src ( [ \"test/setup/node.js\" , \"test/unit/**/*.js\" ] )", "commit_type": "fix"}
{"commit_tokens": ["Making", "several", "improvements", "at", "once"], "add_tokens": "if ( Object . is ( this . source [ prop ] , value ) ) return", "del_tokens": "if ( this . source [ prop ] === value ) return", "commit_type": "make"}
{"commit_tokens": ["Fixed", "the", "styles", "for", "formio", "component", "."], "add_tokens": ". pipe ( replace ( \"styleUrls: ['formio.component.scss']\" , \"styles: ['\" + css . replace ( / \\\\' / g , \"'\" ) . replace ( / ' / g , \"\\\\'\" ) + \"']\" ) )", "del_tokens": ". pipe ( replace ( \"styleUrls: ['formio.component.css']\" , \"styles: ['\" + css . replace ( / \\\\' / g , \"'\" ) . replace ( / ' / g , \"\\\\'\" ) + \"']\" ) )", "commit_type": "fix"}
{"commit_tokens": ["Add", "cache", "for", "versions", "list"], "add_tokens": "var config = require ( './config' ) ; var listVersions = _ . memoize ( function ( ) { } , function ( ) { return Math . ceil ( Date . now ( ) / config . versions . timeout ) } ) ;", "del_tokens": "function listVersions ( ) { }", "commit_type": "add"}
{"commit_tokens": ["removed", "deprecated", "adm", "-", "zip", "and", "ls", "modules"], "add_tokens": "var ZipZipTop = require ( 'zip-zip-top' ) var zip = new ZipZipTop ( ) zip . folder ( config . logger . dir ) zip . writeToFile ( archFileName )", "del_tokens": "var AdmZip = require ( 'adm-zip' ) var zip = new AdmZip ( ) var ls = require ( 'ls' ) var logfiles = ls ( config . logger . dir + '/*' ) zip . addLocalFile ( cfgDumpFileName ) // console.log ('Adding file ' + cfgDumpFileName) logfiles . forEach ( function ( f ) { // console.log ('Adding file ' + f.file ) zip . addLocalFile ( f . full ) } ) zip . writeZip ( archFileName )", "commit_type": "remove"}
{"commit_tokens": ["Added", "some", "documentation", "to", "the", "new", "functions", "."], "add_tokens": "* * * This function is empty but necessary * because it is called during the rendering process of Leaflet v1 .0 . * This function is called during the rendering process of leaflet v1 .0 * Sets the contents of the d - attribute in a path - element of an svg - file .", "del_tokens": "* * Set the Path", "commit_type": "add"}
{"commit_tokens": ["add", "config", "for", "ardock", "update", "slurmProfiles", "for", "arwen", "-", "dev"], "add_tokens": "//var jobTmp = clone(curr_job); // deepcopy of the disappeared job //jobTmp.obj.emitter = curr_job.obj.emitter; // keep same emitter reference let tmpJob = jobsArray [ key ] ; tmpJob . obj . emitter . emit ( 'lostJob' , 'The job \"' + key + '\" is not in the queue !' , tmpJob . obj ) ;", "del_tokens": "var jobTmp = clone ( curr_job ) ; // deepcopy of the disappeared job jobTmp . obj . emitter = curr_job . obj . emitter ; // keep same emitter reference jobTmp . obj . emitter . emit ( 'lostJob' , 'The job \"' + key + '\" is not in the queue !' , jobTmp . obj ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "proteus", "-", "js", "-", "protobuf", "generator"], "add_tokens": "import { BrokerInfoServiceClient } from '../proteus/broker_info_proteus_pb' ; import { Empty } from 'google-protobuf/google/protobuf/empty_pb' ;", "del_tokens": "import BrokerInfoServiceClient from '../BrokerInfoServiceClient' ; import { Empty } from 'proteus-js-core' ;", "commit_type": "use"}
{"commit_tokens": ["adding", "file", "watching", "for", "all", "requested", "files"], "add_tokens": "let transpilations = { } ; const chokidar = require ( 'chokidar' ) ; let watcher = configureFileWatching ( ) ; function configureFileWatching ( ) { return chokidar . watch ( [ ] ) . on ( 'change' , ( path ) => { const fileEnding = path . slice ( path . lastIndexOf ( '.' ) ) ; if ( fileEnding === '.ts' ) { builder . compile ( path ) . then ( ( output ) => { transpilations [ path ] = output . source ; reloadBrowser ( ) ; } , ( error ) => { console . log ( error ) ; } ) ; } else { reloadBrowser ( ) ; } } ) ; } function reloadBrowser ( ) { console . log ( 'reloadBrowser' ) ; } watcher . add ( relativeFilePath || 'index.html' ) ;", "del_tokens": "const transpilations = { } ;", "commit_type": "add"}
{"commit_tokens": ["Add", "APP_ID", "for", "test", "use", "only"], "add_tokens": "// !!! IMPORTANT: THE TEST APP_ID BELOW IS ONLY FOR TEST EXECUTION IN CI !! // Sample APP_ID from open source code (https://core.telegram.org/api/obtaining_api_id#using-telegram-39s-open-source-code) appId : { id : 10534 , hash : '844584f2b1fd2daecee726166dcc1ef8' } , // FOR YOUR APPLICATION DO NOT USE THE TEST APP_ID ABOVE! Your application may be blocked! // See https://core.telegram.org/api/obtaining_api_id // You can get your own `api_id` and `api_hash` at https://core.telegram.org/myapp }", "del_tokens": "} , httpPath : '/apiw1'", "commit_type": "add"}
{"commit_tokens": ["move", "graph", "code", "into", "module", "(", "basis", ".", "ui", ".", "graph", ")", "add", "demo", "with", "dynamic", "threads", "tiny", "fixes", "in", "ajax", ".", "js"], "add_tokens": "this . clearTimeout ( ) ;", "del_tokens": "clearTimeout ( ) ; console . log ( 'abort' ) ;", "commit_type": "move"}
{"commit_tokens": ["fixed", "asError", "using", "incorrect", "offset"], "add_tokens": "this . reset ( ) ; this . skip ( 1 ) ;", "del_tokens": "debugger ; this . offset = 1 ;", "commit_type": "fix"}
{"commit_tokens": ["add", "field", "stack", "stub", "out", "testing"], "add_tokens": "var fs = require ( 'fs' ) ; exports . testFieldStack = function ( ) { var testHash = { Type : 'BaseModel' , Id : '123' , InstanceId : 10 , View : { Type : 'BaseModel' , Id : 'Test' , View : { Type : 'BaseModel' , Id : 'Test2' , View : [ \"zero\" , 1 , { Type : 'BaseModel' , Id : 'Test3' } , { Type : 'BaseModel' , Id : 'Test4' , View : { 'a' : { 'b' : { Type : 'BaseModel' , Id : 'deep' } } } } , \"four\" ] } } } ; stack = _ . fieldStack ( testHash ) ; //console.dir(stack); //_.each(stack, function(val){ console.log(val.fieldName); }); } ; exports . testAsyncLockSimple = function ( beforeExit ) {", "del_tokens": "exports . testAsyncLockSimple = function ( beforeExit ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "note", "regarding", "CLI", "writing", "to", "output"], "add_tokens": ". description ( 'Convert a RAML data type into JSON schema. ' + 'Writes to output.' )", "del_tokens": ". description ( 'Convert a RAML data type into JSON schema' )", "commit_type": "add"}
{"commit_tokens": ["Add", "spec", "for", "assertion", "errors"], "add_tokens": "setTimeout ( done , 100 ) ; } , 100 ) ; setTimeout ( done , 100 ) ;", "del_tokens": "setTimeout ( done , 500 ) ; } , 500 ) ; setTimeout ( done , 500 ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "first", "test", "for", "startBroadcasting"], "add_tokens": "keys [ key ] || ( keys [ key ] = new NativeCall ( key ) ) ; invokeCallback ( 'StopBroadcasting' , args ) ; registerToNative : function ( cb ) {", "del_tokens": "keys [ key ] || ( key [ keys ] = new NativeCall ( key ) ) ; invokeCallback ( 'StopBroadcasting' , args ) ; registerNative : function ( cb ) {", "commit_type": "add"}
{"commit_tokens": ["fixed", "flows", "unit", "test", "+", "StreamlineHelpers", "-", ">", "StreamlineFlows", "API", "change", "(", "browser", "only", ")"], "add_tokens": "} ) ( ( ( typeof exports !== \"undefined\" ) ? exports : ( window . StreamlineFlows = ( window . StreamlineFlows || {", "del_tokens": "} ) ( ( ( typeof exports !== \"undefined\" ) ? exports : ( window . StreamlineHelpers = ( window . StreamlineHelpers || {", "commit_type": "fix"}
{"commit_tokens": ["added", "option", "to", "enable", "/", "disable", "milliseconds", "updated", "readme", "added", "test", "cases", "for", "printFrame", "options", "."], "add_tokens": "var ZigBeeHelper = new XbeeHelper . ZigBeeHelper ( false , true ) ;", "del_tokens": "var ZigBeeHelper = new XbeeHelper . ZigBeeHelper ( ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "global", "/", "local", "globs", "to", "be", "resolved", "explicitly"], "add_tokens": "var files = [ ] ; if ( opts . resolveGlobal === true ) { files = files . concat ( utils . resolveUp ( patterns , opts ) ) ; } if ( opts . resolveLocal === true ) { files = files . concat ( utils . glob . sync ( patterns , opts ) ) ; }", "del_tokens": "var files = utils . resolveUp ( patterns , opts ) ; files = files . concat ( utils . glob . sync ( patterns , opts ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["fix", "corrupted", "files", "on", "stream"], "add_tokens": "var ERROR_WAIT_TIME = 1000 * 60 ; var FILE_ERROR_MAX_ATTEMPTS = 30 ; self . fileErrorsAttemps = { } ; if ( self . fileErrorsAttemps [ task . filename ] === undefined ) { // show the error first time console . log ( err ) ; console . log ( task . filename + ' processed with error' ) ; self . fileErrorsAttemps [ task . filename ] = 0 ; } if ( self . fileErrorsAttemps [ task . filename ] ++ < FILE_ERROR_MAX_ATTEMPTS ) { // wait a then proccess again setTimeout ( function ( ) { self . queue . push ( task ) ; } , ERROR_WAIT_TIME ) ; } else { console . log ( task . filename + ' was error on all attempts' ) ; }", "del_tokens": "console . log ( err ) ; //console.log(task.filename + ' processed with error');", "commit_type": "fix"}
{"commit_tokens": ["Upgraded", "the", "mock", "device", "and", "added", "a", "configureMockDevice", "function", "to", "the"], "add_tokens": "var mock_device_defaults_cache_test = require ( './mock_device_defaults_cache_test' ) ; var mock_device_attrs_test = require ( './mock_device_attrs_test' ) ; exports . mock_device_test = mock_device_test . tests ; // Passing exports . mock_device_defaults_cache_test = mock_device_defaults_cache_test . tests ; // Passing exports . mock_device_attrs_test = mock_device_attrs_test . tests ; // exports.t7_basic_test = t7_basic_test.tests; // Passing // exports.t7_check_calibration_test = t7_check_calibration_test.tests; // Passing", "del_tokens": "var mock_device_defaults_cache_test = require ( './mock_device_defaults_cache_test' ) ; // exports.mock_device_test = mock_device_test.tests; // Passing // exports.mock_device_defaults_cache_test = mock_device_defaults_cache_test.tests;// Passing exports . t7_basic_test = t7_basic_test . tests ; // Passing exports . t7_check_calibration_test = t7_check_calibration_test . tests ; // Passing", "commit_type": "upgrade"}
{"commit_tokens": ["add", "square", "brackets", "into", "lexicon", "for", "list"], "add_tokens": "'!' , // negation / unary '[' , // list start ']' // list end", "del_tokens": "'!' // negation / unary", "commit_type": "add"}
{"commit_tokens": ["Remove", "www", ".", "from", "links", "in", "prettyURL", "and", "domainURL"], "add_tokens": "return url . hostname . replace ( 'www.' , '' ) + path return url . hostname . replace ( 'www.' , '' )", "del_tokens": "return url . hostname + path return url . hostname", "commit_type": "remove"}
{"commit_tokens": ["fixing", "issue", "with", "increments", "id", "adding", "debug", "for", "config"], "add_tokens": "this . bindings = this . bindings . concat ( _ . values ( values [ i ] ) ) ; return this . _addColumn ( 'integer' , ( column || 'id' ) , { autoIncrement : true , length : 11 } ) ;", "del_tokens": "var record = values [ i ] ; this . bindings = this . bindings . concat ( _ . values ( record ) ) ; return this . _addColumn ( 'integer' , ( column || 'id' ) , { autoIncrement : true } ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "coveralls", "integration", "with", "nyc", ";", "remove", "duplicate", "test"], "add_tokens": "t . plan ( 3 ) ;", "del_tokens": "t . plan ( 4 ) ; t . equal ( requestIp . getClientIpFromXForwardedFor ( '107.77.213.113, 172.31.41.116' ) , '107.77.213.113' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "customisable", "alphabets", ".", "Changed", "the", "signature", "for", "the", "id", "generation", "function", "in", "preparation", "for", "pluggable", "id", "-", "generation", "functions"], "add_tokens": "var alphabet = idInfo . alphabet ; genId ( { len : len , base : base , alphabet : alphabet } , function ( err , id ) {", "del_tokens": "genId ( len , base , function ( err , id ) {", "commit_type": "add"}
{"commit_tokens": ["make", "the", "app", "name", "for", "rc", "config", "module", "configurable", "via", "env", "var"], "add_tokens": "var rc = new RC ( appType , spmDefaultConfig )", "del_tokens": "var rc = new RC ( apptype , spmDefaultConfig )", "commit_type": "make"}
{"commit_tokens": ["Updated", "to", "use", "2", "space", "indenting", "for", "package", ".", "json"], "add_tokens": "const v = versiony . from ( pkgJsonFile ) . indent ( ' ' . repeat ( 2 ) )", "del_tokens": "const v = versiony . from ( pkgJsonFile )", "commit_type": "update"}
{"commit_tokens": ["Removed", "es6", "code", "in", "gulpfile", ".", "js"], "add_tokens": "gulp . task ( 'lint' , function ( ) {", "del_tokens": "gulp . task ( 'lint' , ( ) => {", "commit_type": "remove"}
{"commit_tokens": ["Use", "signal", "-", "exit", "fix", "kill", "(", "process", ".", "pid", ")", "race"], "add_tokens": "var signalExit = require ( 'signal-exit' ) signalExit ( function ( code , signal ) {", "del_tokens": "process . on ( 'exit' , function ( ) {", "commit_type": "use"}
{"commit_tokens": ["Create", "and", "test", "selector", "-", "delimiter", "-", "space", "-", "after"], "add_tokens": ". catch ( err => console . error ( err . stack ) )", "del_tokens": ". catch ( err => console . error ( err ) )", "commit_type": "create"}
{"commit_tokens": ["Fix", "mount", "::", "simulate", "()", "signature"], "add_tokens": "* @ param { Object } mock ( optional ) simulate ( event , mock = { } ) { eventFn ( findDOMNode ( n ) , mock ) ;", "del_tokens": "* @ param { Array } args simulate ( event , ... args ) { eventFn ( findDOMNode ( n ) , ... args ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "ability", "to", "yield", "and", "resume", "from", "the", "host", "."], "add_tokens": "var args = [ ] , running = luajs . Coroutine . _running ; running . _yieldVars = args ; running . status = 'suspending' ; return { resume : function ( ) { // var args = [running], // i, // l = arguments.length; // // for (i = 0; i < l; i++) args.push (arguments[i]); // luajs.lib.coroutine.resume.apply (undefined, args); luajs . lib . coroutine . resume ( running ) ; } }", "del_tokens": "var args = [ ] ; luajs . Coroutine . _running . _yieldVars = args ; luajs . Coroutine . _running . status = 'suspending' ; return ;", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "it", "works", "without", "Set", "and", "that", "it", "throws", "as", "appropriate", "when", "there", "s", "no", "Set", "."], "add_tokens": "var hasSets = typeof Set !== 'undefined' && ES . IsCallable ( Set ) ; var setValues ; if ( hasSets ) { setValues = Set . prototype . values ; } var requireSet = function requireSet ( ) { if ( ! hasSets ) { throw new TypeError ( 'Set.prototype.toJSON requires Set (either native, or polyfilled with es6-shim)' ) ; } } ; } else if ( hasSets ) { } else { requireSet ( ) ; requireSet ( ) ;", "del_tokens": "if ( ! ES . IsCallable ( Set ) ) { module . exports = new Error ( 'Set.prototype.toJSON requires Set (either native, or polyfilled with es6-shim)' ) ; return ; } var setValues = Set . prototype . values ; } else {", "commit_type": "make"}
{"commit_tokens": ["Fixed", ":", "make", "app", "config", "optional", "."], "add_tokens": "var worker = child . fork ( serverWorker , [ '--port' , port , '--server' , serverFile , '--config' , JSON . stringify ( config . app || { } ) ] ) ;", "del_tokens": "var worker = child . fork ( serverWorker , [ '--port' , port , '--server' , serverFile , '--config' , JSON . stringify ( config . app ) ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "doc", "for", "Model", ".", "count"], "add_tokens": "Return a count where the where clause passes some condition", "del_tokens": "create indicies on all defined properties", "commit_type": "fix"}
{"commit_tokens": ["Updated", "registation", "API", "to", "use", "serialized", "updates", "with", "promises", "."], "add_tokens": "console . error ( ` ${ errBody } ` ) ; resetMDNS ( ) ; } ) ; resetMDNS ( ) ; resetMDNS ( ) ; res . on ( 'error' , function ( e ) { console . error ( ` ${ e } ` ) ; resetMDNS ( ) ; } ) } ) ; req . on ( 'error' , function ( e ) { console . error ( ` ${ e } ` ) ; resetMDNS ( ) ; clearInterval ( healthcheck ) ;", "del_tokens": "console . error ( ` ${ errBody } ` ) ; } ) ; clearInternal ( healthcheck ) ; clearInterval ( healthcheck ) ;", "commit_type": "update"}
{"commit_tokens": ["improved", "browsing", "of", "existing", "api", "doc", "and", "fixed", "some", "syntactical", "errors", "."], "add_tokens": "* @ memberOf laxar * function bootstrap ( widgetModules ) { } return { bootstrap : bootstrap , log : log , configuration : configuration , directives : directives , text : text , i18n : i18n , assert : assert , array : array , object : object , storage : storage , string : string } ;", "del_tokens": "var laxar = { log : log , configuration : configuration , directives : directives , text : text , i18n : i18n , assert : assert , array : array , object : object , storage : storage , string : string } ; /////////////////////////////////////////////////////////////////////////////////////////////////////////// laxar . bootstrap = function ( widgetModules ) { } ; return laxar ;", "commit_type": "improve"}
{"commit_tokens": ["Added", "promise", "API", "for", "encrypt", "and", "decrypt", "methods"], "add_tokens": "var promise = require ( 'promise' ) ; callback ( ) ; * @ returns { Promise } return new Promise ( function ( resolve , reject ) { _xcrypt ( options , crypto . createCipher , function ( ) { if ( typeof callback !== 'undefined' ) { callback ( ) ; } resolve ( ) ; } ) ; } ) ; * @ returns { Promise } return new Promise ( function ( resolve , reject ) { _xcrypt ( options , crypto . createDecipher , function ( ) { if ( typeof callback !== 'undefined' ) { callback ( ) ; } resolve ( ) ; } ) ; } ) ;", "del_tokens": "if ( typeof callback !== 'undefined' ) { callback ( ) ; } _xcrypt ( options , crypto . createCipher , callback ) ; _xcrypt ( options , crypto . createDecipher , callback ) ;", "commit_type": "add"}
{"commit_tokens": ["Makeing", "custom", "Assert", "s", "bundled", "with", "test", "suite", "specific", "to", "them", "instead", "of", "expecting", "a", "global", "one", "in", "the", "root", "."], "add_tokens": ", Assert : unitMap . Assert || Assert", "del_tokens": ", Assert = options . Assert , Assert : Assert , Assert : { value : Assert } , Assert : units . Assert || Assert", "commit_type": "make"}
{"commit_tokens": ["fixed", "error", "with", "negative", "numbers", "and", "decimal", "points"], "add_tokens": "console . log ( num ) ; var decimalplace ; if ( num . indexOf ( '.' ) < 0 ) decimalplace = - 1 ; else { decimalplace = num . length - num . indexOf ( '.' ) - 1 ; num = num . split ( '.' ) . join ( '' ) ; } { if ( char == '-' ) setChar ( addr , offset , char , i > 0 && i == decimalplace ) ; else setDigit ( addr , offset , parseInt ( char ) , i > 0 && i == decimalplace ) ; } var minus = false ; if ( num < 0 ) { minus = true ; num = Math . abs ( num ) ; } if ( num . indexOf ( '.' ) >= 0 ) mindigits ++ ; if ( minus ) num = '-' + num ;", "del_tokens": "var decimalplace = num . length - num . indexOf ( '.' ) - 1 ; if ( decimalplace != - 1 ) num = num . split ( '.' ) . join ( '' ) ; setDigit ( addr , offset , parseInt ( char ) , i > 0 && i == decimalplace ) ; if ( num . indexOf ( '.' ) >= 0 ) mindigits ++ ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "cap", "error", "and", "requires", "list"], "add_tokens": "if ( self . length ( ) > self . cap ) {", "del_tokens": "if ( self . length ( ) > cap ) {", "commit_type": "fix"}
{"commit_tokens": ["fixed", "delta", "fetcher", "if", "has_more", "is", "true"], "add_tokens": "fetchDelta ( { cursor : data . cursor } , cb ) ;", "del_tokens": "fetchDelta ( { cursor : data . cursor } , params , cb ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "config", "and", "config", "tests"], "add_tokens": "if ( ! config . outdir ) { config . outdir = path . join ( config . basedir , 'mendel' ) } else { config . outdir = path . resolve ( config . basedir , config . outdir ) ; }", "del_tokens": "if ( ! config . outdir ) config . outdir = path . join ( config . basedir , 'mendel' ) ; config . outdir = path . join ( config . basedir , config . outdir ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "Buffer", ".", "from", "()"], "add_tokens": "return sha512half ( Buffer . from ( hex , 'hex' ) ) ; return ( Buffer . from ( bytes ) ) . toString ( 'hex' ) ; return ( Buffer . from ( decodeAddress ( address ) ) ) . toString ( 'hex' ) ;", "del_tokens": "return sha512half ( new Buffer ( hex , 'hex' ) ) ; return ( new Buffer ( bytes ) ) . toString ( 'hex' ) ; return ( new Buffer ( decodeAddress ( address ) ) ) . toString ( 'hex' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "the", "watching", "of", "the", "template", "files"], "add_tokens": "persistent : true", "del_tokens": "persistent : false", "commit_type": "fix"}
{"commit_tokens": ["adding", "attributes", "option", "to", "get", "file", "attributes", "by", "demand"], "add_tokens": "if ( 'attributes' in options && options . attributes . indexOf ( 'content' ) !== - 1 ) { if ( 'attributes' in options ) { if ( options . attributes . indexOf ( 'mode' ) !== - 1 ) { node [ '-mode' ] = file . getMode ( ) ; } if ( options . attributes . indexOf ( 'owner' ) !== - 1 ) { node [ '-owner' ] = file . getUid ( ) ; } if ( options . attributes . indexOf ( 'group' ) !== - 1 ) { node [ '-group' ] = file . getGid ( ) ; } } attributes : [ ]", "del_tokens": "if ( options . content ) { content : true", "commit_type": "add"}
{"commit_tokens": ["Add", "files", "[", "*", "]", ".", "comments", "and", "files", "[", "*", "]", ".", "comments", "[", "*", "]", ".", "reply", "()"], "add_tokens": "github . getReviewComments ( this . repo . data . owner . login , this . repo . data . name , this . data . number , function ( err , comments ) { files = attachCommentsToFile . call ( this , files , comments ) ; this . exports . files = files ; callback ( null , files ) ; } . bind ( this ) ) ; // attach review comments to the related file function attachCommentsToFile ( files , comments ) { return files . filter ( function ( file ) { return file . comments = comments . filter ( function ( comment ) { if ( file . filename === comment . path ) { return comment . reply = attachCommentReply . call ( this , comment ) ; } } . bind ( this ) ) ; } . bind ( this ) ) ; } // reply to a comment on a diff function attachCommentReply ( comment ) { return function reply ( body , callback ) { github . replyToReviewComment ( this . repo . data . owner . login , this . repo . data . name , this . data . number , comment . id , body , callback ) ; } . bind ( this ) ; }", "del_tokens": "this . exports . files = files ; callback ( null , files ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "exit", "problem", "when", "waitForRelease", "come", "with", "redis", "server", "crash"], "add_tokens": "logger . trace ( ` ${ idx } ` ) ; const w = this . waitQueue . shift ( ) ; if ( w ) { w . res ( this . connections [ idx ] ) ; this . emitter . on ( \"error\" , e => { logger . info ( \"Redis server error, flush the waitQueue.\" ) ; var w ; while ( w = this . waitQueue . shift ( ) ) w . rej ( e ) ; } ) ; //Redis server will not close a client connection in normal case. this . conn . connection . on ( \"end\" , ( ) => { this . broken = true ; this . pool . emitter . emit ( \"error\" , new Error ( \"Redis Server Error\" ) ) ; } ) ;", "del_tokens": "logger . trace ( ` ${ idx } ` + ` ${ this . waitQueue . length } ` ) ; const fn = this . waitQueue . shift ( ) ; if ( fn ) { fn . res ( this . connections [ idx ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "defensive", "semicolon", "so", "jshint", "will", "pass"], "add_tokens": "var Plates = ( typeof process !== 'undefined' && typeof process . title !== 'undefined' ) ? exports : { } ;", "del_tokens": "; var Plates = ( typeof process !== 'undefined' && typeof process . title !== 'undefined' ) ? exports : { } ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "an", "issue", "where", "plugins", "where", "being", "wrapped", "."], "add_tokens": "if ( ! ( typeof window === 'undefined' && typeof global !== 'undefined' && { } . toString . call ( global ) === '[object global]' ) ) { if ( typeof $ !== 'undefined' && $ ( document ) ) {", "del_tokens": "if ( typeof window === 'undefined' && typeof global !== 'undefined' && { } . toString . call ( global ) === '[object global]' ) { if ( $ && $ ( document ) ) {", "commit_type": "fix"}
{"commit_tokens": ["remove", "debugging", "code", ".", "(", "most", "tests", "failing", "on", "travis", ")"], "add_tokens": "// this.xcodebuild.on('output', (d, e) => { // log.warn(d, e); // });", "del_tokens": "log . warn ( 'calling createSimLogsSubProcess' ) ; agentLog . warn ( d , e ) ; log . warn ( 'calling createXcodeBuildSubProcess' ) ; this . xcodebuild . on ( 'output' , ( d , e ) => { log . warn ( d , e ) ; } ) ; log . warn ( 'starting xcodebuild' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "quote", "bug", "in", "some", "special", "situations"], "add_tokens": "var REGEX_QUOTE = / \"[^\"]*\"|'[^']*' / g ;", "del_tokens": "var REGEX_QUOTE = / \"[^\"]+\"|'[^']+' / g ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "a", "bug", "where", "min", "items", "is", "0"], "add_tokens": "if ( obj . minItems || obj . minItems === 0 ) {", "del_tokens": "if ( obj . minItems ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "fs", ".", "exists", "if", "available"], "add_tokens": "// Get \"exists\" from the right place var existsCompat = fs . exists || path . exists ; existsCompat ( fileDir , function ( exists ) {", "del_tokens": "path . exists ( fileDir , function ( exists ) {", "commit_type": "use"}
{"commit_tokens": ["fixed", "expression", "endpoint", "+", "fixed", "post"], "add_tokens": "// .then (function () { // return callApi // // return jsonHttp.get({ // // \"url\" : myurl, // // \"headers\": { // // \"Auth-token\": credentials.token // // } // // }) // .catch(catchErr); . then ( callApi ) . catch ( catchErr ) ; // }); var prefixExpression = \"private/target/expression?\" ;", "del_tokens": ". then ( function ( ) { return jsonHttp . get ( { \"url\" : myurl , \"headers\" : { \"Auth-token\" : credentials . token } } ) . catch ( catchErr ) ; } ) ; var prefixExpression = \"private/expression?\" ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "dockerfile", "relative", "to", "path"], "add_tokens": "const path = require ( \"path\" ) ; const buildArgs = [ 'build' , '-t' , image , '-f' , path . resolve ( art . path , art . dockerfile ) ] ;", "del_tokens": "// const path = require(\"path\"); const buildArgs = [ 'build' , '-f' , art . dockerfile , '-t' , image ] ;", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "URLParams", "type"], "add_tokens": "showInputControl : PropTypes . bool . isRequired , URLParams : PropTypes . bool . isRequired", "del_tokens": "showInputControl : PropTypes . bool . isRequired", "commit_type": "add"}
{"commit_tokens": ["Added", "test", "for", "type", "consistency", "of", "custom", "fields"], "add_tokens": "it ( \"Test custom fields log output\" , function ( ) { it ( \"Test custom fields log type consistency\" , function ( ) { var obj = { \"fieldString\" : \"value\" , \"fieldNumber\" : 123 , \"fieldObj\" : { a : 456 } , \"fieldArray\" : [ 7 , 8 , 9 ] } ; log ( \"info\" , \"Test\" , obj ) ; assert . isString ( obj . fieldString ) ; assert . isNumber ( obj . fieldNumber ) ; assert . isObject ( obj . fieldObj ) ; assert . isArray ( obj . fieldArray ) ; } ) ;", "del_tokens": "it ( \"Test custom fields log\" , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Made", "unique", "tester", "asynchronous", "."], "add_tokens": "if ( schema . unique ) { return unique ( validArray , function ( res ) { if ( res ) return finalize ( validArray , fn ) ; return fn ( new ValidationError ( keyPath , schema , 'unique' , ( schema . errors || { } ) . unique || 'Array is not unique.' ) ) ; } ) ;", "del_tokens": "if ( schema . unique && validArray . length > 1 ) { for ( var idx1 = 0 ; idx1 < validArray . length - 1 ; idx1 ++ ) { for ( var idx2 = idx1 + 1 ; idx2 < validArray . length ; idx2 ++ ) { if ( unique . equals ( validArray [ idx1 ] , validArray [ idx2 ] ) ) { keyPath = keyPath . concat ( [ idx1 . toString ( ) ] ) ; return fn ( new ValidationError ( keyPath , schema , 'unique' , ( schema . errors || { } ) . unique || 'Is not unique.' ) ) ; } } }", "commit_type": "make"}
{"commit_tokens": ["Use", "event", "-", "stream", "in", "place", "of", "stream", "-", "array"], "add_tokens": "var event_stream = require ( 'event-stream' ) ; var id_stream = event_stream . readArray ( Object . keys ( records ) ) ;", "del_tokens": "var stream_array = require ( 'stream-array' ) ; var id_stream = stream_array ( Object . keys ( records ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "missing", "file", "extension", "for", "cover", "image"], "add_tokens": "fs . rename ( \"./\" + bookData . cover , bookPath + \"/\" + cover [ 0 ] [ \"$\" ] . content + \".jpg\" , function ( err ) {", "del_tokens": "fs . rename ( \"./\" + bookData . cover , bookPath + \"/\" + cover [ 0 ] [ \"$\" ] . content , function ( err ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "route", "param", "to", "authorize"], "add_tokens": "* - server assets * - authorization * - body - parsers * * @ param { Object } route authorize ( ctx , route , req ) { // Check the user role if ( route . opts . roles . indexOf ( decoded . role ) === - 1 )", "del_tokens": "* - server assets * - body - parsers * - authorization authorize ( ctx , req ) { // Check the role from JWT if ( decoded . role != \"admin\" )", "commit_type": "add"}
{"commit_tokens": ["Added", "test", "and", "fixed", "DescribeSpotInstanceRequests"], "add_tokens": "var awsConfig = Object . assign ( { } , constructOps . keys ) awsConfig . logger = constructOps . logger this . _awsConfig = new AWS . Config ( awsConfig ) constructOps . logger = internals . logger", "del_tokens": "this . _awsConfig = new AWS . Config ( constructOps . keys ) constructOps . keys . logger = internals . logger", "commit_type": "add"}
{"commit_tokens": ["fix", "a", "bug", "which", "cause", "app", "crashes", "on", "wp7"], "add_tokens": "window . addEventListener ( 'load' , function ( ) { _checkAuthResponse ( window . location . href ) ; } , false ) ; //W3C window . attachEvent ( 'onload' , function ( ) { _checkAuthResponse ( window . location . href ) ; } ) ; //IE", "del_tokens": "window . addEventListener ( 'load' , _checkAuthResponse ( window . location . href ) , false ) ; //W3C window . attachEvent ( 'onload' , _checkAuthResponse ( window . location . href ) ) ; //IE", "commit_type": "fix"}
{"commit_tokens": ["Make", "Hydro", "global", "for", "the", "tests"], "add_tokens": "var obj = { } ;", "del_tokens": "var Hydro = require ( '..' ) ; var obj = Object . create ( null ) ;", "commit_type": "make"}
{"commit_tokens": ["Adds", ".", "map", "helper", "function", "."], "add_tokens": "// ## jam.map( array, iterator( next, element ) ) // Execute the given `iterator` for each element given in the `array`. The iterator is // given a `next` function and the element to act on. // // You can also pass `arguments` and `\"strings\"` as an array. // // Under the hood, a JAM step is added for each element. So the iterator will be // called serially, one after another finish. A parallel version maybe added in the // future. func . map = function ( array , iterator ) { assert ( array && typeof array === 'object' && typeof array . length === 'number' , 'array argument missing or does not looks like an array' ) ; assert ( typeof iterator === 'function' ) ; return function ( next ) { // Builds another JAM chain internally. var chain = jam ( jam . identity ) , count = array . length ; for ( var i = 0 ; i < count ; i ++ ) ( function ( element , i ) { chain = chain ( function ( next ) { iterator ( next , element , i ) ; } ) ; } ) ( array [ i ] , i ) ; return chain ( next ) ; } ; } ; assert ( typeof func === 'function' , 'function argument missing or not a function' ) ; assert ( typeof func === 'function' , 'function argument missing or not a function' ) ;", "del_tokens": "// TODO: map()", "commit_type": "add"}
{"commit_tokens": ["move", "assertions", "into", "AVA", "core"], "add_tokens": "var assert = require ( './assert' ) ; Object . keys ( assert ) . forEach ( function ( el ) { assert [ el ] . apply ( assert , arguments ) ;", "del_tokens": "var assert = require ( 'assert' ) ; var claim = require ( 'claim' ) ; // TODO: find a better way to count assertions // decorate the `claim` methods with our assert counter Object . keys ( claim ) . forEach ( function ( el ) { claim [ el ] . apply ( claim , arguments ) ;", "commit_type": "move"}
{"commit_tokens": ["change", "some", "things", "resulting", "from", "internal", "review"], "add_tokens": "assert . equal ( logs [ 0 ] . event , 'ImplementationChanged' )", "del_tokens": "assert . equal ( logs [ 0 ] . event , 'ImplementationAdded' )", "commit_type": "change"}
{"commit_tokens": ["Remove", "lingering", "debugger", "statement", "."], "add_tokens": "reindexNodes . call ( this ) ;", "del_tokens": "try { reindexNodes . call ( this ) ; } catch ( ex ) { debugger ; }", "commit_type": "remove"}
{"commit_tokens": ["fixed", "retrieval", "of", "field", "paths", "from", "an", "object", "-", "IDBKeyRange", "instances", "are", "now"], "add_tokens": "( value instanceof Array ) || ( value instanceof IDBKeyRange ) let fieldPath = parts . slice ( ) if ( ! currentObject . hasOwnProperty ( fieldName ) ) {", "del_tokens": "( value instanceof Array ) fieldPath = parts . slice ( ) if ( ! currentObject . hasOwnProperty ( field ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "test", "-", "client", "documentation"], "add_tokens": "bin / sc - u YOUR_USERNAME - k YOUR_ACCESS_KEY any modules listed in your config file will automatically be loaded var testfolder = config . path . clientTests ; dust . render ( 'testrunner' , { } , function ( err , out ) {", "del_tokens": "bin / sc - u coin - k 86 aed001 - ddbe - 4497 - 9497 - 10 f948a51299 var testfolder = '' ; testfolder = path . join ( config . path . tests , 'client' ) ; var templateData = getTemplateData ( ) ; dust . render ( 'testrunner' , templateData , function ( err , out ) { function getTemplateData ( ) { return { assertModule : 'proclaim' , assertVar : 'proclaim' } ; }", "commit_type": "add"}
{"commit_tokens": ["use", "graceful", "-", "fs", "to", "avoid", "EMFILE", "for", "large", "projects"], "add_tokens": "import { stat } from 'fs-promise' ; import { readdir , readFile } from './graceful-fs' ; const pkgPath = resolve ( path , 'package.json' ) ; const pkgData = await readFile ( pkgPath , 'utf8' ) ; let s ; s = await stat ( path ) ; s = await stat ( path ) ; if ( s . isDirectory ( ) ) { const all = await readdir ( file ) ; return ( await readFile ( path , 'utf8' ) ) ;", "del_tokens": "import fs , { readFile as read } from 'fs-promise' ; const pkgData = await read ( resolve ( path , 'package.json' ) , 'utf8' ) ; let stat ; stat = await fs . stat ( path ) ; stat = await fs . stat ( path ) ; if ( stat . isDirectory ( ) ) { const all = await fs . readdir ( file ) ; return ( await fs . readFile ( path , 'utf8' ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "mode", "to", "readdir", "for", "output", "switching"], "add_tokens": "/ ** * Readdir processing mode . * When set to 'node' , readdir will return an array of strings like Node ' * fs . readdir does . When set to 'stat' , readdir will return an array of stat * objects . * @ see stat * @ typedef { ( 'node' | 'stat' ) } ReadDirMode * / * @ param { ReadDirMode = } mode The readdir processing mode ( default 'node' ) * @ see ReadDirMode readdir : function ( path , callback , mode ) { mode = mode || \"node\" ; if ( mode === \"stat\" ) { var fileStat = processing . createStat ( dirEntry ) ; fileStat . name = dirEntry . basename ; return fileStat ; }", "del_tokens": "readdir : function ( path , callback ) {", "commit_type": "add"}
{"commit_tokens": ["fixed", "docs", ":", "preset", "argument", "is", "of", "type", "object", "not", "string"], "add_tokens": "var bar = new _progress . Bar ( { } , _progress . Presets [ name ] || _progress . Presets . legacy ) ;", "del_tokens": "var bar = new _progress . Bar ( { } , _progress . Presets [ name ] || 'legacy' ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "merge_options", "()", "to", "extend", "()"], "add_tokens": "pb_targetingMap [ bidClone . adUnitCode ] = utils . extend ( pb_targetingMap [ bidClone . adUnitCode ] , bidClone . adserverTargeting ) ; pb_targetingMap [ adUnitCode ] = utils . extend ( pb_targetingMap [ adUnitCode ] , keyValues ) ;", "del_tokens": "pb_targetingMap [ bidClone . adUnitCode ] = utils . merge_options ( pb_targetingMap [ bidClone . adUnitCode ] , bidClone . adserverTargeting ) ; pb_targetingMap [ adUnitCode ] = utils . merge_options ( pb_targetingMap [ adUnitCode ] , keyValues ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "event", "capture", "hack", "implementation", "note"], "add_tokens": "// XXX The capture phase in these events is a hack. It's only needed because sibling overlay elements sometimes expect to capture events instead of the canvas. // The correct way to handle this would be to compute the CSS and bubble up from the correct element.", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "tests", "to", "more", "be", "more", "flexible", "."], "add_tokens": "'/' . should . match ( app . stack [ 0 ] . route ) '/0' . should . match ( app . stack [ 0 ] . route ) '/1' . should . match ( app . stack [ 1 ] . route )", "del_tokens": "app . stack [ 0 ] . route . should . equal ( / ^\\/$ / ) app . stack [ 0 ] . route . should . equal ( / ^\\/0$ / ) app . stack [ 1 ] . route . should . equal ( / ^\\/1$ / )", "commit_type": "change"}
{"commit_tokens": ["FIXED", ":", "reset", "transform", "before", "rendering", "text", "/", "bitmaptext", "since", "it", "may", "have", "changed"], "add_tokens": "destCtx . setTransform ( 1 , 0 , 0 , 1 , 0 , 0 ) ;", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["add", "additional", "unit", "test", "for", "fs", ".", "watch"], "add_tokens": "it ( \"should return error if path does not exist\" , function ( done ) { var vpath = \"/newfile.txt\" ; expect ( fs . existsSync ( base + vpath ) ) . not . ok ; vfs . watch ( base + vpath , { file : false } , function ( err , meta ) { expect ( err ) . ok ; done ( ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "broken", "Material", "Design", "Icon", "font"], "add_tokens": "tests : 'src/**/*.spec.ts' , fonts : 'src/assets/fonts/**.*' 'node_modules/materialize-css/font/roboto/Roboto-Regular.*'", "del_tokens": "tests : 'src/**/*.spec.ts' 'node_modules/materialize-css/font/roboto/Roboto-Regular.*' , 'node_modules/materialize-css/font/material-design-icons/*'", "commit_type": "fix"}
{"commit_tokens": ["Adding", "support", "for", "running", "local", "shields", "host"], "add_tokens": "var https = require ( \"https\" ) ; var http = require ( \"http\" ) ; var httpClient = url . indexOf ( \"https://\" ) === 0 ? https : http ; var req = httpClient . get ( url , function requestHandler ( res ) {", "del_tokens": "var http = require ( \"https\" ) ; var req = http . get ( url , function requestHandler ( res ) {", "commit_type": "add"}
{"commit_tokens": ["Make", "toCasandraValues", "pass", "undefined", "as", "null"], "add_tokens": "if ( value === null || value === undefined ) { list . push ( null ) ; } else {", "del_tokens": "if ( value !== null ) { } else { list . push ( null ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "hook", "for", "extensions", "added", "debug", "logger"], "add_tokens": "const windowExists = ( ) => typeof window !== 'undefined' ; if ( windowExists ( ) ) {", "del_tokens": "if ( typeof window !== 'undefined' ) {", "commit_type": "add"}
{"commit_tokens": ["Adding", "check", "for", "row", "being", "southmost", "geohash", "row", ".", "Avoiding", "processing", "for", "last", "row", "which", "is", "outsite", "of", "bounding", "box", "."], "add_tokens": "hashes = results || [ ] ; // No more geojsons to check means there are no more hashes - we're done here if ( ! self . geojson . length ) return done ( ) ; // Make sure the row is within the bounding box if ( rowBox [ 2 ] <= self . bounding [ 0 ] ) { self . geojson . shift ( ) ; self . rowHash = null ; self . bounding = null ; return done ( null , rowHashes ) ; } var southNeighbour = geohash . neighbor ( self . rowHash , [ - 1 , 0 ] ) ; // Check if the current rowHash was already the most southerly hash on the map. if ( southNeighbour === self . rowHash ) { } else { self . rowHash = southNeighbour ;", "del_tokens": "hashes = results ; // if(inside(columnCenter, intersection)) rowHashes.push(columnHash); self . rowHash = geohash . neighbor ( self . rowHash , [ - 1 , 0 ] ) ; if ( rowBox [ 2 ] <= self . bounding [ 0 ] ) {", "commit_type": "add"}
{"commit_tokens": ["making", "clone", "dest", "configurable", "via", "STRIDER_CLONE_DEST"], "add_tokens": "return process . env . STRIDER_CLONE_DEST || path . join ( __dirname , \"_work\" )", "del_tokens": "return path . join ( __dirname , \"_work\" )", "commit_type": "make"}
{"commit_tokens": ["fix", "bug", "X", "-", "Forwarder", "-", "For"], "add_tokens": "* var forwardedIpsStr = req . header ( 'X-Forwarder-For' ) , exports . getClientIp = getClientIp ;", "del_tokens": "* var forwardedIpsStr = req . header ( 'X-Forwarded-For' ) , exports . getClientIp = getClientIp ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "config", "loading", "indepenent", "of", "paths"], "add_tokens": "\"use strict\" ; const config = require ( './configuration' ) ; const path = require ( 'path' ) ; configuration : config ( path . resolve ( process . cwd ( ) , 'config' ) )", "del_tokens": "var config = require ( './configuration' ) ; configuration : config ( )", "commit_type": "make"}
{"commit_tokens": ["added", "indexes", "to", "schema", "and", "tests", "for", "finding", "them"], "add_tokens": "this . indexes = { } ; Schema . prototype . $_getIndexes = function ( descriptor ) { var self = this ; var res = ps . searchForBoolean ( descriptor , 'index' , { separator : '.' } ) ; if ( res && res . length > 0 ) { var inds = _ . map ( res , function ( elem ) { if ( Array . isArray ( elem . value ) ) { return { path : elem . path . slice ( 0 , elem . path . lastIndexOf ( '.' ) ) } } else { return { path : elem . path } } } ) ; if ( inds && inds . length > 0 ) { inds . forEach ( function ( elem ) { self . indexes [ elem . path ] = elem ; } ) ; } } } ; var d ; d = descriptor ; d = key ; this . $_getRefs ( d ) ; this . $_getIndexes ( d ) ; this . $_applyDocumentKey ( d ) ;", "del_tokens": "this . $_applyDocumentKey . apply ( this , arguments ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "back", "/", "forword", "buttons", "in", "the", "browser"], "add_tokens": "var self = this ; addEvent ( window , 'popstate' , self . onPopState , self ) ;", "del_tokens": "addEvent ( window , 'popstate' , this . onPopState , this ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "sbot", ".", "pull", ".", "replicateProgress", "and", "queryProgress"], "add_tokens": "search : true , replicateProgress : true , queryProgress : true } ) , replicateProgress : rec . source ( function ( opts ) { return sbot . replicate . changes ( ) } ) , queryProgress : rec . source ( function ( opts ) { return sbot . query . progress ( )", "del_tokens": "search : true", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "when", "all", "adapters", "are", "from", "plugins"], "add_tokens": "return this . injector . adapters || { } ;", "del_tokens": "return adapters ;", "commit_type": "fix"}
{"commit_tokens": ["Move", "to", "logger", "from", "appium", "-", "support"], "add_tokens": "import { logger } from 'appium-support' ; const log = logger . getLogger ( 'UiAutomator2' ) ;", "del_tokens": "import { getLogger } from 'appium-logger' ; const log = getLogger ( 'UiAutomator2' ) ;", "commit_type": "move"}
{"commit_tokens": ["change", "string", "splitting", "using", "Array", ".", "from", "to", "punycode"], "add_tokens": "import punycode from 'punycode' ; const getString = ( array , from , to ) => punycode . ucs2 . encode ( array . slice ( from , to ) ) ; this . textArray = punycode . ucs2 . decode ( text ) ;", "del_tokens": "const getString = ( array , from , to ) => array . slice ( from , to ) . join ( '' ) ; this . textArray = Array . from ( text ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "a", "logErrors", "option", "to", "control", "whether", "script", "errors", "are", "logged", "to", "grunt", "."], "add_tokens": "bail : false , // Log script errors as grunt errors logErrors : false // Output errors on script errors if ( options . logErrors ) { phantomjs . on ( 'error.*' , function ( error , stack ) { var stack = _ . map ( stack , function ( frame ) { return \" at \" + ( frame . function ? frame . function : \"undefined\" ) + \" (\" + frame . file + \":\" + frame . line + \")\" ; } ) . join ( \"\\n\" ) ; grunt . log . error ( error + \"\\n\" + stack ) ; } ) ; }", "del_tokens": "phantomjs . on ( 'error.*' , function ( error , stack ) { var stack = _ . map ( stack , function ( frame ) { return \" at \" + ( frame . function ? frame . function : \"undefined\" ) + \" (\" + frame . file + \":\" + frame . line + \")\" ; } ) . join ( \"\\n\" ) ; grunt . log . error ( error + \"\\n\" + stack ) ; } ) ; bail : false", "commit_type": "add"}
{"commit_tokens": ["Added", "an", "FAQ", "page", "basic", "Web", "Worker", "detection", "and", "reworked", "the", "build", "scripts", "."], "add_tokens": "console . log ( \"Welcome to Quanah :-)\" ) ;", "del_tokens": "console . log ( \"Welcome to the Quanah Lab :-)\" ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "spaces", "in", "regex", "as", "causing", "bug", "."], "add_tokens": "let c = '{\"a\" : 1, \"b\" : 2}' ;", "del_tokens": "let c = '{\"a\":1, \"b\":2}' ;", "commit_type": "remove"}
{"commit_tokens": ["adding", "capability", "to", "fail", "grunt", "task", "outside", "zap_stop"], "add_tokens": "grunt . fail . fatal ( 'Error launching ZAProxy. Make sure that ZAProxy is installed and ' + zapScript + ' is available on the executable path: ' + JSON . stringify ( err , null , 2 ) ) ; var done = this . async ( ) ; grunt . registerTask ( 'zap_results' , 'It fails if found an alert that should not be ignored' , function ( ) { var done = this . async ( ) ; grunt . log . write ( 'Verifying alert errors...' ) ; if ( grunt . config . get ( 'zap_alert.failed' ) ) { grunt . log . write ( 'Error found!' ) ; done ( false ) ; } done ( true ) ; } ) ;", "del_tokens": "grunt . fail . fatal ( 'Error launching ZAProxy. Make sure that ZAProxy is installed and zap.sh is available on the executable path: ' + JSON . stringify ( err , null , 2 ) ) ; var asyncDone = this . async ( ) ; // fail the build if zap_alert found errors var done = function ( ) { if ( grunt . config . get ( 'zap_alert.failed' ) ) { asyncDone ( false ) ; } else { asyncDone ( true ) ; } } ;", "commit_type": "add"}
{"commit_tokens": ["Created", "index", "defaults", "and", "resize", "-", "root", "-", "font", "-", "size", "specs"], "add_tokens": "import { isCallBackDefined } from './utilities' ; console . log ( preCalculatedValues ) rootElement . style . fontSize = ( rootFontSize * designWidthRatio * evalDevicePixelRatio ) . toFixed ( 6 ) + 'rem' ; export default resizeRootFontSize ;", "del_tokens": "import { isCallBackDefined } from './utilities' ; rootElementStyle , rootElementStyle . fontSize = ( rootFontSize * designWidthRatio * evalDevicePixelRatio ) . toFixed ( 6 ) + 'rem' ; export default resizeRootFontSize ;", "commit_type": "create"}
{"commit_tokens": ["Add", "back", "just", "the", "style", "changes"], "add_tokens": "< th style = { { minWidth : '100px' } } >", "del_tokens": "< th >", "commit_type": "add"}
{"commit_tokens": ["remove", "annoying", "console", ".", "log"], "add_tokens": "//console.log(\"No possible entries for\", file, mime_type, await this.entries.find(mime_type)) //console.log(\"No valid entries\", possible_entries) //console.log(\"Valid entry : \", valid_entries[0][this.entries.type[\"name\"]])", "del_tokens": "console . log ( \"No possible entries for\" , file , mime_type , await this . entries . find ( mime_type ) ) console . log ( \"No valid entries\" , possible_entries ) console . log ( \"Valid entry : \" , valid_entries [ 0 ] [ this . entries . type [ \"name\" ] ] )", "commit_type": "remove"}
{"commit_tokens": ["improve", "event", "bubbling", "for", "embedded", "models"], "add_tokens": "var contract = [ 'model' , '_events' , '_byId' , 'compareFunction' ]", "del_tokens": "var contract = [ 'model' , '_events' , 'compareFunction' ]", "commit_type": "improve"}
{"commit_tokens": ["add", "side", "effect", "to", "reactive", "-", "component"], "add_tokens": "this . state = { childProps : { } } // make dispatch and upstream accessible to all components // make dispatch side effect accessible to all components this . dispatchSideEffect = this . context . upstream . dispatchSideEffect . bind ( this . context . upstream ) ; // creates a new substream for each action type // subscribes to the props stream. This will trigger a rerender whenever a new action has been dispatched to any filtered stream passed down as props to a component this . setState ( { childProps : props } ) ; Object . assign ( this . state . childProps , { dispatch : this . dispatch , dispatchSideEffect : this . dispatchSideEffect } } ) , } ReactiveComponent . contextTypes = { upstream : React . PropTypes . object . isRequired } return ReactiveComponent ;", "del_tokens": "this . state = { childProps : { } } // make dispatch and upstream accessible to all components // creates a new substream for each action type // subscribes to the props stream. This will trigger a rerender whenever a new action has been dispatched to any filtered stream passed down as props to a component this . setState ( { childProps : props } ) ; Object . assign ( this . state . childProps , { dispatch : this . dispatch } ) , } ReactiveComponent . contextTypes = { upstream : React . PropTypes . object . isRequired } return ReactiveComponent ;", "commit_type": "add"}
{"commit_tokens": ["implement", "read", "-", "dir", "-", "structure"], "add_tokens": "const fileOrDir = ( lstat ) => { return lstat . isFile ( ) || lstat . isDirectory ( ) } return recursive ? fileOrDir ( file . lstat ) : file . lstat . isFile ( )", "del_tokens": "return recursive ? true : file . lstat . isFile ( )", "commit_type": "implement"}
{"commit_tokens": ["Add", "support", "for", "Adobe", "AIR", "."], "add_tokens": "} else if ( this . userAgent_ . indexOf ( \"AdobeAIR\" ) != - 1 ) { name = \"AdobeAIR\" ; } else if ( name == \"AdobeAIR\" ) { version = this . getMatchingGroup_ ( this . userAgent_ , / AdobeAIR\\/([\\d\\.]+) / , 1 ) ; } var supportWebFont = false ; if ( name == \"AdobeAIR\" ) { var minor = this . getMatchingGroup_ ( version , / \\d+\\.(\\d+) / , 1 ) ; supportWebFont = this . getMajorVersion_ ( version ) > 2 || this . getMajorVersion_ ( version ) == 2 && parseInt ( minor , 10 ) >= 5 ; } else { var minor = this . getMatchingGroup_ ( webKitVersion , / \\d+\\.(\\d+) / , 1 ) ; supportWebFont = this . getMajorVersion_ ( webKitVersion ) >= 526 || this . getMajorVersion_ ( webKitVersion ) >= 525 && parseInt ( minor , 10 ) >= 13 ; platform , platformVersion , this . getDocumentMode_ ( this . doc_ ) , supportWebFont ) ;", "del_tokens": "var minor = this . getMatchingGroup_ ( webKitVersion , / \\d+\\.(\\d+) / , 1 ) ; platform , platformVersion , this . getDocumentMode_ ( this . doc_ ) , this . getMajorVersion_ ( webKitVersion ) >= 526 || this . getMajorVersion_ ( webKitVersion ) >= 525 && parseInt ( minor , 10 ) >= 13 ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "timestamp", "to", "zip", "name"], "add_tokens": ". pipe ( zip ( 'ceb-source-' + ( Date . now ( ) ) + '.zip' ) )", "del_tokens": ". pipe ( zip ( 'ceb-source.zip' ) )", "commit_type": "add"}
{"commit_tokens": ["fix", "errors", "in", "hlp", "/", "add"], "add_tokens": "throw new Error ( stringify ( lefthand ) + ' + ' + stringify ( righthand ) +", "del_tokens": "throw new Error ( stringify ( lefthand ) + ' + ' stringify ( righthand ) +", "commit_type": "fix"}
{"commit_tokens": ["adding", "play", "command", "link", "to", "the", "7", "-", "bit", "+", "1", "parity", "link"], "add_tokens": "// https://hifiduino.wordpress.com/apple-aluminum-remote/ 46 : \"center\" , 47 : \"play\"", "del_tokens": "46 : \"center\"", "commit_type": "add"}
{"commit_tokens": ["Use", "a", "pager", "if", "the", "number", "of", "results", "exceed", "the", "number", "of", "row", "in", "the", "tty", "."], "add_tokens": "var exec = require ( './utils' ) . exec", "del_tokens": "var spawn = require ( 'child_process' ) . spawn / ** * Some of this code was stolen from npm . * https : //github.com/isaacs/npm/blob/master/lib/utils/exec.js * / function exec ( cmd , args , env , cb ) { var stdio = process . binding ( \"stdio\" ) , fds = [ stdio . stdinFD || 0 , stdio . stdoutFD || 1 , stdio . stderrFD || 2 ] spawn ( cmd , args , { env : env , customFds : fds , cwd : __dirname } ) . on ( \"exit\" , cb ) ; }", "commit_type": "use"}
{"commit_tokens": ["fix", "flags", "z", "nz", "nc"], "add_tokens": "case 'z' : value = cpu . f >> 7 ; break ; case 'nz' : value = cpu . f >> 7 ? 0 : 1 ; break ; case 'nc' : value = cpu . f >> 4 & 1 ? 0 : 1 ; break ;", "del_tokens": "case 'z' : value = cpu . f & 0x80 ; break ; case 'nz' : value = ! ( cpu . f & 0x80 ) ? 1 : 0 ; break ; case 'nc' : value = ! ( cpu . f & 0x10 ) ? 1 : 0 ; break ;", "commit_type": "fix"}
{"commit_tokens": ["fixing", "target", "after", "same", "parent", "index", "value", "."], "add_tokens": "if ( target . accept ( scope , target . sortableScope ) ) { if ( targetBefore ) { dragInfo . moveTo ( target . sortableScope , target . index ( ) ) ; } else { dragInfo . moveTo ( target . sortableScope , target . index ( ) + 1 ) ;", "del_tokens": "if ( targetBefore ) { currentAccept = target . accept ( scope , target . sortableScope ) ; if ( currentAccept ) { dragInfo . moveTo ( target . sortableScope , target . $index ) ; } } else { currentAccept = target . accept ( scope , target . sortableScope ) ; if ( currentAccept ) { dragInfo . moveTo ( target . sortableScope , target . $index + 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "an", "error", "in", "the", "error", "-", "reporting", "for", "the", "writeMany", "function", "."], "add_tokens": "'addresseses' : addresses , 'values' : values", "del_tokens": "'addresseses' : addresseses , 'values' : values", "commit_type": "fix"}
{"commit_tokens": ["Make", "swagger", "-", "security", "send", "errors", "downstream", "via", "next"], "add_tokens": "var helpers = require ( '../helpers' ) ; helpers . sendSecurityError ( errors [ 0 ] , res , next ) ;", "del_tokens": "function handleSecurityError ( err , res ) { var body = { 'error_description' : err . message , state : err . state , error : err . code || 'server_error' } ; if ( err . headers ) { _ . each ( _ . keys ( err . headers ) , function ( name ) { res . setHeader ( name , err . headers [ name ] ) ; } ) ; } res . statusCode = err . statusCode || 403 ; res . end ( JSON . stringify ( body ) ) ; } handleSecurityError ( errors [ 0 ] , res ) ;", "commit_type": "make"}
{"commit_tokens": ["Update", "version", "for", "new", "release"], "add_tokens": "this . version = function ( ) { return '1.5.3' ; } ;", "del_tokens": "this . version = function ( ) { return '1.5.2' ; } ;", "commit_type": "update"}
{"commit_tokens": ["Remove", "support", "for", "multiple", "eventTypes", "in", "a", "single", "#on", "or", "#off", "."], "add_tokens": "delegate . on ( 'click' , '#delegate-test-clickable' , spyA ) ; delegate . on ( 'click' , '#delegate-test-clickable' , spyB ) ; delegate . on ( 'click' , '#delegate-test-clickable' , spy ) ; delegate . on ( 'click' , '#delegate-test-clickable' , spy ) ; delegate . on ( 'click' , '#delegate-test-clickable' , spyA ) ; delegate . on ( 'click' , '#another-delegate-test-clickable' , spyB ) ;", "del_tokens": "delegate . on ( 'click mouseover' , '#delegate-test-clickable' , spyA ) ; delegate . on ( 'click mouseover' , '#delegate-test-clickable' , spyB ) ; delegate . on ( 'click mouseover' , '#delegate-test-clickable' , spy ) ; delegate . on ( 'click mouseover' , '#delegate-test-clickable' , spy ) ; delegate . on ( 'click mouseover' , '#delegate-test-clickable' , spyA ) ; delegate . on ( 'click mouseover' , '#another-delegate-test-clickable' , spyB ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "test", "for", "non", "-", "null", "hbs", ".", "handlebars", "before", "first", "compile", "call"], "add_tokens": "var handlebars = hbs . handlebars ; assert . ok ( handlebars != null ) ;", "del_tokens": "//var handlebars = hbs.handlebars; //assert.ok(handlebars != null);", "commit_type": "add"}
{"commit_tokens": ["make", "d3", "tree", "responsive", "dynamically", "size", "width", "of", "node", "boxes", "by", "max", "label", "length"], "add_tokens": "< script type = \"text/javascript\" > \\n var d3Obj = $ { JSON . stringify ( d3Obj , null , 2 ) } \\n $ { treeLogic } \\n < / script > \\ n ${ endHtml } ` ; fs . writeFile ( ` ${ process . cwd ( ) } ` , insert , err => {", "del_tokens": "< script type = \"text/javascript\" > \\n var d3Obj = $ { JSON . stringify ( d3Obj ) } \\n $ { treeLogic } \\n < / script > \\ n ${ endHtml } ` ; fs . writeFile ( ` ${ process . cwd ( ) } ` , insert , err => {", "commit_type": "make"}
{"commit_tokens": ["Fixed", "the", "row", "count", "in", "selectAllHeader", "from", "breaking", "the", "table", "header", "/"], "add_tokens": "< th style = { { minWidth : '100px' } } >", "del_tokens": "< th >", "commit_type": "fix"}
{"commit_tokens": ["implement", "deleteMany", "for", "web", "client"], "add_tokens": "deleteOne ( ns , filter , options , callback ) { this . _getCollection ( ns ) . deleteOne ( filter , options ) . then ( ( result ) => { callback ( null , result ) ; } ) . catch ( ( err ) => { callback ( err ) ; } ) ; } / ** * Delete multiple documents from the collection . * * @ param { String } ns - The namespace . * @ param { Object } filter - The filter . * @ param { Object } options - The options . * @ param { Function } callback - The callback . * / deleteMany ( ns , filter , options , callback ) { this . _getCollection ( ns ) . deleteMany ( filter , options )", "del_tokens": "deleteOne ( ns , doc , options , callback ) { this . _getCollection ( ns ) . deleteOne ( doc )", "commit_type": "implement"}
{"commit_tokens": ["Add", "remove", "method", "for", "older", "browsers", "."], "add_tokens": "function remove ( key ) { } that . remove = remove ; that [ \"delete\" ] = remove ;", "del_tokens": "that . delete = function ( key ) { } ;", "commit_type": "add"}
{"commit_tokens": ["Removing", "SkillTier", "and", "Karma", "mapping", "from", "Stats"], "add_tokens": "get skillTier ( ) { return skillTiers . find ( tier => tier . serverName === stats . skillTier ) || null ; } get karmaLevel ( ) { const stats = this . raw . attributes . stats ; return karma . find ( tier => tier . serverName === stats . karmaLevel ) || null ; } get stats ( ) { return this . raw . attributes . stats ;", "del_tokens": "get stats ( ) { const skillTier = skillTiers . find ( tier => tier . serverName === stats . skillTier ) ; const karmaLevel = karma . find ( k => k . serverName === stats . karmaLevel ) ; stats . skillTier = skillTier ? skillTier . name : stats . skillTier ; stats . karmaLevel = karmaLevel ? karmaLevel . name : stats . karmaLevel ; return stats ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "support", "for", "storing", "into", "seneca", "column", "special", "data", "types", "."], "add_tokens": "CREATE TABLE foo ( id VARCHAR ( 36 ) , p1 VARCHAR ( 255 ) , p2 VARCHAR ( 255 ) , seneca VARCHAR ( 125 ) ) ; obj TEXT , seneca VARCHAR ( 125 ) ) ;", "del_tokens": "CREATE TABLE foo ( id VARCHAR ( 36 ) , p1 VARCHAR ( 255 ) , p2 VARCHAR ( 255 ) ) ; obj TEXT ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "spaces", "after", "semicolons", "in", "for", "loops"], "add_tokens": "line , line ,", "del_tokens": "softline , softline ,", "commit_type": "add"}
{"commit_tokens": ["updating", "for", "new", "module", "structure"], "add_tokens": "import resolve from 'rollup-plugin-node-resolve' ; moduleName : 'stickyNav' , // for the iife bundle resolve ( { // this allows us to pull in other modules as ES6 bundles (ie. scrollify stuffs) jsnext : true , main : true , browser : false } ) ,", "del_tokens": "moduleName : 'stickyNav' ,", "commit_type": "update"}
{"commit_tokens": ["Added", "express", "dependency", "and", "drafted", "some", "initial", "endpoints", "."], "add_tokens": "if ( ! pkg ) { callback ( new Error ( 'Package ' + pkgName + ' not found. Did you add it yet?' ) ) ; return ; }", "del_tokens": "callback ( new Error ( 'Package ' + pkgName + ' not found. Did you add it yet?' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "log", "message", "lost", "before", "document", "ready"], "add_tokens": "html = html . replace ( / <head> / ig , function ( match ) { return match + script ;", "del_tokens": "html = html . replace ( / (<\\/head>) / ig , function ( match ) { return script + match ;", "commit_type": "fix"}
{"commit_tokens": ["Move", "replace", "to", "functional", "node", "-", "building", "style"], "add_tokens": "if ( to >= this . depth ) return this", "del_tokens": "if ( to == this . depth ) return this", "commit_type": "move"}
{"commit_tokens": ["Removed", "old", "f_", "versions", "renamed", "master", "to", "f_"], "add_tokens": "module . exports = require ( './lib/f_.js' ) ;", "del_tokens": "module . exports = require ( './lib/f_dev.js' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Update", "the", "format", "of", "the", "source", "code"], "add_tokens": "/ *! * range - parser * Copyright ( c ) 2012 - 2014 TJ Holowaychuk * MIT Licensed * / / ** * Module exports . * @ public * / module . exports = rangeParser ; * @ public function rangeParser ( size , str ) { }", "del_tokens": "* @ api public module . exports = function ( size , str ) { } ;", "commit_type": "update"}
{"commit_tokens": ["changed", ":", "remove", "comment", "in", "cdp", ".", "js", "."], "add_tokens": "* Date : 2016 - 05 - 11 T12 : 51 : 21 + 0900", "del_tokens": "* Date : 2016 - 05 - 10 T22 : 26 : 32 + 0900", "commit_type": "change"}
{"commit_tokens": ["use", "cotton", "candy", "setter", "getter", "plugin"], "add_tokens": "var cottonCandySetterGetter = require ( 'cotton-candy/setter-getter' ) cottonCandyInclude , cottonCandySetterGetter", "del_tokens": "cottonCandyInclude", "commit_type": "use"}
{"commit_tokens": ["Added", "list", "of", "parameters", "for", "each", "action", "to", "IOD", "object", ".", "Added", "action", "parameter", "aliases", "to", "be", "included", "in", "schema", "check", "."], "add_tokens": "U . invalidStringType ( IOD , 'database_match' , 'DT' , alias ) , U . invalidStringType ( IOD , 'min_date' , 'FRC' , action ) , U . invalidStringType ( IOD , 'max_date' , 'DT' , alias ) , U . invalidNumberType ( IOD , 'min_score' , 'FRC' , action ) , U . invalidNumberType ( IOD , 'sample_size' , 'DT' , alias ) , U . invalidNumberType ( IOD , 'max_results' , 'FRC' , action )", "del_tokens": "U . invalidStringType ( IOD , 'min_date' , 'DT' , alias ) , U . invalidStringType ( IOD , 'max_date' , 'FRC' , action ) , U . invalidNumberType ( IOD , 'min_score' , 'DT' , alias ) , U . invalidNumberType ( IOD , 'sample_size' , 'FRC' , action ) , U . invalidNumberType ( IOD , 'max_results' , 'DT' , alias )", "commit_type": "add"}
{"commit_tokens": ["create", "virtual", "dom", "is", "this"], "add_tokens": "var this . createVirtualDOM = function ( node ) {", "del_tokens": "var createVirtualDOM = function ( node ) {", "commit_type": "create"}
{"commit_tokens": ["Fix", "slashes", "in", "sources", "path", "for", "Windows"], "add_tokens": "sourceMap . sources [ i ] = path . relative ( file . base , absPath ) . replace ( '\\\\' , '/' ) ;", "del_tokens": "sourceMap . sources [ i ] = path . relative ( file . base , absPath ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "specifying", "request", "headers", ".", "Update", "README", "to", "mention", "$", ".", "Bump", "version", "."], "add_tokens": "var cliHelper = require ( \"../lib/spiderUtils\" ) ;", "del_tokens": "var cliHelper = require ( \"../lib/cliHelper\" ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "memoize", "for", "getters", "without", "value"], "add_tokens": "import { isStateLocked , markSetterOnPrivateScope } from './Controller' ; markSetterOnPrivateScope ( privateScope ) ; if ( isStateLocked ( internalState ) && internalState . initialState !== undefined ) {", "del_tokens": "if ( internalState . isStateLocked && internalState . initialState !== undefined ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "initial", "back", "button", "behaviour", "(", "hash", "routing", ")"], "add_tokens": "var path = this . getPath ( ) ;", "del_tokens": "var path = window . location . hash . slice ( 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "profile", "getter", "for", "single", "key", ";"], "add_tokens": "this . _prepareProfile ( options . profile ) ; } else if ( typeof key === 'string' ) { _prepareProfile : function ( name ) { var current = name || this . current ( ) ;", "del_tokens": "this . _prepareProfile ( ) ; var current = options . current || this . current ( ) ; current && this . _initProfile ( current ) ; } else if ( typeof key === value ) { _prepareProfile : function ( ) { var current = options . current || this . current ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "CSV", "support", "and", "test", "cases"], "add_tokens": "types : [ / text\\/ / , \"application/csv\" , \"application/javascript\" ] ,", "del_tokens": "types : [ / text\\/ / , \"application/javascript\" ] ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "up", "the", "test", "to", "validate", "dependencies", "exist", "after", "update"], "add_tokens": "\"Test update & save only async and request dependencies\" : function ( test ) { var proc = childProcess . exec ( \"node ../../../bin/david update async request\" , { cwd : \"test/tmp/test-filtered-update\" } , function ( er ) { if ( depName === \"async\" || depName === \"request\" ) { // Ensure the dependencies still exist test . ok ( updatedPkg . dependencies . async ) test . ok ( updatedPkg . devDependencies . request ) if ( depName === \"request\" ) {", "del_tokens": "\"Test update & save only async and grunt dependencies\" : function ( test ) { var proc = childProcess . exec ( \"node ../../../bin/david update async grunt\" , { cwd : \"test/tmp/test-filtered-update\" } , function ( er ) { if ( depName === \"async\" || depName === \"grunt\" ) { if ( depName === \"grunt\" ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "keep", "array", "selector", "function"], "add_tokens": "return [ _ . takeWhile ( pred , array ) , _ . dropWhile ( pred , array ) ] ; } , // Returns an array of existy results of a function over an source array. keep : function ( array , fun ) { if ( ! isSeq ( array ) ) throw new TypeError ( \"expected an array as the first argument\" ) ; return _ . filter ( _ . map ( array , function ( e ) { return fun ( e ) ; } ) , existy ) ; }", "del_tokens": "return [ _ . takeWhile ( pred , array ) , L . dropWhile ( pred , array ) ] ; }", "commit_type": "add"}
{"commit_tokens": ["adding", "the", "--", "public", "flag", "to", "allow", "users", "to", "open", "the", "drakov", "server", "to"], "add_tokens": "if ( argv . public ) { console . log ( ' PUBLIC MODE ' . grey . bold . inverse , 'running publicly' . grey ) ; } if ( argv . public === true ) { return https . createServer ( sslOptions , app ) . listen ( argv . serverPort , startCb ) ; } else { return https . createServer ( sslOptions , app ) . listen ( argv . serverPort , 'localhost' , startCb ) ; } if ( argv . public === true ) { return app . listen ( argv . serverPort , startCb ) ; } else { return app . listen ( argv . serverPort , 'localhost' , startCb ) ; }", "del_tokens": "return https . createServer ( sslOptions , app ) . listen ( argv . serverPort , 'localhost' , startCb ) ; return app . listen ( argv . serverPort , 'localhost' , startCb ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "fallback", "for", "triggering", "events"], "add_tokens": "if ( typeof MouseEvent === 'function' && typeof element . dispatchEvent === 'function' ) { var event = new MouseEvent ( 'click' , { view : window , bubbles : true , cancelable : true } ) ; element . dispatchEvent ( event ) ; } else { var event = document . createEvent ( 'MouseEvent' ) ; event . initEvent ( 'click' , true , true ) ; element . dispatchEvent ( event ) ; }", "del_tokens": "var event = new MouseEvent ( 'click' , { view : window , bubbles : true , cancelable : true } ) ; element . dispatchEvent ( event ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "sure", "object", "is", "type", "function", "before", "calling", "cleanup"], "add_tokens": "if ( ! obj ) { throw new Error ( 'Unable to call `' + name + '`, which is undefined or falsey' ) ; else if ( typeof obj !== 'function' ) { throw new Error ( 'Unable to call `' + name + '`, which is not a function' ) ; } return obj . apply ( this , args ) ;", "del_tokens": "if ( obj ) { return obj . apply ( this , args ) ; throw new Error ( 'Could not find value \"' + name + '\" to call.' ) ;", "commit_type": "make"}
{"commit_tokens": ["changed", "null", "to", "user", ".", "id"], "add_tokens": "// force create by pass of user id self . findOrCreateAuth ( user . id , attributes , cb ) ; } ;", "del_tokens": "// force create by pass null criteria self . findOrCreateAuth ( null , attributes , cb ) ; } ;", "commit_type": "change"}
{"commit_tokens": ["Use", "node", "style", "callback", "errors"], "add_tokens": "function fakeReq ( server , callback ) { function getManifest ( server , callback ) { callback ( null , manifest ) ; callback ( err ) ; it ( 'Should contain expected elements' , function ( done ) { getManifest ( server , function ( err , manifest ) { if ( err ) { done ( err ) ; return ; } } ) ;", "del_tokens": "function fakeReq ( server , callback ) { //TODO: use err, stuff node style callback function getManifest ( server , callback , done ) { callback ( manifest ) ; done ( err ) ; it ( 'should contain expected elements' , function ( done ) { getManifest ( server , function ( manifest ) { } , done ) ;", "commit_type": "use"}
{"commit_tokens": ["Use", "riot", ".", "compile", "instead", "of", "riot", ".", "tag"], "add_tokens": "// compile using riot.compile { var dummyHtml = \"<\" + tagName + \">\" + template + \"</\" + tagName + \">\" ; var compiled = riot . compile ( dummyHtml , true ) ; var stripped = compiled . substr ( 12 + tagName . length ) ; var x = stripped . lastIndexOf ( \", function(opts) {\" ) ; stripped = stripped . substr ( 0 , x ) ; var compiledTemplate = eval ( \"[\" + stripped + \"]\" ) ; var html = compiledTemplate . length > 0 ? compiledTemplate [ 0 ] : \"\" ; var css = compiledTemplate . length > 1 ? compiledTemplate [ 1 ] : \"\" ; var attr = compiledTemplate . length > 2 ? compiledTemplate [ 2 ] : undefined ; riot . tag ( tagName , html , css , attr , transformFunction ) ; } //riot.tag(tagName, template, transformFunction);", "del_tokens": "riot . tag ( tagName , template , transformFunction ) ;", "commit_type": "use"}
{"commit_tokens": ["remove", "webpack", "Buffer", "polyfill", "to", "save", "50KB"], "add_tokens": "this . contours . addChildren ( current ) ;", "del_tokens": "this . addContour ( current ) ;", "commit_type": "remove"}
{"commit_tokens": ["add", "support", "for", "specifying", "badge", "format"], "add_tokens": "opts . badgeFormat = opts . badgeFormat || \"svg\" ; url += \"%-\" + color + \".\" + opts . badgeFormat + \"?style=\" + opts . shieldStyle ; var badgeFileName = path . join ( opts . destinationDir , opts . badgeFileName + \".\" + opts . badgeFormat ) ;", "del_tokens": "url += \"%-\" + color + \".svg?style=\" + opts . shieldStyle ; var badgeFileName = path . join ( opts . destinationDir , opts . badgeFileName + \".svg\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "more", "than", "6", "digits", "in", "Unicode", "code", "points"], "add_tokens": "// Using `u` flag, 6 digits, 10FFFF is max. expect ( re ( / \\u{10FFFF} / u ) . body ) . toEqual ( { value : '\\\\u{10FFFF}' , // Using `u` flag, leading zeros. expect ( re ( / \\u{000001D306} / u ) . body ) . toEqual ( { value : '\\\\u{000001D306}' ,", "del_tokens": "// Using `u` flag, 5 digits. expect ( re ( / \\u{1D306} / u ) . body ) . toEqual ( { value : '\\\\u{1D306}' , // Using `u` flag, 6 digits, 10FFFF is max. expect ( re ( / \\u{10FFFF} / u ) . body ) . toEqual ( { value : '\\\\u{10FFFF}' ,", "commit_type": "allow"}
{"commit_tokens": ["Improve", "cannonicalization", "by", "skipping", "the", "html", "parser", "when", "unnecessary", ".", "Make", "sure", "define", ".", "min", "is", "not", "wrapped", ".", "bump", "version", "."], "add_tokens": "if ( ! div . addEventListener ) { div . innerHTML = div . innerHTML ; // Run the current innerHTML back through the parser }", "del_tokens": "div . innerHTML = div . innerHTML ; // Run the current innerHTML back through the parser", "commit_type": "improve"}
{"commit_tokens": ["Remove", "pouchdb", "-", "find", "from", "dist"], "add_tokens": "window . PouchDB . plugin ( exports ) ;", "del_tokens": "window . PouchDB . plugin ( exports ) . plugin ( require ( 'pouchdb-find' ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Upgrade", "to", "semver", "to", "2", ".", "Refactored", "and", "simplified", "semverext", ".", "gtr", "code", "in", "response", "."], "add_tokens": ", [ \"1\" , \"2.0.0beta\" , true ] , [ \"1\" , \"2.0.0beta\" , true ] , [ \"<1\" , \"1.0.0beta\" , true ] , [ \"< 1\" , \"1.0.0beta\" , true ] var result = semverext . gtr ( tuple [ 1 ] , tuple [ 0 ] , tuple [ 2 ] ) ; 'negative gtr tests' : function ( test ) { , [ \"\" , \"1.0.0\" , true ] , [ \"1\" , \"1.0.0beta\" , true ] console . log ( 'Is' , tuple [ 1 ] , 'greater than' , tuple [ 0 ] , '?' ) ; var result = semverext . gtr ( tuple [ 1 ] , tuple [ 0 ] , tuple [ 2 ] ) ; console . log ( result ? 'Yes' : 'No' , result ? '<--- UNEXPECTED' : '(Expected)' ) ;", "del_tokens": ", [ \"1\" , \"2.0.0beta\" ] , [ \"1\" , \"2.0.0beta\" ] , [ \"<1\" , \"1.0.0beta\" ] , [ \"< 1\" , \"1.0.0beta\" ] var result = semverext . gtr ( tuple [ 1 ] , tuple [ 0 ] ) ; 'Negative gtr tests' : function ( test ) { , [ \"\" , \"1.0.0\" ] , [ \"1\" , \"1.0.0beta\" ] //console.log('Is', tuple[1], 'greater than', tuple[0], '?'); var result = semverext . gtr ( tuple [ 1 ] , tuple [ 0 ] ) ; //console.log(result ? 'Yes' : 'No', result ? '<--- UNEXPECTED' : '(Expected)');", "commit_type": "upgrade"}
{"commit_tokens": ["Fix", "for", "Mac", "building", "typo"], "add_tokens": "path . resolve ( platform . releasePath , self . options . appName + '.app' , 'Contents' , 'Resources' , 'app.nw' )", "del_tokens": "path . resolve ( platform . releasePath , self . options . appName + '.app' , 'Contents' , 'Resources' , 'nw.icns' )", "commit_type": "fix"}
{"commit_tokens": ["removed", "crisp", "references", "in", "cli"], "add_tokens": "console . log ( 'Examples: `resume export myresume.pdf --theme modern`' ) ;", "del_tokens": "console . log ( 'Examples: `resume export myresume.pdf --theme crisp`' ) ; console . log ( 'available themes: modern, traditional, crisp' ) ;", "commit_type": "remove"}
{"commit_tokens": ["adds", "README", ".", "md", "to", "created", "project"], "add_tokens": "function addFile ( target , filename ) { const content = fs . readFileSync ( filename , 'utf-8' ) ; target [ filename ] = content ; } const fs = { } ; addFile ( fs , ProjectInitCommand . templateFile ( 'README.md' ) ) ; mockfs ( fs ) ; expectTemplate ( path . join ( directory , 'README.md' ) , 'README.md' , properties ) ;", "del_tokens": "mockfs ( { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "latest", "version", "of", "amcharts", "package", ".", "json"], "add_tokens": "require ( 'amcharts3' ) ;", "del_tokens": "require ( 'amcharts3/amcharts/amcharts' ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "css", "imports", "from", "javascript"], "add_tokens": "constructor ( { dependencyRepositoryFactory , loaderFactory , temporaryLoaderFactory } ) {", "del_tokens": "constructor ( { importParser , exportParser , wrapperGenerator , dependencyRepositoryFactory , loaderFactory , temporaryLoaderFactory } ) { this . importParser = importParser ; this . exportParser = exportParser ; this . wrapperGenerator = wrapperGenerator ; getScriptInterceptor ( ) { return this . intercept . bind ( this ) ; } intercept ( script ) { const module = { script , imports : [ ] , exports : [ ] } ; this . importParser . rewrite ( module ) ; this . exportParser . rewrite ( module ) ; this . wrapperGenerator . wrap ( module ) ; return script ; } intercept : this . getScriptInterceptor ( ) ,", "commit_type": "add"}
{"commit_tokens": ["Moving", "the", "options", ".", "rmtree", "condition", "outside", "self", ".", "parseData"], "add_tokens": "if ( options . action == 'add' && options . rmtree == true && fs . isDirectory ( data [ page ] . directory ) ) { self . echo ( '\\nWarning! ' + data [ page ] . directory + \" directory tree erased.\" , 'WARNING' ) ; fs . removeTree ( data [ page ] . directory ) ; }", "del_tokens": "if ( action == 'add' && options . rmtree == true && fs . isDirectory ( data [ p ] . directory ) ) { self . echo ( '\\nWarning! ' + data [ p ] . directory + \" directory tree erased.\" , 'WARNING' ) ; fs . removeTree ( data [ p ] . directory ) ; }", "commit_type": "move"}
{"commit_tokens": ["Update", "uint", "-", "var", ".", "esm", ".", "js"], "add_tokens": "//@export=BinaryVariableLengthInt //@endexport //@export=_UIntVar class __UIntVar extends BinaryVariableLengthInt { //＠endexport //@export=IntVar class IntVar extends BinaryVariableLengthInt { //@endexport export const UIntVar = __UIntVar ; export const IntVar = __IntVar ;", "del_tokens": "export class UIntVar extends BinaryVariableLengthInt { export class IntVar extends BinaryVariableLengthInt {", "commit_type": "update"}
{"commit_tokens": ["Added", "isHexString", "and", "sha256", "to", "utils", "."], "add_tokens": "var hash = require ( '../node_modules/elliptic/node_modules/hash.js/lib/hash.js' ) ; //if (keccak(new Buffer('ricmoo')) !== 'b05e424817fb90aa7a79e9da5c5f94070a316219c6ebb863a9ff7ca357dc9fa9') { // throw new Error('problem with sh3?!'); //} function sha256 ( data ) { if ( typeof ( data ) === 'string' ) { data = new Buffer ( data , 'utf8' ) ; } else if ( ! Buffer . isBuffer ( data ) ) { throw new Error ( 'must be a sting' ) ; } return ( new Buffer ( hash . sha256 ( ) . update ( data ) . digest ( 'hex' ) , 'hex' ) ) ; function isHexString ( value , length ) { if ( typeof ( value ) !== 'string' || ! value . match ( / ^0x[0-9A-Fa-f]*$ / ) ) { return false } if ( length && value . length !== 2 + 2 * length ) { return false ; } return true ; } if ( ! isHexString ( value ) ) { isHexString : isHexString , sha256 : sha256 ,", "del_tokens": "if ( keccak ( new Buffer ( 'ricmoo' ) ) !== 'b05e424817fb90aa7a79e9da5c5f94070a316219c6ebb863a9ff7ca357dc9fa9' ) { throw new Error ( 'problem with sh3?!' ) ; if ( typeof ( value ) !== 'string' || ! value . match ( / ^0x[0-9A-Fa-f]*$ / ) ) {", "commit_type": "add"}
{"commit_tokens": ["fixing", "path", "issue", "in", "windows"], "add_tokens": "return ( options . path ? path . join ( options . path , zapScript ) : zapScript ) ; var child = ( options . os === 'windows' ? spawn ( zapScript , args , { cwd : options . path } ) : spawn ( cmd ( ) , args ) ) ;", "del_tokens": "return path . join ( options . path , zapScript ) ; var child = ( options . path ? spawn ( cmd ( ) , args ) : spawn ( zapScript , args ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", ".", "DS_Store", "bug", "in", "common", "tests"], "add_tokens": "files = files . filter ( function ( filename ) { return / .js$ / . test ( filename ) ; } ) ; var compareFunctionPath = path . join ( __dirname , '../' , 'comparators' , compareFunction ) ;", "del_tokens": "console . log ( 'filename: ' , filename ) ; var compareFunctionPath = path . join ( '../' , 'comparators' , compareFunction ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "the", "right", "constructor", "for", "sync", "scheduler"], "add_tokens": "var syncSchedulerModule = require ( './sync-scheduler' ) ; var syncLockModule = require ( './lock' ) ; //TODO: remove redisClient. We probably don't need it anymore var syncLock = null ; syncStorage = storageModule ( ) ; syncLock = syncLockModule ( ) ; var SyncScheduler = syncSchedulerModule ( syncLock , syncStorage , metricsClient ) . SyncScheduler ; syncScheduler = new SyncScheduler ( syncQueue ) ;", "del_tokens": "var SyncScheduler = require ( './sync-scheduler' ) . SyncScheduler ; var datasetClientsCacheKey = 'sync:datasetClients' ; syncStorage = storageModule ( redisClient ) ; syncScheduler = new SyncScheduler ( redisClient , datasetClientsCacheKey ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "possibility", "to", "delete", "a", "property", "in", "DB"], "add_tokens": "MongoDatabase . prototype . removeProp = function ( collection , prop , callback ) { var query = { } ; query [ prop ] = { $exists : true } ; query [ 'locked' ] = { $ne : true } ; var update = { } ; update [ '$unset' ] = { } ; update [ '$unset' ] [ prop ] = '' ; collection = this . db . collection ( collection ) ; collection . update ( query , update , { multi : true } , callback ) ; } ; collection . update ( criteria , { $set : data } ,", "del_tokens": "collection . update ( criteria , { $set : data } ,", "commit_type": "add"}
{"commit_tokens": ["Use", "RegExp", ".", "sticky", "flag", "where", "available"], "add_tokens": "var ATTRIB_PATTERN = ' ([a-zA-Z][a-zA-Z_-]*)=(?:\\'([^\\']*)\\'|\"([^\"]*)\")' ; // Use sticky flag where available. var ATTRIB = new RegExp ( ATTRIB_PATTERN , RegExp . sticky ? 'yg' : 'g' ) ;", "del_tokens": "var ATTRIB = / ([a-zA-Z][a-zA-Z_-]*)=(?:'([^']*)'|\"([^\"]*)\") / g ;", "commit_type": "use"}
{"commit_tokens": ["Move", "removeExtension", "to", "util", "."], "add_tokens": "import { removeExtension , readFile , writeFile , readYamlFile } from './util' ;", "del_tokens": "import { readFile , writeFile , readYamlFile } from './util' ; export function removeExtension ( filename ) { return filename . replace ( / \\.\\w+$ / , '' ) ; }", "commit_type": "move"}
{"commit_tokens": ["Added", "test", "for", "immutable", "queries", "."], "add_tokens": "it ( 'is immutable' , function ( ) { var original = db . select ( 'users' ) ; var filtered = original . where ( { id : 2 } ) ; expect ( original . sql ( ) ) . to . not . eql ( filtered . sql ( ) ) ; } ) ;", "del_tokens": "it ( 'is immutable' ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "drawObjectList", "when", "type", "is", "gl", ".", "POINTS"], "add_tokens": "var type = object . type === undefined ? gl . TRIANGLES : object . type ; drawBufferInfo ( gl , type , bufferInfo , object . count , object . offset ) ;", "del_tokens": "drawBufferInfo ( gl , object . type || gl . TRIANGLES , bufferInfo , object . count , object . offset ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "for", "upstream", "swagger", "-", "ui", "changes"], "add_tokens": "// version 2.1.0-alpha.3 if ( this . model . swaggerVersion === \"2.0\" ) { if ( \"validatorUrl\" in opts . swaggerOptions ) { return this . model . validatorUrl = opts . swaggerOptions . validatorUrl ; } else if ( this . model . url . match ( / https?:\\/\\/localhost / ) ) { return this . model . validatorUrl = this . model . url ; } else { return this . model . validatorUrl = \"http://online.swagger.io/validator\" ; }", "del_tokens": "// version 2.1.0-alpha.2 if ( \"validatorUrl\" in opts . swaggerOptions ) { return this . model . validatorUrl = opts . swaggerOptions . validatorUrl ; } else if ( this . model . url . match ( / https?:\\/\\/localhost / ) && this . model . swaggerVersion === 2 ) { return this . model . validatorUrl = this . model . url ; } else { return this . model . validatorUrl = \"http://online.swagger.io/validator\" ;", "commit_type": "update"}
{"commit_tokens": ["added", "invocation", "history", "to", "track", "last", "invocations"], "add_tokens": "var invocationHistory = require ( './betfair_invocation_history.js' ) ; // Bet emulation stuff, Betfair has no demo accounts, so bet emulation agent : smartAgent , Connection : \"Keep-Alive\" // agent: smartAgent, // add to invocation history invocationHistory . addInvocationRecord ( self . action , self . duration ( ) , res . statusCode , self . result . header && self . result . header . errorCode , self . result . errorCode ) ;", "del_tokens": "// Bet emulation stuff, Betfair has no demo accounts, so bet emulation agent : smartAgent , Connection : \"Keep-Alive\" //agent: smartAgent,", "commit_type": "add"}
{"commit_tokens": ["moved", "cast", "-", "to", "-", "buffer", "to", "external", "module", "cast", "-", "buffer"], "add_tokens": "const castBuffer = require ( 'cast-buffer' ) args [ 2 ] = castBuffer ( args [ 2 ] ) args [ 1 ] = castBuffer ( args [ 1 ] ) content = castBuffer ( args . content ) content = castBuffer ( args . content )", "del_tokens": "const castToBuffer = require ( './utils/cast-to-buffer.js' ) args [ 2 ] = castToBuffer ( args [ 2 ] ) args [ 1 ] = castToBuffer ( args [ 1 ] ) content = castToBuffer ( args . content ) content = castToBuffer ( args . content )", "commit_type": "move"}
{"commit_tokens": ["add", "local", ":", "error", "option", "to", "only", "show", "errors", "in", "local", "files", "middleware"], "add_tokens": "if ( verbose . local || verbose [ 'local:error' ] ) console . log ( 'localfile not found: ' , pathname ) ;", "del_tokens": "if ( verbose . local ) console . log ( 'localfile not found: ' , pathname ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "incorrect", "reference", "to", "that", ".", "_playlist"], "add_tokens": "return that . _playlist . getAll ( ) ;", "del_tokens": "return that . _playlis . getAll ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "grunt", "task", "to", "create", "start", "project", "zip"], "add_tokens": "dest : 'dist/fh-starter-project-latest.zip' ,", "del_tokens": "dest : 'dist/feedhenry-latest.zip' ,", "commit_type": "update"}
{"commit_tokens": ["Updated", "README", ".", "Linted", "Tested"], "add_tokens": "function getDependencies ( func ) {", "del_tokens": "function getDependencies ( func ) { if ( ! func || typeof func !== 'function' ) { return [ ] }", "commit_type": "update"}
{"commit_tokens": ["Updated", "to", "report", "correct", "time", "in", "multicompiler", "watch", "mode"], "add_tokens": "this . previousEndTimes = { } ; const time = this . getCompileTime ( stats ) ; getCompileTime ( stats , statsIndex ) { if ( isMultiStats ( stats ) ) { // Webpack multi compilations run in parallel so using the longest duration. // https://webpack.github.io/docs/configuration.html#multiple-configurations return stats . stats . reduce ( ( time , stats , index ) => Math . max ( time , this . getCompileTime ( stats , index ) ) , 0 ) ; } // When we have multi compilations but only one of them is rebuilt, we need to skip the // unchanged compilers to report the true rebuild time. if ( statsIndex !== undefined ) { if ( this . previousEndTimes [ statsIndex ] === stats . endTime ) { return 0 ; } this . previousEndTimes [ statsIndex ] = stats . endTime ; } return stats . endTime - stats . startTime ; }", "del_tokens": "const time = getCompileTime ( stats ) ; function getCompileTime ( stats ) { if ( isMultiStats ( stats ) ) { // Webpack multi compilations run in parallel so using the longest duration. // https://webpack.github.io/docs/configuration.html#multiple-configurations return stats . stats . reduce ( ( time , stats ) => Math . max ( time , getCompileTime ( stats ) ) , 0 ) ; } return stats . endTime - stats . startTime ; }", "commit_type": "update"}
{"commit_tokens": ["removing", "path", "directory", "from", "tests"], "add_tokens": "}", "del_tokens": "scales : { } , } , tooltip : { }", "commit_type": "remove"}
{"commit_tokens": ["Added", "SOA", "support", "and", "channel", "mapping", "restriction"], "add_tokens": "const SOAHrirBase64 = require ( './resources/omnitone-soa-hrir-base64.js' ) ; 'HOARenderer: Invalid rendering mode. (got ' + config . renderingMode + ') Fallbacks to \"ambisonic\".' ) ; this . input . channelCount = this . _config . numberOfChannels ; this . input . channelCountMode = 'explicit' ; this . input . channelInterpretation = 'discrete' ; let bufferList ; if ( this . _config . pathList ) { bufferList = new BufferList ( this . _context , this . _config . pathList , { dataType : 'url' } ) ; } else { bufferList = this . _config . ambisonicOrder === 2 ? new BufferList ( this . _context , SOAHrirBase64 ) : new BufferList ( this . _context , TOAHrirBase64 ) ; }", "del_tokens": "'HOARenderer: Invalid rendering mode. (got ' + config . renderingMode + ') Fallbacks to \"ambisonic\".' ) ; const bufferList = this . _config . pathList ? new BufferList ( this . _context , this . _config . pathList , { dataType : 'url' } ) : new BufferList ( this . _context , TOAHrirBase64 ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "&", "tests", "for", "Express", "-", "style", "splat", "params", "(", "/", ":", "a", "*", "and", "/", ":", "a", "+", ")", "."], "add_tokens": "let param = route [ i ] . replace ( / (^\\:|[+*?]+$) / g , '' ) , flags = ( route [ i ] . match ( / [+*?]+$ / ) || EMPTY ) [ 0 ] || '' , plus = ~ flags . indexOf ( '+' ) , star = ~ flags . indexOf ( '*' ) , val = url [ i ] || '' ; if ( ! val && ! star && ( flags . indexOf ( '?' ) < 0 || plus ) ) { ret = false ; break ; } matches [ param ] = decodeURIComponent ( val ) ; if ( plus || star ) { matches [ param ] = url . slice ( i ) . map ( decodeURIComponent ) . join ( '/' ) ; break ; }", "del_tokens": "matches [ route [ i ] . substring ( 1 ) ] = decodeURIComponent ( url [ i ] || '' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "the", "ability", "to", "specify", "custom", "controls", "to", "olControl"], "add_tokens": "scope : { properties : '=olControlProperties' } , var isDefined = olHelpers . isDefined ; var olControl ; if ( ! isDefined ( scope . properties ) ) { if ( attrs . name ) { olControl = new controlClasses [ attrs . name ] ( ) ; map . addControl ( olControl ) ; } return ; } if ( isDefined ( scope . properties . control ) ) { olControl = scope . properties . control ; map . addControl ( olControl ) ; map . removeControl ( olControl ) ;", "del_tokens": "scope : false , var control ; if ( attrs . name ) { control = new controlClasses [ attrs . name ] ( ) ; map . addControl ( control ) ; map . removeControl ( control ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "accidental", "adding", "of", "unnecessary", "keys", "to", "URIs"], "add_tokens": "var uriOptions = utils . getURIOptions ( [ utils . setup ( ) , this , args . params ] ) ; utils . removeAuthOptions ( args . params ) ; var uriOptions = utils . getURIOptions ( [ utils . setup ( ) , this , body ] ) ; utils . removeAuthOptions ( body ) ;", "del_tokens": "var uriOptions = utils . getURIOptions ( args . params ) ; var uriOptions = utils . getURIOptions ( body ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "selected", "=", "false", "over", "_", ".", "omit", "to", "deselect", "a", "source"], "add_tokens": "// Clear out any previously selected sources (see: #11) _ . each ( sources , function ( source ) { source . selected = false ; } ) ;", "del_tokens": "sources = _ . map ( sources , _ . partial ( _ . omit , _ , 'selected' ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "test", "for", "deep", "equal", "matcher"], "add_tokens": "'Failed to assert that \"' + JSON . stringify ( data ) + '\" matched the next expected event data \"' + JSON . stringify ( next . arg ) +", "del_tokens": "'Failed to assert that ' + JSON . stringify ( data ) + ' matched the next expected event data \"' + next . arg +", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "command", "log", "entry", "be", "verbose", "."], "add_tokens": "me . verbose ( 'command:' , command , argv )", "del_tokens": "me . info ( 'command:' , command , argv )", "commit_type": "make"}
{"commit_tokens": ["fix", "some", "tests", "and", "increase", "coverage"], "add_tokens": "module . exports = data ;", "del_tokens": "module . exports = data ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "display", "when", "no", "options", "are", "specified"], "add_tokens": "var w = $header . html ( column . name ) . outerWidth ( ) + 13 ; // leave space for sort indicator", "del_tokens": "var w = $header . html ( column . name ) . outerWidth ( ) + 12 ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "fixed", "versions", "for", "jQuery", "UI", "dependencies", "for", "better", "caching", "."], "add_tokens": "requires : 'http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js' , style : 'http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.0/themes/base/jquery-ui.css' ,", "del_tokens": "requires : 'http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js' , style : 'http://ajax.googleapis.com/ajax/libs/jqueryui/1/themes/base/jquery-ui.css' , // { text: 'jQuery UI 1.6', url: 'http://ajax.googleapis.com/ajax/libs/jqueryui/1.6/jquery-ui.min.js' }", "commit_type": "use"}
{"commit_tokens": ["added", "lazy", "loading", "for", "models"], "add_tokens": "return ; } } , preload : { value : function preload ( ) { var _this = this ; Object . keys ( this . _models ) . forEach ( function ( modelName ) { _this . model ( modelName ) ; } ) ;", "del_tokens": "isLazy : { get : function ( ) { return ! ! this . options . isLazy ; } } , if ( this . isLazy ) { return ; } return this . model ( name ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "all", "methods", "that", "take", "boolean", "params", "to", "accept", "booleans", "instead", "of", "0", "/", "1"], "add_tokens": "isEnableTimeStamp : true , isEnableDevName : false , isEnableOSDMask : true cam . setOSDMask ( false ) ; isEnableLocalAlarmRecord : true , assertCalledWith ( cam . get , 'setLocalAlarmRecordConfig' , { isEnableLocalAlarmRecord : 1 , localAlarmRecordSecs : 4 } ) ; } ) ; isEnablePreRecord : true , assertCalledWith ( cam . get , 'setAlarmRecordConfig' , { isEnablePreRecord : 1 , preRecordSecs : 5 , alarmRecordSecs : 2 } ) ; cam . setPCAudioAlarmCfg ( false ) ;", "del_tokens": "isEnableTimeStamp : 1 , isEnableDevName : 0 , isEnableOSDMask : 1 cam . setOSDMask ( 0 ) ; isEnableLocalAlarmRecord : 1 , assertCalledWith ( cam . get , 'setLocalAlarmRecordConfig' , params ) ; } ) isEnablePreRecord : 1 , assertCalledWith ( cam . get , 'setAlarmRecordConfig' , params ) ; cam . setPCAudioAlarmCfg ( 0 ) ;", "commit_type": "change"}
{"commit_tokens": ["Adding", "mget", "and", "mset", "initial", "commit", "."], "add_tokens": "self . checkOnPreviousEmpty = ( typeof config . checkOnPreviousEmpty === 'boolean' ) ? config . checkOnPreviousEmpty : true ;", "del_tokens": "//self.cacheWhenEmpty = (typeof config.cacheWhenEmpty === 'boolean') ? config.cacheWhenEmpty : true; self . checkOnPreviousEmpty = ( typeof config . checkOnPreviousEmpty === 'boolean' ) ? config . checkOnPreviousEmpty : false ; self . get = function ( key , cb , cleanKey ) { try { cacheKey = ( cleanKey ) ? cleanKey : key ; self . log ( false , 'Attempting to get key:' , { key : cacheKey } ) ; self . db . get ( cacheKey , function ( err , result ) { try { result = JSON . parse ( result ) ; } catch ( err ) { //Do nothing } cb ( err , result ) ; } ) ; } catch ( err ) { cb ( { name : 'GetException' , message : err } , null ) ; } }", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "to", "import", "plain", "css", "files"], "add_tokens": "var path = require ( 'path' ) // Whitespace util to allow importing of plain css function transformWhitespace ( css , file ) { return path . extname ( file ) === '.wcss' ? whitespace ( css ) : css } post . use ( importer ( { transform : transformWhitespace , root : options . root } ) )", "del_tokens": "post . use ( importer ( { transform : whitespace , root : options . root } ) )", "commit_type": "add"}
{"commit_tokens": ["Use", ".", "then", "instead", "of", ".", "done", "to", "get", "a", "promise", "result", "."], "add_tokens": "return hook ( makeRequestObject ( model , false ) ) . then ( ( beforeSaveOverrideValue ) => {", "del_tokens": "return hook ( makeRequestObject ( model , false ) ) . done ( ( beforeSaveOverrideValue ) => {", "commit_type": "use"}
{"commit_tokens": ["adding", "test", "and", "update", "for", "returning", "results", "from", "mergeFile"], "add_tokens": "res = this . merge ( obj ) ;", "del_tokens": "this . merge ( obj ) ;", "commit_type": "add"}
{"commit_tokens": ["move", "curvature", "logic", "to", "edge", "class"], "add_tokens": "this . updateGeometry ( true ) ; Transitive . prototype . updateGeometry = function ( snapGrid ) { if ( snapGrid ) this . graph . snapToGrid ( ( this . options && this . options . gridCellSize ) ? this . options . gridCellSize : 0.01 ) ; // clear the stop render data for ( var key in this . stops ) this . stops [ key ] . renderData = [ ] ; //this.graph.convertTo1D(); this . graph . apply2DOffsets ( ) ; this . graph . initCurvature ( ) ; } ; //for (var key in this.stops) this.stops[key].renderData = []; for ( var key in this . stops ) {", "del_tokens": "//this.graph.convertTo1D(); this . graph . snapToGrid ( ( this . options && this . options . gridCellSize ) ? this . options . gridCellSize : 0.01 ) ; this . graph . apply2DOffsets ( ) ; for ( var key in this . stops ) this . stops [ key ] . renderData = [ ] ; for ( key in this . stops ) {", "commit_type": "move"}
{"commit_tokens": ["Update", "example", "to", "use", "load"], "add_tokens": "// var loadimage = require('../loadimage') // loadimage('pex-logo.png', (err, img) => { var load = require ( '../load' ) var resources = { img : { image : 'pex-logo.png' } } load ( resources , ( err , res ) => { console . log ( err ) var img = res . img var tex = regl . texture ( img )", "del_tokens": "var loadImage = require ( '../loadImage' ) loadImage ( 'pex-logo.png' , ( err , img ) => { // console.log(err) var tex = regl . texture ( { width : 512 , height : 512 , data : img . data } )", "commit_type": "update"}
{"commit_tokens": ["Added", "ability", "to", "capture", "output", "when", "running", "inside", "a", "script"], "add_tokens": "exports . start = function ( job , options , callback , capture_output ) { var output ; if ( capture_output ) { output = [ ] ; job_obj . output = function ( out ) { if ( out instanceof Array ) { out . forEach ( function ( line ) { output . push ( line ) ; } ) ; } else { output . push ( out ) ; } } } if ( typeof callback === 'function' ) { oncomplete_callback = function ( err ) { callback ( err , output ) ; } } else { oncomplete_callback = function ( err ) { if ( err ) status . error ( err ) ; process . exit ( 1 ) ; } }", "del_tokens": "exports . start = function ( job , options , callback ) { if ( typeof callback === 'function' ) { oncomplete_callback = function ( err ) { callback ( err ) ; } } else { oncomplete_callback = function ( err ) { if ( err ) status . error ( err ) ; process . exit ( 1 ) ; } }", "commit_type": "add"}
{"commit_tokens": ["make", "the", "default", "value", "for", "type", "-", "enum", "rule", "empty"], "add_tokens": "// 'feat', // 'fix', // 'docs', // 'style', // 'refactor', // 'perf', // 'test', // 'chore', // 'revert',", "del_tokens": "'feat' , 'fix' , 'docs' , 'style' , 'refactor' , 'perf' , 'test' , 'chore' , 'revert' ,", "commit_type": "make"}
{"commit_tokens": ["Use", "query", "-", "string", "instead", "of", "qs"], "add_tokens": "import queryString from 'query-string' ; return '?' + queryString . stringify ( queryParamObj ) ; const queryParamObj = queryString . parse ( queryParamString ) ; . keys ( queryParamObj ) camelCaseParamObj [ camelCase ( key ) ] = queryParamObj [ key ] ;", "del_tokens": "import qs from 'qs' ; // Use bracket arrayFormat as history.js and react-router use it return '?' + qs . stringify ( queryParamObj , { arrayFormat : 'brackets' } ) ; const qsQueryParamObj = qs . parse ( queryParamString ) ; . keys ( qsQueryParamObj ) camelCaseParamObj [ camelCase ( key ) ] = qsQueryParamObj [ key ] ;", "commit_type": "use"}
{"commit_tokens": ["adding", "documentation", "and", "browser", "builds"], "add_tokens": "var curId = 0 // for ids\\ curId ++ this . id = curId", "del_tokens": "Future . n = 0 // for ids Future . n ++ this . id = Future . n", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "html", "in", "titles"], "add_tokens": "this . element . find ( '.lm_title' ) . html ( lm . utils . filterXss ( this . _contentItem . config . title , true ) ) ;", "del_tokens": "this . element . find ( '.lm_title' ) . text ( this . _contentItem . config . title ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "descriptions", "to", "grunt", "tasks"], "add_tokens": "grunt . registerTask ( 'test' , 'Run the jasmine and nodeunit tests' , [ 'webpack:global' , 'nodeunit' , 'karma:single' ] ) ; grunt . registerTask ( 'build' , 'Run webpack and bundle the source' , [ 'webpack' ] ) ; grunt . registerTask ( 'publish' , 'Prepare the code for release' , [ 'clean' , 'test' , 'build' , 'usebanner' , 'update_json' ] ) ;", "del_tokens": "grunt . registerTask ( 'test' , [ 'webpack:global' , 'nodeunit' , 'karma:single' ] ) ; grunt . registerTask ( 'build' , [ 'webpack' ] ) ; grunt . registerTask ( 'publish' , [ 'clean' , 'test' , 'build' , 'usebanner' , 'update_json' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "little", "debugger", "info", "for", "now", "."], "add_tokens": "var $ = require ( 'jquery-browserify' ) $ ( document ) . ready ( function ( ) { } window . onpopstate = function ( event ) { console . log ( 'Location: ' + document . location + ', state: ' + JSON . stringify ( event . state ) ) }", "del_tokens": "#!/usr/bin/env node", "commit_type": "add"}
{"commit_tokens": ["Adding", "the", "ability", "to", "connect", "to", "a", "selenium", "server", "on", "SauceLabs"], "add_tokens": "} , 100000 ) ; } , 100000 ) ; // it('should greet using binding - this one fails', function(done) { // ptor.get('http://www.angularjs.org'); // ptor.findElement(protractor.By.input(\"yourName\")).sendKeys(\"Julie\"); // ptor.findElement(protractor.By.binding(\"Hello {{yourName}}!\")). // getText().then(function(text) { // expect(text).toEqual('Hello Jack'); // done(); // }); // });", "del_tokens": "} , 10000 ) ; } , 10000 ) ; / * it ( 'should greet using binding - this one fails' , function ( done ) { ptor . get ( 'http://www.angularjs.org' ) ; ptor . findElement ( protractor . By . input ( \"yourName\" ) ) . sendKeys ( \"Julie\" ) ; ptor . findElement ( protractor . By . binding ( \"Hello {{yourName}}!\" ) ) . getText ( ) . then ( function ( text ) { expect ( text ) . toEqual ( 'Hello Jack' ) ; done ( ) ; } ) ; } ) ; * /", "commit_type": "add"}
{"commit_tokens": ["Fix", "typo", "in", "widthAsDir", "option", "definition"], "add_tokens": "widthAsDir : false", "del_tokens": "widthsAsDir : false", "commit_type": "fix"}
{"commit_tokens": ["added", "some", "upgrade", "instructions", "."], "add_tokens": "{ expand : true , cwd : './source/css/' , src : '*.css' , dest : './public/css/' } ,", "del_tokens": "{ expand : true , cwd : './source/css/' , src : 'style.css' , dest : './public/css/' } ,", "commit_type": "add"}
{"commit_tokens": ["make", "the", "clearRequireCacheInDir", "platform", "windows", "friendly"], "add_tokens": "var path = require ( 'path' ) clearRequireCache ( dir + path . sep + ( file . split ( / \\\\|\\/ / g ) . join ( path . sep ) ) ) ;", "del_tokens": "clearRequireCache ( dir + '/' + file ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "tape", "-", "run", "package", "for", "run", "test", "in", "a", "(", "headless", ")", "browser"], "add_tokens": "} ;", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Adding", "/", "js", "/", "folder", "to", "watcher", "task", "excluding", "theme", ".", "js", "and", "theme", ".", "min", ".", "js"], "add_tokens": "gulp . watch ( [ basePaths . dev + 'js/**/*.js' , 'js/**/*.js' , '!js/theme.js' , '!js/theme.min.js' ] , [ 'scripts' ] )", "del_tokens": "gulp . watch ( [ basePaths . dev + 'js/**/*.js' ] , [ 'scripts' ] )", "commit_type": "add"}
{"commit_tokens": ["Make", "request", "length", "limit", "configurable", "."], "add_tokens": "if ( config . limit != undefined ) { this . length_limit = limit ; } else { this . length_limit = '500mb' ; } app . use ( bodyParser . json ( { type : function ( ) { return true ; } , limit : this . length_limit } ) ) ;", "del_tokens": "let limit = '500mb' ; app . use ( bodyParser . json ( { type : function ( ) { return true ; } , limit : limit } ) ) ; app . use ( bodyParser . urlencoded ( { limit : limit , extend : true } ) ) ;", "commit_type": "make"}
{"commit_tokens": ["change", "bot", "config", "file", "name"], "add_tokens": "filePath : botSettingsFolder + paiBOT . setModuleName ( ) + '.json'", "del_tokens": "filePath : botSettingsFolder + 'config.json'", "commit_type": "change"}
{"commit_tokens": ["Add", "more", "length", "checks", "to", "tests"], "add_tokens": "assert . equal ( vtBuffer . length , 171 ) ; assert . equal ( vtBuffer . length , 181 ) ; assert . equal ( vtBuffer . length , 181 ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Add", "CSSVars", "and", "JSFlat", "processors"], "add_tokens": "const fs = require ( 'fs' ) ; const cssvars = require ( './processors/cssvars' ) ; const jsflat = require ( './processors/jsflat' ) ; cssvars , jsflat ,", "del_tokens": "const fs = require ( 'fs' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "with", "password", "prompt"], "add_tokens": "this . write ( \"\\n\" ) ; // manually output the line return as the readline was muted this . clean ( 1 ) . render ( ) ; // Mask answer this . rl . removeAllListeners ( \"keypress\" ) ; this . error ( isValid ) . clean ( ) . render ( ) ;", "del_tokens": "this . down ( ) . clean ( 2 ) . render ( ) ; //Mask answer this . down ( ) . error ( isValid ) . clean ( ) . render ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "line", "break", "between", "records", "in", "CLI", "output"], "add_tokens": "const str = serialize ( record ) ; process . stdout . write ( format ( str ) ) ; } function format ( str ) { return str . endsWith ( '\\n' ) ? str : ` ${ str } \\n ` ;", "del_tokens": "process . stdout . write ( serialize ( record ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "test", ":", "tracker", "client", "from", "magnet", "uri"], "add_tokens": "// TODO: add test where tracker doesn't support compact test ( 'torrent: client.start()' , function ( t ) { test ( 'torrent: client.stop()' , function ( t ) { test ( 'torrent: client.update()' , function ( t ) { test ( 'torrent: client.scrape()' , function ( t ) {", "del_tokens": "test ( 'client.start()' , function ( t ) { test ( 'client.stop()' , function ( t ) { test ( 'client.update()' , function ( t ) { test ( 'client.scrape()' , function ( t ) { // TODO: add test where tracker doesn't support compact", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "TableHandler", "and", "associated", "unit", "tests", "."], "add_tokens": "exports . TableHandler = require ( './TableHandler' ) . TableHandler ;", "del_tokens": "//exports.TableHandler = require('./TableHandler').TableHandler;", "commit_type": "add"}
{"commit_tokens": ["adding", "missing", "variables", "to", "exceptions"], "add_tokens": ", UnsupportedFormat , SerializationError , NotFound , Unauthorized , BadRequest util . inherits ( UnsupportedFormat , BaseException ) ;", "del_tokens": ", Unsupported , Serialization util . inherits ( Unsupported , BaseException ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "a", "mirror", "of", "tapInto", "for", "async", "taps"], "add_tokens": "WebpackUtils . tapInto ( compiler , 'done' , function ( ) { WebpackUtils . tapAsyncInto ( compiler , 'watch-run' , function ( _ , done ) { WebpackUtils . tapAsyncInto ( compiler , 'run' , that . start . bind ( that ) ) ; WebpackUtils . tapInto ( compiler , 'done' , that . stop . bind ( that ) ) ; WebpackUtils . tapInto ( compiler , 'compilation' , function ( compilation ) { WebpackUtils . tapInto ( compilation , 'failed-module' , that . stop . bind ( that ) ) ;", "del_tokens": "WebpackUtils . tapInto ( compiler , 'done' , false , function ( ) { WebpackUtils . tapInto ( compiler , 'watch-run' , true , function ( _ , done ) { WebpackUtils . tapInto ( compiler , 'run' , true , that . start . bind ( that ) ) ; WebpackUtils . tapInto ( compiler , 'done' , false , that . stop . bind ( that ) ) ; WebpackUtils . tapInto ( compiler , 'compilation' , false , function ( compilation ) { WebpackUtils . tapInto ( compilation , 'failed-module' , false , that . stop . bind ( that ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "tasks", "support", "for", "sauce", "."], "add_tokens": "var tasks = [ ] tasks . push ( { id : \"sauce\" , data : { total : result . total , failed : result . failed , passed : result . passed , runtime : result . runtime , id : result . id } } ) cb ( buildStatus , tasks )", "del_tokens": "cb ( buildStatus )", "commit_type": "add"}
{"commit_tokens": ["Update", "additional", "files", "for", "grunt", "release", "."], "add_tokens": "additionalFiles : [ 'package.json' , 'bower.json' ] , commitMessage : 'Release version <%= version %>.'", "del_tokens": "additionalFiles : 'bower.json' , commitMessage : 'Release version <%= version %>.'", "commit_type": "update"}
{"commit_tokens": ["fixed", "bug", "in", "style", "tool", ".", "Fixed", "bug", "in", "copy", "function", "."], "add_tokens": "if ( ! self . hasFocus || ! e . clipboardData ) { return ; }", "del_tokens": "if ( ! self . hasFocus ) { return ; }", "commit_type": "fix"}
{"commit_tokens": ["fixed", "no", "-", "animation", "bug"], "add_tokens": "// animation stuff if ( typeof that . opt . animation === 'number' ) { addClass ( currImage . img , 'jslghtbx-animate-transition' ) ; } // set animation if ( typeof that . opt . animation === 'number' ) { addClass ( currImage . img , 'jslghtbx-animate-transition' ) ; } that . resize ( ) ;", "del_tokens": "that . resize ( ) ; addClass ( currImage . img , 'jslghtbx-animate-transition' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implement", "first", "unit", "tests", "and", "fix", "bugs"], "add_tokens": "if ( ! Array . isArray ( event ) && typeof event !== 'object' ) { throw new Error ( ` ${ typeof event } ` ) events . forEach ( ( eventIt ) => { if ( ! eventIt . type || typeof eventIt . type !== 'string' ) { console . error ( ` ` , eventIt ) throw new Error ( ` ` ) } } ) currentListeners . splice ( index , 1 )", "del_tokens": "if ( typeof event !== 'object' ) { throw new Error ( ` ${ typeof event } ` ) } if ( ! event . type || typeof event . type !== 'string' ) { throw new Error ( ` ` ) currentListeners = currentListeners . splice ( index , 1 )", "commit_type": "implement"}
{"commit_tokens": ["Removed", "windows", "/", "sense", "dependency", "in", "integration", "tests"], "add_tokens": "before ( ( ) => { const config = utils . getDefaultConfig ( ) ; config . mixins = [ { types : 'Global' , extend : { tweet ( ) { return Promise . resolve ( 'Mr tweeter!' ) ; } , } , } ] ; return Qix . create ( config ) . open ( ) . then ( ( global ) => { qixGlobal = global ; } ) ; } ) ;", "del_tokens": "import WebSocket from 'ws' ; import schema from '../../schemas/12.20.0.json' ; // let isServer = true; let config ; before ( ( ) => utils . getDefaultConfig ( ) . then ( ( cfg ) => { config = cfg ; config . Promise = Promise ; config . schema = schema ; config . mixins = [ { types : 'Global' , extend : { tweet ( ) { return Promise . resolve ( 'Mr tweeter!' ) ; } , } , } ] ; config . createSocket = url => new WebSocket ( url , config . socket ) ; return Qix . create ( config ) . open ( ) . then ( ( global ) => { qixGlobal = global ; } ) ; } ) , ) ;", "commit_type": "remove"}
{"commit_tokens": ["Make", "sure", "to", "clean", "up", "the", "listeners", "for", "propagated", "events"], "add_tokens": "process . stdin . on ( \"keypress\" , function ( s , key ) { rlVent . emit ( \"keypress\" , s , key ) ; } ) ; // Remove events rlVent . removeAllListeners ( ) ; rl . removeAllListeners ( ) ; process . stdin . removeAllListeners ( \"keypress\" ) ;", "del_tokens": "process . stdin . on ( \"keypress\" , function ( s , key ) { rlVent . emit ( \"keypress\" , s , key ) ; } ) ; rlVent . removeAllListeners ( ) ; // just little memory leaks prevention", "commit_type": "make"}
{"commit_tokens": ["fixed", "broken", "type", "doc", "for", "gridsInCircle"], "add_tokens": "* @ returns { Array < Point2D > }", "del_tokens": "* @ regridsInCircleoint2D > }", "commit_type": "fix"}
{"commit_tokens": ["Allow", "the", "UDP", "discovery", "bind", "port", "to", "be", "specified"], "add_tokens": "this . socket . bind ( options , function ( ) {", "del_tokens": "this . socket . bind ( function ( ) {", "commit_type": "allow"}
{"commit_tokens": ["Fix", "a", "bug", "in", "which", "we", "couldn", "t", "extend", "a", "singleton", "and", "removed", "some", "useless", "interface", "checks", "."], "add_tokens": "$singleton : true , // We hold this in order to inform that we have a singleton delete this . prototype . $initializing ;", "del_tokens": "this . prototype . $initializing = false ;", "commit_type": "fix"}
{"commit_tokens": ["added", "dest", "option", "in", "files"], "add_tokens": "cwd : f . orig . cwd , dest : f . orig . dest tempDestPath = correctedDestination + ( tempPath . charAt ( 0 ) === \"/\" ? tempPath . slice ( 1 ) : tempPath ) , destPath = fileObject . dest ? correctedDestination + fileObject . dest : tempDestPath ;", "del_tokens": "cwd : f . orig . cwd destPath = correctedDestination + ( tempPath . charAt ( 0 ) === \"/\" ? tempPath . slice ( 1 ) : tempPath ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "a", "single", "client", "instance", "during", "a", "transaction"], "add_tokens": "// This is overridden with a single client instance during a transaction. const client = this . client client . query ( findRecords , parameters . length ? parameters : null , client . query ( query ( 'select count(*) from ' + const client = this . client client . query ( createRecords , parameters , ( error , result ) => { const client = this . client client . query ( updateRecord , parameters , ( error , result ) => { const client = this . client client . query ( deleteRecords , ids ? ids : null ,", "del_tokens": "// Set `client` alias for backwards compatibility. const pool = this . pool pool . query ( findRecords , parameters . length ? parameters : null , pool . query ( query ( 'select count(*) from ' + const pool = this . pool pool . query ( createRecords , parameters , ( error , result ) => { const pool = this . pool pool . query ( updateRecord , parameters , ( error , result ) => { const pool = this . pool pool . query ( deleteRecords , ids ? ids : null ,", "commit_type": "use"}
{"commit_tokens": ["Added", "new", "test", "suite", "using", "vows", "-", "Removing", "old", "test"], "add_tokens": "var scope = ( typeof exports === 'object' ) ? exports : window ; } ) ( scope ) ;", "del_tokens": "} ) ( window ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "API", "docs", "to", "README"], "add_tokens": "/ ** * Invokes a registered actionGroup ' * / actions ( group ) { if ( ! this . __actions . get ( group ) ) { throw new Error ( \"Actions not defined for \" + group ) } return this . __actions . get ( group ) }", "del_tokens": "/ ** * Invokes a registered actionGroup ' * / actions ( group ) { if ( ! this . __actions . get ( group ) ) { throw new Error ( \"Actions not defined for \" + group ) } return this . __actions . get ( group ) }", "commit_type": "add"}
{"commit_tokens": ["add", ".", "match", "(", "route", ")", "method"], "add_tokens": "emit . emit = emit emit . match = match var matched = match ( route ) args [ 0 ] = matched . params return matched . cb . apply ( matched . cb , args ) } function match ( route ) { assert . notEqual ( route , undefined , \"'route' must be defined\" ) var matched = _trie . match ( route ) if ( matched && matched . cb ) return new Route ( matched ) if ( dft && dft . cb ) return new Route ( dft ) function Route ( matched ) { this . cb = matched . cb this . route = matched . cb . route this . params = matched . params }", "del_tokens": "emit . emit = emit assert . notEqual ( route , undefined , \"'route' must be defined\" ) var node = _trie . match ( route ) if ( node && node . cb ) { args [ 0 ] = node . params var cb = node . cb return cb . apply ( cb , args ) } if ( dft && dft . cb ) { args [ 0 ] = dft . params var dftcb = dft . cb return dftcb . apply ( dftcb , args ) }", "commit_type": "add"}
{"commit_tokens": ["Added", "dom", "string", ".", "Fixed", "node", "client", "exports", ".", "Updated", "build", "system", "tests", "."], "add_tokens": ". addFile ( 'node/_.header.js' ) . addFile ( 'client/wrapped-context.js' ) . addFile ( 'client/dom-str.js' ) . addFile ( 'node/_.footer.js' ) ;", "del_tokens": ". addFile ( 'client/wrapped-context.js' ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "node", "-", "github", "from", "extern", "since", "it", "contains", "modifications", "."], "add_tokens": "var GitHubApi = require ( './extern/node-github' ) . GitHubApi ;", "del_tokens": "var GitHubApi = require ( 'github' ) . GitHubApi ;", "commit_type": "use"}
{"commit_tokens": ["Add", "disclaimer", "that", "the", "tokens", "file", "is", "automatically", "generated"], "add_tokens": "const tpl = '// Design System Tokens\\n// This file is automatically generated, DO NOT change it manually.\\n\\n<%= data %>' ;", "del_tokens": "const tpl = '// Design System Tokens\\n\\n<%= data %>' ;", "commit_type": "add"}
{"commit_tokens": ["Use", "lodash", "instead", "of", "lodash", "-", "contrib"], "add_tokens": "var _ = require ( 'lodash' ) ; exports . createClient = function ( options ) { return new Client ( options || { } ) ; } ; function exists ( value ) { return value != null ; } function truthy ( value ) { return ( value !== false ) && exists ( value ) ; } if ( truthy ( value ) ) compacted [ key ] = value ; if ( ! exists ( object [ property ] ) ) return _ . isObject ( object ) && _ . isObject ( object . sys ) && 'type' in object . sys && object . sys . type in parseableResourceTypes ;", "del_tokens": "var _ = require ( 'lodash-contrib' ) ; exports . createClient = _ . fnull ( function ( options ) { return new Client ( options ) ; } , { } ) ; if ( _ . truthy ( value ) ) compacted [ key ] = value ; if ( ! _ . exists ( object [ property ] ) ) return _ . getPath ( object , [ 'sys' , 'type' ] ) in parseableResourceTypes ;", "commit_type": "use"}
{"commit_tokens": ["add", "jsobj2pyobj", "pyobj2jsobj", "to", "javascript", "library"], "add_tokens": "$B . jsobj2pyobj = jsobj2pyobj = function ( jsobj ) { switch ( jsobj ) { case true : case false : return jsobj case null : return _b_ . None } if ( typeof jsobj === 'object' ) { if ( 'length' in jsobj ) return _b_ . list ( jsobj ) var d = _b_ . dict ( ) for ( var $a in jsobj ) _b_ . dict . $dict . __setitem__ ( d , $a , jsobj [ $a ] ) return d } if ( typeof jsobj === 'number' ) { if ( jsobj . toString ( ) . indexOf ( '.' ) == - 1 ) return _b_ . int ( jsobj ) // for now, lets assume a float return _b_ . float ( jsobj ) } return $B . JSObject ( jsobj ) } $B . pyobj2jsobj = pyobj2jsobj = function ( pyobj ) {", "del_tokens": "//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")} function pyobj2jsobj ( pyobj ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "ternary", "operator", "for", "baseUrl"], "add_tokens": "let baseUrl = newBaseUrl ? ` ${ this . baseUrl } ${ newBaseUrl } ` : this . baseUrl ; let baseUrl = newBaseUrl ? ` ${ this . baseUrl } ${ newBaseUrl } ` : this . baseUrl ;", "del_tokens": "let baseUrl = this . baseUrl ; if ( newBaseUrl ) { baseUrl = ` ${ this . baseUrl } ${ newBaseUrl } ` ; } let baseUrl = this . baseUrl ; if ( newBaseUrl ) { baseUrl = ` ${ this . baseUrl } ${ newBaseUrl } ` ; }", "commit_type": "use"}
{"commit_tokens": ["using", "translate3d", "to", "force", "hardware", "acceleration", "-", "a"], "add_tokens": "app . controller ( 'MainController' , function ( $rootScope , $scope ) { var digests = 0 ; $scope . $watch ( function ( ) { digests ++ ; console . log ( digests + \" calls\" ) ; } ) ;", "del_tokens": "app . controller ( 'MainController' , function ( $rootScope ) { $rootScope . logClick = function ( ) { // var el = angular.element(document.getElementsByClassName(\"scrollable-content\")[1]); // el.prepend('<p class=\"alert alert-warning\">ng-click</p>'); } ;", "commit_type": "use"}
{"commit_tokens": ["Added", "clientX", "and", "clientY", "to", "mouse", "and", "touch", "input", ".", "Fixed", "magnify", "tool", "for", "rotated", "/", "zoomed", "/", "translated", "images"], "add_tokens": "image : cornerstone . pageToPixel ( element , e . pageX , e . pageY ) , client : { x : e . clientX , y : e . clientY } image : cornerstone . pageToPixel ( element , e . pageX , e . pageY ) , client : { x : e . clientX , y : e . clientY } image : cornerstone . pageToPixel ( element , e . pageX , e . pageY ) , client : { x : e . clientX , y : e . clientY } image : cornerstone . pageToPixel ( element , e . pageX , e . pageY ) , client : { x : e . clientX , y : e . clientY }", "del_tokens": "image : cornerstone . pageToPixel ( element , e . pageX , e . pageY ) image : cornerstone . pageToPixel ( element , e . pageX , e . pageY ) image : cornerstone . pageToPixel ( element , e . pageX , e . pageY ) image : cornerstone . pageToPixel ( element , e . pageX , e . pageY )", "commit_type": "add"}
{"commit_tokens": ["Updated", "the", "mongoose", "version", "and", "used", "Q", "instead", "of", "Bluebird", "as", "promise", "library", "."], "add_tokens": "Q = require ( 'q' ) ; var def = Q . defer ( ) ;", "del_tokens": "Promise = require ( 'bluebird' ) ; var def = Promise . defer ( ) ;", "commit_type": "update"}
{"commit_tokens": ["Adding", "a", "try", "catch", "around", "xml", "response", "building"], "add_tokens": "var xml ; try { var xmlObject = { } ; if ( _ . isObject ( res . data ) ) { xmlObject = res . data ; } else if ( _ . isString ( res . data ) ) { xmlObject = { message : res . data } ; } xml = this . xmlBuilder . buildObject ( xmlObject ) ; } catch ( e ) { }", "del_tokens": "var xml = this . xmlBuilder . buildObject ( res . data ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "router", "options", "more", "clearly"], "add_tokens": "url : 'amqp://guest:guest@localhost:5672' , exchangeType : 'topic' , autoAck : false ch . assertExchange ( that . options . exchange , that . options . exchangeType ) ,", "del_tokens": "middleware : [ ] , amqpUrl : 'amqp://guest:guest@localhost:5672' , autoAck : false , errorHandler : function ( err ) { console . error ( err ) ; } ch . assertExchange ( that . options . exchange , 'topic' ) ,", "commit_type": "make"}
{"commit_tokens": ["add", "more", "samples", "to", "gulpfile", ".", "js"], "add_tokens": "// Or, you can add an \"order\" property to sub-task. \"task-1\" : { \"order\" : 0 // just used to sort } , \"task-2\" : { \"order\" : 1 } , \"named-inline\" : { \"order\" : 2 , \"task\" : function ( gulp , config , stream , done ) { } } , } , // not recommended \"series-in-object-array\" : { \"series\" : [ { \"ref-task-1\" : { } } , { \"ref-task-2\" : { } } , { \"inline\" : function ( gulp , config , stream , done ) { } } ] \"task\" : function ( gulp , config , stream , done ) { \"task\" : function ( ) {", "del_tokens": "\"task-1\" : { } , \"task-2\" : { } , // 注意：有時候 normalizer 會遇到無窮迴圈的情況，似乎是在陣列的時候， // 因為 index (當然)並未定義在 schema 中，所以一直成為 others 部份。 task : function ( gulp , config , stream , done ) { task : function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "default", "fixed", "agent", "and", "made", "it", "the", "default", "export"], "add_tokens": "* Create a default fixed version to use . const fixedAgent = fixedSupertestAgent ( request . agent ) ; / ** * Export the fixedSupertestAgent function and the default fixedAgent . * / exports = module . exports = fixedAgent ;", "del_tokens": "* Export the fixedSupertestAgent function . exports = module . exports = fixedSupertestAgent ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "the", "EntityManager", "s", "refresh", "()", "method", "finished", "tests", "of", "the", "entity", "manager"], "add_tokens": "runTransactionOperation : Symbol ( \"runTransactionOperation\" ) , deleteExtraneousFields : Symbol ( \"deleteExtraneousFields\" ) this [ PRIVATE . deleteExtraneousFields ] ( entity , entityData ) / ** * Deletes all fields from the target object that are not present in the mask * object . * * @ param { Object < string , * > } target The object that should have its fields * filtered according to the mask . * @ param { Object < string , * > } mask An object that acts as a mask , specifying * which fields are allowed in the target . * / [ PRIVATE . deleteExtraneousFields ] ( target , mask ) { for ( let fieldName of Object . keys ( target ) ) { if ( mask . hasOwnProperty ( fieldName ) ) { continue } delete target [ fieldName ] } }", "del_tokens": "runTransactionOperation : Symbol ( \"runTransactionOperation\" )", "commit_type": "fix"}
{"commit_tokens": ["Added", "back", "the", "semantic", "validation", "for", "an", "operation", "having", "multiple", "body", "parameters"], "add_tokens": "* Validates paths and operations ( Written as one validator to avoid multiple passes ) * * Ensure that an operation only has one body parameter function validatePathsAndOperations ( api ) { var definedPathParameters = { } ; var oPath = pPath . concat ( method ) ; var pathMetadata ; pathMetadata = _ . reduce ( parameters , function ( metadata , parameter ) { // Record path parameters definedPathParameters [ parameter . name ] = parameter . ptr ; } else if ( parameter . in === 'body' ) { metadata . bodyParameteters += 1 ; return metadata ; } , { bodyParameteters : 0 } ) ; // Identify multiple body parameters if ( pathMetadata . bodyParameteters > 1 ) { response . errors . push ( { code : 'MULTIPLE_BODY_PARAMETERS' , message : 'Operation has multiple body parameters' , path : oPath } ) ; } path : oPath validatePathsAndOperations", "del_tokens": "* Validates paths and path paramters ( Written as one validator to avoid multiple passes ) function validatePathsAndPathParameters ( api ) { var definedPathParameters ; definedPathParameters = _ . reduce ( parameters , function ( pathParameters , parameter ) { pathParameters [ parameter . name ] = parameter . ptr ; return pathParameters ; } , { } ) ; path : pPath . concat ( method ) validatePathsAndPathParameters", "commit_type": "add"}
{"commit_tokens": ["Remove", "unused", "container", "in", "instance", "initializer"], "add_tokens": "var registry ; if ( applicationOrRegistry . registry ) {", "del_tokens": "var registry , container ; if ( applicationOrRegistry . registry && applicationOrRegistry . container ) { container = applicationOrRegistry . container ; if ( registry . container ) { // Support Ember 1.10 - 1.11 container = registry . container ( ) ; } else { // Support Ember 1.9 container = registry ; }", "commit_type": "remove"}
{"commit_tokens": ["add", "select", "and", "start", "keys"], "add_tokens": "if ( this . _keys [ 40 ] ) this . _joyp [ 1 ] &= ~ 8 ; // down if ( this . _keys [ 13 ] ) this . _joyp [ 0 ] &= ~ 8 ; // start if ( this . _keys [ 32 ] ) this . _joyp [ 0 ] &= ~ 4 ; // select if ( this . _keys [ 37 ] ) this . _joyp [ 1 ] &= ~ 2 ; // left if ( this . _keys [ 83 ] ) this . _joyp [ 0 ] &= ~ 2 ; // b", "del_tokens": "if ( this . _keys [ 37 ] ) this . _joyp [ 1 ] &= ~ 2 ; // left if ( this . _keys [ 40 ] ) this . _joyp [ 1 ] &= ~ 8 ; // bottom if ( this . _keys [ 83 ] ) this . _joyp [ 0 ] &= ~ 2 ; // b", "commit_type": "add"}
{"commit_tokens": ["Add", "database", "and", "newData", "props", "to", "results"], "add_tokens": "constructor ( path , operationType , db , newDb , newValue ) { this . auth = isRead ? db . auth : newDb . auth ; this . database = db ; this . newDatabase = newDb ; get root ( ) { return this . database . snapshot ( '/' ) ; } get newRoot ( ) { return this . newDatabase . snapshot ( '/' ) ; } get data ( ) { return this . database . snapshot ( this . path ) ; } get newData ( ) { return this . newDatabase . snapshot ( this . path ) ; }", "del_tokens": "constructor ( path , operationType , data , newData , newValue ) { this . auth = isRead ? data . auth : newData . auth ; this . data = data . snapshot ( path ) ; this . root = data . snapshot ( '/' ) ; if ( isRead ) { return ; } this . newData = newData . snapshot ( path ) ; this . newRoot = newData . snapshot ( '/' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "parsing", "the", "event", "stream", "format"], "add_tokens": "// of a single event. This buffer helps handle fragments. // Let's think of a series of the following chunks: // * `\"data: {}\\n\\ndata: {}\\n\\n\"` // * `\"data: {}\\n\\ndata: {\"` // * `\"}\\n\\ndata:{\"` // * `\"..\"` // * `\".}\"` // * `\"\\n\\ndata: {}\\n\\n\"` // // It looks not easy to handle. So let's concatenate buffer and chunk. // Here the buffer is a string after last `\\n\\n` of the concatenation. // * `\"\"` + `\"data: {}\\n\\ndata: {}\\n\\n\"` // * `\"\"` + `\"data: {}\\n\\ndata: {\"` // * `\"data: {\"` + `\"}\\n\\ndata:{\"` // * `\"data: {\"` + `\"..\"` // * `\"data: {..\"` + `\".}\"` // * `\"data: {...}\"` + `\"\\n\\ndata: {}\\n\\n\"` // Let's split the concatenation by `\\n\\n`. var i , lines = ( buffer + chunk ) . split ( \"\\n\\n\" ) ; // Lines except the last consist of a complete data starting // with 'data: ' Unwraps 'data: ' and fires a message event. for ( i = 0 ; i < lines . length - 1 ; i ++ ) { transport . emit ( \"message\" , lines [ i ] . substring ( \"data: \" . length ) ) ; } // The last element is a fragment of a data. Assigns it to buffer. buffer = lines [ lines . length - 1 ] ;", "del_tokens": "// of a single event. This buffer is used to aggregate fragments to // complete a single event. // `data: {}\\n\\n` will be split into `[\"data: {}\", \"\"]`. chunk . split ( / \\n\\n / ) . forEach ( function ( line ) { // Fires a message event and clears the buffer. if ( ! line ) { transport . emit ( \"message\" , buffer ) ; buffer = \"\" ; // A single data field, e.g. the former of `data: {...` and `...}`. } else if ( / ^data:\\s / . test ( line ) ) { buffer += line . substring ( \"data: \" . length ) ; // A fragment of a data field, e.g. the latter of `data: {...` and `...}`. } else { buffer += line ; } } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Improving", "build", "time", "by", "avoiding", "rebuilds", "of", "the", "bootstrap", "package", "."], "add_tokens": "} , plannedBuilds : 1 var planBootstrapFileRebuild = function ( packaging , config ) { var info = getInfo ( packaging , config ) ; info . plannedBuilds ++ ; } ; var skipCurrentBootstrapFileBuild = function ( packaging , config ) { var info = getInfo ( packaging , config ) ; info . plannedBuilds -- ; return info . plannedBuilds > 0 ; } ; rebuildBootstrapFile : rebuildBootstrapFile , planBootstrapFileRebuild : planBootstrapFileRebuild , skipCurrentBootstrapFileBuild : skipCurrentBootstrapFileBuild", "del_tokens": "} rebuildBootstrapFile : rebuildBootstrapFile", "commit_type": "improve"}
{"commit_tokens": ["changed", "to", "promise", "doesn", "t", "work", "quite", "yet", "though"], "add_tokens": "const exec = Promise . promisify ( require ( 'child_process' ) . exec ) ; // let promise = new Promise((resolve, reject) => { // exec(validator.versionCheck, (error, stdout, stderr) => { // // if (error) { // reject(stderr); // return; // } // // resolve({ // result: validator.versionValidate(stdout, expectedVersion), // reason: stdout // }); // }); // }); // // return promise; return exec ( validator . versionCheck ) . then ( ( result ) => { console . log ( result ) ; return { result : validator . versionValidate ( result [ 0 ] , expectedVersion ) , reason : result [ 0 ] } ;", "del_tokens": "const exec = require ( 'child_process' ) . exec ; let promise = new Promise ( ( resolve , reject ) => { exec ( validator . versionCheck , ( error , stdout , stderr ) => { if ( error ) { reject ( stderr ) ; return ; } resolve ( { result : validator . versionValidate ( stdout , expectedVersion ) , reason : stdout } ) ; } ) ; return promise ;", "commit_type": "change"}
{"commit_tokens": ["add", "tests", "and", "major", "updates", "to", "api"], "add_tokens": "var gulp = require ( 'gulp' ) ; var test = require ( 'tape' ) ; var run = require ( 'tape-run' ) ; var spec = require ( 'tap-spec' ) ; var browserify = require ( 'browserify' ) ; var scssify = require ( './' ) ; var changed = require ( 'gulp-changed' ) ; var babel = require ( 'gulp-babel' ) ; var eslint = require ( 'gulp-eslint' ) ; var eventstream = require ( 'event-stream' ) gulp . task ( 'test' , function ( ) { var stream = test . createStream ( ) . pipe ( spec ( ) ) . pipe ( process . stdout ) ; require ( './tests' ) ; return stream ; } ) gulp . task ( 'build' , [ 'lint' , 'transpile' ] ) gulp . task ( 'default' , [ 'build' ] )", "del_tokens": "var gulp = require ( 'gulp' ) ; var changed = require ( 'gulp-changed' ) ; var babel = require ( 'gulp-babel' ) ; var eslint = require ( 'gulp-eslint' ) ; . pipe ( changed ( conf . dist ) ) gulp . task ( 'default' , [ 'transpile' ] )", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "separators", "within", "domain", "anchors"], "add_tokens": "const separatorCharacters = ':?/=^' ; function findFirstSeparatorChar ( input , startPos ) { for ( let i = startPos ; i < input . length ; i ++ ) { if ( separatorCharacters . indexOf ( input [ i ] ) !== - 1 ) { return i ; } } return - 1 ; } let indexOfSep = findFirstSeparatorChar ( input , beginIndex + 1 ) ; if ( indexOfSep === - 1 ) { indexOfSep = input . length ; parsedFilterData . host = input . substring ( beginIndex , indexOfSep ) ; let domainIndexEnd = findFirstSeparatorChar ( input , domainIndexStart ) ; indexOfFilter ( input , parsedFilterData . data ) !== - 1 ;", "del_tokens": "const separatorCharacters = ':?/=' ; let indexOfSlash = input . indexOf ( '/' , beginIndex + 1 ) ; if ( indexOfSlash === - 1 ) { indexOfSlash = input . length ; parsedFilterData . host = input . substring ( beginIndex , indexOfSlash ) ; let domainIndexEnd = input . indexOf ( '/' , domainIndexStart ) ; input . indexOf ( parsedFilterData . data ) !== - 1 ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "that", "the", "field", "would", "sometimes", "miscalculate", "inserted", "/", "deleted", "."], "add_tokens": "sharedSuffixLength = 0 ; for ( i = _j = 0 , _ref1 = ctext . length - sharedPrefixLength ; 0 <= _ref1 ? _j < _ref1 : _j > _ref1 ; i = 0 <= _ref1 ? ++ _j : -- _j ) {", "del_tokens": "sharedSuffixLength = ctext . length ; for ( i = _j = 0 , _ref1 = ctext . length ; 0 <= _ref1 ? _j < _ref1 : _j > _ref1 ; i = 0 <= _ref1 ? ++ _j : -- _j ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "start", "date", "to", "handler", "scope", "."], "add_tokens": "ip : req . connection . remoteAddress , date : new Date ( )", "del_tokens": "// @todo Add start date (can be used for performance measures). ip : req . connection . remoteAddress", "commit_type": "add"}
{"commit_tokens": ["removed", ".", "only", "from", "meta", "folder", "tests"], "add_tokens": "describe ( \"when getting metadata for a folder\" , function ( ) {", "del_tokens": "describe . only ( \"when getting metadata for a folder\" , function ( ) {", "commit_type": "remove"}
{"commit_tokens": ["Implement", "generating", "new", "clusters", "as", "required", "when", "zooming", "down"], "add_tokens": "//Returns { 'clusters': [new clusters], 'unclustered': [unclustered markers] } if ( ! hasChildClusters ) { newCluster . _zoomForCluster = zoom + 1 ; } nc . _haveGeneratedChildClusters = true ;", "del_tokens": "//Returns FIXME TODO", "commit_type": "implement"}
{"commit_tokens": ["Added", "find", ".", "count", "crudify", "filter"], "add_tokens": "* find . count ( intentObj , countQry ) * find . count ( intentObj , countQry ) - > right before we call the count ( ) with the query if ( opt . maxLimit !== false ) { // run the filters. try { actionObj . _runFilters ( 'find.count' , intentObj , countQuery ) ; } catch ( e ) { intentObj . error ( thorin . error ( e ) ) ; actionObj . _runSend ( 'find.error' , intentObj ) ; return null ; } if ( opt . maxLimit !== false ) {", "del_tokens": "if ( opt . maxLimit !== false ) { if ( opt . maxLimit !== false ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "broke", "compatibility", "with", "working", "with", "subscription", "services", "."], "add_tokens": "data . meadcoServer + \", or \" + data . meadcoPrinthtmlserver +", "del_tokens": "data . meadcoServer +", "commit_type": "fix"}
{"commit_tokens": ["Fix", "sample", "tour", "image", "path", "."], "add_tokens": "var urlPrefix = \"//www.marzipano.net/media\" ; urlPrefix + \"/\" + data . id + \"/{z}/{f}/{y}/{x}.jpg\" , { cubeMapPreviewUrl : urlPrefix + \"/\" + data . id + \"/preview.jpg\" } ) ;", "del_tokens": "\"tiles/\" + data . id + \"/{z}/{f}/{y}/{x}.jpg\" , { cubeMapPreviewUrl : \"tiles/\" + data . id + \"/preview.jpg\" } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "ExtendableFunction", "to", "work", "with", "babel", "and", "jest"], "add_tokens": "const CallableInstance = require ( 'callable-instance' ) ; // FIXME CallableInstance is a nicer name, so take it from super... class ExtendableFunction extends CallableInstance { * @ constructor super ( '__callSelf' ) ; this . _func = f ; } __callSelf ( ... args ) { return this . _func ( ... args ) ; module . exports = ExtendableFunction ;", "del_tokens": "class ExtensibleFunction extends Function { * @ returns { * } The function f with updated prototype super ( ) ; Object . setPrototypeOf ( f , new . target . prototype ) ; return f ; module . exports = ExtensibleFunction ;", "commit_type": "update"}
{"commit_tokens": ["implemented", "file", "conversion", "and", "process", "pooling", "not", "yet", "working", "..."], "add_tokens": "var Worker = require ( './worker' ) ; var EventEmitter = new require ( 'events' ) . EventEmitter ; var eventEmitter = new EventEmitter ( ) ; eventEmitter . setMaxListeners ( 1000 ) ; var freeWorkers = [ ] ; var waiting = [ ] ; var freeWorker = function ( worker ) { if ( waiting . length > 0 ) { waiting . shift ( ) ( worker ) ; } else { freeWorkers . push ( worker ) ; } } ; for ( var i = 0 ; i < config . maxWorkers ; i ++ ) { var worker = new Worker ( ) ; worker . on ( 'free' , freeWorker ) ; freeWorkers . push ( worker ) ; } module . exports = { getFreeWorker : function ( callback ) { if ( freeWorkers . length > 0 ) { callback ( freeWorkers . pop ( ) ) ; } else { waiting . push ( callback ) ; } } } ;", "del_tokens": "var processes = new Array ( config . workers ) ;", "commit_type": "implement"}
{"commit_tokens": ["add", "btoa", "for", "node", ".", "js", "env", "and", "export", "ttf2base64", "and", "ttf2icon"], "add_tokens": "otf2ttfobject : require ( './ttf/otf2ttfobject' ) , ttf2base64 : require ( './ttf/ttf2base64' ) , ttf2icon : require ( './ttf/ttf2icon' )", "del_tokens": "otf2ttfobject : require ( './ttf/otf2ttfobject' )", "commit_type": "add"}
{"commit_tokens": ["Fix", "stream", "key", "decoding", "for", "live", "streams"], "add_tokens": "// decode keys even when keys or values aren't requested specifically if ( ( opts . keys && opts . values ) || ( ! opts . keys && ! opts . values ) ) {", "del_tokens": "if ( opts . keys && opts . values ) {", "commit_type": "fix"}
{"commit_tokens": ["updated", "FQDN", "s", "to", "googleapis", ".", "com", "with", "a", "trailing", "dot"], "add_tokens": "this . defaultBaseUrl_ = 'pubsub.googleapis.com.' ;", "del_tokens": "this . defaultBaseUrl_ = 'pubsub.googleapis.com' ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "issue", "for", "null", "response", "from", "Bower"], "add_tokens": "if ( this . version === '*' && this . bower_info && this . bower_info . hasOwnProperty ( 'latest' ) ) { if ( bower && bower . hasOwnProperty ( 'dependencies' ) ) { if ( dep . bower_info && ! dep . bower_info . hasOwnProperty ( 'main' ) ) {", "del_tokens": "if ( this . version === '*' && this . bower_info . hasOwnProperty ( 'latest' ) ) { if ( bower . hasOwnProperty ( 'dependencies' ) ) { if ( ! dep . bower_info . hasOwnProperty ( 'main' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["create", "interface", "for", "storage", "and", "wrap", "in", "-", "memory", "implementation", "in", "it"], "add_tokens": "import { InMemory } from './db' ; const db = new InMemory ( reducer ) ; const store = db . get ( gameid ) ; if ( store == null ) { db . set ( gameid , store ) ; let store = null ; if ( db . get ( gameid ) == null ) { store = Redux . createStore ( reducer ) ; db . set ( gameid , store ) ; } else { store = db . get ( gameid ) ;", "del_tokens": "const games = { } ; if ( ! ( gameid in games ) ) { const store = games [ gameid ] ; if ( ! ( gameid in games ) ) { games [ gameid ] = Redux . createStore ( reducer ) ; const store = games [ gameid ] ;", "commit_type": "create"}
{"commit_tokens": ["Fix", "bug", "where", "synchronous", "errors", "weren", "t", "getting", "caught"], "add_tokens": "try { this . __func ( this . assert , function ( ) { self . finish ( ) } , this ) ; } catch ( err ) { if ( this . listeners ( 'uncaughtException' ) . length > 0 ) { this . emit ( 'uncaughtException' , err ) ; } else { this . failed ( err ) ; } }", "del_tokens": "this . __func ( this . assert , function ( ) { self . finish ( ) } , this ) ;", "commit_type": "fix"}
{"commit_tokens": ["Move", "percySnapshot", "to", "its", "own", "public", "method", "."], "add_tokens": "import percySnapshot from './snapshot' ; console . log ( '[percy] Snapshotting:' , name ) ; percySnapshot ( name ) ;", "del_tokens": "function getDoctype ( ) { let doctypeNode = document . doctype ; let doctype = \"<!DOCTYPE \" + doctypeNode . name + ( doctypeNode . publicId ? ' PUBLIC \"' + doctypeNode . publicId + '\"' : '' ) + ( ! doctypeNode . publicId && doctypeNode . systemId ? ' SYSTEM' : '' ) + ( doctypeNode . systemId ? ' \"' + doctypeNode . systemId + '\"' : '' ) + '>' ; return doctype ; } // Create a full-page DOM snapshot from the current testing page. // TODO(fotinakis): more memory-efficient way to do this? let domCopy = $ ( 'html' ) . clone ( ) ; // TODO(fotinakis): this is Mocha specific, need to support other testing frameworks. let html = domCopy . find ( '#ember-testing-container' ) . html ( ) ; // Hoist the testing container contents up to the body. domCopy . find ( 'body' ) . html ( html ) ; Ember . $ . ajax ( '/_percy/snapshot' , { method : 'POST' , contentType : 'application/json; charset=utf-8' , data : JSON . stringify ( { name : name , content : getDoctype ( ) + domCopy [ 0 ] . outerHTML , } ) , } ) ;", "commit_type": "move"}
{"commit_tokens": ["fix", "uploads", "in", "Firefox", "49", "and", "below"], "add_tokens": "if ( t . files && t . files . length ) {", "del_tokens": "if ( t . files && t . files . length && \"webkitRelativePath\" in t . files [ 0 ] ) {", "commit_type": "fix"}
{"commit_tokens": ["moved", "cards", "to", "their", "own", "project"], "add_tokens": "var blueBook = null ; // TODO: there must be a better way return _ . clone ( dcCards ) ; return _ . clone ( insurances ) ; return _ . clone ( cars ) ; } } , blueBook : { enumerable : true , get : function ( ) { return blueBook ; } , set : function ( value ) { assert ( ! blueBook ) ; blueBook = value ;", "del_tokens": "_ . clone ( dcCards ) ; _ . clone ( insurances ) ; _ . clone ( cars ) ;", "commit_type": "move"}
{"commit_tokens": ["add", "basic", "waves", "attribute", "and", "attached", "them", "to", "navbar", "no", "sample", "yet"], "add_tokens": "// is this how we/users import materialize? import 'materialize' ; aurelia . use . standardConfiguration ( ) . developmentLogging ( ) . plugin ( 'plugin-builder' , plugin => plugin . useClickCounter ( ) . useWaves ( ) ) ; aurelia . use . globalResources ( 'shared/collapse-panel' ) ; aurelia . use . globalResources ( 'shared/markdown' ) ; aurelia . use . globalResources ( 'shared/logger' ) ; aurelia . use . globalResources ( 'shared/au-code' ) ; . then ( au => au . setRoot ( 'app' ) ) ;", "del_tokens": "aurelia . use . standardConfiguration ( ) . developmentLogging ( ) . plugin ( 'plugin-builder' , plugin => plugin . useClickCounter ( ) ) ; aurelia . use . globalResources ( 'shared/collapse-panel' ) ; aurelia . use . globalResources ( 'shared/markdown' ) ; aurelia . use . globalResources ( 'shared/logger' ) ; aurelia . use . globalResources ( 'shared/au-code' ) ; . then ( au => au . setRoot ( 'app' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "font", "alpha", "bump", "version", "number"], "add_tokens": "ctx . fillStyle = '#00ff00' ; var count = 1 ; //*1000; var str = \"A\" ; ctx . fillStyle = '#00ff00' ; ctx . fillStyle = '#ffff00' ; ctx . fillText ( str , 30 , 60 ) ; // ctx.save(); //ctx.translate(0,80); //ctx.fillText(str,30,30); //ctx.restore();", "del_tokens": "ctx . fillStyle = '#000000' ; var count = 1 * 1000 ; var str = \"ABCDEgae\" ; ctx . save ( ) ; ctx . translate ( 0 , 80 ) ; ctx . fillText ( str , 30 , 30 ) ; ctx . restore ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "error", "response", "regarding", "email", "authenticated", "wallets"], "add_tokens": "ERR_SYNC : 'Attempt to save wallet to server failed' , ERR_AUTH : 'Wallets that require email authorization are currently not supported in the Wallet API. Please disable this in your wallet settings, or add the IP address of this server to your wallet IP whitelist.' ,", "del_tokens": "ERR_SYNC : 'Attempt to save wallet to server failed'", "commit_type": "add"}
{"commit_tokens": ["added", "test", "for", "recoverMissedExecutions", "on", "node", "-", "cron", "option"], "add_tokens": "it ( 'should recover missed executions' , ( done ) => { let executed = 0 ; this . clock . restore ( ) ; let scheduledTask = cron . schedule ( '* * * * * *' , ( ) => { executed += 1 ; } , { recoverMissedExecutions : true } ) ; let wait = true ; let startedAt = new Date ( ) ; while ( wait ) { if ( ( new Date ( ) . getTime ( ) - startedAt . getTime ( ) ) > 1000 ) { wait = false ; } } setTimeout ( ( ) => { scheduledTask . stop ( ) ; assert . equal ( 2 , executed ) ; done ( ) ; } , 1000 ) ; } ) . timeout ( 4000 ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "Windows", "path", "-", "issue", "23"], "add_tokens": "var root = path . join ( path . resolve ( dir ) , '/' ) ,", "del_tokens": "var root = path . resolve ( dir ) + '/' ,", "commit_type": "fix"}
{"commit_tokens": ["Move", "setup", "step", "to", "#startWriting", "method", "."], "add_tokens": "Step ( function ( ) { mbtiles . _setup ( this ) ; } , function ( err ) { if ( err ) throw err ; // Sets the synchronous flag to OFF for (much) faster inserts. // See http://www.sqlite3.org/pragma.html#pragma_synchronous if ( ! mbtiles . _isWritable ) { mbtiles . _isWritable = 1 ; mbtiles . _clearCaches ( ) ; mbtiles . _db . run ( 'PRAGMA synchronous=OFF' , this ) ; } else { mbtiles . _isWritable ++ ; this ( ) ; } } , function ( err ) { return callback ( err ) ; } ) ;", "del_tokens": "} , function ( err ) { if ( err ) throw err ; mbtiles . _setup ( this ) ; // Sets the synchronous flag to OFF for (much) faster inserts. // See http://www.sqlite3.org/pragma.html#pragma_synchronous if ( ! this . _isWritable ) { this . _isWritable = 1 ; this . _clearCaches ( ) ; this . _db . run ( 'PRAGMA synchronous=OFF' , callback ) ; } else { this . _isWritable ++ ; return callback ( null ) ; }", "commit_type": "move"}
{"commit_tokens": ["Remove", "use", "method", "(", "temporary", ")"], "add_tokens": "mount : mount", "del_tokens": "mount : mount , use : use", "commit_type": "remove"}
{"commit_tokens": ["Add", "the", "concept", "of", "defined", "commands", "and", "options"], "add_tokens": "function markCommands ( commands ) { let command = Object . assign ( { } , commands [ i ] ) command . defined = true command . root = ! nonRootCommands [ command . id ] function markOptions ( options ) { let newOptions = [ ] for ( let i = 0 ; i < options . length ; i ++ ) { let option = Object . assign ( { } , options [ i ] ) option . defined = true newOptions [ i ] = option } return newOptions } let { commands , options } = config config . commands = commands && markCommands ( commands ) config . options = options && markOptions ( options )", "del_tokens": "function markRootCommands ( commands ) { let command = commands [ i ] let isRoot = ! nonRootCommands [ command . id ] // eslint-disable-next-line eqeqeq if ( isRoot != command . root ) { command = Object . assign ( { } , command ) command . root = isRoot } config . commands = markRootCommands ( config . commands )", "commit_type": "add"}
{"commit_tokens": ["Use", "conductor", "actions", "to", "implement", "compositions"], "add_tokens": "composer . if ( 'authenticate' , /* then */ 'success' , /* else */ 'failure' )", "del_tokens": "'use strict' const composer = require ( '@ibm-functions/composer' ) // author action composition const app = composer . if ( 'authenticate' , /* then */ 'welcome' , /* else */ 'login' ) // compile action composition composer . compile ( app , 'demo.json' )", "commit_type": "use"}
{"commit_tokens": ["Fix", "typo", "in", "comments", "which", "is", "used", "for", "README", "generation"], "add_tokens": "* as style url , layers will be added to the map when the Mapbox Style document", "del_tokens": "* as style url , layers will be added to the map when the Mapbox Style docukment", "commit_type": "fix"}
{"commit_tokens": ["change", "Smartcar", ".", "errors", "to", "static", "property"], "add_tokens": "Smartcar . errors = errors ;", "del_tokens": "this . errors = errors ;", "commit_type": "change"}
{"commit_tokens": ["Added", "persistent", "vars", "for", "legacy", "browsers"], "add_tokens": "persist : settings . updateDOM , // Convert all property names to leading '--' style const prop = ` ${ key . replace ( / ^-+ / , '' ) } ` ; const value = settings . variables [ key ] ; document . documentElement . style . setProperty ( prop , value ) ;", "del_tokens": "// Normalize variables by ensuring all start with leading '--' const varName = ` ${ key . replace ( / ^-+ / , '' ) } ` ; const varValue = settings . variables [ key ] ; document . documentElement . style . setProperty ( varName , varValue ) ; // Functions (Private) // ============================================================================= / ** * Ponyfill for native Element . matches method * * @ param { object } elm - The element to test * @ param { string } selector - The CSS selector to test against * @ returns { boolean } * / function matchesSelector ( elm , selector ) { /* istanbul ignore next */ const matches = elm . matches || elm . matchesSelector || elm . webkitMatchesSelector || elm . mozMatchesSelector || elm . msMatchesSelector || elm . oMatchesSelector ; return matches . call ( elm , selector ) ; }", "commit_type": "add"}
{"commit_tokens": ["Change", "hasView", "logic", "to", "cover", "corner", "cases"], "add_tokens": "if ( 'center' in glStyle && ! view . getCenter ( ) ) { if ( 'zoom' in glStyle && view . getZoom ( ) === undefined ) { if ( ! view . getCenter ( ) || view . getZoom ( ) === undefined ) {", "del_tokens": "var hasView = true ; if ( 'center' in glStyle && ! hasView ) { if ( 'zoom' in glStyle && ! hasView ) { if ( ! ( 'zoom' in glStyle || 'center' in glStyle ) && ! hasView ) { hasView = false ;", "commit_type": "change"}
{"commit_tokens": ["Update", "the", "accessors", "tests", "after", "the", "accessor", "methods", "were", "moved", "from", "the", "prototype", "to", "the", "constructor", "."], "add_tokens": "var ctor = require ( '../' ) ; this . addGetters ( 'foo' , 'bar' ) ; this . addSetters ( 'foo' , 'bar' ) ; var Ctor = ctor ( function ( ) { this . addAccessors ( 'foo' , 'bar' ) ;", "del_tokens": "var ctor = require ( '..' ) ; proto . addGetters ( 'foo' , 'bar' ) ; proto . addSetters ( 'foo' , 'bar' ) ; var Ctor = ctor ( function ( proto ) { proto . addAccessors ( 'foo' , 'bar' ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "undefined", "variable", "for", "onSort", "callback"], "add_tokens": "var sortBy = this . state . sortBy ; var order ; if ( sortBy . order === 'desc' ) {", "del_tokens": "var order = this . state . sortBy . order ; if ( order === 'desc' ) {", "commit_type": "fix"}
{"commit_tokens": ["Removed", "extraneous", "body", "from", "POST", "/", "PUT", "/", "DEL", "if", "no", "params", "are", "found"], "add_tokens": "else { // only set body if there are values if ( _ . keys ( params ) . length > 0 ) { result . body = params ; }", "del_tokens": "else { result . body = params ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "ability", "to", "disable", "timeout", "."], "add_tokens": "// do not hide if -1 is passed in. if ( delay !== \"-1\" ) { // delay the hiding operation for 1.5s by default. if ( ! isDef ( delay ) ) { delay = 1.5 ; } hider_ . id_ = $timeout ( function ( ) { $popover . off ( 'click' , insideClickHandler ) ; $document . off ( 'click' , outsideClickHandler ) ; elm . off ( 'click' , buttonClickHandler ) ; $popover . isOpen = false ; displayer_ . cancel ( ) ; $popover . css ( 'display' , 'none' ) ; } , delay * 1000 ) ; }", "del_tokens": "// delay the hiding operation for 1.5s by default. if ( ! isDef ( delay ) ) { delay = 1.5 ; } hider_ . id_ = $timeout ( function ( ) { $popover . off ( 'click' , insideClickHandler ) ; $document . off ( 'click' , outsideClickHandler ) ; elm . off ( 'click' , buttonClickHandler ) ; $popover . isOpen = false ; displayer_ . cancel ( ) ; $popover . css ( 'display' , 'none' ) ; } , delay * 1000 ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "smarter", "way", "of", "instantiating", "table", "widget", "(", "wait", "for", "animations", "to", "finish", ")"], "add_tokens": "$ ( this . element ) . parent ( ) . parent ( ) . find ( '.jr-appearance-field-list .jr-appearance-list-nolabel, .jr-appearance-field-list .jr-appearance-label' ) . parent ( ) . parent ( '.jr-appearance-field-list' ) . each ( function ( ) { // remove the odd input element that XLSForm adds for the 'easier table method' // see https://github.com/modilabs/pyxform/issues/72 $ ( this ) . find ( 'input[readonly]' ) . remove ( ) ; // fix the column widths, after any ongoing animations have finished $ ( this ) . promise ( ) . done ( function ( ) { } ) ; this . init ( ) ;", "del_tokens": "setTimeout ( function ( ) { // When loading a form dynamically the DOM elements don't have a width yet (width = 0), // so we call this with a bit of a delay. $ ( this . element ) . parent ( ) . parent ( ) . find ( '.jr-appearance-field-list .jr-appearance-list-nolabel, .jr-appearance-field-list .jr-appearance-label' ) . parent ( ) . parent ( '.jr-appearance-field-list' ) . each ( function ( ) { // remove the odd input element that XLSForm adds for the 'easier method' // see https://github.com/modilabs/pyxform/issues/72 $ ( this ) . find ( 'input[readonly]' ) . remove ( ) ; // fix the column widths } , 50 ) ;", "commit_type": "use"}
{"commit_tokens": ["Remove", "commonjs", "to", "fix", "the", "problem", "with", "cjs", "/", "esm", "interop"], "add_tokens": "export const userAgent = typeof navigator !== 'undefined' ? const window_ = typeof window !== 'undefined' ? window : global ; const global_ = typeof global !== 'undefined' ? global : window ; const document_ = typeof document !== 'undefined' ? document : { } ; export { window_ as window , global_ as global , document_ as document", "del_tokens": "const isBrowser = require ( './is-browser' ) . default ; const userAgent = typeof navigator !== 'undefined' ? module . exports = { window : typeof window !== 'undefined' ? window : global , global : typeof global !== 'undefined' ? global : window , document : typeof document !== 'undefined' ? document : { } , isBrowser , userAgent", "commit_type": "remove"}
{"commit_tokens": ["Removed", "unused", "name", "argument", "from", "APIBase", "constructor"], "add_tokens": "resourceConstructor . prototype = new APIBase (", "del_tokens": "resourceConstructor . prototype = new APIBase ( resourceName ,", "commit_type": "remove"}
{"commit_tokens": ["Added", "copying", "index", ".", "d", ".", "ts", "file", "into", "dist", "folder"], "add_tokens": "import copy from \"rollup-plugin-copy\" ; // copy typescript definitions const copyPlugin = copy ( { targets : [ { src : \"index.d.ts\" , dest : \"dist\" } , ] , verbose : true , copyOnce : true , } ) ; bublePlugin , copyPlugin copyPlugin ,", "del_tokens": "bublePlugin", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "regenerating", "sessions", "."], "add_tokens": "this . status = 404 ; case '/session/regenerate' : yield regenerate ( this ) ; break ; case '/session/regenerateWithData' : this . session . foo = 'bar' ; yield regenerate ( this ) ; this . body = { foo : this . session . foo , hasSession : this . session !== undefined } ; break ; function * regenerate ( ctx ) { yield ctx . regenerateSession ( ) ; ctx . session . data = 'foo' ; getId ( ctx ) ; }", "del_tokens": "this . staus = 404 ;", "commit_type": "add"}
{"commit_tokens": ["fix", "parsing", "array", "param", "error"], "add_tokens": "var paren = s . slice ( params . str . length ) . match ( / \\s*\\] / ) ;", "del_tokens": "var paren = s . slice ( params . str . length ) . match ( / \\s*\\]\\s* / ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "the", "custom", "update", "module", "so", "if", "a", "user", "get", "s", "disabled", "they", "will", "also", "be", "logged", "out", "of", "the", "system", "."], "add_tokens": "module . exports . update = require ( './update' ) ;", "del_tokens": "module . exports . update = require ( '../db' ) ( db . users , db . users . update ) ;", "commit_type": "implement"}
{"commit_tokens": ["added", "the", "possibility", "to", "set", "percentage", "values"], "add_tokens": "value = Math . max ( MIN_VALUE , Math . min ( value , MAX_VALUE ) ) ; value = value * MAX_VALUE ; value = parseInt ( value , 10 ) ;", "del_tokens": "//value = parseInt(value * MAX_VALUE, 10); value = Math . max ( MIN_VALUE , Math . min ( value , MAX_VALUE ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "review", "comment", "for", "issue", "11"], "add_tokens": "assert . throw ( function ( ) { var result = ICAL . parse ( blankLineMidICS ) ; } , ICAL . ParserError , \"Parser falsly accepted blank line inbetween\" ) ;", "del_tokens": "var error , result ; try { result = ICAL . parse ( blankLineMidICS ) ; } catch ( e ) { error = e ; } if ( ! error ) { throw \"Expected Error but passed\" + result . toSource ( ) ; }", "commit_type": "fix"}
{"commit_tokens": ["add", "sender", "to", "all", "packages"], "add_tokens": "if ( nodeID == null ) { this . logger . error ( \"Missing nodeID from node info package!\" ) ; return ; } node . id = nodeID ; this . nodes . set ( nodeID , node ) ; this . registerAction ( action , nodeID ) ;", "del_tokens": "this . nodes . set ( node . nodeID , node ) ; this . registerAction ( action , node . nodeID ) ;", "commit_type": "add"}
{"commit_tokens": ["improve", "error", "handling", "of", "custom", "auth", "callback"], "add_tokens": "try { Promise . resolve ( _callback ( err , user , info , status ) ) . then ( ( ) => callback . resolve ( false ) ) . catch ( err => callback . reject ( err ) ) } catch ( err ) { callback . reject ( err ) }", "del_tokens": "Promise . resolve ( _callback ( err , user , info , status ) ) . then ( ( ) => callback . resolve ( false ) ) . catch ( err => callback . reject ( err ) )", "commit_type": "improve"}
{"commit_tokens": ["Added", "hasAttribute", "method", "to", "Node", ".", "Fixed", "small", "lint", "."], "add_tokens": "if ( ! ( child instanceof Node ) ) {", "del_tokens": "if ( ! child instanceof Node ) {", "commit_type": "add"}
{"commit_tokens": ["added", "json", "parsing", "onto", "panda"], "add_tokens": "} else if ( t == 'obj' ) { return ast [ 1 ] ; }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["removed", "log", "coloring", "on", "collation"], "add_tokens": "//l.color = l._colors.FgMagenta;", "del_tokens": "l . color = l . _colors . FgMagenta ;", "commit_type": "remove"}
{"commit_tokens": ["Use", "owner", "()", "instead", "of", "manual", "check", "."], "add_tokens": "var params = orgaId ? [ orgaId , appId ] : [ appId ] ; return api . owner ( orgaId ) . applications . _ . get ( ) . withParams ( params ) . send ( ) ;", "del_tokens": "if ( orgaId ) { return api . organisations . _ . get ( ) . withParams ( [ orgaId ] ) . send ( ) . map ( function ( organisation ) { return _ . find ( organisation . apps , function ( app ) { return app . id === appId ; } ) ; } ) ; } else { return api . owner ( ) . applications . _ . get ( ) . withParams ( [ appId ] ) . send ( ) ; }", "commit_type": "use"}
{"commit_tokens": ["Implemented", "the", "IStorage", "and", "added", "queue", "tests", "."], "add_tokens": "sourceMap : true , target : 'ES5' gulp . task ( 'test' , [ ] , function ( ) {", "del_tokens": "target : 'ES6' gulp . task ( 'test' , [ 'build' ] , function ( ) {", "commit_type": "implement"}
{"commit_tokens": ["Update", "express", "-", "handlebars", ".", "js"], "add_tokens": "defaultLayout : 'default' ,", "del_tokens": "defaultLayout : undefined ,", "commit_type": "update"}
{"commit_tokens": ["updated", "browser", "dist", "file", "and", "version"], "add_tokens": "if ( ! forBlock ) { curr = scanner . next ( ) ; }", "del_tokens": "curr = scanner . next ( ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "additional", "alias", "for", "pw", "option"], "add_tokens": "pw = options . pw || options . pass || options . password ;", "del_tokens": "pw = options . pw || options . password ;", "commit_type": "add"}
{"commit_tokens": ["Update", "html", "-", "to", "-", "text", ".", "js"], "add_tokens": "var MAX_ELEMENTS = 2000 ;", "del_tokens": "var MAX_ELEMENTS = 4000 ;", "commit_type": "update"}
{"commit_tokens": ["Adding", "a", "client", "side", "resource", "support", "."], "add_tokens": "mapper . queryDecorator = function ( query , req , res ) { // query.owner = 'luke'; } ; mapper . authorizer = function ( result , req , res ) { if ( result . data . owner === 'luke' ) { result . meta . can . edit = true ; } } // mapper.setAuthorizer(function) [ 'get' , 'robots' , mapper . get ( 'robots' , [ ] ) ] ,", "del_tokens": "[ 'get' , 'robots' , mapper . get ( 'robots' ) ] ,", "commit_type": "add"}
{"commit_tokens": ["fixed", "/", "improved", "*", "zuix", ".", "createComponent", "*", "method"], "add_tokens": "return ctx ; * Create the component ` ` and return its ` ` object . * The ` ` element is detached from the DOM . * After attaching it to the DOM , ` ` must be called in * order to load and display the component . * @ param { ContextOptions | undefined } [ options ] Component context options . if ( util . isNoU ( options . contextId ) ) options . contextId = 'zuix-ctx-' + ( ++ _contextSeqNum ) ; if ( context ( options . contextId ) != null ) { throw ( 'Context arelady exists.' ) ; } else { options . container = document . createElement ( 'div' ) ; options . componentId = componentId ; _componentizer . applyOptions ( options . container , options ) ; } return createContext ( options ) ;", "del_tokens": "return ctx ; //loadResources(ctx, options); * Create an instance of the component ` ` * loading it asynchronously and immediately returning its * context object with associated container element ( detached ) . * @ param { ContextOptions | undefined } [ options ] Options . options . container = document . createElement ( 'div' ) ; return load ( componentId , options ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "JsDoc", "errors", "on", "enume"], "add_tokens": "* @ type { WEBM | MP4 }", "del_tokens": "* @ type { 'WEBM' | 'MP4' }", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "customizable", "ad", "label", "field", "to", "the", "settings", "."], "add_tokens": "prerollTimeout : 100 , adLabel : 'Advertisement' countdownDiv . innerHTML = settings . adLabel ; settings . adLabel + podCount +", "del_tokens": "prerollTimeout : 100 countdownDiv . innerHTML = 'Advertisement' ; 'Advertisement' + podCount +", "commit_type": "add"}
{"commit_tokens": ["add", "ConfigurableTask", ".", "createReferenceTask", "()"], "add_tokens": "function createReferenceTask ( taskName ) { return function ( gulp , config , stream , done ) { var task = gulp . task ( taskName ) ; if ( ! task ) { throw new ConfigurationError ( taskName , 'referring task not found: ' + taskName ) ; } if ( task . run ) { return task . run ( gulp , config , stream , done ) ; } // support for tasks registered directlly via gulp.task(). return task . call ( gulp , done ) ; } ; } getTaskRuntimeInfo : getTaskRuntimeInfo , createReferenceTask : createReferenceTask", "del_tokens": "getTaskRuntimeInfo : getTaskRuntimeInfo", "commit_type": "add"}
{"commit_tokens": ["Moving", "the", "bodyparser", "middleware", "."], "add_tokens": "// Parse the request body. router . use ( bodyParser . urlencoded ( { extended : true } ) ) ;", "del_tokens": "// Parse the request body. router . use ( bodyParser . urlencoded ( { extended : true } ) ) ; // Initialize Stormpath middleware. router . use ( stormpathMiddleware ) ;", "commit_type": "move"}
{"commit_tokens": ["using", "undefined", "instead", "of", "anonymous", "for", "non", "-", "logged", "in", "users"], "add_tokens": "if ( curr === String ( who ) || curr === 'all' ) return true ;", "del_tokens": "if ( curr === who || curr === 'all' ) return true ;", "commit_type": "use"}
{"commit_tokens": ["remove", "console", "reporting", "logic", "from", "JUnitXmlReporter", "(", "use", "ConsoleReporter", "if", "you"], "add_tokens": "if ( ! spec . suite . startTime ) {", "del_tokens": "reportRunnerStarting : function ( runner ) { this . log ( \"Runner Started.\" ) ; } , if ( ! spec . suite . startTime ) { this . log ( spec . suite . description + ' : ' + spec . description + ' ... ' ) ; spec . didFail = ! results . passed ( ) ; spec . status = spec . didFail ? 'Failed.' : 'Passed.' ; if ( results . skipped ) { spec . status = 'Skipped.' ; } this . log ( spec . status ) ; this . log ( suite . description + \": \" + results . passedCount + \" of \" + results . totalCount + \" expectations passed.\" ) ; this . log ( \"Runner Finished.\" ) ;", "commit_type": "remove"}
{"commit_tokens": ["adds", "on", "event", "listener", "method"], "add_tokens": "const on = { } ; const update = boxes . enter ( ) . append ( \"text\" ) if ( wrapResults . truncated ) { } const events = Object . keys ( on ) ; for ( let e = 0 ; e < events . length ; e ++ ) update . on ( events [ e ] , on [ events [ e ] ] ) ; / ** @ memberof box @ desc Adds or removes a * listener * to each box for the specified event * typenames * . If a * listener * is not specified , returns the currently - assigned listener for the specified event * typename * . Mirrors the core [ d3 - selection ] ( https : //github.com/d3/d3-selection#selection_on) behavior. @ param { String } [ * typenames * ] @ param { Function } [ * listener * ] * / box . on = function ( typenames , listener ) { return arguments . length === 2 ? ( on [ typenames ] = listener , box ) : arguments . length ? on [ typenames ] : on ; } ;", "del_tokens": "boxes . enter ( ) . append ( \"text\" ) if ( wrapResults . truncated )", "commit_type": "add"}
{"commit_tokens": ["Updated", "the", "request", "verification", "to", "only", "set", "the", "default", "values", "for", "model", "attributes", "when", "the", "fields", "are", "required", "."], "add_tokens": "//set attribute value to default if its not passed and required if ( Object . keys ( parameters [ param ] ) . indexOf ( attribute ) === - 1 && self . blueprint . actions [ req . action ] . params [ param ] . model . validate [ attribute ] . required === true ) {", "del_tokens": "//set attribute value to default if its not passed if ( Object . keys ( parameters [ param ] ) . indexOf ( attribute ) === - 1 ) {", "commit_type": "update"}
{"commit_tokens": ["use", "JSON", ".", "stringify", "to", "dump", "the", "AST"], "add_tokens": "console . log ( JSON . stringify ( flow . parse ( content ) , null , 2 ) ) ;", "del_tokens": "console . log ( util . inspect ( flow . parse ( content ) , { showHidden : false , depth : null } ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "detailed", "failure", "status", "support", "."], "add_tokens": "console . error ( e ) ; var useFiber = true ;", "del_tokens": "var useFiber = false ;", "commit_type": "add"}
{"commit_tokens": ["Added", "seeded", "RNG", ".", "New", "option", "parameter", "seed", "and", "a", "number", ".", "No", "checks", "for", "seed", "validity", "are", "made"], "add_tokens": "// Seed to get repeatable colors var seed = null ; if ( options . seed && ! seed ) seed = options . seed ; //Keep the seed constant between runs. if ( options . seed ) seed = options . seed ; if ( seed == null ) { return Math . floor ( range [ 0 ] + Math . random ( ) * ( range [ 1 ] + 1 - range [ 0 ] ) ) ; } else { //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/ var max = range [ 1 ] || 1 ; var min = range [ 0 ] || 0 ; seed = ( seed * 9301 + 49297 ) % 233280 ; var rnd = seed / 233280.0 ; return Math . floor ( min + rnd * ( max - min ) ) ; }", "del_tokens": "return Math . floor ( range [ 0 ] + Math . random ( ) * ( range [ 1 ] + 1 - range [ 0 ] ) ) ;", "commit_type": "add"}
{"commit_tokens": ["removed", "changes", "that", "are", "included", "in", "an", "other", "pr"], "add_tokens": "this . props . onClick ( ) ;", "del_tokens": "this . props . onClick ( ev ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "more", "details", "to", "AjaxException"], "add_tokens": "function first1024 ( x ) { return x && x . length > 1024 ? x . substr ( 0 , 1024 ) : ( x || '' ) ; } READONLY , String , 'url' , function $ ( status , statusText , response , url_ ) { this . url = url_ || null ; } , OVERRIDE , String , function toString ( ) { var lines = BASE ( ) . split ( '\\n' ) ; lines . splice ( 1 , 0 , [ ' URL: ' + this . url , ' Response: ' + first1024 ( this . response ) ] ) ; return lines . join ( '\\n' ) ; : ria . ajax . AjaxException ( this . _xhr . status , this . _xhr . statusText , this . _xhr . response , this . _url ) ) ; } ) ;", "del_tokens": "function $ ( status , statusText , response ) { : ria . ajax . AjaxException ( this . _xhr . status , this . _xhr . statusText , this . _xhr . response ) ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "payment", "stuff", "from", "models"], "add_tokens": "var exportModel = require ( '../lib/utils' ) . exportModel ; var _ = require ( 'underscore' ) ; ] . forEach ( _ . partial ( exportModel , module . exports ) ) ;", "del_tokens": "function exportModel ( schema ) { schemas [ schema . metadata . modelName ] = schema //lazily get models Object . defineProperty ( models , schema . metadata . modelName , { get : function ( ) { return schema . getModel ( ) ; } } ) ; Object . defineProperty ( module . exports , schema . metadata . modelName , { get : function ( ) { return schema . getModel ( ) ; } } ) ; } require ( './financial-transaction' ) , require ( './funding-instrument' ) , require ( './subscription' ) , require ( './campaign' ) , //require('./fund'), ] . forEach ( exportModel ) ;", "commit_type": "remove"}
{"commit_tokens": ["Allow", "whitespace", "in", "expressions", "inside", "template", "literals"], "add_tokens": "import escapeStringRegExp from 'escape-string-regexp' pattern : new RegExp ( ` \\\\ \\\\ \\\\ ${ escapeStringRegExp ( e . getSource ( ) ) } \\\\ \\\\ ` ) , currentReplacement . pattern ,", "del_tokens": "currentReplacement . initial ,", "commit_type": "allow"}
{"commit_tokens": ["updated", "meteor", "/", "package", ".", "js", "and", "uploaded", "new", "version", "to", "atomsphere"], "add_tokens": "* Date : 2017 - 11 - 20 T11 : 13 Z", "del_tokens": "* Date : 2017 - 11 - 13 T15 : 27 Z", "commit_type": "update"}
{"commit_tokens": ["add", "source", "component", "to", "event", "object"], "add_tokens": "Ember . mixin ( props , { originalEvent : e , source : this } ) ;", "del_tokens": "Ember . mixin ( props , { originalEvent : e } ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "it", "work", "in", "IE8"], "add_tokens": "$ ( element ) . on ( 'scroll' , this . _scroll ) ; $ ( element ) . off ( 'scroll' , this . _scroll ) ;", "del_tokens": "element . addEventListener ( 'scroll' , this . _scroll ) ; element . removeEventListener ( 'scroll' , this . _scroll ) ;", "commit_type": "make"}
{"commit_tokens": ["Allow", "components", "to", "be", "configured"], "add_tokens": "/* allow configuration of which components to use for headers and rows */ HeaderComponent : React . PropTypes . func , RowComponent : React . PropTypes . func , HeaderComponent : TacoTableHeader , RowComponent : TacoTableRow , const { columns , HeaderComponent } = this . props ; { columns . map ( ( column , i ) => < HeaderComponent key = { i } column = { column } / > ) } const { data , columns , RowComponent } = this . props ; < RowComponent key = { i } rowNumber = { i } rowData = { rowData } columns = { columns } tableData = { data } / > console . log ( 'Table render.' ) ; console . table ( this . props . columns ) ; console . log ( 'Data = ' , this . props . data ) ;", "del_tokens": "const { columns } = this . props ; console . log ( columns ) ; { columns . map ( ( column , i ) => < TacoTableHeader key = { i } column = { column } / > ) } const { data , columns } = this . props ; < TacoTableRow key = { i } rowData = { rowData } columns = { columns } tableData = { data } / >", "commit_type": "allow"}
{"commit_tokens": ["fix", "typo", "in", "internal", "debug", "()", "function"], "add_tokens": "window && window . console && window . console . log && window . console . log ( \"jQuery.floatThead: \" + str ) ;", "del_tokens": "window . console && window . console && window . console . log && window . console . log ( \"jQuery.floatThead: \" + str ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "JS", "files", "to", "local", "change", "absolute", "urls", "to", "relative", "local", "url"], "add_tokens": ". wf - main { visibility : hidden ; opacity : 0 ; transition : visibility 0 s , opacity 1.5 s ease - in - out ; } . wf - main . active { visibility : visible ; opacity : 1 ; } < div id = \"wild-fire\" class = \"wf wf-main\" : class = \"{ active: isLoaded }\" > : user = \"userData\" : user = \"userData\" : comment = \"Object.assign({'.key': key}, reply)\" < a id = \"add-to-your-site\" href = \"https://github.com/cheng-kang/wildfire\" target = \"blank\" > < img src = \"./static/add-button.svg\" > { { $i18next . t ( 'text/add_wildfire_to_your_site' ) } } < / a > url : './src/modules/firebase.js' , url : './src/modules/moment.min.js' , // 'https://unpkg.com/vuefire/dist/vuefire.js', // 'https://unpkg.com/vue@2.4.2/dist/vue.js', './src/modules/vuefire.js' , './src/modules/vue.js' ,", "del_tokens": "[ v - cloak ] { display : none ; } < div id = \"wild-fire\" class = \"wf wf-main\" : class = \"{ active: isLoaded }\" v - cloak > : comment = \"{ ...reply, '.key': key}\" < a id = \"add-to-your-site\" href = \"https://github.com/cheng-kang/Wild-Fire\" target = \"blank\" > < img src = \"./static/add-button.svg\" > { { $i18next . t ( 'text/add_wildfire_to_your_site' ) } } < / a > url : 'https://www.gstatic.com/firebasejs/4.3.0/firebase.js' , url : 'https://momentjs.com/downloads/moment.min.js' , 'https://unpkg.com/vuefire/dist/vuefire.js' , 'https://unpkg.com/vue@2.4.2/dist/vue.js' , // 'http://127.0.0.1:8080/src/modules/tribute.min.js', // 'http://127.0.0.1:8080/dist/wf-firebase.js'", "commit_type": "add"}
{"commit_tokens": ["remove", "lodash", ".", "isequal", "(", "performance", "bottleneck", ")"], "add_tokens": "layer . dataChanged = matchingLayer . data . length !== layer . data . length ; // TODO remove, currently set for debugging layer . dataChanged = true ; matchingLayer . width !== layer . width || matchingLayer . height !== layer . height || matchingLayer . latitude !== layer . latitude || matchingLayer . longitude !== layer . longitude || matchingLayer . zoom !== layer . zoom ;", "del_tokens": "import isEqual from 'lodash.isequal' ; // TODO, remove || true, currently set for debugging layer . dataChanged = ! isEqual ( matchingLayer . data , layer . data ) || true ; ! isEqual ( matchingLayer . width , layer . width ) || ! isEqual ( matchingLayer . height , layer . height ) || ! isEqual ( matchingLayer . latitude , layer . latitude ) || ! isEqual ( matchingLayer . longitude , layer . longitude ) || ! isEqual ( matchingLayer . zoom , layer . zoom ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "React", "Transform", "for", "Webpack", "HMR", "instead", "of", "React", "Hot", "Loader"], "add_tokens": "loaders : [ { test : / \\.js$ / , exclude : / node_modules / , loader : 'babel' , query : { stage : 0 , plugins : [ ] } } ] config . module . loaders [ 0 ] . query . plugins . push ( 'react-transform' ) ; config . module . loaders [ 0 ] . query . extra = { 'react-transform' : [ { target : 'react-transform-webpack-hmr' , imports : [ 'react-native' ] , locals : [ 'module' ] } ] } ;", "del_tokens": "loaders : [ { test : / \\.js$ / , exclude : / node_modules / , loaders : [ 'babel?stage=0&blacklist=validation.react' ] } , ] ,", "commit_type": "add"}
{"commit_tokens": ["add", "conditional", "around", "module", ".", "export"], "add_tokens": "if ( typeof module != 'undefined' && module . exports ) { module . exports = GraphemeSplitter ; }", "del_tokens": "module . exports = GraphemeSplitter", "commit_type": "add"}
{"commit_tokens": ["Added", "check", "for", "Google", "Maps", "API"], "add_tokens": "/ *! jQuery Google Maps Store Locator - v2.1.0 - 2015-10-23 // Only allow for one instantiation of this script and make sure Google Maps API is included if ( typeof $ . fn [ pluginName ] !== 'undefined' || typeof google === 'undefined' ) {", "del_tokens": "/ *! jQuery Google Maps Store Locator - v2.1.0 - 2015-09-20 // Only allow for one instantiation of this script if ( typeof $ . fn [ pluginName ] !== 'undefined' ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "path", "formatting", "for", "default", "actions", "on", "resources"], "add_tokens": "action = typeof actionDefinition . apiCall === 'undefined' ? actionDefinition : actionDefinition . apiCall , console . log ( this . resourceName + ' ' + action ) ; console . dir ( action ) ;", "del_tokens": "action = actionDefinition . apiCall || actionDefinition ,", "commit_type": "fix"}
{"commit_tokens": ["add", "break", "statements", "to", "case", "blocks"], "add_tokens": "const caseBlock = block . expressions . map ( ( expr ) => mapStatement ( expr , meta ) ) ; // test is null if this switchcase is of type 'default' // in which case we won't add a breakstatement if ( test !== null ) { caseBlock . push ( b . breakStatement ( ) ) ; } caseBlock", "del_tokens": "block . expressions . map ( ( expr ) => mapStatement ( expr , meta ) )", "commit_type": "add"}
{"commit_tokens": ["Use", "shared", "discover", "in", "http", "as", "well"], "add_tokens": "var sharedDiscover = require ( './discover.js' ) ; sharedDiscover ( body , callback ) ;", "del_tokens": "var refs = { } ; var caps = null ; body . read ( onLine ) ; function onLine ( err , line ) { if ( err ) return callback ( err ) ; if ( line === null ) { return callback ( null , { refs : refs , caps : caps } ) ; } line = line . trim ( ) ; if ( ! caps ) line = pullCaps ( line ) ; var index = line . indexOf ( \" \" ) ; refs [ line . substr ( index + 1 ) ] = line . substr ( 0 , index ) ; body . read ( onLine ) ; } function pullCaps ( line ) { var index = line . indexOf ( \"\\0\" ) ; caps = { } ; line . substr ( index + 1 ) . split ( \" \" ) . map ( function ( cap ) { var pair = cap . split ( \"=\" ) ; caps [ pair [ 0 ] ] = pair [ 1 ] || true ; } ) ; return line . substr ( 0 , index ) ; }", "commit_type": "use"}
{"commit_tokens": ["Use", "defineProperty", "for", "_functions", "too"], "add_tokens": "Object . defineProperty ( this , \"_functions\" , { \"value\" : { } , \"writable\" : true } ) ;", "del_tokens": "this . _functions = { } ;", "commit_type": "use"}
{"commit_tokens": ["allow", "modal", "options", "(", "-", "h", "-", "v", ")", "to", "ignore", "-", "d"], "add_tokens": "required = [ ] , modal = false ; if ( options [ option . option ] . modal ) { modal = true ; } if ( ! modal ) { required . forEach ( function ( option ) { if ( ! args [ option ] || ! args [ option ] . value ) { console . log ( \"Must specify a value for option %s (%s : %s)\" , option , options [ option ] . long , options [ option ] . desc ) ; info . help ( ) ; process . exit ( 1 ) ; } } ) ; }", "del_tokens": "required = [ ] ; } required . forEach ( function ( option ) { if ( ! args [ option ] || ! args [ option ] . value ) { console . log ( \"Must specify a value for option %s (%s : %s)\" , option , options [ option ] . long , options [ option ] . desc ) ; info . help ( ) ; process . exit ( 1 ) ; } ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "middleware", "and", "request", "level", "response", "handlers"], "add_tokens": "import { apiMiddleware , createMiddleware } from './middleware' ; createMiddleware ,", "del_tokens": "import { apiMiddleware } from './middleware' ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "base64", "import", "for", "authorization", "header"], "add_tokens": "var base64 = require ( 'js-base64' ) . Base64 ;", "del_tokens": "var base64 = require ( 'js-base64' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "optional", "callback", "to", "randomBytes"], "add_tokens": "randomBytes : function ( length , cb ) { if ( cb ) { reqQueue . fetchBuffers ( function ( u8 ) { var tmp = new Buffer ( u8 . length ) ; for ( let k in u8 ) { tmp . writeUInt8 ( u8 [ k ] , k ) ; } ; cb ( tmp ) ; } ) ; } else { var u8 = reqQueue . getBuffer ( ) ; var retbuf = new Buffer ( u8 . length ) ; for ( let k in u8 ) { retbuf . writeUInt8 ( u8 [ k ] , k ) ; } return retbuf ;", "del_tokens": "randomBytes : function ( length ) { var retbuf = null ; var u8 = reqQueue . getBuffer ( ) ; retbuf = new Buffer ( u8 . length ) ; for ( let k in u8 ) { retbuf . writeUInt8 ( u8 [ k ] , k ) ; return retbuf ;", "commit_type": "add"}
{"commit_tokens": ["Add", "file", "path", "to", "the", "error", "message"], "add_tokens": "var err = new gutil . PluginError ( pluginName , \"This plugin requires buffered files (\" . concat ( file . path , \").\" ) ) ;", "del_tokens": "var err = new gutil . PluginError ( pluginName , \"This plugin requires buffered files\" , { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "in", "generated", "onChange", "handlers"], "add_tokens": "import { addUrlProps , UrlQueryParamTypes } from 'react-url-query' ; } ; // change handlers are automatically generated and passed if a config is provided // and `addChangeHandlers` isn't false. They use `replaceIn` by default, just // updating that single query parameter and keeping the other existing ones. onChangeFoo : PropTypes . func , onChangeBar : PropTypes . func , const { foo , bar , onChangeFoo , onChangeBar } = this . props ; < button onClick = { ( ) => onChangeFoo ( Math . round ( Math . random ( ) * 1000 ) ) } > < button onClick = { ( ) => onChangeBar ( Math . random ( ) . toString ( 32 ) . substring ( 8 ) ) } >", "del_tokens": "import { encode , addUrlProps , UrlQueryParamTypes , replaceInUrlQuery } from 'react-url-query' ; } onChangeFoo ( foo ) { // update the URL with the new encoded value replaceInUrlQuery ( 'fooInUrl' , encode ( UrlQueryParamTypes . number , foo ) ) ; } onChangeBar ( bar ) { // update the URL with the new encoded value replaceInUrlQuery ( 'bar' , bar ) ; } const { foo , bar } = this . props ; < button onClick = { ( ) => this . onChangeFoo ( Math . round ( Math . random ( ) * 1000 ) ) } > < button onClick = { ( ) => this . onChangeBar ( Math . random ( ) . toString ( 32 ) . substring ( 8 ) ) } >", "commit_type": "add"}
{"commit_tokens": ["Update", "Chart", ".", "Core", ".", "js"], "add_tokens": "* Copyright 2015 Nick Downie", "del_tokens": "* Copyright 2014 Nick Downie", "commit_type": "update"}
{"commit_tokens": ["use", "performance", ".", "now", "for", "timing", "when", "possible"], "add_tokens": "var Time = require ( './time' ) ; this . _time = Time . now ( ) ; var time = ( Time . now ( ) - this . _time ) / 1000 ;", "del_tokens": "this . _time = Date . now ( ) ; var time = ( Date . now ( ) - this . _time ) / 1000 ;", "commit_type": "use"}
{"commit_tokens": ["Fixed", "View", "to", "return", "first", "child", "when", "getSizedNode", "called", "and", "children", ".", "length", "is", "more", "than", "1"], "add_tokens": "if ( ! this . node || this . _children . length === 0 )", "del_tokens": "if ( ! this . node || this . _children . length !== 1 )", "commit_type": "fix"}
{"commit_tokens": ["Move", "packfile", "parsing", "to", "it", "s", "own", "module"], "add_tokens": "var applyDelta = require ( 'git-pack-codec/apply-delta.js' ) ( platform ) ; var parse = pushToPull ( require ( 'git-pack-codec/decode.js' ) ( platform ) ) ;", "del_tokens": "var applyDelta = require ( './lib/apply-delta.js' ) ( platform ) ; var parse = pushToPull ( require ( './lib/parse-pack.js' ) ( platform ) ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "__c", "variable", "escaping", "to", "global", "scope"], "add_tokens": "var __c = locals . __contents || { } ;", "del_tokens": "__c = locals . __contents || { } ;", "commit_type": "fix"}
{"commit_tokens": ["add", "utility", "function", "information", "to", "README", "only", "load", "css", "files", "with", "loadcss", "option"], "add_tokens": "// only load css files if ( options . loadcss && path . extname ( file ) === '.css' ) {", "del_tokens": "if ( options . loadcss ) {", "commit_type": "add"}
{"commit_tokens": ["fixed", "issues", "with", "caching", "on", "auth", "enabled", "channels", "angular", "client", "will", "have", "to", "wait", "until", "later", "this", "evening"], "add_tokens": "if ( attr . rpcAuth ) { var authGetter = $rpc . auth [ attr . rpcAuth ] ; if ( typeof authGetter !== 'function' ) { throw new Error ( 'no auth getter function found under ' + attr . rpcAuth ) ; } } var authCallResult = authGetter ( ) ; var promise = $q . all ( $rpc . loadChannel ( attr . rpcChannel ) , $q . when ( authCallResult ) ) ;", "del_tokens": "var promise = $rpc . loadChannel ( attr . rpcChannel ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "a", "flow", "after", "upload", "file", "success"], "add_tokens": "owner . request ( 'after-send-file' , [ file , ret , headers ] , function ( ) { file . setStatus ( Status . COMPLETE ) ; owner . trigger ( 'uploadComplete' , file ) ; tr . destroy ( ) ; } ) . fail ( function ( reason ) { tr . trigger ( 'error' , reason ) ; } ) ;", "del_tokens": "file . setStatus ( Status . COMPLETE ) ; owner . trigger ( 'uploadComplete' , file ) ; tr . destroy ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "nested", "elements", "inside", "lists"], "add_tokens": "pos = state . bMarks [ startLine ] + state . tShift [ startLine ] , max = state . eMarks [ startLine ] ;", "del_tokens": "pos = state . bMarks [ startLine ] , max = state . eMarks [ startLine ] , offset = state . tShift [ startLine ] ; if ( offset > 3 ) { return false ; } pos += offset ;", "commit_type": "fix"}
{"commit_tokens": ["make", "Component", "methods", "not", "enumerable"], "add_tokens": "function defineProps ( target , properties ) { for ( var prop in properties ) { if ( properties . hasOwnProperty ( prop ) ) { Object . defineProperty ( target , prop , { value : properties [ prop ] , enumerable : false , configurable : true , writable : true } ) ; } } } defineProps ( Component . prototype , {", "del_tokens": "var assign = require ( 'react/lib/Object.assign' ) ; assign ( Component . prototype , {", "commit_type": "make"}
{"commit_tokens": ["Implemented", "the", "Disconnect", "when", "Client", "TCP", "/", "IP", "socket", "is", "closed", "."], "add_tokens": "var clientConnectTrials ; / * //fixing ECONNREFUSED when request socket for some reason is not ready if ( clientConnectTrials < 2 ) { clientConnectTrials = clientConnectTrials + 1 ; startClientSocket ( port , tmpAddress ) ; } * / clientConnectTrials = 0 ; if ( clientSocket != 0 ) { console . log ( \"Disconnect clientSocket now.\" ) ; clientSocket . end ( ) ; clientSocket = 0 ; } / * // debug time I use \"\" as peer address, it disconnects all } ) ; * /", "del_tokens": "// debug time I use \"\" as peer address, it disconnects al } ) ;", "commit_type": "implement"}
{"commit_tokens": ["Add", "abort", "()", "to", "cursor"], "add_tokens": "it ( 'should ends immediate when aborted' , function ( done ) { client . execute ( 'SELECT * FROM client_test' , { pageSize : 20 } , function ( err , rs ) { var count = 0 ; if ( err ) { return done ( err ) ; } var cursor = rs . cursor ( ) ; cursor . on ( 'row' , function ( ) { count ++ ; if ( count === 25 ) { cursor . abort ( ) ; } } ) ; cursor . on ( 'end' , function ( ) { expect ( count ) . to . eql ( 25 ) ; done ( ) ; } ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["move", "isTransient", "()", "and", "asPersistent", "()", "to", "Sequence", "and", "improve", "equality", "checking"], "add_tokens": "// TODO: ensure Map has same owner? Does it matter? Set . prototype . toSet = function ( ) { \"use strict\" ; // Note: identical impl to Map.toMap return this . isTransient ( ) ? this . clone ( ) . asPersistent ( ) : this ; } ;", "del_tokens": "// TODO: ensure same owner.", "commit_type": "move"}
{"commit_tokens": ["add", "alt", "title", "to", "images"], "add_tokens": "var id , cssClass , src , target , link , alt , title ; alt = hashedit . current . node . getAttribute ( 'alt' ) || '' ; title = hashedit . current . node . getAttribute ( 'title' ) || '' ; document . getElementById ( 'hashedit-image-alt' ) . value = alt ; document . getElementById ( 'hashedit-image-title' ) . value = title ;", "del_tokens": "console . log ( hashedit . current . node ) ; console var id , cssClass , src , target , link ; target = hashedit . current . node . getAttribute ( 'target' ) || '' ; document . getElementById ( 'hashedit-image-target' ) . value = target ;", "commit_type": "add"}
{"commit_tokens": ["Use", "different", "read", "-", "line", "library"], "add_tokens": "var byline = require ( 'byline' ) ; var stream = byline ( fs . createReadStream ( objFile , { encoding : 'utf8' } ) ) ; stream . on ( 'data' , function ( line ) { stream . on ( 'end' , function ( ) { var stream = byline ( fs . createReadStream ( objFile , { encoding : 'utf8' } ) ) ; stream . on ( 'data' , function ( line ) { stream . on ( 'end' , function ( ) {", "del_tokens": "var readline = require ( 'readline' ) ; var stream = fs . createReadStream ( objFile , 'utf8' ) ; var reader = readline . createInterface ( { input : stream } ) ; reader . on ( 'line' , function ( line ) { reader . on ( 'close' , function ( ) { var stream = fs . createReadStream ( objFile , 'utf8' ) ; var reader = readline . createInterface ( { input : stream } ) ; reader . on ( 'line' , function ( line ) { reader . on ( 'close' , function ( ) {", "commit_type": "use"}
{"commit_tokens": ["Remove", "only", "in", "test", "case"], "add_tokens": "describe ( 'getAllPaths test propane' , function ( ) {", "del_tokens": "describe . only ( 'getAllPaths test propane' , function ( ) {", "commit_type": "remove"}
{"commit_tokens": ["use", "instanceof", "for", "type", "matching", "for", "now"], "add_tokens": "function isConstant ( object ) { return object instanceof REGLFlowConstant } function isArc ( object ) { return object instanceof REGLFlowArc } function isNode ( object ) { return object instanceof REGLFlowNode } function createFlowClass ( options ) { if ( isArc ( input ) ) { return input } else if ( typeof input === 'function' ) { if ( isNode ( input . node ) ) { module . exports = { isConstant : isConstant , isArc : isArc , isNode : isNode , createClass : createFlowClass }", "del_tokens": "function className ( object ) { return Object . prototype . toString . call ( object ) } module . exports = function createFlowClass ( options ) { switch ( className ( input ) ) { case '[object REGLFlowArc]' : return input } if ( typeof input === 'function' ) { if ( className ( input . node ) === '[object REGLFlowNode]' ) {", "commit_type": "use"}
{"commit_tokens": ["remove", "old", "window", ".", "onresize", "listeners", "when", "redrawing", "or", "destroying", "the", "chart"], "add_tokens": "// Remove onresize listeners of the old chart // window . onresize = null ; // Registers a $destroy listeners for cleanup purposes // scope . registerDestroyListener = function ( ) { element . on ( '$destroy' , function ( ) { scope . chart . destroy ( ) ; } ) ; } ; scope . registerDestroyListener ( ) ;", "del_tokens": "", "commit_type": "remove"}
{"commit_tokens": ["Add", "clone", "method", "for", "object", "cloning"], "add_tokens": "let state = clone ( defaultState ) ; state = clone ( newState || defaultState ) ; / ** * Deep clone object to break references * / function clone ( obj ) { return JSON . parse ( JSON . stringify ( obj ) ) ; }", "del_tokens": "let state = JSON . parse ( JSON . stringify ( defaultState ) ) ; // Deep clone the default state state = JSON . parse ( JSON . stringify ( newState || defaultState ) ) ;", "commit_type": "add"}
{"commit_tokens": ["improved", "dependency", "injection", "for", "view"], "add_tokens": "this . _renderer = config . renderer ; this . _uid = config . uid ; this . _compiled [ name ] = this . _renderer . compile ( this . _template [ name ] ) ;", "del_tokens": "// internal libs import uuid from '../helpers/uuid' ; // external libs import Handlebars from 'handlebars' ; this . _init ( ) ; _init ( ) { this . _uid = uuid ( ) ; } this . _compiled [ name ] = Handlebars . compile ( this . _template [ name ] ) ;", "commit_type": "improve"}
{"commit_tokens": ["removing", "request", "and", "request", "promise", "dependencies"], "add_tokens": "googleTrends . interestOverTime ( { keyword : 'Valentines Day' } ) . then ( ( res ) => { console . log ( 'this is res' , res ) ; } ) . catch ( ( err ) => { console . log ( 'got the error' , err ) ; } )", "del_tokens": "// googleTrends.interestOverTime({keyword: 'Valentines Day'}) // .then((res) => { // console.log('this is res', res); // }) // .catch((err) => { // console.log('got the error', err); // })", "commit_type": "remove"}
{"commit_tokens": ["Allow", "Items#get", "()", "to", "receive", "a", "negative", "index"], "add_tokens": "* Get the item at a given index . Can be negative . if ( index < 0 ) { index = this . length + index ; }", "del_tokens": "* Get the item at a given index", "commit_type": "allow"}
{"commit_tokens": ["add", "lambda", "function", "full", "access", "to", "the", "create", "iam", "user", "url", "deep", "link"], "add_tokens": "\"https://console.aws.amazon.com/iam/home?region=us-east-1#/users$new?step=review&accessKey&userNames=AWSMobileCLI&permissionType=policies&policies=arn:aws:iam::aws:policy%2FAWSMobileHub_FullAccess&policies=arn:aws:iam::aws:policy%2FAWSDeviceFarmFullAccess&policies=arn:aws:iam::aws:policy%2FAWSLambdaFullAccess&policies=arn:aws:iam::aws:policy%2FIAMReadOnlyAccess\"", "del_tokens": "\"https://console.aws.amazon.com/iam/home?region=us-east-1#/users$new?step=review&accessKey&userNames=AWSMobileCLI&permissionType=policies&policies=arn:aws:iam::aws:policy%2FAWSMobileHub_FullAccess&policies=arn:aws:iam::aws:policy%2FAWSDeviceFarmFullAccess&policies=arn:aws:iam::aws:policy%2FIAMReadOnlyAccess\"", "commit_type": "add"}
{"commit_tokens": ["Made", "sure", "this", "is", "correct", "in", "added", "/", "removed", "and", "added", "documentation"], "add_tokens": "this . outsideProp = true ; } , outsideProp : { type : \"boolean\" , value : false ok ( people . outsideProp , \"people was passed to added\" ) ;", "del_tokens": "", "commit_type": "make"}
{"commit_tokens": ["use", "strict", "inequality", "in", "property", "setter"], "add_tokens": "if ( oldValue !== newValue ) {", "del_tokens": "if ( oldValue != newValue ) {", "commit_type": "use"}
{"commit_tokens": ["removed", "socket", "objects", "from", "library", "registration", "for", "message", "handling", "should", "be", "done", "outside"], "add_tokens": "Call . prototype . join = function ( userId , sendMessageCallback , sessionId , userRegistry ) { var participant = new UserSession ( userId , this , sendMessageCallback ,", "del_tokens": "Call . prototype . join = function ( userId , wsSession , sessionId , userRegistry ) { var participant = new UserSession ( userId , this , wsSession ,", "commit_type": "remove"}
{"commit_tokens": ["Updated", "template", "and", "partials", "to", "draw", "a", "more", "readble", "version", "of", "the", "swagger", "-", "models", ".", "Labels", "are", "now", "all", "in", "LESS"], "add_tokens": "\"swagger-to-html\" : path . join ( __dirname , \"..\" , \"templates\" , \"partials\" ) , \"json-schema\" : path . join ( __dirname , \"..\" , \"templates\" , \"partials-json-schema\" ) require . resolve ( \"../styles/json-schema.less\" ) , require . resolve ( \"../styles/json-schema-labels.less\" ) , require . resolve ( \"../styles/swagger-to-html.less\" ) , require . resolve ( \"../styles/swagger-to-html-labels.less\" )", "del_tokens": "\"swagger-to-html\" : path . join ( __dirname , \"..\" , \"templates\" , \"partials\" ) require . resolve ( \"../styles/base-theme.less\" )", "commit_type": "update"}
{"commit_tokens": ["Remove", "hard", "coded", "inv", "bind", "matrix"], "add_tokens": "// var mat4Multiply = require('gl-mat4/multiply') / * * / // mat4Multiply(currentJointMatrix, invBinds[count], currentJointMatrix)", "del_tokens": "var mat4Multiply = require ( 'gl-mat4/multiply' ) mat4Multiply ( currentJointMatrix , invBinds [ count ] , currentJointMatrix ) // TODO: get rid of this. pass in matrices via code count ++", "commit_type": "remove"}
{"commit_tokens": ["Added", "option", "to", "override", "args", "passed", "via", "resolve"], "add_tokens": "* @ param { Boolean } [ resolveArgs = null ] Optional parameters that will override * the arguments passed to resolve ( ) , irrespective of what * was passed via the callback . getResolver : function ( def , resolveArgs ) { if ( resolveArgs ) { def . resolve ( resolveArgs ) ; } else { var args = Array . prototype . slice . call ( arguments , 1 ) ; def . resolve . apply ( def , args ) ; }", "del_tokens": "getResolver : function ( def ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; def . resolve . apply ( def , args ) ;", "commit_type": "add"}
{"commit_tokens": ["improve", "install", "/", "uninstall", "app", "/", "plugin", "commands", "to", "rely", "on", "app", "name", "and", "avoid", "twice", "installation"], "add_tokens": "( 'hello' ) . should . eql ( config . apps [ 'hello' ] . name ) ; ( 'test-plugin' ) . should . eql ( config . plugins [ 'test-plugin' ] . name ) ; var app = 'hello' ; var plugin = 'test-plugin' ; var app = 'hello' ; var plugin = 'test-plugin' ; var app = 'hello' ; var testPlugin = 'test-plugin' ;", "del_tokens": "( 'hello' ) . should . eql ( config . apps [ app ] . name ) ; ( 'test-plugin' ) . should . eql ( config . plugins [ testPlugin ] . name ) ; var app = 'cozy-labs/hello' ; var plugin = pathExtra . join ( fixturesDir , 'test-plugin' ) ; var app = 'cozy-labs/hello' ; var plugin = pathExtra . join ( fixturesDir , 'test-plugin' ) ; var app = 'cozy-labs/hello' ; var testPlugin = pathExtra . join ( fixturesDir , 'test-plugin' ) ;", "commit_type": "improve"}
{"commit_tokens": ["Change", "to", "the", "API", "for", "collecting", "data"], "add_tokens": "getContent : function ( path , cb ) { // Set the content path octofish . setContentPath ( path ) ; // Use the content path to retrieve content var data = null ; // Log the error - not a very useful log at the moment console . log ( 'It is most likely a URL error with the path' ) ; // Call the callback with a null value to denote an error cb ( data ) ; // If the content was collected successfully then call the callback and remember to pass in the data // Register the config object that was collected from octo-config.js } , / ** * setPath * sets the path for retrieving a file from github * @ param path * / setContentPath : function ( path ) { octofish . config . githubapi . contentOpts . path = path ;", "del_tokens": "getContent : function ( cb ) { console . log ( 'Should be displaying a 404 here as the URL is probably invalid' ) ; var data = null ; // If the operation to get content from github was successful then call the callback with only the content // This file should actually handle what happens next but for now delegate to a callback } , / ** * setPath * sets the path for retrieving a file from github * @ param path * / setContentPath : function ( path ) { octofish . config . githubapi . contentOpts . path = path ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "for", "default", "headers", "and", "payload", "options"], "add_tokens": "// // This needs to be fixed up. // headers : { } , timeout : 10 * 1000 //debug('json', requestParams.json); //debug('body', requestParams.body); if ( config . defaults && config . defaults . headers ) { requestParams . headers = _ . extend ( _ . cloneDeep ( config . defaults . headers || { } ) , params . headers || { } ) ; }", "del_tokens": "function areWeFinishedYet ( ee ) { if ( Stats . pendingScenarios . toJSON ( ) === 0 ) { ee . emit ( 'done' , Stats ) ; } else { debugStats ( 'Pending requests: ' , Stats . pendingRequests . toJSON ( ) ) ; debugStats ( 'Pending scenarios: ' , Stats . pendingScenarios . toJSON ( ) ) ; } } // TODO: Presuming target doesn't have a trailing slash. headers : { } debug ( 'json' , requestParams . json ) ; debug ( 'body' , requestParams . body ) ; requestParams . headers = _ . extend ( _ . cloneDeep ( config . defaults . headers || { } ) , params . headers || { } ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "issue", "where", "first", "worksheet", "of", "workbook", "did", "not", "allow", "for", "feature", "edits", "(", "sorting", "grouping", "etc", ")", "if", "more", "than", "one", "worksheet", "existed", "."], "add_tokens": "//'@tabSelected':1,", "del_tokens": "'@tabSelected' : 1 ,", "commit_type": "fix"}
{"commit_tokens": ["fixed", "require", "statement", "filename", "letter", "case"], "add_tokens": "var upgradeFragmentShaderToHaveFakeHDRIOutput = require ( './upgradeFragmentShaderToHaveFakeHdriOutput' ) ;", "del_tokens": "var upgradeFragmentShaderToHaveFakeHDRIOutput = require ( './upgradeFragmentShaderToHaveFakeHDRIOutput' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "onValid", "and", "transistion", "time"], "add_tokens": "var { field , onValueChange , template , onValidate , ... props } = this . props ; < Template field = { rfield } { ... props } fieldClass = { fieldClass } title = { title }", "del_tokens": "var { field , onValueChange , onValid , template , onValidate , ... props } = this . props ; < Template field = { rfield } { ... props } onValid = { onValid } fieldClass = { fieldClass } title = { title }", "commit_type": "fix"}
{"commit_tokens": ["Allow", "using", "length", "equal", "to", "0"], "add_tokens": "options = options || { } ; length : typeof options . length === 'number' ? options . length : defaultLength , template : options . template || defaultTemplate , chars : ( options . chars || defaultChars ) . slice ( ) if ( options . args ) {", "del_tokens": "length : options && options . length || defaultLength , template : options && options . template || defaultTemplate , chars : ( options && options . chars || defaultChars ) . slice ( ) if ( options && options . args ) {", "commit_type": "allow"}
{"commit_tokens": ["add", "line", "wrap", "to", "long", "comments"], "add_tokens": "// if `options.extension` equals \".html\": // `{{> ./path/to/partial }}` => `{{> ./path/to/partial.html }}` // when `options.extension` is not a string or // `partialName + options.extension` does not exists. // try use `.mustache` extension to load `partial` file. // use `ex.message` property instead of `partialPath`, // because `this.emit()` seems not a sync method. // also the `ex.message` property provide more details // about error information.", "del_tokens": "// if `options.extension` equals \".html\": `{{> ./path/to/partial }}` => `{{> ./path/to/partial.html }}` // when `options.extension` is not a string or `partialName + options.extension` // does not exists. try use `.mustache` extension to load `partial` file. // use `ex.message` property instead of `partialPath`, because `this.emit()` seems not a sync method. // also the `ex.message` property provide more details about error information.", "commit_type": "add"}
{"commit_tokens": ["Added", "wrap", "around", "for", "full", "songs"], "add_tokens": "var symbols = getSymbolsFromChordList ( j . fullChordList ( ) , j . getMainKey ( ) ) ; symbols : symbols . concat ( [ symbols [ 0 ] ] ) // Wrap around for certain turnarounds", "del_tokens": "symbols : getSymbolsFromChordList ( j . fullChordList ( ) , j . getMainKey ( ) )", "commit_type": "add"}
{"commit_tokens": ["Use", "proper", "DNS", "equality", "when", "probing"], "add_tokens": "var dnsEqual = require ( 'dns-equal' ) return dnsEqual ( rr . name , service . fqdn )", "del_tokens": "return rr . name === service . fqdn", "commit_type": "use"}
{"commit_tokens": ["Add", "support", "for", "monitoring", "http"], "add_tokens": "function API ( agent , appmetrics ) { this . appmetrics = appmetrics ; module . exports . getAPI = function ( agent , appmetrics ) { return new API ( agent , appmetrics ) ; that . appmetrics . enable ( data ) ; that . appmetrics . disable ( data ) ;", "del_tokens": "function API ( agent ) { module . exports . getAPI = function ( agent ) { return new API ( agent ) ; if ( data == 'profiling' ) that . agent . sendControlCommand ( \"profiling_node\" , \"on,profiling_node_subsystem\" ) ; if ( data == 'profiling' ) that . agent . sendControlCommand ( \"profiling_node\" , \"off,profiling_node_subsystem\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "fully", "qualified", "domains", "(", "trailing", "dot", "in", "domain", "name", ")"], "add_tokens": "function ltrim ( value ) { return String ( value ) . replace ( / ^\\s+ / g , '' ) ; } function rtrim ( value ) { return String ( value ) . replace ( / [.]+$ / g , '' ) ; value = ltrim ( value ) . toLowerCase ( ) ; if ( parts . hostname && ! invalidHostnameChars . test ( parts . hostname ) ) { return rtrim ( parts . hostname ) ; } if ( ! invalidHostnameChars . test ( value ) ) { return rtrim ( value ) ; }", "del_tokens": "function trim ( value ) { return String ( value ) . replace ( / (^\\s+|\\s+$) / g , '' ) ; value = trim ( value ) . toLowerCase ( ) ; if ( parts . hostname && ! invalidHostnameChars . test ( parts . hostname ) ) { return parts . hostname ; } if ( ! invalidHostnameChars . test ( value ) ) { return value ; }", "commit_type": "add"}
{"commit_tokens": ["changed", "Backbone", ".", "LayoutManager", ".", "View", "to", "just", "be", "a", "Backbone", ".", "View"], "add_tokens": "Backbone . LayoutManager . View = Backbone . View ;", "del_tokens": "Backbone . LayoutManager . View = LayoutManager ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "bug", "in", "reading", "location", "from", "history"], "add_tokens": "const { history } = urlQueryOptions ;", "del_tokens": "const { history } = urlQueryOptions . history ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "append", "prepend", "before", "and", "after", "methods"], "add_tokens": "children . each ( function ( index , child ) { children . each ( function ( index , child ) { siblings . each ( function ( index , sibling ) { siblings . each ( function ( index , sibling ) {", "del_tokens": "children . each ( function ( child ) { children . each ( function ( child ) { siblings . each ( function ( sibling ) { siblings . each ( function ( sibling ) {", "commit_type": "fix"}
{"commit_tokens": ["added", "support", "for", "afterTime", "and", "beforeTime", "constraints"], "add_tokens": "describe ( 'before time' , function ( ) { it ( 'should store a single before time constraint' , function ( ) { var r = recur ( ) . beforeTime ( '08:30:00' ) ; r . schedules [ 0 ] . tb . should . eql ( [ '08:30:00' ] ) ; } ) ; it ( 'should store multiple before time constraints' , function ( ) { var r = recur ( ) . beforeTime ( '08:30' , '10:30:00' ) ; r . schedules [ 0 ] . tb . should . eql ( [ '08:30:00' , '10:30:00' ] ) ; } ) ; } ) ; describe ( 'after time' , function ( ) { it ( 'should store a single after time constraint' , function ( ) { var r = recur ( ) . afterTime ( '08:30:00' ) ; r . schedules [ 0 ] . ta . should . eql ( [ '08:30:00' ] ) ; } ) ; it ( 'should store multiple after time constraints' , function ( ) { var r = recur ( ) . afterTime ( '08:30' , '10:30:00' ) ; r . schedules [ 0 ] . ta . should . eql ( [ '08:30:00' , '10:30:00' ] ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Removed", "deprecated", "rollup", "hooks", "."], "add_tokens": "generateBundle : async ( ) => { console . log ( colors . yellow ( ` ${ from } ${ to } \\n ` , ex . message ) ) ;", "del_tokens": "async ongenerate ( ) { console . log ( colors . yellow ( ` ${ from } ${ to } \\n ` , ex ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Move", "resolve", "page", "id", "from", "partials", "to", "template"], "add_tokens": "var pageId = document . getElementsByTagName ( 'html' ) [ 0 ] . getAttribute ( 'data-page-id' ) ; function getPartInterface ( part , region ) { function createEditButton ( part , region ) { 'data-target-part=' + part + ' data-target-region=' + region + '>' ; var button = createEditButton ( region . getAttribute ( 'data-part' ) , region . getAttribute ( 'data-region' ) ) ; iframe . contentWindow . window . pagespace = getPartInterface ( part , region ) ;", "del_tokens": "function getPartInterface ( part , pageId , region ) { function createEditButton ( part , pageId , region ) { 'data-target-part=' + part + ' data-target-page-id=' + pageId + ' data-target-region=' + region + '>' ; editButton . setAttribute ( 'data-target-page-id' , pageId ) ; var button = createEditButton ( region . getAttribute ( 'data-part' ) , region . getAttribute ( 'data-page-id' ) , region . getAttribute ( 'data-region' ) ) ; var pageId = evSrc . getAttribute ( 'data-target-page-id' ) ; //iframe.src = '/_dashboard/region?pageId=' + encodeURIComponent(pageId) +'&region=' + encodeURIComponent(region); //iframe.contentWindow.window.pagesapce = getPartInterface(part, pageId, region);; iframe . contentWindow . window . pagespace = getPartInterface ( part , pageId , region ) ;", "commit_type": "move"}
{"commit_tokens": ["moved", "robots", ".", "json", "to", "resources", "folder"], "add_tokens": "* Detector detects if the current request is from a search engine robot using the robots . json file * @ param boolean robotsJson Absolute path to a the robots . json file robotsJson = ( robotsJson ) ? robotsJson : __dirname + '/../resources/robots.json' ; * Parses the robots . json file by decoding the JSON and throwing an exception if the decoding went wrong . * @ param string robotsJson Absolute path to robots . json", "del_tokens": "* Detector detects if the current request is from a search engine robot using the Robots . json file * @ param boolean robotsJson Absolute path to a the Robots . json file robotsJson = ( robotsJson ) ? robotsJson : __dirname + '/Robots.json' ; * Parses the Robots . json file by decoding the JSON and throwing an exception if the decoding went wrong . * @ param string robotsJson Absolute path to Robots . json", "commit_type": "move"}
{"commit_tokens": ["use", "merge", "instead", "of", "extend"], "add_tokens": "res = utils . merge ( { } , config , res ) ;", "del_tokens": "res = utils . extend ( { } , config , res ) ;", "commit_type": "use"}
{"commit_tokens": ["Make", "unwrap", "return", "the", "chilren", "that", "were", "unwrapped", "."], "add_tokens": "var $ = require ( \"jquery\" ) ; var children = [ ] ; else { children = Array . prototype . slice . call ( node . childNodes ) ; } return children ;", "del_tokens": "else", "commit_type": "make"}
{"commit_tokens": ["Move", "prettier", "config", "into", "dedicated", "file", "so", "vscode", "plugins", "pick", "it", "up"], "add_tokens": "'self/prettier' : [ 'error' ] ,", "del_tokens": "'self/prettier' : [ 'error' , { singleQuote : true } ] ,", "commit_type": "move"}
{"commit_tokens": ["Update", "to", "the", "latest", "es6", "-", "module", "-", "transpiler", "release", "."], "add_tokens": "formatter : 'bundle'", "del_tokens": "formatter : 'export-variable'", "commit_type": "update"}
{"commit_tokens": ["Use", "grunt", "to", "register", "and", "run", "tasks", "add", "local", "and", "remote", "methods", "."], "add_tokens": "shipit . runTask ( tasks ) ;", "del_tokens": "shipit . runTasks ( tasks ) ;", "commit_type": "use"}
{"commit_tokens": ["Use", "Promise", "API", "instead", "of", "Q", "API"], "add_tokens": "var Promise = require ( 'q' ) ; return Promise . resolve ( ) . then ( function ( ) { . catch ( function ( err ) {", "del_tokens": "var Q = require ( 'q' ) ; return Q . fcall ( function ( ) { . fail ( function ( err ) {", "commit_type": "use"}
{"commit_tokens": ["Remove", "raptor", "-", "util", "dependency"], "add_tokens": "const inherit = require ( './util/inherit' ) ;", "del_tokens": "const inherit = require ( 'raptor-util/inherit' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "possibility", "to", "have", "this", "in", "a", "template"], "add_tokens": "return result . call ( this , _ . extend ( { engine : self } , self . _env , data ) ) ;", "del_tokens": "return result ( _ . extend ( { engine : self } , self . _env , data ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "double", "precision", "problems", "of", "test", "cases"], "add_tokens": "expect : \"23.140692632779267i\" expect : \"-0.008876640735623678 - 0.0013801328997494863i\" expect : \"0.1290095940744669 + 0.03392409290517001i\" expect : \"-54.051758861078156 + 7.704891372731154i\" expect : \"3.165778513216168 + 1.9596010414216063i\" expect : \"0.03381282607989669 + 1.0147936161466335i\" expect : \"0.7680176472869112 - 0.059168539566050726i\" expect : \"0.9994481238383576 + 0.0037048958915019857i\" expect : \"1.6636768291213935e-7 - 1.0000001515864902i\" assert . equal ( one . pow ( one ) . toString ( ) , \"0.2739572538301211 + 0.5837007587586147i\" ) ; assert . equal ( one . tan ( ) . toString ( ) , \"0.27175258531951174 + 1.0839233273386948i\" ) ; assert . equal ( t . toString ( ) , \"-9.405287417451663e-14 - 511.9999999999995i\" ) ;", "del_tokens": "expect : \"23.140692632779274i\" expect : \"-0.008876640735623675 - 0.0013801328997494896i\" expect : \"0.12900959407446697 + 0.033924092905170025i\" expect : \"-54.05175886107815 + 7.7048913727311525i\" expect : \"3.1657785132161678 + 1.9596010414216063i\" expect : \"0.0338128260798967 + 1.0147936161466335i\" expect : \"0.7680176472869114 - 0.05916853956605073i\" expect : \"0.9994481238383571 + 0.0037048958915019844i\" expect : \"1.663676829121394e-7 - 1.0000001515864905i\" assert . equal ( one . pow ( one ) . toString ( ) , \"0.27395725383012104 + 0.5837007587586146i\" ) ; assert . equal ( one . tan ( ) . toString ( ) , \"0.2717525853195118 + 1.0839233273386948i\" ) ; assert . equal ( t . toString ( ) , \"-9.405287417451663e-14 - 511.99999999999955i\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "bugs", "related", "to", "the", "user", "field", "."], "add_tokens": "// See if this is a multi-lookup field if ( state . fieldInfo . allowMultiple ) { var results = [ ] ; // Parse the users var users = ( _this . props . defaultValue ? _this . props . defaultValue . results : _this . props . defaultValue ) || [ ] ; for ( var i = 0 ; i < users . length ; i ++ ) { // Add the item id results . push ( users [ i ] . ID || users [ i ] ) ; } // Set the value state . value = { results : results } ; } else { // Set the value state . value = _this . props . defaultValue ? _this . props . defaultValue . ID || _this . props . defaultValue : null ; } React . createElement ( common_1 . SPPeoplePicker , { allowMultiple : this . state . fieldInfo . allowMultiple , fieldValue : this . props . defaultValue ? this . props . defaultValue . results || [ this . props . defaultValue ] : null , props : props , ref : \"user\" } ) ) ) ;", "del_tokens": "state . value = common_1 . SPPeoplePicker . convertToFieldValue ( _this . props . defaultValue ) ; React . createElement ( common_1 . SPPeoplePicker , { allowMultiple : this . state . fieldInfo . allowMultiple , fieldValue : this . state . value , props : props , ref : \"user\" } ) ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "tree", "rearrangement", "and", "refactor", "."], "add_tokens": "var treeBuilder = require ( './tree' ) , tree = treeBuilder . tableToTree ( map ) ; transform = treeBuilder . safeMerge ( tree , 'ZZ' ) ; transform = treeBuilder . findRearrangements ( tree ) ; output = treeBuilder . treeToTable ( transform ) ;", "del_tokens": "var util = require ( './util' ) , tree = util . tableToTree ( map ) ; transform = util . safeMerge ( tree , 'ZZ' ) ; transform = util . findRearrangements ( tree ) ; output = util . treeToTable ( transform ) ;", "commit_type": "add"}
{"commit_tokens": ["changed", "confusing", "directory", "docs", "to", "config", "/", "jsdoc"], "add_tokens": "{ path : './config/jsdoc/template' } , { plugins : [ __dirname + '/config/jsdoc/plugins/angular' ] }", "del_tokens": "{ path : './docs/custom' } , { plugins : [ __dirname + '/docs/custom/plugins/angular' ] }", "commit_type": "change"}
{"commit_tokens": ["Make", ".", "env", "file", "private", "but", "provide", ".", "env", ".", "default"], "add_tokens": "if ( ! process . env . DB_CONNECTION_URL ) { throw new Error ( ` ` ) } return connectTo ( process . env . DB_CONNECTION_URL , createCollections )", "del_tokens": "const storagePath = process . env . DB_SQLITE_STORAGE return connectTo ( ` ${ storagePath } ` , createCollections )", "commit_type": "make"}
{"commit_tokens": ["Fixed", "the", "gulp", "coverage", "task", "."], "add_tokens": "var jshint = require ( 'gulp-jshint' ) ; var tests = [ 'test/unit/containerTest.js' , 'test/unit/semverTest.js' , 'test/unit/sysrevTest.js' , 'test/unit/topologyTest.js' ] return gulp . src ( tests ) . pipe ( mocha ( { reporter : 'list' } ) ) gulp . task ( 'jshint' , function ( ) { return gulp . src ( [ './lib/**/*.js' , './test/**/*.js' ] ) . pipe ( jshint ( ) ) . pipe ( jshint . reporter ( 'default' ) ) ; } ) gulp . task ( 'coverage' , function ( ) { gulp . src ( [ 'lib/**/*.js' ] ) . on ( 'finish' , function ( ) { gulp . src ( tests ) reporter : 'list' } ) ;", "del_tokens": "return gulp . src ( [ 'test/unit/containerTest.js' , 'test/unit/semverTest.js' , 'test/unit/sysrevTest.js' , 'test/unit/topologyTest.js' ] ) . pipe ( mocha ( { reporter : 'list' } ) ) gulp . task ( 'test' , function ( ) { gulp . src ( [ 'lib/**/*.js' , 'main.js' ] ) . on ( 'end' , function ( ) { gulp . src ( [ 'test/**/*.js' ] ) reporter : 'list' } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "per", "feedback", "from", "Dmarcos"], "add_tokens": "var skyColor = this . getAttribute ( 'skyColor' ) || \"#FFFFFF\" ; var groundColor = this . getAttribute ( 'groundColor' ) || \"#FFFFFF\" ;", "del_tokens": "var skyColor = parseFloat ( this . getAttribute ( 'skyColor' ) ) || \"#FFFFFF\" ; var groundColor = parseFloat ( this . getAttribute ( 'groundColor' ) ) || \"#FFFFFF\" ; } , update : { value : function ( ) { }", "commit_type": "update"}
{"commit_tokens": ["Use", "local", "version", "of", "async", "-", "each"], "add_tokens": "var asyncEach = require ( 'async-each' ) ;", "del_tokens": "// bug, see: https://github.com/paulmillr/async-each/issues/2 require ( 'async-each' ) ; var asyncEach = window . asyncEach ;", "commit_type": "use"}
{"commit_tokens": ["Move", "the", "JSONP", "hack", "to", "an", "emit", "-", "optimize", "plugin", "."], "add_tokens": "var ConcatSource = require ( \"webpack/lib/ConcatSource\" ) ; //HACK: changes the JSONP chunk eval function to `global[\"nativescriptJsonp\"]` // applied to tns-java-classes.js only function FixJsonpPlugin ( options ) { } FixJsonpPlugin . prototype . apply = function ( compiler ) { compiler . plugin ( 'compilation' , function ( compilation , params ) { compilation . plugin ( \"optimize-chunk-assets\" , function ( chunks , callback ) { chunks . forEach ( function ( chunk ) { chunk . files . forEach ( function ( file ) { if ( file === \"tns-java-classes.js\" ) { var src = compilation . assets [ file ] ; var code = src . source ( ) ; var match = code . match ( / window\\[\"nativescriptJsonp\"\\] / ) ; if ( match ) { compilation . assets [ file ] = new ConcatSource ( code . replace ( / window\\[\"nativescriptJsonp\"\\] / g , \"global[\\\"nativescriptJsonp\\\"]\" ) ) ; } } } ) ; } ) ; callback ( ) ; } ) ; } ) ; } ; userDefined . context = path . resolve ( \"./app\" ) ; userDefined . plugins . push ( new FixJsonpPlugin ( ) ) ;", "del_tokens": "userDefined . context = \"./app\" ;", "commit_type": "move"}
{"commit_tokens": ["Added", "proper", "prefixfree", "support", "for", "link", "tags"], "add_tokens": "if ( typeof StyleFix !== 'undefined' ) { // Prefixfree support href = cleanHref ( styleSheet . ownerNode . href || styleSheet . ownerNode . getAttribute ( 'data-href' ) ) ; if ( href ) { cssIncludes . push ( { type : 'prefixfree' , href : href , node : styleSheet . ownerNode } ) ; } } if ( cssInclude . type === 'link' ) { cssInclude . node . setAttribute ( 'href' , newHref ) ; } if ( cssInclude . type === 'prefixfree' ) { // The next two lines are hacks to make Prefixfree think this is a link and not a style block cssInclude . node . setAttribute ( 'href' , href ) ; // No cache buster needed cssInclude . node . rel = 'stylesheet' ; StyleFix . link ( cssInclude . node ) ; }", "del_tokens": "} else { cssInclude . node . setAttribute ( 'href' , newHref ) ; if ( typeof StyleFix !== 'undefined' && StyleFix . link ) { // PrefixFree support http://leaverou.github.com/prefixfree/ freed = cssInclude . node . prefixfreed ; StyleFix . link ( cssInclude . node , true ) ; freed . parentNode . removeChild ( freed ) ; }", "commit_type": "add"}
{"commit_tokens": ["fixes", "reference", "to", "old", "JS", "file"], "add_tokens": "/*================ Templates ================*/", "del_tokens": "/*================ Sections ================*/ // =require templates/giftcard.js", "commit_type": "fix"}
{"commit_tokens": ["added", "configurable", "separator", "to", "csv", "export", "(", "useful", "for", "scandinavian", "region", "that", "uses", "semicolons", "rather", "than", "commas", ")"], "add_tokens": "fileName : 'export.csv' , separator : ',' // add separator identifier; str += ` ${ options . separator } \\r \\n ` ; line += options . separator ; line += options . separator ;", "del_tokens": "fileName : 'export.csv' line += ',' ; line += ',' ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "rounding", "of", "target", "duration", "in", "master", "playlist"], "add_tokens": "const longestSegment = Math . round ( findLongestSegment ( segmented ) ) ;", "del_tokens": "const longestSegment = findLongestSegment ( segmented ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "double", "free", "when", "loading", "malformed", "PE", "file"], "add_tokens": "var port = OPT . port || 6667", "del_tokens": "var port = OPT . port || 6697", "commit_type": "fix"}
{"commit_tokens": ["Make", "hotspots", "be", "behind", "controls", "."], "add_tokens": "document . getElementById ( 'container' ) . appendChild ( a ) ; document . getElementById ( 'container' ) . appendChild ( div ) ; document . getElementById ( 'container' ) . appendChild ( div ) ; document . getElementById ( 'container' ) . appendChild ( div ) ; while ( current . parentNode . id != 'container' ) { document . getElementById ( 'container' ) . removeChild ( current ) ;", "del_tokens": "document . getElementById ( 'page' ) . appendChild ( a ) ; document . getElementById ( 'page' ) . appendChild ( div ) ; document . getElementById ( 'page' ) . appendChild ( div ) ; document . getElementById ( 'page' ) . appendChild ( div ) ; while ( current . parentNode . id != 'page' ) { document . getElementById ( 'page' ) . removeChild ( current ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "bug", "where", "null", "cannot", "be", "set", "in", "computed", "object"], "add_tokens": "} else if ( expression && expression . isComputedProperty ) {", "del_tokens": "} else if ( expression . isComputedProperty ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "session", "resave", "and", "saveUninitialized", "to", "config", "and", "changed", "them", "to", "comming", "default", "values", "(", "false", ")"], "add_tokens": "session_resave : false , session_saveUninitialized : false , resave : config . session_resave , saveUninitialized : conf . session_saveUninitialized , app . use ( session ( { secret : 'testing-secret' , resave : config . session_resave , saveUninitialized : config . session_saveUninitialized } ) ) ; resave : config . session_resave , saveUninitialized : config . session_saveUninitialized ,", "del_tokens": "resave : true , saveUninitialized : true , app . use ( session ( { secret : 'testing-secret' , resave : true , saveUninitialized : true } ) ) ; resave : true , saveUninitialized : true ,", "commit_type": "add"}
{"commit_tokens": ["Add", "ability", "to", "import", "states"], "add_tokens": "props . importState ( function ( fieldStates ) { // Check that all types are ok. fieldStates . forEach ( function ( s ) { if ( ! _this . state . fieldTypes . map ( function ( f ) { return f . info . type ; } ) . includes ( s . type ) ) { assert ( false , s . type + ' is not included in field types.' ) ; } } ) ; _this . pushHistoryState ( fieldStates ) ; } ) ; exportState : React . PropTypes . func , importState : React . PropTypes . func var importFunc = void 0 ; } , importState : function importState ( f ) { return importFunc = f ; this . importState = function ( s ) { return importFunc ( s ) ; } ;", "del_tokens": "exportState : React . PropTypes . func", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "an", "alternate", "iPad", "ua", "string"], "add_tokens": "var iVersion = this . getMatchingGroup_ ( this . userAgent_ , / (iPhone )?OS ([\\d_]+) / , 2 ) ; return this . getMatchingGroup_ ( str , regexp , 1 ) ; } ; webfont . UserAgentParser . prototype . getMatchingGroup_ = function ( str , regexp , index ) { if ( groups && groups [ index ] ) { return groups [ index ] ;", "del_tokens": "var iVersion = this . getFirstMatchingGroup_ ( this . userAgent_ , / iPhone OS ([\\d_]+) / ) ; if ( groups && groups [ 1 ] ) { return groups [ 1 ] ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "in", "user", "methods"], "add_tokens": "this . _ref . createUser ( credentials , oc ) ; this . _ref . changePassword ( credentials , oc ) ; this . _ref . resetPassword ( credentials , oc ) ; this . _ref . removeUser ( credentials , oc ) ;", "del_tokens": "this . _ref . createUser ( credentials , onComplete ) ; this . _ref . changePassword ( credentials , onComplete ) ; this . _ref . resetPassword ( credentials , onComplete ) ; this . _ref . removeUser ( credentials , onComplete ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "return", "value", "to", "dantil", ".", "assertTrue", "()"], "add_tokens": "* Tests if ` ` is truthy . If so , prints the calling file path and line number , prepended by ` ` . * @ returns { boolean } Returns ` ` if ` ` is truthy , else ` ` . * dantil . assertTrue ( 100 < Infinity , 'Condition met' ) * // => true * // => Prints \"Condition met: /Users/Danny/foo.js:1\" * * if ( dantil . assertTrue ( rareConditionIsTrue ) ) { * // => true * // => Prints \"Reached: /Users/Danny/foo.js:5\" * } if ( value ) { exports . assert ( message ) return true } return false", "del_tokens": "* Prints the calling file path and line number , prepended by ` ` , if ` ` is truthy . * dantil . assertTrue ( myNumber > 100 , 'Condition met' ) * // => If `myNumber > 100`, prints \"Condition met: /Users/Danny/foo.js:1\" if ( value ) exports . assert ( message )", "commit_type": "add"}
{"commit_tokens": ["Updating", "worker", "dequeuing", "to", "send", "callbacks"], "add_tokens": "queue . dequeue ( { minPriority : this . minPriority , callbacks : this . callbacks } , callback ) ; }", "del_tokens": "queue . dequeue ( { minPriority : this . minPriority } , callback ) ; }", "commit_type": "update"}
{"commit_tokens": ["Fix", "the", "crash", "caused", "by", "Siri", "."], "add_tokens": "console . log ( updates_objects ) ; if ( update_char !== undefined ) { var update_char_iid = update_char [ \"iid\" ] ; var update_char_value = update_char [ \"value\" ] ; var update_char_event = update_char [ \"ev\" ] ; var charObject = this . objects [ update_char_iid ] ; if ( update_char_value !== undefined ) { charObject . updateCharacteristicValue ( update_char_value , peer ) ; } if ( update_char_event !== undefined ) { charObject . updateCharacteristicEvent ( update_char_event , peer ) ; } } ; } ;", "del_tokens": "var update_char_iid = update_char [ \"iid\" ] ; var update_char_value = update_char [ \"value\" ] ; var update_char_event = update_char [ \"ev\" ] ; var charObject = this . objects [ update_char_iid ] ; if ( update_char_value !== undefined ) { charObject . updateCharacteristicValue ( update_char_value , peer ) ; } if ( update_char_event !== undefined ) { charObject . updateCharacteristicEvent ( update_char_event , peer ) ; } } ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "tests", "for", "the", "removeAccessOrigin", "method"], "add_tokens": "// If the access tag exists, remove it", "del_tokens": "// If the access tag allready exist, remove it", "commit_type": "add"}
{"commit_tokens": ["remove", "isChange", "arg", "from", "#createAddress"], "add_tokens": "var address = wallet . createAddress ( false ) ;", "del_tokens": "* @ param { truthy } opts . isChange - Indicates whether this is a regular address or a change address . var isChange = opts . isChange || false ; Utils . checkRequired ( opts , [ 'isChange' ] ) ; var address = wallet . createAddress ( opts . isChange ) ;", "commit_type": "remove"}
{"commit_tokens": ["remove", "permission", ".", "service", "attribute"], "add_tokens": "/ ** * TODO remove enum and support permissions based on all controller * actions , including custom ones * /", "del_tokens": "/ ** * controller service that this permission governs . * * TODO dormant . enable in future release * / service : { type : 'string' , defaultsTo : null } ,", "commit_type": "remove"}
{"commit_tokens": ["make", "use", "of", "public", "GITHUB_ACTION", "env", "var"], "add_tokens": "} else if ( process . env . GITHUB_ACTION ) {", "del_tokens": "} else if ( process . env . GITHUB_ACTIONS ) {", "commit_type": "make"}
{"commit_tokens": ["Added", "closeBeforeUnload", "flag", "to", "allow", "close", "before", "unload", "to", "be", "skipped", "if", "desired", "(", "defaults", "to", "true", "to", "preserve", "original", "behavior", ")"], "add_tokens": "// Last time updated at Monday, November 23rd, 2015, 7:54:15 PM if ( ! connection . closeBeforeUnload ) { return ; } connection . closeBeforeUnload = true ;", "del_tokens": "// Last time updated at Saturday, November 21st, 2015, 3:08:56 PM", "commit_type": "add"}
{"commit_tokens": ["remove", "eventListenr", "when", "directive", "is", "destroy"], "add_tokens": "var dist = ( env && env . DEV ? '/../websites/boxes-scroll/node_modules/boxes-scroll/dist' : '/dist' ) ; console . log ( \"Build to\" , dist ) ; path : __dirname + dist", "del_tokens": "path : __dirname + env . DEV ? '/../websites/boxes-scroll/node_modules/boxes-scroll/dist' : '/dist'", "commit_type": "remove"}
{"commit_tokens": ["add", ":", "cmd", "field", "in", "opt", "and", "cmdArguments"], "add_tokens": "var toString = { } . toString ; module . exports = function ( opts , cmdArguments ) { if ( toString . call ( opts ) === '[object String]' ) { var cmd = opts . cmd ; if ( ! cmd ) { cmd = 'install' ; } delete ( opts . cmd ) ; if ( toString . call ( cmdArguments ) !== '[object Array]' ) { cmdArguments = [ ] ; } if ( toString . call ( cmdArguments [ 0 ] ) !== '[object Array]' ) { cmdArguments [ 0 ] = [ ] ; } cmdArguments [ 1 ] = cmdArguments [ 1 ] || { } ; cmdArguments [ 2 ] = opts ; bower . commands [ cmd ] . apply ( bower . commands , cmdArguments )", "del_tokens": "module . exports = function ( opts ) { if ( typeof opts === 'string' ) { bower . commands . install ( [ ] , { } , opts )", "commit_type": "add"}
{"commit_tokens": ["using", "tnt", ".", "rest", "instead", "of", "tnt", ".", "ensembl"], "add_tokens": "var eRest = tnt . board . track . data . genome . ensembl ; var url = eRest . url ( ) . endpoint ( \"xrefs/symbol/:species/:symbol\" ) . parameters ( { species : \"human\" , symbol : thisGene } ) ; var url = eRest . url ( ) . endpoint ( \"lookup/id/:id\" ) . parameters ( { id : ensId , expand : true } ) ;", "del_tokens": "var eRest = tnt . board . track . data . genome . rest ; var url = eRest . url . xref ( { species : \"human\" , name : thisGene } ) ; var url = eRest . url . gene ( { id : ensId , expand : true } ) ;", "commit_type": "use"}
{"commit_tokens": ["adds", "tests", "for", "rql", "builder"], "add_tokens": "this . run_tests_rql = function ( store , name ) { this . run_tests_rql ( store , typeof name === 'undefined' ? void 0 : name ) ;", "del_tokens": "this . run_tests = function ( store , name ) { QUnit . config . reorder = false ; QUnit . config . autostart = false ; QUnit . config . autorun = false ; this . run_tests ( store , typeof name === 'undefined' ? void 0 : name ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "possibility", "to", "fill", "gauge", "plate", "with", "gradient", "color"], "add_tokens": "drawRectangle ( context , r , x4 , y4 , w4 , h4 , options . colorPlate , options . colorPlateEnd ) ;", "del_tokens": "drawRectangle ( context , r , x4 , y4 , w4 , h4 , options . colorPlate ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "unit", "test", "descriptions", "for", "tests", "reading", "modules", "from", "options", ".", "module", "rather", "than", "options", ".", "context"], "add_tokens": "describe ( \"when importing a module called `no` from options.modules\" , function ( ) { describe ( \"when importing module `no` and `yes` from options.modules\" , function ( ) { describe ( \"and module `no` is loaded from options.modules\" , function ( ) {", "del_tokens": "describe ( \"when importing a module called `no` from options.context\" , function ( ) { describe ( \"when importing module `no` and `yes` from options.context\" , function ( ) { describe ( \"and module `no` is loaded from options.context\" , function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "domain", "options", "to", "define", "prefix", "of", "topic"], "add_tokens": "function getHandler ( method , getArgs , trans , domain = 'feathers' ) { topic : ` ${ domain } ${ service } ` ,", "del_tokens": "function getHandler ( method , getArgs , trans ) { topic : ` ${ service } ` ,", "commit_type": "add"}
{"commit_tokens": ["Removed", "check", "for", "existence", "when", "finding", "all", "font", "and", "images"], "add_tokens": "paths = grunt . fcoo . paths ; base : paths . bower_components , checkExistence : false , //options.notDEBUG, //true=all bower components must be pressent. false=allows missing files debugging : options . DEBUG , bowerDirectory : paths . bower_components ,", "del_tokens": "paths = grunt . fcoo . paths ; base : paths . bower_components , checkExistence : options . notDEBUG , //true=all bower components must be pressent. false=allows missing files (only in debug) debugging : options . DEBUG , bowerDirectory : paths . bower_components ,", "commit_type": "remove"}
{"commit_tokens": ["Creating", "the", "root", "module", "before", "the", "loader", "and", "resolver", "."], "add_tokens": "this . resolver = new Resolver ( this ) ; this . loader = new Loader ( this ) ;", "del_tokens": "this . resolver = new Resolver ( this ) ; this . loader = new Loader ( this ) ;", "commit_type": "create"}
{"commit_tokens": ["Fix", ".", "zoom", "to", "reject", "on", "error"], "add_tokens": "return HorsemanPromise . fromCallback ( function ( done ) { self . page . set ( 'zoomFactor' , zoomFactor , done ) ;", "del_tokens": "return new HorsemanPromise ( function ( resolve , reject ) { self . page . set ( 'zoomFactor' , zoomFactor , resolve ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "support", "for", "function", "based", "custom", "elements"], "add_tokens": "if ( typeof name === 'function' ) { return name ( object , content ) ; } var resolved = this . resolveElementPath ( name ) ; return this . include ( resolved , attributes ) ; return this . include ( resolved , attributes , body ( context , object ) ) ; return this . include ( resolved , attributes , body ) ;", "del_tokens": "return this . include ( this . resolveElementPath ( name ) , attributes ) ; return this . include ( this . resolveElementPath ( name ) , attributes , body ( context , object ) ) ; return this . include ( this . resolveElementPath ( name ) , attributes , body ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "that", "to", "be", "overridden", "images", "stop", "the", "upload", "progress", "with", "500"], "add_tokens": "define ( [ 'knockout' , 'knockout-collection' , 'knockout-mapping' , 'lodash' , 'cms/modules/ui' , 'cms/modules/dropbox-chooser' , 'cms/modules/dispatcher' , 'amplify' , 'bluebird' ] , function ( ko , KnockoutCollection , koMapping , _ , ui , Dropbox , dispatcher , amplify ) { var warnings = [ ] ; var response = inspection . value ( ) ; if ( response . body && response . body . warnings && response . body . warnings . length ) { warnings = _ . concat ( warnings , response . body . warnings ) ; } return afterwards ( response , warnings ) ; this . error = ko . observable ( ) ; that . sync . uploadFromDropbox ( ci , files , that . processing , that . filesProgress , function ( response , warnings ) { if ( warnings . length ) { that . error ( { message : _ . join ( warnings , \"<br>\\n\" ) } ) ; }", "del_tokens": "define ( [ 'knockout' , 'knockout-collection' , 'knockout-mapping' , 'lodash' , 'cms/modules/ui' , 'cms/modules/dropbox-chooser' , 'cms/modules/dispatcher' , 'amplify' , 'bluebird' ] , function ( ko , KnockoutCollection , koMapping , lodash , ui , Dropbox , dispatcher , amplify ) { return afterwards ( response ) ; that . sync . uploadFromDropbox ( ci , files , that . processing , that . filesProgress , function ( response ) {", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "gitignore", "and", "moving", "run", "states", "to", "Test"], "add_tokens": "if ( test . state !== Test . STATE . RUNNING ) {", "del_tokens": "if ( test . state !== Constants . RUN_STATE . RUNNING ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "silk", "-", "alog", "flow", "interface"], "add_tokens": "const log = require ( 'silk-alog' ) ;", "del_tokens": "let createLog = require ( 'silk-log/device' ) ; let log = createLog ( 'device-main' ) ;", "commit_type": "use"}
{"commit_tokens": ["Removed", "reverse", "from", "indexjs", ".", "Refactored", "file", "collector", "."], "add_tokens": "var results = inspector ( files ) ;", "del_tokens": "var results = inspector ( files . reverse ( ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["allow", "karma", "to", "find", "all", ".", "spec", "files", "from", "src", "instead", "of", "just", "inside", "app", "."], "add_tokens": "const srcPath = path . resolve ( process . cwd ( ) , 'src' ) ;", "del_tokens": "const srcPath = path . resolve ( process . cwd ( ) , 'src' , 'app' ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "arguments", "as", "an", "optional", "input", "."], "add_tokens": "app . handle = function ( path , args , kontx ) { deferred = q . defer ( ) , kontxArgs = [ ] ; //Args is optional param. Shift if needed. if ( _ . isUndefined ( args . payload ) ) { kontxArgs = ( ! _ . isUndefined ( args ) ) ? Array . prototype . slice . call ( args ) : [ ] ; } else { kontx = args ; } kontx . args = kontxArgs ;", "del_tokens": "app . handle = function ( path , kontx ) { deferred = q . defer ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "sass", "task", "to", "rename", "and", "pipe", "first"], "add_tokens": ". pipe ( rename ( '_pattern-library.scss' ) ) . pipe ( gulp . dest ( 'dist' ) )", "del_tokens": "gulp . src ( dirs . sass . main ) . pipe ( rename ( '_pattern-library.scss' ) ) . pipe ( gulp . dest ( 'dist' ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "publish", "(", "..", "{", "noAcl", ":", "true", "}", ")", "option"], "add_tokens": "* - noAcl : do not set x - amz - acl by default * - simulate : debugging option to simulate s3 upload * - createOnly : skip file updates if ( ! headers [ 'x-amz-acl' ] && ! options . noAcl ) headers [ 'x-amz-acl' ] = 'public-read' ;", "del_tokens": "if ( ! headers [ 'x-amz-acl' ] ) headers [ 'x-amz-acl' ] = 'public-read' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "resolving", "from", "an", "axe"], "add_tokens": "var commands = require ( './lib/cli/commands.js' ) ;", "del_tokens": "var fs = require ( 'fs' ) ; var commands = { \"generate\" : function ( args ) { if ( args . length !== 1 ) { console . error ( \"You need to specify the name of the new resolver.\" ) ; process . exit ( 1 ) ; } console . error ( \"Not yet implemented. Please stand by!\" ) ; // FIXME: Implement! } , \"resolve\" : function ( args ) { if ( args . length == 0 ) { console . error ( \"You need to specify a resolver to utilise.\" ) ; process . exit ( 1 ) ; } if ( args . length < 3 || args . length > 4 ) { console . error ( \"Usage: \\n\\t tomahawkjs resolve <resolver> <artist> <title> [<album>]\" ) ; process . exit ( 1 ) ; } fs . stat ( args [ 0 ] , function ( err , stats ) { if ( err ) { console . error ( \"Error while reading the resolver path:\" ) ; console . error ( err ) ; process . exit ( 1 ) ; } if ( stats . isFile ( ) ) { // Load the resolver from a (zipped) bundle. // FIXME: Implement! } else if ( stats . isDirectory ( ) ) { // Load the resolver from a directory. // FIXME: Implement! } else { // Will be interesting what kind of fs type people will access here console . error ( \"Unsupported FS item for a resolver bundle.\" ) ; process . exit ( 1 ) ; } } ) ; } }", "commit_type": "add"}
{"commit_tokens": ["Added", "tests", "for", "hasMethod", "updated", "tests", "for", "isEmptyObjKey", "and", "added", "its", "replacement", "alias", "."], "add_tokens": "* sjl - minimal . js Wed Jul 22 2015 00 : 31 : 29 GMT - 0400 ( Eastern Daylight Time )", "del_tokens": "* sjl - minimal . js Wed Jul 22 2015 00 : 08 : 18 GMT - 0400 ( Eastern Daylight Time )", "commit_type": "add"}
{"commit_tokens": ["add", "templates", "support", "and", "new", "flat", "style", "option"], "add_tokens": "var url = require ( 'url' ) ; var validTemplates = [ 'default' , 'flat' ] ; // parse querystring for specifying template var reqURL = url . parse ( ask . req . url , true ) ; var badgeOpts = { template : 'default' } ; var style = reqURL . query . style || 'default' ; if ( style && validTemplates . indexOf ( style ) > - 1 ) { badgeOpts . template = style ; } ; badge ( cached . badgeData , badgeOpts , makeSend ( cached . format , ask . res , end ) ) ; badge ( badgeData , badgeOpts , makeSend ( 'svg' , ask . res , end ) ) ;", "del_tokens": "badge ( cached . badgeData , makeSend ( cached . format , ask . res , end ) ) ; badge ( badgeData , makeSend ( 'svg' , ask . res , end ) ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "system", "-", "time", "and", "user", "-", "me", "calls", "to", "JAVA", "client"], "add_tokens": "// ###Get self // Returns the user object for the user to given API key _PieceMakerApi . prototype . whoAmI = function ( cb ) { var callback = cb || noop ; xhrGet ( this , { url : api . base_url + '/user/me' , success : function ( response ) { callback . call ( api . context || cb , response ) ; } } ) ; } queryTime : ts2 - ts1", "del_tokens": "callDuration : ts2 - ts1", "commit_type": "add"}
{"commit_tokens": ["Create", "multiple", "records", "at", "once"], "add_tokens": ". set ( 'url' , function ( ) { it ( 'can handle sequences' , function ( ) { it ( 'supports inheritance' , function ( ) { it ( 'can create multiple factories at once' , function ( done ) { list ( 'User' , 10 , function ( users ) { users . length . should . eq ( 10 ) ; users . map ( function ( user ) { user . get ( '_id' ) . should . be . ok ; } ) ; done ( ) ; } ) ; } ) ;", "del_tokens": ". set ( 'url' , function ( ) { it ( 'can handle sequences' , function ( ) { it ( 'supports inheritance' , function ( ) { xit ( 'can create multiple factories at once' ) ;", "commit_type": "create"}
{"commit_tokens": ["Add", "lint", "YAML", "file", ".", "Fix", "lint", "issues"], "add_tokens": ". pipe ( scsslint ( { 'config' : 'lint.yml' } ) )", "del_tokens": ". pipe ( scsslint ( ) )", "commit_type": "add"}
{"commit_tokens": ["add", "and", "validate", "new", "storybookStaticBuildDir", "option"], "add_tokens": "return validate . storybookConfig ( { apiKey : 'key' , projectRepo : 'repo' , storybookConfigDir : '.storybook' , storybookStaticDir : './public' , storybookStaticBuildDir : 'storybook-static' , storybookPort : 6006 , storybookPreview : '/preview.html' , storybook : [ ] , build : 'build' , branch : 'branch' , commit : 'commit' , resolution : '1280x1024' , cssAnimations : true , ignore : 'ignore' , hide : 'hide' , includeRules : [ ] , excludeRules : [ ] , initialBaselineBranch : 'master' , baseBranch : 'master' , alwaysAcceptBaseBranch : true , diffOptions : { compareSVGDOM : true , minShiftGraphic : 5 } , failOnNewStates : true , beforeEachScript : function ( ) { } , ieNativeEvents : true } )", "del_tokens": "return validate . storybookConfig ( { apiKey : 'key' , projectRepo : 'repo' , storybookConfigDir : '.storybook' , storybookStaticDir : './public' , storybookPort : 6006 , storybookPreview : '/preview.html' , storybook : [ ] , build : 'build' , branch : 'branch' , commit : 'commit' , resolution : '1280x1024' , cssAnimations : true , ignore : 'ignore' , hide : 'hide' , includeRules : [ ] , excludeRules : [ ] , initialBaselineBranch : 'master' , baseBranch : 'master' , alwaysAcceptBaseBranch : true , diffOptions : { compareSVGDOM : true , minShiftGraphic : 5 } , failOnNewStates : true , beforeEachScript : function ( ) { } , ieNativeEvents : true } )", "commit_type": "add"}
{"commit_tokens": ["allow", "empty", "conjunctions", "in", "scopesets"], "add_tokens": "test ( \"empty conjunction in scopesets\" , mktest ( [ \"foo:bar\" ] , [ [ ] ] , true ) ) ;", "del_tokens": "test ( \"empty conjunction in scopesets\" , mktest ( [ \"foo:bar\" ] , [ [ ] ] , 'exception' ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "allowDuplicateProperties", "parsing", "option", "and", "make", "it", "the", "default", "."], "add_tokens": "// If true, duplicate properties are allowed and the last definition will be used // e.g. '{\"hello\": \"world1\", \"hello\": \"world2\"}' -> {\"hello\": \"world2\"} // If false, duplicate properties result in a SyntaxError. allowDuplicateProperties = true , if ( ! allowDuplicateProperties && Object . hasOwnProperty . call ( object , key ) ) { return function ( source , reviver , _allowDuplicateProperties ) { allowDuplicateProperties = _allowDuplicateProperties ;", "del_tokens": "if ( Object . hasOwnProperty . call ( object , key ) ) { return function ( source , reviver ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "and", "improve", "generated", "sagui", ".", "config", ".", "js", "file"], "add_tokens": "/ ** * Different application entry - points * Each page is a combination of a JavaScript file and a HTML file * * Example : 'index' - > 'index.html' and 'index.js' * / webpackConfig : { } , / ** * Karma configuration object * see : https : //karma-runner.github.io/0.13/config/configuration-file.html * * Will overwrite and extend the default Sagui configuration * / karmaConfig : {", "del_tokens": "webpack : {", "commit_type": "fix"}
{"commit_tokens": ["Allow", "[", "RSAA", "]", ".", "body", "to", "be", "passed", "as", "a", "function"], "add_tokens": "var { endpoint , body , headers , options = { } } = callAPI ; const { method , credentials , bailout , types } = callAPI ; // Process [RSAA].body function if ( typeof body === 'function' ) { try { body = body ( getState ( ) ) ; } catch ( e ) { return next ( await actionWith ( { ... requestType , payload : new RequestError ( '[RSAA].body function failed' ) , error : true } , [ action , getState ( ) ] ) ) ; } }", "del_tokens": "var { endpoint , headers , options = { } } = callAPI ; const { method , body , credentials , bailout , types } = callAPI ;", "commit_type": "allow"}
{"commit_tokens": ["fixed", "issue", "with", "loading", "proper", "computed", "property", "."], "add_tokens": "types : Ember . computed ( function ( ) { return [ this . get ( 'selectPrompt' ) , 'Excel' , 'CSV' ] } ) , selectedType : null ,", "del_tokens": "types : [ this . get ( 'selectPrompt' ) , 'Excel' , 'CSV' ] , selectedType : null ,", "commit_type": "fix"}
{"commit_tokens": ["Use", "utils", "closest", "function", "instead", "of", "native", "browser", "closest"], "add_tokens": "const droppable = closest ( event . sensorEvent . target , this . options . droppable ) ;", "del_tokens": "const droppable = event . sensorEvent . target . closest ( this . options . droppable ) ;", "commit_type": "use"}
{"commit_tokens": ["Implementing", "MariaDB", "detection", "and", "special", "logic", "."], "add_tokens": "this . _options = ( options || { } ) ;", "del_tokens": "this . _options = options ;", "commit_type": "implement"}
{"commit_tokens": ["Update", "to", "lodash", "v4", "."], "add_tokens": "options = _ . defaults ( options , {", "del_tokens": "options = _ . defaults ( options || { } , {", "commit_type": "update"}
{"commit_tokens": ["add", "css", "-", "concat", "for", "css", "files", "and", "copy", "grunt", "task", "for", "img", "&", "font", "folder"], "add_tokens": "cssmin : { add_banner : { options : { banner : '/*! <%= pkg.name %> - v<%= pkg.version %> - ' + '<%= grunt.template.today(\"yyyy-mm-dd\") %> */' } , files : { 'build/css/<%= pkg.name %>.css' : [ 'app/css/topcoat-mobile-light.css' , 'app/css/*.css' , '!app/css/polyfill/*.css' ] } } } , banner : '/*! <%= pkg.name %> - v<%= pkg.version %> - ' + '<%= grunt.template.today(\"yyyy-mm-dd\") %> */\\n' , } , // Put files not handled in other tasks here copy : { dist : { files : [ { expand : true , dot : true , cwd : 'app' , dest : 'build' , src : [ 'img/{,*/}*.{gif,webp,svg}' , 'font/*' ] } , { expand : true , cwd : 'app/css/polyfill' , dest : 'build/css/polyfill/' , src : [ '*.css' ] } ] } grunt . loadNpmTasks ( 'grunt-contrib-cssmin' ) ; grunt . loadNpmTasks ( 'grunt-contrib-copy' ) ; grunt . registerTask ( 'default' , [ 'uglify' , 'cssmin' , 'copy' ] ) ;", "del_tokens": "banner : '/*! <%= pkg.name %> <%= grunt.template.today(\"yyyy-mm-dd\") %> */\\n' , grunt . registerTask ( 'default' , [ 'uglify' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["adding", "secure", "env", "vars", "to", "use", "on", "my", "repo", "only"], "add_tokens": "} , sl_ie_11 : { base : 'SauceLabs' , browserName : 'internet explorer' , version : '11' browsers : [ 'sl_firefox' , 'sl_ie_9' , 'sl_ie_11' , 'sl_safari' , 'PhantomJS' ] ,", "del_tokens": "browsers : [ 'sl_firefox' , 'sl_ie_9' , 'PhantomJS' ] ,", "commit_type": "add"}
{"commit_tokens": ["Add", "ESLint", "errors", "for", "incomplete", "JSDocs"], "add_tokens": "* @ returns { Promise < Key > } * @ returns { Promise < Nimiq . SerialBuffer > } * @ returns { Promise < void > } * @ returns { Promise < void > }", "del_tokens": "* @ returns { Promise . < Key > } * @ returns { Promise . < Nimiq . SerialBuffer > }", "commit_type": "add"}
{"commit_tokens": ["Fix", "typo", "and", "speed", "up", "tests", "slightly"], "add_tokens": "it ( 'should parse DSN with non-standard port' , function ( ) { var stack = fs . readFileSync ( __dirname + '/fixtures/stack.txt' , 'utf8' ) ;", "del_tokens": "it ( 'should parse DNS with non-standard port' , function ( ) { var stack ; beforeEach ( function ( ) { stack = fs . readFileSync ( __dirname + '/fixtures/stack.txt' , 'utf8' ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["make", "constructors", "nicer", "(", "don", "t", "require", "new", ")"], "add_tokens": "", "del_tokens": "", "commit_type": "make"}
{"commit_tokens": ["Add", "ssh", "transport", "for", "ls", "-", "remote"], "add_tokens": "output : \"\\u2192\" , exec : \"exec\" , connect : \"connect\" ,", "del_tokens": "output : \"\\u2192\"", "commit_type": "add"}
{"commit_tokens": ["Fix", "arguments", "to", "pass", "done", "through", "correctly", "."], "add_tokens": "cb ( 'Could not retrieve latest version of ' + project + ' for Drush makefile.\\n' , null , done ) ;", "del_tokens": "cb ( 'Could not retrieve latest version of ' + project + ' for Drush makefile.\\n' , done ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "mf", ".", "plural", "()"], "add_tokens": "MessageFormat . plural = function ( p , k , o , d , l ) { return ( p [ k + \"\" ] || p [ MessageFormat . locale [ l ] ( k - o ) ] || p [ \"other\" ] ) ( d ) ; } ; s += 'r += MessageFormat.plural(pf_' + data . pf_count + ',k_' + ( data . pf_count + 1 ) + ',off_' + data . pf_count + ',d,\"' + self . fallbackLocale + '\");\\n' ;", "del_tokens": "s += 'if ( pf_' + ( data . pf_count ) + '[ k_' + ( data . pf_count + 1 ) + ' + \"\" ] ) {\\n' ; s += 'r += pf_' + data . pf_count + '[ k_' + ( data . pf_count + 1 ) + ' + \"\" ]( d ); \\n' ; s += '}\\nelse {\\n' ; s += 'r += (pf_' + data . pf_count + '[ MessageFormat.locale[\"' + self . fallbackLocale + '\"]( k_' + ( data . pf_count + 1 ) + ' - off_' + ( data . pf_count ) + ' ) ] || pf_' + data . pf_count + '[ \"other\" ] )( d );\\n' ; s += '}\\n' ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "rebundle", "naming", "issue", "in", "compilejs"], "add_tokens": "rebundle_ ( bundler , outdir , outfile ) ;", "del_tokens": "rebundle ( bundler ) ;", "commit_type": "fix"}
{"commit_tokens": ["used", "default", "uglify", "plugin", "to", "minify", "js"], "add_tokens": "devtool : 'source-map' , devtool : 'source-map' ,", "del_tokens": "devtool : 'sourcemap' , devtool : 'sourcemap' ,", "commit_type": "use"}
{"commit_tokens": ["Add", "grouping", "by", "day", "in", "events", "page"], "add_tokens": "res . json ( CheckEvent . aggregateEventsByDay ( events ) ) ;", "del_tokens": "res . json ( events ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "test", "for", "destoying", "plugins", "fix", "bug", "in", "destroy"], "add_tokens": "return key === 'destroyPlugins' ;", "del_tokens": "return 'key' === 'destroyPlugins' ;", "commit_type": "add"}
{"commit_tokens": ["Implement", "nix", "-", "build", "-", "A", "avatar"], "add_tokens": "var type = process . argv [ 2 ] ; var target = process . argv [ 3 ] ; if ( type === '--website' ) { generateImages ( target ) ; } else if ( type === '--avatar' ) { makeImage ( target , luvSquare , 200 , 200 ) ; }", "del_tokens": "// Generate larger picture, e.g. for GitHub // makeImage('dist/github.png', luvSquare, 200, 200); var targetDir = process . argv [ 2 ] ; generateImages ( targetDir ) ;", "commit_type": "implement"}
{"commit_tokens": ["Make", "SC", ".", "Scanner", "local", "to", "the", "date", "framework"], "add_tokens": "/ ** @ ignore @ private var Scanner = SC . Object . extend ( { Scanner . create ( { string : 'May, 8th' } ) ; var d , parts , opts = { } , check = { } , scanner = Scanner . create ( { string : str } ) ;", "del_tokens": "/ ** @class SC . Scanner = SC . Object . extend ( /** @scope SC.Scanner.prototype */ { SC . Scanner . create ( { string : 'May, 8th' } ) ; var d , parts , opts = { } , check = { } , scanner = SC . Scanner . create ( { string : str } ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "gulp", "as", "an", "alternative", "to", "webpack", "4", "plugin", "/", "loaders", "shortcomings"], "add_tokens": "var fs = require ( \"fs\" ) ; //\"./src/components/string/string.js\", //\"./src/components/loader/loader.js\", //\"./src/components/logger/logger.js\", \"./src/components/datatables/datatables.js\" , //\"./src/pages/index/index.js\" const HtmlWebpackPlugin = require ( 'html-webpack-plugin' ) ; var HtmlWebpackInlineSourcePlugin = require ( 'html-webpack-inline-source-plugin' ) ; var template = ` ` ; var localTemplatePath = path . resolve ( srcDir , \"widget.html\" ) ; if ( fs . existsSync ( localTemplatePath ) ) { template = localTemplatePath ; } { test : / \\.css$ / , use : [ 'css-loader' ] } , , new HtmlWebpackPlugin ( { template : template , appMountId : 'moduledef' , inject : true , inlineSource : '.(js|css)$' } ) //, new HtmlWebpackInlineSourcePlugin()", "del_tokens": "\"./src/components/string/string.js\" , \"./src/components/loader/loader.js\" , \"./src/components/logger/logger.js\" , \"./src/pages/index/index.js\"", "commit_type": "add"}
{"commit_tokens": ["Adds", "version", "to", "CLI", "Contributing", "section", "to", "README"], "add_tokens": "* @ version 0.1 .1", "del_tokens": "* @ version 0.1 .0", "commit_type": "add"}
{"commit_tokens": ["Add", "function", "level", "parse", "(", "static", ")", "fix", "creation", "of", "nested", "rules", "so", "that", "a", "single", "rule", "doesn", "t", "need", "to", "be", "part", "of", "a", "composite", "bump", "version"], "add_tokens": "Ruleset . prototype . parse = Ruleset . parse = function parse ( json ) { return new Rule ( json ) ; obj = new Ruleset ( ) ; obj . rules . push ( parse ( json . rules [ i ] ) ) ;", "del_tokens": "Ruleset . prototype . parse = function parse ( json ) { obj = new Ruleset ( ) ; obj . rules . push ( new Rule ( json ) ) ; return obj ; obj . rules . push ( this . parse ( json . rules [ i ] ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Upgrade", "and", "using", "react", "-", "dom"], "add_tokens": "ReactDOM = require ( 'react-dom' ) , fileElement : ReactDOM . findDOMNode ( this ) , clearInputFile ( ReactDOM . findDOMNode ( this ) ) ;", "del_tokens": "fileElement : findDOMNode ( this ) , clearInputFile ( findDOMNode ( this ) ) ; function findDOMNode ( cmp ) { return React . findDOMNode ? React . findDOMNode ( cmp ) : cmp . getDOMNode ( ) ; }", "commit_type": "upgrade"}
{"commit_tokens": ["add", "concat", "helper", "for", "easy", "stirng", "concatenatization"], "add_tokens": "var helpers = require ( './lib/all-helpers' ) ( {", "del_tokens": "var helpers = require ( './lib/template-helpers' ) ( {", "commit_type": "add"}
{"commit_tokens": ["Updated", "node", "-", "fetch", "to", "version", "2"], "add_tokens": "return type . indexOf ( 'json' ) !== - 1 ? ( res . status === 204 ? { } : res . json ( ) ) : res . text ( ) ; return ( res . status === 204 ? { } : res . json ( ) ) ;", "del_tokens": "return type . indexOf ( 'json' ) !== - 1 ? res . json ( ) : res . text ( ) return res . json ( )", "commit_type": "update"}
{"commit_tokens": ["allow", "flasher", "to", "flash", "a", "binary", "that", "s", "already", "in", "memory", "and", "fix", "data", "formats", "from", "nodeserial", "wrapper"], "add_tokens": "if ( readListener !== undefined ) { var a = new Uint8Array ( data . length ) ; for ( var i = 0 ; i < data . length ; i ++ ) a [ i ] = data [ i ] ; readListener ( a . buffer ) ; } // convert to an array - if we put a string into // a Buffer (expected by nodeserial) then I think // it gets interpreted as UTF8 var a = new Buffer ( data . length ) ; for ( var i = 0 ; i < data . length ; i ++ ) a [ i ] = data . charCodeAt ( i ) ; connection . write ( a ) ;", "del_tokens": "if ( readListener !== undefined ) readListener ( data . toString ( ) ) ; connection . write ( data ) ;", "commit_type": "allow"}
{"commit_tokens": ["Use", "standard", "code", "style", "."], "add_tokens": "'use strict' // //////////////////////////////////////////////////////////////////// // var hashy = require('hashy') var hashy = require ( '..' ) // //////////////////////////////////////////////////////////////////// var hash = '$2a$08$3VbKizuJA1RdlRafd48Kfuf/eKE9kPhP8tOoyHFDmmr/rFkV.d/mO' var password = 'test' if ( error ) { console . error ( error ) return if ( ! success ) { console . error ( 'the password is invalid' ) return console . log ( 'the password has been checked, you are now authenticated!' ) if ( hashy . needsRehash ( hash ) ) { if ( error ) { console . error ( error ) return hash = newHash console . log ( 'the hash has been updated:' , hash ) } ) } )", "del_tokens": "'use strict' ; ////////////////////////////////////////////////////////////////////// // var hashy = require('hashy'); var hashy = require ( '..' ) ; ////////////////////////////////////////////////////////////////////// var hash = '$2a$08$3VbKizuJA1RdlRafd48Kfuf/eKE9kPhP8tOoyHFDmmr/rFkV.d/mO' ; var password = 'test' ; if ( error ) { console . error ( error ) ; return ; if ( ! success ) { console . error ( 'the password is invalid' ) ; return ; console . log ( 'the password has been checked, you are now authenticated!' ) ; if ( hashy . needsRehash ( hash ) ) { if ( error ) { console . error ( error ) ; return ; hash = newHash ; console . log ( 'the hash has been updated:' , hash ) ; } ) ; } ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "util", "func", "to", "validate", "signed", "requests"], "add_tokens": "function validateSignedRequest ( app_secret , signed_request ) { let request = signed_request . split ( '.' ) ; let signature = Buffer . from ( request [ 0 ] . replace ( '-' , '+' ) . replace ( '_' , '/' ) , 'base64' ) . toString ( 'hex' ) ; let payload = Buffer . from ( request [ 1 ] , 'base64' ) . toString ( 'ascii' ) ; let expected_signature = crypto . createHmac ( 'sha256' , app_secret ) . update ( request [ 1 ] ) . digest ( 'hex' ) ; // Confirm the signature if ( signature !== expected_signature ) { console . error ( 'Bad Signed JSON signature!' ) ; return null ; } return payload ; } parseEventType , validateSignedRequest", "del_tokens": "parseEventType", "commit_type": "add"}
{"commit_tokens": ["Add", "maxMatchLen", "option", "to", "readToMatch"], "add_tokens": "* considered an error and a < code > maxMatchLen < / code> option which specifies * the maximum length of a match , which allow additional search optimizations . var maxMatchLen = Number ( options && options . maxMatchLen ) ; regexp . lastIndex = maxMatchLen ? Math . max ( result . length - chunk . length - maxMatchLen + 1 , 0 ) : 0 ;", "del_tokens": "* considered an error . regexp . lastIndex = 0 ;", "commit_type": "add"}
{"commit_tokens": ["fixes", "unicode", "usage", "in", "split", "tests"], "add_tokens": "let char = splitChars [ i ] ; if ( char . startsWith ( \"u\" ) ) char = String . fromCharCode ( ` ${ char . slice ( 1 ) } ` ) ; const sentence = ` ${ char } ` ; const arr = split ( sentence ) ;", "del_tokens": "const char = splitChars [ i ] ; const arr = split ( ` ${ char } ` ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "docs", "&", "entity", "value", "setter", "uses", "also", "the", "state"], "add_tokens": "* @ type { object } Helpers for ` ` method * const { vars } = require ( 'wingbot' ) ; * const { vars } = require ( 'wingbot' ) ; * const { vars } = require ( 'wingbot' ) ;", "del_tokens": "* @ type { object }", "commit_type": "fix"}
{"commit_tokens": ["allow", "for", "changing", "remoteServiceName", "at", "runtime"], "add_tokens": "if ( options . remoteServiceName ) { // torii uses this to determine whether a popout or an iframe is used // we need to be able to pass this option in at runtime this . set ( 'configuredRemoteServiceName' , options . remoteServiceName ) ; delete options . remoteServiceName ; } const display = options . display || this . get ( 'display' ) ; if ( display === 'iframe' ) { // the display parameter is sent on the url querystring", "del_tokens": "if ( this . get ( 'display' ) === 'iframe' ) {", "commit_type": "allow"}
{"commit_tokens": ["Fix", "usage", "of", "highlight", ".", "js"], "add_tokens": "var hljs = require ( 'highlight.js' ) ; highlight : function ( code , lang ) { try { return hljs . highlight ( lang , code ) . value ; } catch ( e ) { return hljs . highlightAuto ( code ) . value ; }", "del_tokens": "highlight : function ( code ) { return require ( 'highlight.js' ) . highlightAuto ( code ) . value ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "relative", "path", "for", "build", "external"], "add_tokens": "const relative = require ( 'relative' ) ; const tmpPlugin = path . join ( tmpDir , 'document.js' ) ; const extendModuleDir = relative ( tmpPlugin , v . path ) ;", "del_tokens": "// const rimraf = require('rimraf'); const extendModuleDir = v . path ; const tmpPlugin = path . join ( tmpDir , 'document.js' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixed", "some", "spacing", "problems", "."], "add_tokens": "md += \" \" + \"void main(String[] args) {\\n\" ; it ( \"headers\" , function ( ) { // it(\"span element\", function() { // expect(downshow(\"<span>this is span element</span>\")).toEqual(\"this is span element\"); // expect(downshow(\"before<span>this is span element</span>after\")).toEqual(\"before this is span element after\"); // expect(downshow(\"before <span>this is span element</span> after\")).toEqual(\"before this is span element after\"); // });", "del_tokens": "md += \" \" + \" void main(String[] args) {\\n\" ; xit ( \"headers\" , function ( ) { xit ( \"span element\" , function ( ) { expect ( downshow ( \"<span>this is span element</span>\" ) ) . toEqual ( \"this is span element\" ) ; expect ( downshow ( \"before<span>this is span element</span>after\" ) ) . toEqual ( \"before this is span element after\" ) ; expect ( downshow ( \"before <span>this is span element</span> after\" ) ) . toEqual ( \"before this is span element after\" ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "the", "host", "property", "to", "the", "WebSocketRequest", "object", ".", "Also", "correctly", "passing", "the", "port", "number", "in", "the", "client", "s", "host", "header", "when", "connecting", "to", "a", "non", "-", "standard", "port", "."], "add_tokens": "var hostHeaderValue = this . url . hostname ; if ( ( this . url . protocol === 'ws:' && this . url . port !== '80' ) || ( this . url . protocol === 'wss:' && this . url . port !== '443' ) ) { hostHeaderValue += ( \":\" + this . url . port ) } 'Host' : hostHeaderValue", "del_tokens": "'Host' : this . url . hostname", "commit_type": "add"}
{"commit_tokens": ["add", "classname", "props", "to", "Table"], "add_tokens": "import classNames from 'classnames' ; basic : PropTypes . bool , striped : PropTypes . bool , let classes = classNames ( 'sd-table' , 'ui' , { 'very basic' : this . props . basic } , 'selectable' , 'fixed' , 'compact' , 'small' , { striped : this . props . striped } , 'table' , ) ; < table className = { classes } >", "del_tokens": "< table className = 'sd-table ui very basic selectable fixed compact small table' >", "commit_type": "add"}
{"commit_tokens": ["added", "zuix", ".", "store", "and", "zuix", ".", "getResourcePath", "methods"], "add_tokens": "// TODO: convert all 'this.<field>' to 'let' variables /** @type {Zuix} **/ let zuix = null ; * @ param { Zuix } zuixInstance function ComponentContext ( zuixInstance , options , eventCallback ) { zuix = zuixInstance ; url : zuix . getResourcePath ( cssPath ) , url : zuix . getResourcePath ( htmlPath ) ,", "del_tokens": "function ComponentContext ( options , eventCallback ) { url : cssPath , url : htmlPath ,", "commit_type": "add"}
{"commit_tokens": ["Use", "style", "attribute", "instead", "of", "width", "/", "height", "in", "svg"], "add_tokens": "if ( scope . options . chart . width && ! isNaN ( scope . options . chart . height ) ) scope . options . chart . height += 'px' ; if ( scope . options . chart . width && ! isNaN ( scope . options . chart . width ) ) scope . options . chart . width += 'px' ; . style ( { height : scope . options . chart . height , width : scope . options . chart . width } )", "del_tokens": ". attr ( 'height' , scope . options . chart . height ) . attr ( 'width' , scope . options . chart . width || '100%' )", "commit_type": "use"}
{"commit_tokens": ["Adds", "select", "/", "option", "tag", "names", "to", "automatically", "set", "container", "/", "child", "mappings"], "add_tokens": "tr : 'td' , select : 'option'", "del_tokens": "tr : 'td'", "commit_type": "add"}
{"commit_tokens": ["Use", "$$", ".", "setProps", "and", "$$", ".", "extendProps"], "add_tokens": ". setProps ( { contextId : this . props . containerId } ) . setProps ( {", "del_tokens": ". addProps ( { contextId : this . props . containerId } ) . addProps ( {", "commit_type": "use"}
{"commit_tokens": ["add", "suite", "[", "before", "/", "after", "]", "hooks"], "add_tokens": "/ ** * External dependencies . * / var Emitter = require ( 'evts' ) ; Suite . prototype . __proto__ = Emitter . prototype ; self . emit ( 'after' , function ( err ) { if ( err ) return fn ( err ) ; emitter . emit ( events . post , self , fn ) ; } ) emitter . emit ( events . pre , this , function ( err ) { if ( err ) return fn ( err ) ; self . emit ( 'before' , next ) ; } ) ;", "del_tokens": "emitter . emit ( events . post , self , function ( err ) { fn ( err , self ) ; } ) ; emitter . emit ( events . pre , this , next ) ;", "commit_type": "add"}
{"commit_tokens": ["Allowing", "user", "to", "select", "template", "file", "from", "choice"], "add_tokens": "TemplateService . prototype . getTemplateSources = function ( ) { return $http . get ( '/_misc/templates' ) ; } ;", "del_tokens": "", "commit_type": "allow"}
{"commit_tokens": ["fixing", "issue", "where", "no", "leading", "whitespace", "in", "a", "function", "body", "would", "kill", "tempView", "(", "presumably", "anything", "that", "used", "util", ".", "formatFunction", "as", "well", ")"], "add_tokens": "var matches = line . match ( / ^\\s+ / m ) ; return ! ! matches ? matches [ 0 ] : \"\" ; } ;", "del_tokens": "return line . match ( / ^\\s+ / m ) [ 0 ] ; } ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", ":", "execute", "tests", "before", "sub", "-", "suites"], "add_tokens": "// pending tests // run sub-suites suite . suites . forEach ( function ( suite ) { self . runSuite ( suite , function ( ) { -- pending || fn ( ) ; } ) ; } ) ;", "del_tokens": "// run sub-suites suite . suites . forEach ( function ( suite ) { self . runSuite ( suite , function ( ) { -- pending || fn ( ) ; } ) ; } ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "jshint", "rules", "to", "bubble", "sort"], "add_tokens": "/* jshint ignore:start */ } ( this , /* jshint ignore:end */ /*jshint -W025 */ function ( ) { /*jshint +W025 */ } /* jshint ignore:start */ ) ) ; /* jshint ignore:end */", "del_tokens": "} ( this , function ( ) { } ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "and", "revive", "some", "colletions", "methods"], "add_tokens": "this . forEach ( function ( element , i ) { return this exports . push = function ( item ) { if ( util . isElement ( item ) ) { this . elements . push ( item ) this . update ( ) return this . length - 1 } else { return - 1 } 'forEach' , 'map' , 'slice' , 'push'", "del_tokens": "exports . forEach = function ( fn ) { this . elements . forEach ( fn ) return this } return this . forEach ( function ( element , i ) { exports . slice = function ( ) { return _slice . apply ( this . elements , arguments ) , 'map'", "commit_type": "fix"}
{"commit_tokens": ["Remove", "line", "break", "for", "class", "properties"], "add_tokens": "node . value ? concat ( [ \" = \" , path . call ( print , \"value\" ) ] ) : \"\" ,", "del_tokens": "node . value ? indent ( concat ( [ line , \"= \" , path . call ( print , \"value\" ) ] ) ) : \"\" ,", "commit_type": "remove"}
{"commit_tokens": ["Added", "support", "for", "runtime", "chunk"], "add_tokens": "function flatten ( arr ) { if ( ! Array . isArray ( arr ) ) return arr ; return arr . reduce ( ( acc , i ) => acc . concat ( flatten ( i ) ) , [ ] ) ; } function getAllParents ( chunkGroup ) { return chunkGroup . getParents ( ) . map ( parentGroup => [ ... parentGroup . chunks , ... getAllParents ( parentGroup ) , ] ) ; } const parents = flatten ( Array . from ( currentChunk . groupsIterable ) . map ( getAllParents ) ) ;", "del_tokens": "const parents = Array . from ( currentChunk . groupsIterable ) . reduce ( ( acc , group ) => acc . concat ( group . getParents ( ) ) , [ ] ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "a", "few", "issues", "with", "relation", "options"], "add_tokens": "* - namespace = store : if we want to use a different action namespace , other than the default \"store\" one .", "del_tokens": "* - namespace = db : if we want to use a different action namespace , other than the default \"db\" one .", "commit_type": "fix"}
{"commit_tokens": ["add", "support", "for", "COPY", "&", "MOVE", "queries"], "add_tokens": "let queries // A COPY query is rewritten into a sequence [CLEAR query, INSERT query] queries = rewritings . rewriteCopy ( update , this . _dataset ) return new ManyConsumers ( [ this . _handleClearQuery ( queries [ 0 ] , options ) , this . _handleInsertDelete ( queries [ 1 ] , options ) ] ) // A MOVE query is rewritten into a sequence [CLEAR query, INSERT query, CLEAR query] queries = rewritings . rewriteMove ( update , this . _dataset ) return new ManyConsumers ( [ this . _handleClearQuery ( queries [ 0 ] , options ) , this . _handleInsertDelete ( queries [ 1 ] , options ) , this . _handleClearQuery ( queries [ 2 ] , options ) ] )", "del_tokens": "return this . _handleInsertDelete ( rewritings . rewriteCopy ( update ) , options ) return this . _handleInsertDelete ( rewritings . rewriteMove ( update ) , options )", "commit_type": "add"}
{"commit_tokens": ["using", "targetDirectory", "in", "the", "publish", "options"], "add_tokens": "targetDirectory : 'ifrau' ,", "del_tokens": "id : 'ifrau' ,", "commit_type": "use"}
{"commit_tokens": ["Implemented", "support", "for", "connecting", "with", "an", "alternative", "id"], "add_tokens": "connection . transport . send ( connection . id , to , message ) ; * @ param { string } [ id ] An optional alternative id to be used * for the connection . By default , the agents * own id is used . Agent . prototype . connect = function ( transport , id ) { var me = this ; return Promise . all ( transport . map ( function ( t ) { return me . connect ( t , id ) ; } ) ) ; id : id || this . id ,", "del_tokens": "connection . transport . send ( this . id , to , message ) ; Agent . prototype . connect = function ( transport ) { return Promise . all ( transport . map ( this . connect . bind ( this ) ) ) ; id : this . id , var me = this ;", "commit_type": "implement"}
{"commit_tokens": ["fix", "tabbar", "-", "item", "not", "selected", "on", "mobile", "when", "click"], "add_tokens": "angular . forEach ( tabItems , function ( tabItem ) { if ( selectedTabItem != tabItem ) { tabItem . isChecked = false ; } } ) ;", "del_tokens": "// angular.forEach(tabItems, function(tabItem) { // if (selectedTabItem != tabItem) { // tabItem.showMe = false; // } // });", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "the", "append", "methods", "to", "update", "this", ".", "root"], "add_tokens": "this . root = root ; doPlayers : false", "del_tokens": "doPlayers : true", "commit_type": "fix"}
{"commit_tokens": ["fixed", "issue", "with", "argument", "ordering"], "add_tokens": "function ( paddingTop , xAxisOrient , xAxisHeight ) {", "del_tokens": "function ( xAxisOrient , xAxisHeight , paddingTop ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "Norwegian", "Gmail"], "add_tokens": "'2016/11/08 14:26、Test user <test@example.com> のメッセージ:', // Japanese A ple Mail iPhone \"tir. 18. apr. 2017 kl. 13:09 skrev Test user <test@example.com>:\" , // Norwegian Gmail it ( 'should handle Norwegian Gmail emails' , function ( ) { var parser = new Parser ( ) ; var fixture = util . getFixture ( \"email_norwegian_gmail.txt\" ) ; var email = parser . parse ( fixture ) ; var fragments = email . getFragments ( ) ; assert . equal ( fragments [ 0 ] . getContent ( ) . trim ( ) , COMMON_FIRST_FRAGMENT , \"Doesn't match common fragment\" ) ; } ) ;", "del_tokens": "'2016/11/08 14:26、Test user <test@example.com> のメッセージ:' // Japanese A ple Mail iPhone", "commit_type": "add"}
{"commit_tokens": ["remove", "enter", "-", "for", "-", "console"], "add_tokens": "var os = require ( 'os' ) ; // http://nodejs.org/api/os.html console . log ( 'http://' + os . hostname ( ) + ':' + serverState . get ( 'network' ) . get ( 'socketToConsolePort' ) ) ; }", "del_tokens": "console . log ( 'Press enter to open web console.' ) ; } // Press enter to open web console. process . stdin . on ( 'data' , function ( ) { _open ( 'http://localhost:' + serverState . get ( 'network' ) . get ( 'socketToConsolePort' ) ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Make", "MongoDB", "search", "page", "parameter", "starts", "at", "0"], "add_tokens": "var skip = limit * page || 0 ;", "del_tokens": "var skip = limit * ( page - 1 ) || 0 ;", "commit_type": "make"}
{"commit_tokens": ["added", "mochaTest", "input", "generator", "target"], "add_tokens": "normal : [ \"test/mocha/**/*.js\" ] , gen : [ \"test/mocha/input-generators/*.js\" ] grunt . registerTask ( \"default\" , [ \"jshint\" , \"mochaTest:normal\" ] ) ; grunt . registerTask ( \"test\" , [ \"mochaTest:normal\" ] ) ;", "del_tokens": "normal : [ \"test/mocha/**/*.js\" ] grunt . registerTask ( \"default\" , [ \"jshint\" , \"mochaTest\" ] ) ; grunt . registerTask ( \"test\" , [ \"mochaTest\" ] ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "RequestContext", ".", "protocol", "jsdoc"], "add_tokens": "* @ type { string }", "del_tokens": "* @ type { protocol }", "commit_type": "fix"}
{"commit_tokens": ["fixing", "*", "for", "week", "day"], "add_tokens": "} else if ( pattern . indexOf ( ',' ) !== - 1 ) { if ( weekDay === 7 ) { weekDay = 0 ;", "del_tokens": "if ( pattern === '*' ) { return true ; } } else if ( pattern . indexOf ( ',' ) !== - 1 ) { if ( weekDay === 0 ) { weekDay = 7 ;", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "mvn", "install", "for", "windows"], "add_tokens": "var cmdFile = 'mvn' ; if ( / ^win / . test ( process . platform ) ) { cmdFile = 'mvn.bat' ; }", "del_tokens": "var cmdFile = \"mvn\"", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "strings", "containing", "style", "names", "separated", "by", "space"], "add_tokens": "for ( const styleName of arg . split ( ' ' ) ) { collectedStyles . push ( style [ styleName ] ) ; }", "del_tokens": "collectedStyles . push ( style [ arg ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "getUniqueId", "helper", "to", "can", "-", "react", "component"], "add_tokens": "} // I don't like this - but there needs to be a reliable way to generate unique IDs // that are deterministic - the same on both the server and the client. This is // temporary but works until we can find a better way. Read more about it: // https://github.com/facebook/react/issues/5867 getUniqueId ( prefix ) { if ( ! this . _uniqueIdIndex ) { this . _uniqueIdIndex = 0 ; } if ( this . _reactInternalInstance && this . _reactInternalInstance . _rootNodeID ) { prefix = ( prefix || \"\" ) + this . _reactInternalInstance . _rootNodeID + \"_\" ; } return prefix + this . _uniqueIdIndex ++ ;", "del_tokens": "this . setState = this . setState . bind ( this ) ; this . forceUpdate = this . forceUpdate . bind ( this ) ;", "commit_type": "add"}
{"commit_tokens": ["improve", "(", "mock", ")", ":", "generate", "random", "dates", "for", "tasks"], "add_tokens": "var created = fixturer . randomDate ( new Date ( '1.1.2014' ) , new Date ( ) ) ; name : fixturer . thingName ( fixturer . random ( 2 , 12 ) ) , created : created , due : fixturer . randomDate ( created , new Date ( '11.29.2014' ) ) , followUp : fixturer . randomDate ( created , new Date ( '10.29.2014' ) ) , description : fixturer . thingName ( fixturer . random ( 7 , 42 ) ) , processInstanceId : null ,", "del_tokens": "name : fixturer . thingName ( ) , created : '2013-01-23T13:42:42' , due : '2013-01-23T13:49:42' , followUp : '2013-01-23T13:44:42' , description : 'aDescription' , processInstanceId : 'aProcessInstanceId' ,", "commit_type": "improve"}
{"commit_tokens": ["fixed", "typo", "on", "watch", "collection", "updated", "People", "render", "to", "use", "arrow", "function", "minified", "ngReact"], "add_tokens": "if ( watchDepth === 'collection' && angular . isFunction ( scope . $watchCollection ) ) {", "del_tokens": "if ( watchDepth === 'collection' && angular . isFunction ( scope . $watchCollections ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "element", ".", "ready", "()", "triggered", "early", "than", "tab", "menu", "item", "doms", "rendered", "when", "using", "sm", "-", "tab", "-", "menu", "in", "partial", "view"], "add_tokens": "app . directive ( 'smTabMenu' , [ 'SemanticUI' , '$browser' , function SemanticTabMenu ( SemanticUI , $browser ) $browser . notifyWhenNoOutstandingRequests ( function ( ) {", "del_tokens": "app . directive ( 'smTabMenu' , [ 'SemanticUI' , function SemanticTabMenu ( SemanticUI ) element . ready ( function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "hasOwnProperty", "check", "before", "trying", "to", "delete"], "add_tokens": "if ( this . _headers . hasOwnProperty ( 'content-length' ) ) { delete this . _headers [ 'content-length' ] ; }", "del_tokens": "delete this . _headers [ 'content-length' ] ;", "commit_type": "add"}
{"commit_tokens": ["Created", "common", "db", "middleware", "that", "covers", "most", "cases", "dealing", "with", "the", "database", "."], "add_tokens": "var db = require ( '../../db' ) ; module . exports . getByEmail = require ( '../db' ) ( db . users , db . users . getByEmail ) ; module . exports . getByLogin = require ( '../db' ) ( db . users , db . users . getByLogin ) ;", "del_tokens": "module . exports . getByEmail = require ( './getByEmail' ) ; module . exports . getByLogin = require ( './getByLogin' ) ;", "commit_type": "create"}
{"commit_tokens": ["fix", "infinite", "loop", "when", "single", "u", "is", "found", "in", "the", "value"], "add_tokens": "type : 'Identifier' , // TODO: Change type to UnicodeRange break ;", "del_tokens": "type : 'Identifier' , break ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "grunt", "-", "bump", "to", "build"], "add_tokens": "commitFiles : [ '.' ] , // '-a' for all files", "del_tokens": "commitFiles : [ '-a' ] , // '-a' for all files", "commit_type": "add"}
{"commit_tokens": ["Added", "sender", "and", "receiver", "settle", "mode", "for", "both", "sender", "and", "receiver", "nodes"], "add_tokens": "this . sndsettlemode = n . sndsettlemode this . rcvsettlemode = n . rcvsettlemode autosettle : node . autosettle , snd_settle_mode : node . sndsettlemode , rcv_settle_mode : node . rcvsettlemode this . sndsettlemode = n . sndsettlemode this . rcvsettlemode = n . rcvsettlemode //prefetch: node.prefetch, credit_window : node . prefetch , snd_settle_mode : node . sndsettlemode , rcv_settle_mode : node . rcvsettlemode", "del_tokens": "autosettle : node . autosettle console . log ( msg ) prefetch : node . prefetch ,", "commit_type": "add"}
{"commit_tokens": ["Fixed", "proxy", "to", "handlBug", "fixes"], "add_tokens": "} else if ( obj . isHash ( o ) ) { } else { ret . push ( o ) ; args . forEach ( function ( a ) { compact : function ( arr ) { if ( isArray ( arr ) && arr . length ) { ret = arr . filter ( function ( item ) { return ! misc . isUndefinedOrNull ( item ) ; } ) }", "del_tokens": "} else if ( string . isString ( o ) || date . isDate ( o ) || number . isNumber ( o ) || misc . isBoolean ( o ) ) { ret . push ( o ) ; } else if ( obj . isObject ( o ) ) { args . forEach ( function ( a ) { compact : function ( arr ) { if ( isArray ( arr ) && arr . length ) { ret = arr . filter ( function ( item ) { return ! misc . isUndefinedOrNull ( item ) ; } ) }", "commit_type": "fix"}
{"commit_tokens": ["Add", "package", "keywords", "update", "package", "name"], "add_tokens": "* * Format Definition : * http : //paulbourke.net/dataformats/ply/", "del_tokens": "// PLY Format Definition // http://paulbourke.net/dataformats/ply/", "commit_type": "add"}
{"commit_tokens": ["Updated", "original", "method", "based", "on", "feedback", "to", "improve", "efficiency", "added", "the", "inverse", "method", "(", "andGroupedOr", ")", "also"], "add_tokens": "assert . throws ( comb . hitch ( dataset , \"andGroupedOr\" , [ { a : 1 } , { y : 2 } ] ) ) ; it . describe ( \"#orGroupedAnd\" , function ( it ) { var dataset = new Dataset ( ) . from ( \"test\" ) , d1 = dataset . where ( { x : 1 } ) ; it . should ( \"raise if no filter exists\" , function ( ) { assert . throws ( comb . hitch ( dataset , \"orGroupedAnd\" , [ { a : 1 } , { y : 2 } ] ) ) ; } ) ; it . should ( \"add an additional expression of ANDed conditions wrapped in parens to the where clause\" , function ( ) { assert . equal ( d1 . orGroupedAnd ( [ [ 'x' , 2 ] , [ 'y' , 3 ] ] ) . sql , \"SELECT * FROM test WHERE ((x = 1) OR ((x = 2) AND (y = 3)))\" ) ; } ) ; } ) ;", "del_tokens": "assert . throws ( comb . hitch ( dataset , \"orGroup\" , [ { a : 1 } , { y : 2 } ] ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "helper", "functions", "that", "return", "the", "default", "config", "and", "plugins"], "add_tokens": "config : helpers . getDefaultConfig ( ) , plugins : helpers . getDefaultPlugins ( ) , config : helpers . getDefaultConfig ( ) , plugins : helpers . getDefaultPlugins ( ) , config : helpers . getDefaultConfig ( ) ,", "del_tokens": "var defaultConfig = { http : { headers : { } , maxRedirects : 5 , timeout : 5000 , withCredentials : false , } } ; var defaultPlugins = host . node ? [ { name : 'NodeUrlPlugin' , priority : 20 } , { name : 'FileSystemPlugin' , priority : 10 } , { name : 'HttpPlugin' , priority : 5 } , { name : 'BufferDecoderPlugin' , priority : 10 } , { name : 'ArrayDecoderPlugin' , priority : 5 } , { name : 'JsonPlugin' , priority : 20 } , ] : [ { name : 'BrowserUrlPlugin' , priority : 20 } , { name : 'XMLHttpRequestPlugin' , priority : 5 } , { name : 'TextDecoderPlugin' , priority : 10 } , { name : 'ArrayDecoderPlugin' , priority : 5 } , { name : 'JsonPlugin' , priority : 20 } , ] ; config : defaultConfig , plugins : defaultPlugins , config : defaultConfig , plugins : defaultPlugins , config : defaultConfig ,", "commit_type": "add"}
{"commit_tokens": ["Updating", "examples", "for", "inserts", "/", "perfs", "."], "add_tokens": "//maxFileSize: 1024*1024", "del_tokens": "maxFileSize : 1024 * 1024", "commit_type": "update"}
{"commit_tokens": ["Add", "new", "option", "for", "speech", "bubble"], "add_tokens": "const { artName , filePath , speechText , speechBubbleOptions } = options || { } ; if ( speechText ) result = ` ${ chatBubble . get ( speechText , speechBubbleOptions ) } \\n ${ result } ` ;", "del_tokens": "const { artName , filePath , speechText } = options || { } ; if ( speechText ) result = chatBubble . get ( speechText ) + '\\n \\\\\\n \\\\\\n' + result ;", "commit_type": "add"}
{"commit_tokens": ["Change", "to", "a", "relative", "path"], "add_tokens": "var reporter = require ( '../node_modules/nodeunit' ) . reporters . default ;", "del_tokens": "var reporter = require ( 'nodeunit' ) . reporters . default ;", "commit_type": "change"}
{"commit_tokens": ["Add", "missing", "semicolons", "and", "unused", "url", "variable", "removed"], "add_tokens": "} ; } ; } ; } ; } ; ret = ( error ? 1 : ( ret > 0.999 ? 1 : ret ) ) ; } ; } ; } ; } ; } ; } ; } ; } ; } ; } ; } ; } ;", "del_tokens": "} } } , } } ret = ( error ? 1 : ( ret > 0.999 ? 1 : ret ) ) } } var url = \"\" } } } } } } } } } }", "commit_type": "add"}
{"commit_tokens": ["Fix", "call", "correct", "callback", "in", "findChanges"], "add_tokens": "return cb ( null ) ;", "del_tokens": "return callback ( null ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "doc", "and", "remove", "avoid", "-", "all", "from", "default"], "add_tokens": "/ * Pagebreak plugin: Adds page - break functionality to the html2pdf library . Page - breaks can be enabled by CSS styles , set on individual elements using selectors , or avoided from breaking inside all elements . Options on the ` ` object : mode : String or array of strings : 'avoid-all' , 'css' , and / or 'legacy' Default : [ 'css' , 'legacy' ] before : String or array of CSS selectors for which to add page - breaks before each element . Can be a specific element with an ID ( '#myID' ) , all elements of a type ( e . g . 'img' ) , all of a class ( '.myClass' ) , or even '*' to match every element . after : Like 'before' , but adds a page - break immediately after the element . avoid : Like 'before' , but avoids page - breaks on these elements . You can enable this feature on every element using the 'avoid-all' mode . * / mode : [ 'css' , 'legacy' ] ,", "del_tokens": "// Add page-break functionality. mode : [ 'avoid-all' , 'css' , 'legacy' ] , // All options: 'avoid-all', 'css', 'legacy'", "commit_type": "add"}
{"commit_tokens": ["Add", "linting", "to", "core", "lib"], "add_tokens": ". then ( ( ) => action . apply ( null , args ) )", "del_tokens": ". then ( ( ) => action . apply ( null , arguments ) )", "commit_type": "add"}
{"commit_tokens": ["move", "angular", "-", "ui", "-", "tree", "from", "devDependency", "to", "dependency"], "add_tokens": "constructor ( $q , $state , $timeout ) { this . $state = $state ;", "del_tokens": "constructor ( $q , $state , $timeout ) { this . $state = $state ; mockService ( ) { let self = this ; return { mock ( data ) { let deferred = self . $q . defer ( ) ; deferred . resolve ( data ) ; return deferred . promise ; } } }", "commit_type": "move"}
{"commit_tokens": ["fixed", "race", "condition", "issue", "for", "settings", "tests"], "add_tokens": ", home = path . join ( __dirname , 'fixtures' , 'home' ) , rcpath = path . join ( home , '.cardinalrc' ) // Get all results synchronously to avoid tests from interfering with each other var norcTheme = settings . resolveTheme ( home ) , namedTheme = resolveTheme ( { theme : \"hide-semicolons\" } ) , pathTheme = resolveTheme ( { theme : path . join ( __dirname , '..' , 'themes' , 'hide-semicolons.js' ) } ) t . equals ( norcTheme , undefined , 'resolves no theme' ) t . deepEquals ( namedTheme , hideSemicolonsTheme , 'resolves hide-semicolons theme' ) t . deepEquals ( pathTheme , hideSemicolonsTheme , 'resolves hide-semicolons theme' )", "del_tokens": ", home = path . join ( __dirname , 'fixtures' , 'home' ) , rcpath = path . join ( home , '.cardinalrc' ) var theme = settings . resolveTheme ( home ) t . equals ( theme , undefined , 'resolves no theme' ) var theme = resolveTheme ( { theme : \"hide-semicolons\" } ) t . deepEquals ( theme , hideSemicolonsTheme , 'resolves hide-semicolons theme' ) var theme = resolveTheme ( { theme : path . join ( __dirname , '..' , 'themes' , 'hide-semicolons.js' ) } ) t . deepEquals ( theme , hideSemicolonsTheme , 'resolves hide-semicolons theme' )", "commit_type": "fix"}
{"commit_tokens": ["fix", "string", "getting", "an", "undefined", "value"], "add_tokens": "return str ? str . replace ( STRING_DECAMELIZE_REGEXP , '$1_$2' ) . toLowerCase ( ) : '' ;", "del_tokens": "return str . replace ( STRING_DECAMELIZE_REGEXP , '$1_$2' ) . toLowerCase ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "cluster", "start", "time", "for", "workers"], "add_tokens": "var numCPUs = require ( 'os' ) . cpus ( ) . length , clusterStartTime = Date . now ( ) , newWorkerEnv = { } ; newWorkerEnv . clusterStartTime = clusterStartTime ; cluster . fork ( newWorkerEnv ) ; cluster . fork ( newWorkerEnv ) ; if ( process . env . clusterStartTime ) { process . clusterStartTime = new Date ( parseInt ( process . env . clusterStartTime , 10 ) ) ; }", "del_tokens": "var numCPUs = require ( 'os' ) . cpus ( ) . length ; cluster . fork ( ) ; cluster . fork ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "unnecessary", "prefixes", "from", "fallback"], "add_tokens": "document . mozVisibilityState ) {", "del_tokens": "document . msVisibilityState || document . mozVisibilityState || document . oVisibilityState ) {", "commit_type": "remove"}
{"commit_tokens": ["Add", "method", "to", "get", "a", "registred", "metric"], "add_tokens": "var getSingleMetric = function getSingleMetric ( name ) { return metrics [ name ] ; } ; removeSingleMetric : removeSingleMetric , getSingleMetric : getSingleMetric", "del_tokens": "removeSingleMetric : removeSingleMetric", "commit_type": "add"}
{"commit_tokens": ["fixing", "chain", "()", "test", "."], "add_tokens": "[ 4 , 8 ] ) ;", "del_tokens": "[ 8 , 4 ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["changed", "observer", "on", "repeat", "to", "use", "same", "fn", "for", "items", "and", "filter"], "add_tokens": "this . __templateGetBinding ( propName ) . annotate ( new NotifyAnnotation ( this , propName ) ) ;", "del_tokens": "this . __templateGetBinding ( propName ) . annotations . push ( new NotifyAnnotation ( this , propName ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Updated", "loaderContext", ".", "emitFile", "to", "account", "for", "new", "argument", "in", "Webpack", "5"], "add_tokens": "// Webpack 5 added the assetInfo argument. // Capture all args so it'll work in Webpack 4+. loaderContext . emitFile = ( ... args ) => { const [ name ] = args ; return emitFile . apply ( module , args ) ;", "del_tokens": "loaderContext . emitFile = ( name , content , sourceMap ) => { return emitFile . call ( module , name , content , sourceMap ) ;", "commit_type": "update"}
{"commit_tokens": ["Make", "stack", "trace", "for", "trying", "to", "load", "default", "config", "a", "node", "debug"], "add_tokens": "var debug = require ( 'debug' ) ( 'blueprints' ) ; debug ( e ) ;", "del_tokens": "console . trace ( e ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "comment", "about", "default", "state", "[", "ci", "skip", "]"], "add_tokens": "* @ param { Array } [ collectionState = [ ] ] - Redux state of current collection", "del_tokens": "* @ param { Array } collectionState - Redux state of current collection", "commit_type": "add"}
{"commit_tokens": ["Updating", "test", "to", "verify", "an", "exception", "is", "not", "thrown", "."], "add_tokens": "expect ( ( ) => { instance . clear ( ) ; } ) . to . not . throw ( \"adSlot.getServices is not a function\" ) ;", "del_tokens": "instance . clear ( ) ;", "commit_type": "update"}
{"commit_tokens": ["Make", "IE", "unit", "test", "happy", "."], "add_tokens": "if ( input . attributes ) { if ( input . attributes instanceof Array ) { // probably evaluating on document created by xmlParse() copyArray ( nodelist , input . attributes ) ; } else { nodelist . push ( input . attributes [ this . nodetest . name ] ) ; }", "del_tokens": "if ( input . attributes instanceof Array ) { // probably evaluating on document created by xmlParse() copyArray ( nodelist , input . attributes ) ; } else { nodelist . push ( input . attributes [ this . nodetest . name ] ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "option", "to", "also", "show", "types", "for", "members", "."], "add_tokens": "Session . setDefault ( \"showAllTypes\" , false ) ; Template . nav . events ( { \"change .show-all-types input\" : function ( event ) { Session . set ( \"showAllTypes\" , event . target . checked ) ; } } ) ; } , showPropertyTypes : function ( ) { return Session . get ( \"showAllTypes\" ) ; } ,", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Update", "to", "use", "Symbol", "instead", "of", "__inSetup", "property"], "add_tokens": "var canSymbol = require ( 'can-symbol' ) ; var inSetupSymbol = canSymbol . for ( \"can.initializing\" ) ; if ( ! this [ inSetupSymbol ] ) {", "del_tokens": "if ( ! this . __inSetup ) {", "commit_type": "update"}
{"commit_tokens": ["add", "minimal", "argument", "parsing", "and", "allow", "showing", "builtins", "and", "/", "or", "local", "files", "conditionally"], "add_tokens": ", argv = require ( 'minimist' ) ( process . argv . slice ( 2 ) ) name = path . basename ( dir ) ; } , { showLocal : Boolean ( argv . l ) , showBuiltins : Boolean ( argv . b ) } ) ;", "del_tokens": "name = path . basename ( dir ) . replace ( / (\\.js) / , \"\" ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "$eval", "instead", "of", "$apply", "in", "loadTemplate", "()"], "add_tokens": "scope . $eval ( function ( ) {", "del_tokens": "scope . $apply ( function ( ) {", "commit_type": "use"}
{"commit_tokens": ["Implemented", "pos", "nn", "yh", "updated", "rules", "added", "tests", "fixed", "Shevchenko", "s", "portrait", "size"], "add_tokens": "const posNnYhStructure = require ( \"./nn/pos-yh/structure.json\" ) ; const posNnYh = new NeuralNetwork ( posNnYhStructure ) ; const posNnYhCache = require ( \"./nn/pos-yh/data/samples.json\" ) . filter ( ( sample ) => NeuralNetwork . isValidPosName ( sample . pos ) ) . filter ( ( sample ) => sample . pos !== posNnYh . run ( sample . value ) ) . reduce ( ( cache , sample ) => ( cache [ sample . value ] = sample . pos , cache ) , { } ) ; \"__pos_nn_a_ya_structure__\" : JSON . stringify ( posNnAYaStructure ) , \"__pos_nn_oi_yi_ii_structure__\" : JSON . stringify ( posNnOiYiIiStructure ) , \"__pos_nn_yh_structure__\" : JSON . stringify ( posNnYhStructure ) , \"__pos_nn_yh_cache__\" : JSON . stringify ( process . env . NODE_ENV === \"test\" ? { } : posNnYhCache ) ,", "del_tokens": "\"__pos_nn_a_ya_structure___\" : JSON . stringify ( posNnAYaStructure ) , \"__pos_nn_oi_yi_ii_structure___\" : JSON . stringify ( posNnOiYiIiStructure ) ,", "commit_type": "implement"}
{"commit_tokens": ["Add", "timeout", "to", "Dgram", "async", "test"], "add_tokens": "import { expect } from 'chai' import DatagramPlugin from '../../src/plugin/dgram' setTimeout ( ( ) => ! resolved && reject ( new Error ( 'Timeout' ) ) , 1000 )", "del_tokens": "import chai , { expect } from 'chai' import DatagramPlugin from '../../src/plugin/dgram' setTimeout ( ( ) => ! resolved && reject ( ) , 1000 )", "commit_type": "add"}
{"commit_tokens": ["Use", "~", "for", "pre", "-", "release", "versions", "for", "proper", "debian", "package", "version", "comparison"], "add_tokens": "// Use '~' on pre-releases for proper debain version ordering. // See https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version version : ( pkg . version || '0.0.0' ) . replace ( / (\\d)[_\\.\\-\\+]?((RC|rc|pre|dev|beta|alpha)[_\\.\\-\\+]?\\d*)$ / , '$1~$2' ) ,", "del_tokens": "version : pkg . version || '0.0.0' ,", "commit_type": "use"}
{"commit_tokens": ["Add", "prerender", "to", "manage", "crawling"], "add_tokens": "define ( 'hr/args' , [ ] , function ( ) { return { \"revision\" : 1381188513589 , \"baseUrl\" : \"/\" } ; } ) ;", "del_tokens": "define ( 'hr/args' , [ ] , function ( ) { return { \"revision\" : 1381188158295 , \"baseUrl\" : \"/\" } ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "filtering", "by", "query", "parameter"], "add_tokens": "request ( app ) . get ( '/users' ) . query ( { name : 'Bob' } ) . end ( function ( err , res ) { expect ( res . body [ 0 ] . name ) . to . equal ( 'Bob' ) ; done ( ) ; } ) ; } ) ; it ( 'should prevent access of hidden fields' , function ( done ) { request ( app ) . get ( '/users' ) . query ( { password : 'hunter2' } ) . end ( function ( err , res ) { expect ( err ) . to . be . null ; expect ( res . status ) . to . equal ( 401 ) ; done ( ) ;", "del_tokens": "request ( app ) . get ( '/users?name=Bob' ) . end ( function ( err , res ) { expect ( res . body [ 0 ] ) . name . to . equal ( 'Bob' ) ;", "commit_type": "add"}
{"commit_tokens": ["Create", "and", "test", "rule", "-", "set", "-", "no", "-", "single", "-", "line"], "add_tokens": "* Check if a * trimmed * string is a single line ( i . e . does not contain * any newline characters ) . * * The fact that it ' * beginning or end will be ignored .", "del_tokens": "* Check if a string is a single line ( i . e . does not contain * any newline characters )", "commit_type": "create"}
{"commit_tokens": ["Add", "start", "and", "stop", "app", "commands"], "add_tokens": "return await this . proxyCommand ( ` ${ windowHandle } ` , 'GET' ) ; } else { return await this . executeAtom ( 'get_window_size' , [ ] ) ; commands . launchApp = iosCommands . general . launchApp ; commands . closeApp = iosCommands . general . closeApp ;", "del_tokens": "throw new errors . UnknownCommandError ( 'This method should be proxied to WDA' ) ; return await this . executeAtom ( 'get_window_size' , [ ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "request", "instance", "in", "before", "handler"], "add_tokens": "return function ( self ) { self . before ( function ( req ) { self . always ( function ( ) {", "del_tokens": "return function ( req ) { req . before ( function ( ) { req . always ( function ( ) {", "commit_type": "use"}
{"commit_tokens": ["Added", "raster", "-", "dem", "to", "fixRasterSource", "."], "add_tokens": "if ( ( source . type === 'raster' || source . type === 'raster-dem' ) && source . tileSize && source . tiles ) { if ( ( source . type === 'raster' || source . type === 'raster-dem' ) && source . url ) {", "del_tokens": "if ( source . type === 'raster' && source . tileSize && source . tiles ) { if ( source . type === 'raster' && source . url ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "events", "hash", "being", "reset", "to", "empty", "after", "child", "collections", "were", "initialized"], "add_tokens": "this . _events = { } ;", "del_tokens": "this . _events = { } ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "lng", "-", "from", "-", "req", "functionality", "for", "proper", "fallbacks"], "add_tokens": "import { lngFromReq , lngPathCorrector } from 'utils' initialLanguage = lngFromReq ( req )", "del_tokens": "import { lngPathCorrector } from 'utils' // First language in array is current lang [ initialLanguage ] = req . i18n . languages", "commit_type": "add"}
{"commit_tokens": ["fixed", "extendObject", "/", "readJSON", "/", "readYAML", "deep", "merging"], "add_tokens": "ret = lib . copyTo ( ret , arg ) ; ret = lib . copyTo ( ret , grunt . file . readJSON ( arg ) ) ; ret = lib . copyTo ( ret , arg ) ; ret = lib . copyTo ( ret , grunt . file . readYAML ( arg ) ) ; ret = lib . copyTo ( ret , arg ) ;", "del_tokens": "grunt . util . _ . extend ( ret , arg ) ; ret = grunt . util . _ . extend ( ret , grunt . file . readJSON ( arg ) ) ; ret = grunt . util . _ . extend ( ret , arg ) ; grunt . util . _ . extend ( ret , grunt . file . readYAML ( arg ) ) ; grunt . util . _ . extend ( ret , arg ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "support", "for", "options", "as", "second", "argument"], "add_tokens": "describe ( 'as second argument' , ( ) => { it ( 'throws an error' , ( ) => { expect ( ( ) => { createCachedSelector ( ( ) => { } ) ( ( ) => { } , { } ) ; } ) . toThrow ( / \"options\" as second argument is not supported anymore / ) ;", "del_tokens": "describe ( 'as function + object' , ( ) => { it ( 'accepts keySelector function + option object' , ( ) => { const keySelectorMock = ( ) => { } ; const cachedSelector = createCachedSelector ( resultFuncMock ) ( keySelectorMock , { cacheObject : new LruObjectCache ( { cacheSize : 10 } ) , } ) ; expect ( cachedSelector . keySelector ) . toBe ( keySelectorMock ) ; expect ( cachedSelector . cache ) . toBeInstanceOf ( LruObjectCache ) ;", "commit_type": "remove"}
{"commit_tokens": ["Allow", "configDependencies", "to", "be", "specified", "."], "add_tokens": "var configDependencies = [ '@loader' , 'npm-extension' ] . concat ( packageDependencies ( pkg ) ) ; return \"define(\" + JSON . stringify ( configDependencies ) + \", function(loader, npmExtension){\\n\" + // Dependencies from a package.json file specified in `system.configDependencies` function packageDependencies ( pkg ) { if ( pkg . system && pkg . system . configDependencies ) { return pkg . system . configDependencies ; } return [ ] ; }", "del_tokens": "return \"define(['@loader','npm-extension'], function(loader, npmExtension){\\n\" +", "commit_type": "allow"}
{"commit_tokens": ["Fix", "a", "number", "of", "issues", ".", "Connect", "/", "disconnect", "has", "been", "worked", "around", "."], "add_tokens": "// no need to announce... can get spammy in chat // socket.broadcast.emit('announcement', name + ' connected.'); function removeCurrentUser ( ) { // no need to announce... can get spammy in chat // socket.broadcast.emit('announcement', socket.nickname + ' disconnected.'); io . sockets . emit ( 'usernames' , usernames ) ; } socket . on ( 'disconnect' , removeCurrentUser ) ; socket . on ( 'logout' , removeCurrentUser ) ;", "del_tokens": "socket . broadcast . emit ( 'announcement' , name + ' connected.' ) ; socket . on ( 'disconnect' , function ( ) { socket . broadcast . emit ( 'announcement' , socket . nickname + ' disconnected.' ) ; socket . broadcast . emit ( 'usernames' , usernames ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "test", "for", "r", ".", "js", "optimization"], "add_tokens": "var cfg = { \"modules\" : [ \"physicsjs/geometries/circle\" , \"physicsjs/geometries/convex-polygon\" , \"physicsjs/bodies/circle\" , \"physicsjs/bodies/convex-polygon\" , \"physicsjs/bodies/point\" , \"physicsjs/behaviors/body-collision-detection\" , \"physicsjs/behaviors/body-impulse-response\" , \"physicsjs/behaviors/constant-acceleration\" , \"physicsjs/behaviors/edge-collision-detection\" , \"physicsjs/behaviors/newtonian\" , \"physicsjs/behaviors/rigid-constraint-manager\" , \"physicsjs/behaviors/sweep-prune\" , \"physicsjs/behaviors/verlet-constraints\" , \"physicsjs/integrators/improved-euler\" , \"physicsjs/renderers/canvas\" , \"physicsjs/renderers/dom\" ] } ;", "del_tokens": "var cfg = { \"modules\" : [ \"physicsjs/geometries/circle.js\" , \"physicsjs/geometries/convex-polygon.js\" , \"physicsjs/bodies/circle.js\" , \"physicsjs/bodies/convex-polygon.js\" , \"physicsjs/bodies/point.js\" , \"physicsjs/behaviors/body-collision-detection.js\" , \"physicsjs/behaviors/body-impulse-response.js\" , \"physicsjs/behaviors/constant-acceleration.js\" , \"physicsjs/behaviors/edge-collision-detection.js\" , \"physicsjs/behaviors/newtonian.js\" , \"physicsjs/behaviors/rigid-constraint-manager.js\" , \"physicsjs/behaviors/sweep-prune.js\" , \"physicsjs/behaviors/verlet-constraints.js\" , \"physicsjs/integrators/improved-euler.js\" , \"physicsjs/renderers/canvas.js\" , \"physicsjs/renderers/dom.js\" ] } ;", "commit_type": "add"}
{"commit_tokens": ["Use", "HTML", "comment", "for", "fastboot", "injected", "body", "."], "add_tokens": "// do nothing unless running `ember fastboot` command if ( ! process . env . EMBER_CLI_FASTBOOT ) { return ; } return \"<!-- EMBER_CLI_FASTBOOT_BODY -->\" ;", "del_tokens": "// When using a dist built html file, we need to reinsert // content-for body so fastboot can insert its content. return \"{{content-for 'body'}}\" ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "deprecation", "warning", "in", "for", "using", "EmberApp", ".", "concatFiles"], "add_tokens": "return originalConcatFiles . apply ( this , arguments ) ;", "del_tokens": "return originalConcatFiles . call ( this , tree , options ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "end", "semicolons", "to", "css", "text"], "add_tokens": "'image-orientation:0deg!important;\"' 'transform:' + getTransform ( imageData ) + ';'", "del_tokens": "'image-orientation:0deg!important\"' 'transform:' + getTransform ( imageData )", "commit_type": "add"}
{"commit_tokens": ["Updated", "association", "setters", "to", "be", "able", "to", "handle", "many", "sequential", "updates", "."], "add_tokens": "promise = model . findByIdAndUpdate ( _id , { isDeleted : true , deletedAt : new Date ( ) } , { new : true } ) ; promise = Q . all ( ownerModel . findByIdAndUpdate ( ownerObject . _id , ownerObject ) , childModel . findByIdAndUpdate ( childObject . _id , childObject ) ) ; promise = Q . all ( ownerModel . findByIdAndUpdate ( ownerObject . _id , ownerObject ) , childModel . findByIdAndUpdate ( childObject . _id , childObject ) ) ;", "del_tokens": "promise = model . findByIdAndUpdate ( _id , { isDeleted : true , deletedAt : new Date ( ) } ) ; promise = Q . all ( ownerObject . save ( ) , childObject . save ( ) ) ; promise = Q . all ( ownerObject . save ( ) , childObject . save ( ) ) ;", "commit_type": "update"}
{"commit_tokens": ["fix", "an", "issue", "in", "browser", "which", "doesn", "t", "have", "terminate", "method", "on", "WebSocket", "."], "add_tokens": "if ( this . ws . terminate ) { this . ws . terminate ( ) ; } else { this . ws . close ( ) ; }", "del_tokens": "this . ws . terminate ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["adds", "and", "exposes", "some", "new", "methods"], "add_tokens": "var ISO3166 = require ( './src/index.js' ) ; module . exports = ISO3166 ;", "del_tokens": "var iso3166 = require ( './src/index.js' ) ; module . exports = iso3166 ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "magic", "color", "matching", "from", "config"], "add_tokens": "const color = borders . defaults . color", "del_tokens": "import findColor from '../util/findColor' const color = findColor ( colors , borders . defaults . color )", "commit_type": "remove"}
{"commit_tokens": ["Fix", "for", "bouncing", "save", "button", "."], "add_tokens": "app . directive ( 'formBuilder' , [ '$timeout' , function ( $timeout ) { ] , link : function ( ) { $timeout ( function ( ) { var child = angular . element ( '.formcomponents' ) . children ( ) [ 0 ] ; angular . element ( '.formcomponents' ) . height ( ( angular . element ( child ) . outerHeight ( ) + 20 ) + 'px' ) ; } , 200 ) ; } } ] ) ;", "del_tokens": "app . directive ( 'formBuilder' , function ( ) { ] } ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "check", "for", "entities", "property"], "add_tokens": "if ( el . entities && el . entities . media && el . entities . media . length ) { else if ( el . entities && el . entities . urls && el . entities . urls . length && el . entities . urls [ 0 ] . display_url ) {", "del_tokens": "if ( el . entities . media && el . entities . media . length ) { else if ( el . entities . urls . length && el . entities . urls [ 0 ] . display_url ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "unit", "tests", "for", "request", ".", "put"], "add_tokens": "nockObj . matchRequestBody = function ( path , method , match , options ) { options = options || { } ; var statusCode = options . statusCode || 200 , statusText = options . statusText || '200 OK' ; . reply ( statusCode , statusText ) ; / ** * Whether or not an error is thrown in the promise , * the mock should have intercepted the request . * /", "del_tokens": "nockObj . matchRequestBody = function ( path , method , match ) { . reply ( 200 , '200 OK' ) ; // Whether or not an error is thrown, the mock should have intercepted // the PROPFIND request. Should replace with Promise.prototype.finally.", "commit_type": "add"}
{"commit_tokens": ["Add", "end", "()", "function", "to", "kill", "child", "processes"], "add_tokens": "pipService . end ( ) ;", "del_tokens": "process . exit ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "batch", "processor", "a", "submodule"], "add_tokens": "function Processor ( options ) { Processor . prototype = { exports . Processor = Processor ;", "del_tokens": "function BatchProcessor ( options ) { BatchProcessor . prototype = { exports . BatchProcessor = BatchProcessor ;", "commit_type": "make"}
{"commit_tokens": ["update", "token", "docs", "and", "example"], "add_tokens": "// Note: These events are only emitted when the newly-retrieved token is CHANGED or NEW.", "del_tokens": "// Note: These events are only emitted when the newly-retrieved token has CHANGED from the stored token.", "commit_type": "update"}
{"commit_tokens": ["add", "prevent", "default", "to", "links"], "add_tokens": "preventDefault : function ( e ) { e . preventDefault ( ) ; } , < a href = '#' onClick = { this . preventDefault } > < i className = 'glyphicon glyphicon-chevron-left' / > < / a > < a href = '#' onClick = { this . preventDefault } > < i className = 'glyphicon glyphicon-chevron-right' / > < / a > < a href = '#' onClick = { this . preventDefault } > { n } < / a >", "del_tokens": "< a href = '#' > < i className = 'glyphicon glyphicon-chevron-left' / > < / a > < a href = '#' > < i className = 'glyphicon glyphicon-chevron-right' / > < / a > < a href = '#' > { n } < / a >", "commit_type": "add"}
{"commit_tokens": ["Making", "selectors", "for", "steps", "more", "specific"], "add_tokens": "var $steps = this . $element . find ( '.steps li' ) ; var prevSelector = '.steps li:lt(' + ( this . currentStep - 1 ) + ')' ; var currentSelector = '.steps li:eq(' + ( this . currentStep - 1 ) + ')' ; this . $element . find ( '.step-pane' ) . removeClass ( 'active' ) ;", "del_tokens": "var $steps = this . $element . find ( 'li' ) ; var prevSelector = 'li:lt(' + ( this . currentStep - 1 ) + ')' ; var currentSelector = 'li:eq(' + ( this . currentStep - 1 ) + ')' ; $ ( '.step-pane' ) . removeClass ( 'active' ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "button", "+", "axis", "events"], "add_tokens": "this . emit ( name , gamepad , button , value ) ; var name = 'gamepadaxismove' ; this . emit ( name , gamepad , axis , value ) ; utils . triggerEvent ( window , name , data ) ;", "del_tokens": "this . emit ( name , gamepad ) ; this . emit ( 'gamepadaxismove' , gamepad ) ; utils . triggerEvent ( window , 'gamepadaxismove' , data ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "Icon", "component", "for", "using", "external", "definition", "svgs"], "add_tokens": "import { Icon } from './Icon' ; < h1 > Componentry < / h1 > < div > < span > This is the chevron icon: < Icon icon = 'chevron' / > < br / > < / span > < span > This is the heart icon: < Icon icon = 'heart' / > < br / > < / span > < span > This is the close icon: < Icon icon = 'close' / > < br / > < / span > < span > This icon is not intended to be a font icon, so it&apos;s baseline will not be adjusted: < Icon icon = 'close' font = { false } / > < / span > < / div >", "del_tokens": "< h1 > Radical UI < / h1 >", "commit_type": "add"}
{"commit_tokens": ["Improve", "performance", "for", "normal", "text"], "add_tokens": "if ( ! txt ) return '' ; if ( ! / \\r / . test ( txt ) ) return txt ; while ( / \\r[^$] / . test ( txt ) ) { var base = / ^(.*)\\r+ / m . exec ( txt ) [ 1 ] ; var insert = / \\r+(.*)$ / m . exec ( txt ) [ 1 ] ; insert = insert + base . slice ( insert . length , base . length ) ; txt = txt . replace ( / \\r+.*$ / m , '\\r' ) . replace ( / ^.*\\r / m , insert ) ;", "del_tokens": "if ( ! txt ) return '' ; while ( txt . search ( / \\r[^$] / g ) > - 1 ) { var base = txt . match ( / ^(.*)\\r+ / m ) [ 1 ] ; var insert = txt . match ( / \\r+(.*)$ / m ) [ 1 ] ; insert = insert + base . slice ( insert . length , base . length ) ; txt = txt . replace ( / \\r+.*$ / m , '\\r' ) . replace ( / ^.*\\r / m , insert ) ;", "commit_type": "improve"}
{"commit_tokens": ["Changed", "name", "of", "local", "created", "test", "private", "keys", "."], "add_tokens": "privateKey = fs . readFileSync ( '.test-account.key' ) . toString ( ) ; fs . writeFileSync ( '.test-account.key' , privateKey ) ;", "del_tokens": "privateKey = fs . readFileSync ( '.make-providers-account' ) . toString ( ) ; fs . writeFileSync ( '.make-providers-account' , privateKey ) ;", "commit_type": "change"}
{"commit_tokens": ["Remove", "reference", "to", "a", "variable", "that", "does", "not", "exist"], "add_tokens": "this . error ( 'NO_END_BRACKET' , 'The end of the string reached with no closing bracket ' + end + ' found.' ) ;", "del_tokens": "this . error ( characterParserErrCode [ ex . code ] , 'The end of the string reached with no closing bracket ' + end + ' found.' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "build", "process", "add", "mixin", "to", "dist", "folder"], "add_tokens": "return obj && typeof obj === 'object' ; function isPlainObject ( obj ) { return isObject ( obj ) && isFunction ( obj . constructor ) && isObject ( obj . constructor . prototype ) && obj . constructor . prototype . hasOwnProperty ( 'isPrototypeOf' ) ; } function merge ( destination , source , key ) { // if source and destination are both plain objects if ( isPlainObject ( destination ) && isPlainObject ( source ) ) { // shallow merge properties into destination object for ( key in source ) { destination [ key ] = source [ key ] ; return destination ; // otherwise, just return source return source ;", "del_tokens": "return obj && typeof obj === 'object' && ( typeof obj . length !== 'number' || ! isFunction ( obj . splice ) ) ; function merge ( source , dest , key ) { // if source and dest are objects, shallow merge properties into new object if ( isObject ( source ) && isObject ( dest ) ) { // shallow merge for ( key in dest ) { source [ key ] = dest [ key ] ; return source ; // otherwise, just return dest return dest ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "windows", "."], "add_tokens": "var child ; if ( process . platform === 'win32' ) { child = spawn ( 'cmd' , [ '/s' , '/c' , opt . cmd ] , { cwd : opt . cwd } ) ; } else { child = spawn ( 'sh' , [ '-c' , opt . cmd ] , { cwd : opt . cwd } ) ; } var separator = '\\n' + utils . string . repeat ( '-' , 30 ) + '\\n' ; } else {", "del_tokens": "colors = require ( 'colors' ) , // TODO: add support for windows var child = spawn ( '/bin/sh' , [ '-c' , opt . cmd ] , { 'cwd' : opt . cwd } ) ; var separator = '\\n' + utils . string . repeat ( '-' , 30 ) + '\\n' ; } else {", "commit_type": "add"}
{"commit_tokens": ["Add", "wallet", "and", "wallet", "transaction", "list", "directives"], "add_tokens": "< div id = \"ows-keypad\" > \\", "del_tokens": "< div id = \"ows-keypad\" ng-controller = \"OWSKeypadCtrl\" > \\", "commit_type": "add"}
{"commit_tokens": ["Added", "optional", "titles", "to", "sections", "."], "add_tokens": "return { content : replace ( content , pkg ) , title : replace ( title || \"\" , pkg ) } ;", "del_tokens": "return { content : replace ( content , pkg ) , title : replace ( title , pkg ) } ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "model", "lookup", "to", "refect", "the", "actual", "model", "database", "."], "add_tokens": "var model = this . db . models [ type ] ;", "del_tokens": "var model = mongoose . models [ type ] ;", "commit_type": "change"}
{"commit_tokens": ["added", "support", "for", "parsing", "one", "feature"], "add_tokens": "const util = require ( 'util' ) ; GeoJSON . version = '0.3.1' ; var geojson , if ( util . isArray ( objects ) ) { geojson = { \"type\" : \"FeatureCollection\" , \"features\" : [ ] } ; objects . forEach ( function ( item ) { geojson . features . push ( getFeature ( item , settings , propFunc ) ) ; } ) ; addOptionals ( geojson , settings ) ; } else { geojson = getFeature ( objects , settings , propFunc ) ; }", "del_tokens": "GeoJSON . version = '0.3.0' ; var geojson = { \"type\" : \"FeatureCollection\" , \"features\" : [ ] } , objects . forEach ( function ( item ) { geojson . features . push ( getFeature ( item , settings , propFunc ) ) ; } ) ; addOptionals ( geojson , settings ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "tests", "work", "in", "a", "broader", "range", "of", "timezones", "."], "add_tokens": "lastmod : new Date ( '1995-12-17T12:24:00' )", "del_tokens": "lastmod : new Date ( '1995-12-17T03:24:00' )", "commit_type": "make"}
{"commit_tokens": ["updated", "known", "limitations", "to", "include", "Firefox", "25", "info", "for", "both", "WebAudo", "and", "Sound"], "add_tokens": "* < b > Firefox 25 Web Audio limitations < / b > * < ul > < li > mp3 audio files do not load properly on all windows machines, reported * < a href = \"https://bugzilla.mozilla.org/show_bug.cgi?id=929969\" target = \"_blank\" > here < / a > . < / br> * For this reason it is recommended to pass ogg file first until this bug is resolved , if possible . < / li>< / ul >", "del_tokens": "* < b > Android HTML Audio Chrome 26.0.1410.58+ specific limitations < / b > < br / > * < ul > < li > Chrome reports true when you run createjs.Sound.BrowserDetect.isChrome, but is a different browser * with different abilities . < / li> * < li > Can only play 1 sound at a time. < / li > * < li > Sound is not cached. < / li > * < li > Sound can only be loaded in a user initiated touch/click event. < / li > * < li > There is a delay before a sound is played, presumably while the src is loaded. < / li > * < / ul >", "commit_type": "update"}
{"commit_tokens": ["Added", "percent", "to", "pinch", "options"], "add_tokens": "this . percent = options . percent || 1.0 const change = ( ( dist - last ) / this . parent . screenWidth ) * this . parent . container . scale . x * this . percent", "del_tokens": "const change = ( ( dist - last ) / this . parent . screenWidth ) * this . parent . container . scale . x", "commit_type": "add"}
{"commit_tokens": ["fixed", "tests", "for", "Kindle", "fire"], "add_tokens": "wru . assert ( 'detail not attached' , e . detail == null ) ; wru . assert ( 'detail not attached' , e . detail == null ) ;", "del_tokens": "wru . assert ( 'detail not attached' , e . detail === null ) ; wru . assert ( 'detail not attached' , e . detail === null ) ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "example", "beacon", "colous", "added", "sorting", "beacon", "list", "."], "add_tokens": "'style-color-unknown style-color-unknown-text' , 'style-color-mint style-color-mint-text' , 'style-color-ice style-color-ice-text' , 'style-color-blueberry-dark style-color-blueberry-dark-text' , 'style-color-white style-color-white-text' , 'style-color-transparent style-color-transparent-text' ] ; // Clear beacon HTML items. // Sort beacons by signal strength. beaconInfo . beacons . sort ( function ( beacon1 , beacon2 ) { return beacon1 . rssi > beacon2 . rssi ; } ) ; // Generate HTML for beacons. var colorClasses = beaconColorStyle ( beacon . color ) ; htm = '<div class=\"' + colorClasses + '\">' // Clear beacon HTML items. // Sort beacons by distance. beaconInfo . beacons . sort ( function ( beacon1 , beacon2 ) { return beacon1 . distance > beacon2 . distance ; } ) ; // Generate HTML for beacons. var colorClasses = beaconColorStyle ( beacon . color ) ; htm = '<div class=\"' + colorClasses + '\">'", "del_tokens": "'style-color-unknown' , 'style-color-mint' , 'style-color-ice' , 'style-color-blueberry' , 'style-color-white' , 'style-color-transparent' ] ; var color = beaconColorStyle ( beacon . color ) ; htm = '<div class=\"' + color + '\">' var color = beaconColorStyle ( beacon . color ) ; htm = '<div class=\"' + color + '\">'", "commit_type": "update"}
{"commit_tokens": ["Make", "securestorage", "a", "factory", "takes", "a", "service", "name", "in", "the", "constructor"], "add_tokens": "return false ; return true ; } ; var SecureStorage = function ( service ) { this . service = service ; return this ; SecureStorage . prototype = { cordova . exec ( success , error , \"SecureStorage\" , \"get\" , [ key , this . service ] ) ; cordova . exec ( success , error , \"SecureStorage\" , \"set\" , [ key , value , this . service ] ) ; cordova . exec ( success , error , \"SecureStorage\" , \"remove\" , [ key , this . service ] ) ;", "del_tokens": "return ; var SecureStorage = { cordova . exec ( success , error , \"SecureStorage\" , \"remove\" , [ key ] ) ; cordova . exec ( success , error , \"SecureStorage\" , \"remove\" , [ key , value ] ) ; cordova . exec ( success , error , \"SecureStorage\" , \"remove\" , [ key ] ) ;", "commit_type": "make"}
{"commit_tokens": ["Implement", "glob", "pattern", "resolve", "test", "for", "gulp", "-", "hub", "module"], "add_tokens": "// Happy-path proxyquire dependencies, i.e., dependencies that will allow // gulp-hub to complete without errors // Proxyquire gulp-hub, optionally extending the happy-path proxy dependencies it ( 'resolves a glob pattern to a file list' , function ( ) { var resolveGlobSpy = sinon . spy ( ) ; var hub = getHub ( { './resolve-glob' : resolveGlobSpy } ) ; hub ( 'test-pattern' ) ; resolveGlobSpy . calledOnce . should . be . true ; resolveGlobSpy . calledWith ( 'test-pattern' ) ; } ) ;", "del_tokens": "// Happy-path proxyquire dependencies, i.e., dependencies that will allow gulp- // hub to complete without errors // Proxyquire a gulp-hub object, optionally extending the happy path dependencies it ( 'resolves a glob pattern to a file list' ) ;", "commit_type": "implement"}
{"commit_tokens": ["Added", "a", "default", "provider", "path"], "add_tokens": "var providerPath = __dirname + \"/\" + ( configuration . providersPath || \".\" ) + \"/\" + config . type", "del_tokens": "var providerPath = configuration . providersPath + \"/\" + config . type", "commit_type": "add"}
{"commit_tokens": ["Allow", "the", "StubbedSession", "to", "consume", "stubs", "on", "use"], "add_tokens": "var _getClient = function ( consumeStubs ) { return tempoiq . Client ( \"stubbed_key\" , \"stubbed_secret\" , \"stubbed_host\" , { secure : false , session : new StubbedSession ( consumeStubs ) } )", "del_tokens": "var _getClient = function ( ) { return tempoiq . Client ( \"stubbed_key\" , \"stubbed_secret\" , \"stubbed_host\" , { secure : false , session : new StubbedSession } )", "commit_type": "allow"}
{"commit_tokens": ["Use", "LOG", "for", "logger", "in", "all", "files"], "add_tokens": ", LOG = require ( 'book' ) . default ( ) this . log = LOG LOG . info ( msg ) LOG . info ( 'Got SIGTERM. Shutting down when all jobs finish...' ) LOG . info ( 'Finished graceful shutdown' ) LOG . error ( err )", "del_tokens": ", log = require ( 'book' ) . default ( ) this . log = CONF . log CONF . log . info ( msg ) CONF . log . info ( 'Got SIGTERM. Shutting down when all jobs finish...' ) CONF . log . info ( 'Finished graceful shutdown' ) CONF . log . error ( err )", "commit_type": "use"}
{"commit_tokens": ["Make", "webview", "-", "bridge", "typecheck", "correctly", "with", "Flow"], "add_tokens": "const onBridgeMessageCallback = this . props . onBridgeMessage ; sendToBridge : function ( message : string ) {", "del_tokens": "var onBridgeMessageCallback = this . props . onBridgeMessage ; sendToBridge : function ( message ) {", "commit_type": "make"}
{"commit_tokens": ["Make", "environment", "schema", "compatible", "with", "k8s"], "add_tokens": "if ( _ . isPlainObject ( env ) ) { _ . each ( env , ( v , k ) => { container . env . push ( { name : k , value : v . toString ( ) } ) ; } ) ; } else if ( _ . isArray ( env ) ) { container . env = _ . cloneDeep ( env ) ; } else { throw new Error ( \"Format of 'environment' is unknown: neither dictionary(object) nor array.\" ) ; }", "del_tokens": "_ . each ( env , ( v , k ) => { container . env . push ( { name : k , value : v . toString ( ) } ) ; } ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "body", "-", "parser", "to", "/", "slack", "/", "commands", "route"], "add_tokens": "const bodyParser = require ( 'body-parser' ) ; // Read the signing secret and access token from the environment variables // Create the adapter using the app's signing secret // Create a Slack Web API client using the access token app . post ( '/slack/commands' , bodyParser . urlencoded ( { extended : false } ) , slackSlashCommand ) ; if ( req . body . command === '/interactive-example' ) {", "del_tokens": "// Read the verification token from the environment variables // Create the adapter using the app's verification token // Create a Slack Web API client app . post ( '/slack/commands' , slackSlashCommand ) ; if ( req . body . token === slackVerificationToken && req . body . command === '/interactive-example' ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "use", "of", "prototype", "methods", "in", "classes", "when", "using", "mixins", "."], "add_tokens": "'Utils/object/hasOwn' , hasOwn , if ( ! hasOwn ( target . prototype , key ) || isUndefined ( target . prototype [ key ] ) ) { // Already defined members are not overwritten", "del_tokens": "'Utils/object/hasOwn' , hasOwn , if ( isUndefined ( target . prototype [ key ] ) ) { // Already defined members are not overwritten", "commit_type": "fix"}
{"commit_tokens": ["Fix", "failing", "test", ".", "Just", "look", "for", "fatal", "."], "add_tokens": "test . ok ( result . toLowerCase ( ) . indexOf ( 'fatal' ) !== - 1 , 'Task should have been fatal.' ) ;", "del_tokens": "test . ok ( result . indexOf ( '<FATAL>' ) !== - 1 , 'Task should have been fatal.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "multiple", "non", "-", "regular", "rule", "types", "in", "the", "same", "stylesheet"], "add_tokens": "if ( rule . type === 'regular' && stringified [ rule . id ] ) { if ( rule . type === 'regular' ) { stringified [ rule . id ] = true }", "del_tokens": "if ( stringified [ rule . id ] ) { stringified [ rule . id ] = true", "commit_type": "fix"}
{"commit_tokens": ["moved", "expect", "interface", "to", "own", "file", "for", "consistency"], "add_tokens": "exports . expect = require ( './interface/expect' ) ;", "del_tokens": "exports . expect = function ( val , message ) { return new exports . Assertion ( val , message ) ; } ;", "commit_type": "move"}
{"commit_tokens": ["allow", "for", "passing", "global", "data", "via", "the", "config", "object"], "add_tokens": "handlebars : require ( './fixtures/handlebars' ) , data : { 'project' : 'Large Hadron' }", "del_tokens": "handlebars : require ( './fixtures/handlebars' )", "commit_type": "allow"}
{"commit_tokens": ["allow", "for", "passing", "of", "opaque", "arg", "on", "producer"], "add_tokens": "* @ param { * = } optOpaque Pass vars to receipt handler . partition , value , key , optOpaque ) { return producerInstance . __kafkaAvro_produce ( kafkaTopic , partition , bufVal , key , optOpaque ) ; return producerInstance . __kafkaAvro_produce ( kafkaTopic , partition , bufValue , key , optOpaque ) ;", "del_tokens": "partition , value , key ) { return producerInstance . __kafkaAvro_produce ( kafkaTopic , partition , bufVal , key ) ; return producerInstance . __kafkaAvro_produce ( kafkaTopic , partition , bufValue , key ) ;", "commit_type": "allow"}
{"commit_tokens": ["fix", "table", "formatting", "in", "ref", "docs"], "add_tokens": "* & nbsp ; | ** Return ` ` ** | ** Return ` ` ** | ** Return ` ` ** | ** Notes ** * : -- -- - : | : -- -- - : | : -- -- - : | : -- -- - : | : -- -- - : * @ param { object } matchingConstraints - the callback ID ( as a string or RegExp ) or", "del_tokens": "* | | ** Return ` ` ** | ** Return ` ` ** | ** Return ` ` ** | ** Notes ** * : -- -- - : | : -- -- - : | : -- -- - : | : -- -- - : | : -- -- - : | : -- -- - : * @ param { * } matchingConstraints - the callback ID ( as a string or RegExp ) or", "commit_type": "fix"}
{"commit_tokens": ["added", "getID", "to", "Credentials", "class"], "add_tokens": "const hash = require ( \"hash.js\" ) ; . then ( credentialsData => Array . isArray ( credentialsData ) ? new Credentials ( Object . assign ( { } , credentialsData [ 1 ] , { type : credentialsData [ 0 ] } ) ) : new Credentials ( credentialsData ) / ** * Get A unique ID of the datasource based on its data * @ returns { String } A hash of the data * @ memberof Credentials * / getID ( ) { return hash . sha256 ( ) . update ( JSON . stringify ( this . data ) ) . digest ( \"hex\" ) ; }", "del_tokens": ". then ( credentialsData => Array . isArray ( credentialsData ) ? new Credentials ( Object . assign ( { } , credentialsData [ 1 ] , { type : credentialsData [ 0 ] } ) ) : new Credentials ( credentialsData )", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "first", "bug", "with", "Git", "data"], "add_tokens": "console . log ( '[Coveralls] Submitting to %s' , client . endPoint ) ; console . error ( err ) ;", "del_tokens": "console . log ( '[Coveralls] Submitting to' , client . endPoint . href ) ; console . error ( err . message ) ; console . error ( err . stack ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "test", "for", "uninstalled", "packages", "."], "add_tokens": "var jsPattern ; var cssPattern ; var defaultPattern = { js : '<script src=\"{{filePath}}\"></script>' , css : '<link rel=\"stylesheet\" href=\"{{filePath}}\" />' } ; return html + spacing + endBlock ; jsPattern = config . get ( 'js-pattern' ) || defaultPattern . js ; cssPattern = config . get ( 'css-pattern' ) || defaultPattern . css ;", "del_tokens": "var jsPattern = '<script src=\"{{filePath}}\"></script>' ; var cssPattern = '<link rel=\"stylesheet\" href=\"{{filePath}}\" />' ; return html + spacing + endBlock ; } else { return match ; jsPattern = config . get ( 'js-pattern' ) || jsPattern ; cssPattern = config . get ( 'css-pattern' ) || cssPattern ;", "commit_type": "add"}
{"commit_tokens": ["Use", "__dirname", "for", "entry", "paths"], "add_tokens": "/ ** * Bind ` ` class * @ property classNames * @ type { Array } * / / ** * Use ` ` element * @ property tagName * @ type { string } * / / ** * Copyright year * @ TODO : Make this dynamic ( moment ? prob not ) * @ property year * @ type { number } * @ default 2016 * / year : 2016", "del_tokens": "// @TODO: Make this dynamic (moment? prob not) year : '2016'", "commit_type": "use"}
{"commit_tokens": ["use", "urlify", "to", "normalize", "folder", "names", "in", "file", "manager"], "add_tokens": "define ( [ 'require' , 'knockout' , 'knockout-collection' , 'knockout-mapping' , 'lodash' , 'cms/modules/ui' , 'cms/modules/dropbox-chooser' , 'cms/modules/dispatcher' , 'amplify' , 'bluebird' , 'urlify' , 'cms/ko-bindings/double-click' ] , function ( require , ko , KnockoutCollection , koMapping , _ , ui , Dropbox , dispatcher ) { var Promise = require ( 'bluebird' ) ; var urlify = require ( 'urlify' ) ; var amplify = require ( 'amplify' ) ; name = urlify ( name , 120 , false ) ;", "del_tokens": "define ( [ 'require' , 'knockout' , 'knockout-collection' , 'knockout-mapping' , 'lodash' , 'cms/modules/ui' , 'cms/modules/dropbox-chooser' , 'cms/modules/dispatcher' , 'amplify' , 'bluebird' , 'cms/ko-bindings/double-click' ] , function ( require , ko , KnockoutCollection , koMapping , _ , ui , Dropbox , dispatcher , amplify ) { var Promise = require ( \"bluebird\" ) ; name = name . replace ( / ä/ g , ae') . r eplace( / ö /g , ' o e'). r e place(/ ü / g, ' u ').r e p lace(/ß / g , ' s s ); name = name . replace ( / [,/\\\\] / g , '_' ) ; name = _ . deburr ( name ) ;", "commit_type": "use"}
{"commit_tokens": ["Use", "archiver", "to", "create", "zip", "but", "test", "with", "adm", "-", "zip"], "add_tokens": "zipfile . writeToFile ( outfile , cb ) ;", "del_tokens": "zipfile . writeToFile ( outfile ) ; cb ( ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "touchmove", "check", "to", "currentTarget"], "add_tokens": "el . addEventListener ( 'touchmove' , cleanup ) ; el . removeEventListener ( 'touchmove' , cleanup ) ;", "del_tokens": "var parentNode = el . parentNode ; document . body . addEventListener ( 'touchmove' , cleanup ) ; document . body . removeEventListener ( 'touchmove' , cleanup ) ;", "commit_type": "add"}
{"commit_tokens": ["updating", "the", "way", "wp", "api", "path", "is", "set"], "add_tokens": "this . wpAPIPath = opt . wpAPIPath || 'wp-json/' ; var api = this . wpAPI ? this . wpAPIPath : 'wc-api/' ;", "del_tokens": "var api = this . wpAPI ? this . wpAPI : 'wc-api/' ;", "commit_type": "update"}
{"commit_tokens": ["added", "some", "ideas", "as", "comment"], "add_tokens": "c . submitJob ( { name : 'reverse' , payload : 'žluťoučký kůň', back g ound: fals e prio r ty: 'HIG H }, fu c t on(err, j ob)", "del_tokens": "c . submitJob ( { name : 'reverse' , payload : 'žluťoučký kůň', back g ound: true , prio r ty: 'HIG H }, fu c t on(err, j ob)", "commit_type": "add"}
{"commit_tokens": ["Allow", "passing", "existing", "Config", "to", "new", "Config", "constructor"], "add_tokens": "if ( config instanceof Config ) { this . _config = config . _config } else { this . _config = { default : config || { } , environment : { } , local : { } }", "del_tokens": "this . _config = { default : config || { } , environment : { } , local : { }", "commit_type": "allow"}
{"commit_tokens": ["Add", "support", "for", "inclusion", "of", "related", "resources"], "add_tokens": "var includes = this . __prepareIncludes ( ( options && options . include ) ) ; var params = filters . concat ( sort , includes ) ; NetworkStore . prototype . __prepareIncludes = function ( include ) { return include ? [ \"include=\" + include ] : [ ] ; } ;", "del_tokens": "var params = filters . concat ( sort ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "gulp", "-", "jsdoc", "-", "to", "-", "markdown"], "add_tokens": "var gutil = require ( \"gulp-util\" ) ; var gulpJsdoc2md = require ( \"gulp-jsdoc-to-markdown\" ) ; var concat = require ( \"gulp-concat\" ) ; debug : false . pipe ( header ( banner , { pkg : pkg } ) ) gulp . task ( 'clean-docs' , function ( ) { del ( [ 'docs' ] ) ; } ) ; gulp . task ( \"docs\" , [ 'clean-docs' ] , function ( ) { return gulp . src ( \"src/prebid.js\" ) . pipe ( concat ( \"readme.md\" ) ) . pipe ( gulpJsdoc2md ( ) ) . on ( \"error\" , function ( err ) { gutil . log ( \"jsdoc2md failed:\" , err . message ) ; } ) . pipe ( gulp . dest ( \"docs\" ) ) ; } ) ;", "del_tokens": "debug : true", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "HTML", "content", "in", "node", "labels"], "add_tokens": "var svgNode = createSVGNode ( u ) ; svg . appendChild ( svgNode ) ; var bbox = svgNode . getBBox ( ) ; svg . removeChild ( svgNode ) ;", "del_tokens": "var text = createTextNode ( u ) ; svg . appendChild ( text ) ; var bbox = text . getBBox ( ) ; svg . removeChild ( text ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "very", "simple", "dependency", "injection", "."], "add_tokens": "ServiceTest = __decorate ( [ DIGlobal ] , ServiceTest ) ; var test = WebAtoms . DI . resolve ( ServiceTest ) ;", "del_tokens": "var test = new ServiceTest ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "special", "permissions", "from", "ssb", "-", "ws"], "add_tokens": "var port cb ( err , value )", "del_tokens": "var http = require ( 'http' ) var pull = require ( 'pull-stream' ) var scopes = require ( 'multiserver-scopes' ) var READ_AND_ADD = [ //except for add, of course 'get' , 'getLatest' , 'createLogStream' , 'createUserStream' , 'createHistoryStream' , 'getAddress' , 'links' , 'blobs.add' , 'blobs.size' , 'blobs.has' , 'blobs.get' , 'blobs.changes' , 'blobs.createWants' , 'add' , 'query.read' , 'links2.read' ] var port , host host = config . ws . host || config . host if ( value === true ) sbot . friends . get ( { source : sbot . id , dest : toId ( id ) } , function ( err , follows ) { if ( err ) return cb ( err ) else if ( follows ) cb ( null , { allow : READ_AND_ADD , deny : null } ) else cb ( null , true ) } ) else cb ( err , value ) var c = 0 //debug('listening on host=%s port=%d', _host, _port)", "commit_type": "remove"}
{"commit_tokens": ["update", "crypto", "-", "deriveKey", "to", "hex", "encoding", "instead", "of", "utf8"], "add_tokens": "salt = util . strToBuffer ( salt ) ;", "del_tokens": "salt = util . strToBuffer ( salt , 'utf8' ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "API", "request", "handler", "to", "http", "-", "events"], "add_tokens": "var Api = require ( './services/api' ) ; function HttpEvents ( prismManager , urlRewrite , api ) { function isApiRequest ( req ) { var config = prismManager . getApiConfig ( ) ; return config . enabled && req . url . indexOf ( config . route ) === 0 ; } } else if ( isApiRequest ( req ) ) { // handle prism API request api . requestHandler ( req , res ) ; di . annotate ( HttpEvents , new di . Inject ( PrismManager , UrlRewrite , Api ) ) ;", "del_tokens": "function HttpEvents ( prismManager , urlRewrite ) { di . annotate ( HttpEvents , new di . Inject ( PrismManager , UrlRewrite ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "in", "Dijkstra", "s", "algorithm"], "add_tokens": "// Returns the edge if it was relaxed return sToV ; var edge = _relax ( paths , source , u , v , wrapperCost ) ; if ( edge ) { queue . decreaseKey ( v , edge . cost ) ; }", "del_tokens": "return sToV ; _relax ( paths , source , u , v , wrapperCost ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "stubs", ".", "Fix", "position", "for", "read", "/", "write", "."], "add_tokens": "var _position = ( ! ( undefined === position && null === position ) ) ? position : ofd . position ; var _position = ( ! ( undefined === position && null === position ) ) ? position : ofd . position ; } ; FileSystem . prototype . rename = function rename ( old , new , callback ) { } ; FileSystem . prototype . truncate = function truncate ( path , length , callback ) { } ; FileSystem . prototype . ftruncate = function ftruncate ( fd , length , callback ) {", "del_tokens": "var _position = ( undefined !== position ) ? position : ofd . position ; var _position = ( undefined !== position ) ? position : ofd . position ;", "commit_type": "add"}
{"commit_tokens": ["added", ":", "support", "for", "namespaces", "and", "comment", "feature"], "add_tokens": "} ) ;", "del_tokens": "} ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "dir", "reference", "for", "charData", ".", "txt"], "add_tokens": "var readFile = fs . readFileSync ( __dirname + '/charData.txt' , 'utf-8' ) ;", "del_tokens": "var readFile = fs . readFileSync ( './charData.txt' , 'utf-8' ) ;", "commit_type": "change"}
{"commit_tokens": ["Adding", "customer", "headers", "and", "POST", "verb", "to", "remote", "logger", "-", "++", "version"], "add_tokens": "superagent = BB . promisifyAll ( require ( 'superagent' ) ) , 'GET' , 'POST' this . config . verb = this . config . verb . toLowerCase ( ) ; this . config . headers = this . config . headers || { } ; var request = superagent [ this . config . verb ] ( this . config . url ) ; switch ( this . config . verb ) { case 'get' : request . query ( entry ) ; break ; case 'post' : request . send ( entry ) ; break ; } _ . forEach ( this . config . headers , function ( headerValue , headerKey ) { request . set ( headerKey , headerValue ) ; } ) ; return request . end ( ) ;", "del_tokens": "superagent = require ( 'superagent' ) , 'GET' return superagent . get ( this . config . url ) . query ( entry ) ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "the", "notification", "plugin", "to", "use", "the", "new", "eventing", "framework"], "add_tokens": "", "del_tokens": "it ( \"should notify by calling 'once' event when there is a callback(s) provided\" , function ( ) { new Notification ( \"N Title\" , { 'onshow' : onShow , 'onerror' : onError } ) ; expect ( mockedWebworks . event . once ) . toHaveBeenCalledWith ( _ID , jasmine . any ( String ) , jasmine . any ( Function ) ) ; } ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "args", "option", "and", "refactor"], "add_tokens": "* force ? : boolean ; * fork ? : boolean | string [ ] ; * args ? : string [ ] ; * inMemory ? : boolean ; * logLevel ? : string ;", "del_tokens": "* force : boolean ; * fork : boolean | string [ ] ; * inMemory : boolean ; * logLevel : string ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "lib", "/", "blockdevice", ":", "Default", "mode", "now", "rs", "+"], "add_tokens": "this . mode = options . mode || 'rs+'", "del_tokens": "this . mode = options . mode || 'r+'", "commit_type": "update"}
{"commit_tokens": ["Adding", "attach", "/", "detach", "to", "ActiveMQ", "test"], "add_tokens": "session . on ( Session . LinkAttached , function ( link ) { session . detachLink ( link ) ; } ) ; session . on ( Session . LinkDetached , function ( ) { session . on ( Session . Mapped , function ( ) { link = session . attachLink ( { name : 'test' , role : constants . linkRole . sender , source : { address : null , dynamic : true } , target : { address : 'testtgt' } , initialDeliveryCount : 1 } ) ; } ) ; session . on ( Session . ErrorReceived , function ( err ) { console . log ( err ) ; } ) ;", "del_tokens": "session . on ( Session . Mapped , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["changed", "tests", "to", "create", "arrays", "of", "maximum", "1400", "elements", "-", "https", ":", "//", "github", ".", "com", "/", "caolan", "/", "async", "/", "issues", "/", "1337", "-", "should", "be", "reverted"], "add_tokens": "async . times ( 1400 , function forEach ( n , next ) {", "del_tokens": "async . times ( 250000 , function forEach ( n , next ) {", "commit_type": "change"}
{"commit_tokens": ["Use", "Nix", "as", "the", "project", "s", "build", "system"], "add_tokens": "'fromRGB' : expandParams ( husl . Husl . rgbToHusl ) , 'fromHex' : husl . Husl . hexToHusl , 'toRGB' : expandParams ( husl . Husl . huslToRgb ) , 'toHex' : expandParams ( husl . Husl . huslToHex ) , 'fromRGB' : expandParams ( husl . Husl . rgbToHuslp ) , 'fromHex' : husl . Husl . hexToHuslp , 'toRGB' : expandParams ( husl . Husl . huslpToRgb ) , 'toHex' : expandParams ( husl . Husl . huslpToHex )", "del_tokens": "'fromRGB' : expandParams ( husl_Husl . rgbToHusl ) , 'fromHex' : husl_Husl . hexToHusl , 'toRGB' : expandParams ( husl_Husl . huslToRgb ) , 'toHex' : expandParams ( husl_Husl . huslToHex ) , 'fromRGB' : expandParams ( husl_Husl . rgbToHuslp ) , 'fromHex' : husl_Husl . hexToHuslp , 'toRGB' : expandParams ( husl_Husl . huslpToRgb ) , 'toHex' : expandParams ( husl_Husl . huslpToHex )", "commit_type": "use"}
{"commit_tokens": ["Add", "test", "for", "env", "()"], "add_tokens": "import { createConfig , customConfig , entryPoint , env , setOutput , sourceMaps } from '../index' test ( 'env()' , ( t ) => { const originalEnv = process . env . NODE_ENV const create = ( ) => createConfig ( [ env ( 'development' , [ sourceMaps ( ) ] ) , env ( 'production' , [ customConfig ( { foo : 'bar' } ) ] ) ] ) try { process . env . NODE_ENV = '' const defaultConfig = create ( ) t . is ( defaultConfig . devtool , 'cheap-module-source-map' ) t . is ( defaultConfig . foo , undefined ) process . env . NODE_ENV = 'development' const devConfig = create ( ) t . is ( devConfig . devtool , 'cheap-module-source-map' ) t . is ( devConfig . foo , undefined ) process . env . NODE_ENV = 'production' const prodConfig = create ( ) t . is ( prodConfig . devtool , undefined ) t . is ( prodConfig . foo , 'bar' ) } finally { process . env . NODE_ENV = originalEnv } } )", "del_tokens": "import { createConfig , entryPoint , setOutput , sourceMaps } from '../index'", "commit_type": "add"}
{"commit_tokens": ["Fix", "incorrect", "time", "returned", "in", "aptime", "at", "noon", "+", "minutes"], "add_tokens": "* @ return { string } if ( hours === 12 ) { hour = hours ; } else { hour = hours - 12 ; }", "del_tokens": "* @ return { String } hour = hours - 12 ;", "commit_type": "fix"}
{"commit_tokens": ["creates", "simple", "integration", "test", "framework"], "add_tokens": ". catch ( logGenericError ( __filename ) ) ;", "del_tokens": ". catch ( logGenericError ) ;", "commit_type": "create"}
{"commit_tokens": ["Changed", "whitespace", "for", "untagged", "lines"], "add_tokens": "text += '\\n' + repeat ( options . space , tagDepth - 1 ) ; html = escapeSingleQuotes ( content ) ; if ( options . space ) { html = '\\\\n' + repeat ( options . space , tagDepth ) + html ; } appendText ( 'html' , html ) ; if ( ! tag ) { console . log ( blockFilter ) ; }", "del_tokens": "text += ( previousTag == '-' ? '' : '\\n' ) + repeat ( options . space , tagDepth - 1 ) ; appendText ( 'html' , escapeSingleQuotes ( content ) ) ;", "commit_type": "change"}
{"commit_tokens": ["add", "tests", "for", "bitwiseXor", "and", "absDiff"], "add_tokens": ", \".absDiff\" : function ( cv ) { var mat1 = new cv . Matrix ( 1 , 1 ) ; mat1 . set ( 0 , 0 , 0 ) ; var mat2 = new cv . Matrix ( 1 , 1 ) ; mat2 . set ( 0 , 0 , 1 ) ; var diff = new cv . Matrix ( 1 , 1 ) ; diff . absDiff ( mat1 , mat2 ) ; assert . equal ( diff . get ( 0 , 0 ) , 1 ) ; } , \".bitwiseXor\" : function ( cv ) { var mat1 = new cv . Matrix ( 1 , 1 ) ; mat1 . set ( 0 , 0 , 1 ) ; var mat2 = new cv . Matrix ( 1 , 1 ) ; mat2 . set ( 0 , 0 , 1 ) ; var xored = new cv . Matrix ( 1 , 1 ) ; xored . bitwiseXor ( mat1 , mat2 ) ; assert . equal ( xored . get ( 0 , 0 ) , 0 ) ; }", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["updated", "build", "with", "fix", "for", "trimLeading"], "add_tokens": "if ( text . startsWith ( prefix ) || text . indexOf ( prefix ) === 0 ) {", "del_tokens": "if ( text . startsWith ( prefix ) ) {", "commit_type": "update"}
{"commit_tokens": ["Fix", "forceUpdate", "()", "bug", "and", "other", "issues"], "add_tokens": "constructor ( { id , ref , rawOnData , onData , initialData , responseHandler , keepAliveFor = false , componentRefresh } ) { this . componentRefreshFn = componentRefresh this . expireTimeout = null // will contain timeoutID this . hasExpired = false this . refreshComponent ( ) refreshComponent ( ) { this . componentRefreshFn && this . componentRefreshFn ( ) } setComponentRefresh ( componentRefresh ) { this . componentRefreshFn = componentRefresh } this . expireTimeout = null this . setComponentRefresh ( null ) this . hasExpired = true suspended ( ) { return this . expireTimeout != null } expired ( ) { return this . hasExpired || this . expired ( ) this . refreshComponent ( )", "del_tokens": "constructor ( { id , ref , rawOnData , onData , initialData , responseHandler , keepAliveFor = false } ) { this . expireTimeout = null // will contain timeoutID or true when DP expired this . expireTimeout = true isExpired ( ) { return this . expireTimeout === true || this . isExpired ( )", "commit_type": "fix"}
{"commit_tokens": ["remove", "alert", "()", "-", "change", "to", "console", ".", "log"], "add_tokens": "if ( req . indexOf ( '#' ) >= 0 ) { console . log ( \"@@ makeIconCallback: Not expecting # in URI whose state changed: \" + req ) //alert('Should have no hash in '+req) }", "del_tokens": "if ( req . indexOf ( '#' ) >= 0 ) alert ( 'Should have no hash in ' + req )", "commit_type": "remove"}
{"commit_tokens": ["Add", "maintainability", "to", "the", "plain", "output", "format", "."], "add_tokens": "line : lines . start . line ,", "del_tokens": "lines : lines ,", "commit_type": "add"}
{"commit_tokens": ["added", "functions", "files", "isFile", "isDire", "readString", "writeString", "and", "made", "shell", "tests", "succeed"], "add_tokens": "var path = require ( 'path' ) ; var expandArgument = exports . expandArgument = function ( arg , applyGlobbing ) { res . push ( expandArgument ( arg [ key ] , applyGlobbing ) ) ; if ( applyGlobbing && glob . hasMagic ( arg , globOptions ) ) return utils . flatten ( args . map ( function ( arg ) { return expandArgument ( arg , true ) ; } ) ) ; fixLocalScript = function ( scriptName ) { if ( scriptName . indexOf ( path . sep ) !== - 1 ) // there is a folder name, or the script name is already relative, absolute or related to home return scriptName ; if ( shell . isFile ( scriptName ) ) return \"./\" + scriptName ; return scriptName ; } //expand the arguments before spawning, the first argument is treated differently var executable = fixLocalScript ( expandArgument ( commandAndArgs . shift ( ) , false ) ) ; commandAndArgs . unshift ( executable ) ; shell . lastExitCode = status ;", "del_tokens": "var expandArgument = exports . expandArgument = function ( arg , i ) { res . push ( arg [ key ] ) ; //TODO: expand value! if ( glob . hasMagic ( arg , globOptions ) ) return utils . flatten ( args . map ( expandArgument ) ) ; //TODO: update lastExitCode", "commit_type": "add"}
{"commit_tokens": ["Fix", "issue", "with", "minifyMapping", "and", "add", "tests"], "add_tokens": "let newMapping = _ . pick ( copyDeep ( mapping ) , [ \"to\" , \"from\" , \"toScheme\" , \"fromScheme\" , \"creator\" , \"type\" ] )", "del_tokens": "let newMapping = _ . pick ( mapping , [ \"to\" , \"from\" , \"toScheme\" , \"fromScheme\" , \"creator\" , \"type\" ] )", "commit_type": "fix"}
{"commit_tokens": ["Add", "favorites", "to", "locals", "instead", "of", "res", "and", "access", "it", "with", "@favorites", "in", "partial", "view"], "add_tokens": "hbs . localsAsTemplateData ( app ) ; app . use ( ( req , res , next ) => { res . locals . favorites = favoritesDb // Enhance it with per user favorites based on authentication next ( ) } )", "del_tokens": "app . use ( ( req , res , next ) => { req . favorites = favoritesDb ; next ( ) ; } )", "commit_type": "add"}
{"commit_tokens": ["Add", "result", "component", ".", "Not", "used", "yet"], "add_tokens": "return schema . filter ( node => ! ! node ) ;", "del_tokens": "return schema ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "modifier", "to", "be", "logged", "with", "keydown", "and", "keyup"], "add_tokens": "if ( this . lastKeydownShift ) { if ( this . lastKeydownAlt ) { if ( this . lastKeydownCtrl ) { if ( this . lastKeydownMeta ) {", "del_tokens": "if ( event . type === 'keypress' && this . lastKeydownShift ) { if ( event . type === 'keypress' && this . lastKeydownAlt ) { if ( event . type === 'keypress' && this . lastKeydownCtrl ) { if ( event . type === 'keypress' && this . lastKeydownMeta ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "cache", "usage", ".", "garbage", "collection", "."], "add_tokens": "this . _index = { } ; index [ key ] = [ pos , length ] ; Object . keys ( index ) . forEach ( function ( key ) { delete index [ key ] . previous ; self . _index [ key ] = index [ key ] ; } ) ;", "del_tokens": "index [ key ] = [ pos , length ] ;", "commit_type": "fix"}
{"commit_tokens": ["changed", "middleware", "plugin", "to", "errback", "if", "there", "is", "an", "error"], "add_tokens": "var next = func . hitch ( this , function ( err ) { if ( err ) { promise . errback ( err ) ; } else { process . nextTick ( func . hitch ( this , function ( ) { //if Ive looped through all of them callback if ( count == length ) { promise . callback ( ) ; } else { //call next var nextArgs = args . slice ( 0 ) ; nextArgs . unshift ( next ) ; funcs [ count ++ ] . apply ( this , nextArgs ) ; } } ) ) ; }", "del_tokens": "var next = func . hitch ( this , function ( ) { process . nextTick ( func . hitch ( this , function ( ) { //if Ive looped through all of them callback if ( count == length ) { promise . callback ( ) ; } else { //call next var nextArgs = args . slice ( 0 ) ; nextArgs . unshift ( next ) ; funcs [ count ++ ] . apply ( this , nextArgs ) ; } } ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Implement", "remaining", "methods", "on", "epoll", "stub"], "add_tokens": "add : sinon . stub ( ) , remove : sinon . stub ( ) . returnsThis ( ) , close : sinon . stub ( )", "del_tokens": "add : sinon . stub ( )", "commit_type": "implement"}
{"commit_tokens": ["Making", "polymer", "controls", "better", "."], "add_tokens": "runtime = new ( require ( './runtime' ) ) ( runtime ) ;", "del_tokens": "runtime = new ( require ( './runtime' ) ) ( runtime ) ; runtime = new ( require ( './runtime' ) ) ( runtime ) ;", "commit_type": "make"}
{"commit_tokens": ["Making", "port", "on", "echo", "server", "configurable", "via", "--", "port", "command", "line", "option", "."], "add_tokens": "var args = { /* defaults */ port : '8080' } ; /* Parse command line options */ var pattern = / ^--(.*?)(?:=(.*))?$ / ; process . argv . forEach ( function ( value ) { var match = pattern . exec ( value ) ; if ( match ) { args [ match [ 1 ] ] = match [ 2 ] ? match [ 2 ] : true ; } } ) ; var port = parseInt ( args . port , 10 ) ; console . log ( \"WebSocket-Node: echo-server\" ) ; console . log ( \"Usage: ./echo-server.js [--port=8080]\" ) ; server . listen ( port , function ( ) { console . log ( ( new Date ( ) ) + \" Server is listening on port \" + port ) ;", "del_tokens": "server . listen ( 8080 , function ( ) { console . log ( ( new Date ( ) ) + \" Server is listening on port 8080\" ) ;", "commit_type": "make"}
{"commit_tokens": ["Implemented", "possibility", "to", "load", "savedata", "."], "add_tokens": "var data = opts [ 'data' ] ; this . _initNew ( this . _options , data ) ; Tox . prototype . _initNew = function ( options , data ) { if ( data ) { size = size_t ( data . length ) ; } else { data = ref . NULL ; } this . _handle = this . getLibrary ( ) . tox_new ( options , data , size , eptr ) ;", "del_tokens": "this . _initNew ( this . _options ) ; Tox . prototype . _initNew = function ( options ) { this . _handle = this . getLibrary ( ) . tox_new ( options , ref . NULL , size , eptr ) ;", "commit_type": "implement"}
{"commit_tokens": ["Make", "sure", "we", "restore", "Module", ".", "_compile", "(", "try", "/", "catch", ")"], "add_tokens": "// load the package.json var pkg = require ( opts . pkg ) ; var basedir = path . dirname ( opts . pkg ) ; var sources = allSources ( basedir , pkg , opts . sources ) ; var dependencies = [ ] ; // override of Module._compile // to find all call to \"require\" function _compile ( str , filename ) { } // override Module._compile temporarily override ( Module . prototype , '_compile' , _compile , function ( ) { sources . forEach ( require ) ; } ) ; function override ( object , method , override , fn ) { old = object [ method ] ; try { object [ method ] = override ; fn ( ) ; } finally { object [ method ] = old ; } }", "del_tokens": "var dependencies = [ ] ; // override Module._compile // to intercept any \"require\" statement _compile = Module . prototype . _compile ; Module . prototype . _compile = function ( str , filename ) { } ; // load the package.json var pkg = require ( opts . pkg ) ; var basedir = path . dirname ( opts . pkg ) ; var sources = allSources ( basedir , pkg , opts . sources ) ; // require and process all sources sources . forEach ( require ) ; // restore Module._compile Module . prototype . _compile = _compile ;", "commit_type": "make"}
{"commit_tokens": ["fix", "typo", "in", "init", "caused", "library", "to", "fail", "on", "load"], "add_tokens": "if ( config . clientid ) { config . clientId = config . clientid ; } //TODO: Normalize transport using onconnect topic const client = config . createClient ( config ) ; / ** * This will publish a message once the client * has been connected . * / action : 'up' , client : config . clientId ,", "del_tokens": "const client = options . createClient ( config ) ; service : config . clientId , action : 'up'", "commit_type": "fix"}
{"commit_tokens": ["Change", "anonymous", "user", "id", "from", "anonymous", "user", "to", "anonym"], "add_tokens": "anonymousUserId : 'Anonym' 'textarea/joinTheConversationAnonymously' : 'Join the discusstion as Anonym' , 'text/anonym' : 'Anonym' , 'text/anonym' : '匿名用户',", "del_tokens": "anonymousUserId : 'Anonymous' 'textarea/joinTheConversationAnonymously' : 'Join the discusstion as Anonymous User' , 'text/anonymousUser' : 'Anonymous User' , 'text/anonymousUser' : '匿名用户',", "commit_type": "change"}
{"commit_tokens": ["Fix", "join", "()", "in", "accordance", "with", "ES6", "spec"], "add_tokens": "if ( s === undefined || s === null ) { s = '' ; } let e = array [ i ] ; if ( e === undefined || e === null ) { e = '' ; } s += separator + e ;", "del_tokens": "s += separator + array [ i ] ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "czech", "language", "prepositions", "rule"], "add_tokens": "[ / (\\s|^)([KkSsVvZzOoUuAI])(?:\\s+)(\\S) / g , '$1$2\\u00A0$3' ] } , { description : 'distinguish prepositions from just word-ending letter' , input : 'Nalijme si čistého vína', expected : 'Nalijme si čistého vína',", "del_tokens": "[ / ([KkSsVvZzOoUuAI])(?:\\s+)(\\S) / g , '$1\\u00A0$2' ]", "commit_type": "fix"}
{"commit_tokens": ["implemented", ":", "remove", "_dev", ".", "dependencies", ".", "d", ".", "ts", "reference", "."], "add_tokens": "// remove '_dev.dependencies.d.ts' reference. rev = rev . replace ( / \\/\\/\\/ <reference path=\"_dev.dependencies.d.ts\"[\\s\\S]*?\\n / g , '' ) ; var rev = src . replace ( / \\/\\/\\/ <reference path=\"[\\s\\S]*?> / g , '' ) . replace ( / \\/\\/@ sourceURL=[\\s\\S]*?\\n / g , '' ) . replace ( / \\/\\/# sourceURL=[\\s\\S]*?\\n / g , '' ) . replace ( / declare var module: any;[\\s\\S]*?\\n / g , '' ) ;", "del_tokens": "var rev = src ; rev = rev . replace ( / \\/\\/\\/ <reference path=\"[\\s\\S]*?> / g , '' ) ; rev = rev . replace ( / \\/\\/@ sourceURL=[\\s\\S]*?\\n / g , '' ) ; rev = rev . replace ( / \\/\\/# sourceURL=[\\s\\S]*?\\n / g , '' ) ; rev = rev . replace ( / declare var module: any;[\\s\\S]*?\\n / g , '' ) ;", "commit_type": "implement"}
{"commit_tokens": ["use", "file", "for", "commit", "message"], "add_tokens": "// generate commit message var commitFile = 'commitFile-' + crypto . createHash ( 'md5' ) . update ( message ) . digest ( 'hex' ) . substring ( 0 , 6 ) ; fs . writeFileSync ( commitFile , message ) ; execWrap ( 'git commit --file=' + commitFile ) ; fs . unlinkSync ( commitFile ) ;", "del_tokens": "execWrap ( 'git commit -m \"' + message + '\"' ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "key", "option", "to", "cancel", "method"], "add_tokens": "} , 'apikey' : { 'key' : { name : 'key' , key : 'k' , api : 'k' , param : 'api_key' , info : 'API key (if assigned). Contact the WebPageTest server administrator for a key if required' } options : [ options . apikey , options . test , options . request , options . results ] , options : [ options . apikey ] ,", "del_tokens": "'key' : { name : 'key' , key : 'k' , api : 'k' , param : 'api_key' , info : 'API key (if assigned). Contact the WebPageTest server administrator for a key if required' } , options : [ options . test , options . request , options . results ] ,", "commit_type": "add"}
{"commit_tokens": ["Allow", "clients", "to", "disable", "keyboard", "events"], "add_tokens": "var filterKey = typeof options . filterKey === 'function' ? options . filterKey : noop ; if ( filterKey ( e , x , y , z ) ) { // They don't want us to handle the key: https://github.com/anvaka/panzoom/issues/45 return ; }", "del_tokens": "console . log ( 'resujme' )", "commit_type": "allow"}
{"commit_tokens": ["add", "searchKey", "to", "identity", "search", "results"], "add_tokens": "var identitiesByHash , r , i , d , id ; _context9 . next = 30 ; _context9 . next = 25 ; _context9 . next = 22 ; id = new Identity ( d ) ; id . searchKey = r [ i ] . key ; identitiesByHash [ r [ i ] . value ] = id ; _context9 . next = 22 ; case 19 : _context9 . prev = 19 ; case 22 : case 25 : _context9 . next = 27 ; case 27 : case 30 : case 31 : } , _callee9 , this , [ [ 8 , 19 ] ] ) ; var version$2 = \"0.0.44\" ;", "del_tokens": "var identitiesByHash , r , i , d ; _context9 . next = 28 ; _context9 . next = 23 ; _context9 . next = 20 ; identitiesByHash [ r [ i ] . value ] = new Identity ( d ) ; _context9 . next = 20 ; case 17 : _context9 . prev = 17 ; case 20 : case 23 : _context9 . next = 25 ; case 25 : case 28 : case 29 : } , _callee9 , this , [ [ 8 , 17 ] ] ) ; var version$2 = \"0.0.43\" ;", "commit_type": "add"}
{"commit_tokens": ["Add", "Location", "to", "putObject", "return", "data"], "add_tokens": "done ( err , { Location : dest } ) ;", "del_tokens": "done ( err ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "template", "name", "for", "site", "generation", "to", "site"], "add_tokens": "this . template = swig . compileFile ( path . resolve ( this . options . theme , 'templates/site.html' ) ) ;", "del_tokens": "this . template = swig . compileFile ( path . resolve ( this . options . theme , 'templates/page.html' ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Use", "correct", "global", "/", "local", "tag", "order", "in", "TCP", "test"], "add_tokens": "assert . equal ( metrics , 'test:1337|c|#gtag,foo' ) ;", "del_tokens": "assert . equal ( metrics , 'test:1337|c|#foo,gtag' ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "option", "to", "ignore", "properties", "."], "add_tokens": "ignore : [ 'border' , 'border-left' , 'border-right' , 'border-top' , 'border-bottom' ] max_decimals : 2 , ignore : [ 'border' , 'border-left' , 'border-right' , 'border-top' , 'border-bottom' ]", "del_tokens": "max_decimals : 2", "commit_type": "add"}
{"commit_tokens": ["Added", "event", "type", "to", "messageData", "object"], "add_tokens": "width : data [ 2 ] , type : data [ 3 ]", "del_tokens": "width : data [ 2 ]", "commit_type": "add"}
{"commit_tokens": ["Fix", "multi", "-", "table", "issue", "(", "buffer", "not", "flushed", ")"], "add_tokens": "var i = 0 , lines = text . split ( '\\n' ) , line , hs , rows , out = [ ] ; var tbl = [ ] ;", "del_tokens": "var i = 0 , lines = text . split ( '\\n' ) , tbl = [ ] , line , hs , rows , out = [ ] ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "options", "to", "be", "passed", "to", "user", "-", "plugins"], "add_tokens": "var NR = require ( __dirname + \"/../index.js\" ) ;", "del_tokens": "var NR = require ( __dirname + \"/index.js\" ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "a", "test", "for", "404"], "add_tokens": "expect ( response . statusCode ) . to . equal ( 200 ) ; expect ( response . statusCode ) . to . equal ( 200 ) ; it ( '/not-found HTML contents' , function ( ) { return request ( 'http://localhost:49741/not-found' ) . then ( function ( response ) { expect ( response . statusCode ) . to . equal ( 404 ) ; expect ( response . body ) . to . equal ( \"Not Found\" ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["fix", "typo", "in", "powpow", "player", ".", "js"], "add_tokens": "define ( [ '../../scripts/2d' , './ships' , './shot' ] , function ( M2D , Ships , Shot ) {", "del_tokens": "define ( [ '../../scripts//2d' , './ships' , './shot' ] , function ( M2D , Ships , Shot ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "heinous", "and", "stupid", "unit", "test", "error", "."], "add_tokens": "statsd . initialise ( ) ;", "del_tokens": "udp . initialise ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixing", ";", "in", "cart", "api"], "add_tokens": "} ;", "del_tokens": "}", "commit_type": "fix"}
{"commit_tokens": ["Added", "desktop", "external", "window", "specs", "options"], "add_tokens": "var newWindow = window . open ( url , title , ( specs || \"\" ) + 'width=' + w + ', height=' + h + ', top=' + top + ', left=' + left ) ;", "del_tokens": "var newWindow = window . open ( url , title , specs + 'width=' + w + ', height=' + h + ', top=' + top + ', left=' + left ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "tests", "to", "reflect", "argument", "order", "of", "Validator", "constructor", ".", "fixed", "bug", "with", "using", "floats", "in", "validator"], "add_tokens": "/ *! Laravel inspired Validator constructor function - v0.0.2 - 2013-01-21 * Copyright ( c ) 2013 David ; Licensed MIT , GPL * / ruleVal = parseFloat ( rule [ 1 ] ) ;", "del_tokens": "/ *! Laravel inspired Validator constructor function - v0.0.2 - 2012-10-11 * Copyright ( c ) 2012 David ; Licensed MIT , GPL * / ruleVal = parseInt ( rule [ 1 ] , 10 ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "flags", "w", "&", "filter", "output", "istanbul", "s", "log"], "add_tokens": "it ( 'should output a result.log file' , function ( ) { return fs . existsSync ( 'result.log' ) ;", "del_tokens": "it ( 'should output a result.log file' , function ( done ) { fs . existsSync ( 'result.log' ) && done ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "version", "number", "in", "powerd", "by"], "add_tokens": "var VERSION = 0.1 ; locals . powerdBy = \"LooseLeaf \" + VERSION ;", "del_tokens": "* Version : 0.1", "commit_type": "add"}
{"commit_tokens": ["Added", "AWS", ".", "Service", "AWS", ".", "DynamoDB", "now", "extends", "this"], "add_tokens": "var AWS = { VERSION : '0.1' } ; require ( './service' ) ;", "del_tokens": "var AWS = { } ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "hard", "reset", "issue", "which", "requires", "a", "validated", "connection", "earlier"], "add_tokens": "// software reset if ( options . softreset ) { _nodemcutool . softreset ( options . port , options . baudrate ) ; // hard-reset nRST } else { _nodemcutool . reset ( options . port , options . baudrate ) ; }", "del_tokens": "_nodemcutool . reset ( options . port , options . baudrate , options . softreset ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updating", "shallowClearAndCopy", "to", "respect", "nested", "objects", "through", "recursion", "."], "add_tokens": "// Remove any properties in destination that were not // returned from the source if ( ! src . hasOwnProperty ( key ) ) { delete dst [ key ] ; } for ( var key in src ) { if ( src . hasOwnProperty ( key ) ) { // For properties common to both source and destination, // check for object references and recurse as needed if ( angular . isObject ( src [ key ] ) ) { shallowClearAndCopy ( src [ key ] , dst [ key ] ) ; } else { // Not an object, so just overwrite with value from source dst [ key ] = src [ key ] ; }", "del_tokens": "delete dst [ key ] ; for ( var key in src ) { if ( src . hasOwnProperty ( key ) ) { dst [ key ] = src [ key ] ;", "commit_type": "update"}
{"commit_tokens": ["Fixed", "a", "naming", "convention", "issue"], "add_tokens": "* Get an array of gender names . var genderNames = [ shevchenko . getGenderNameMale ( ) , shevchenko . getGenderNameFemale ( ) ] ; return genderNames . slice ( 0 ) ; * Get an array of case names .", "del_tokens": "* Get an array of available gender names . var genders = [ shevchenko . getGenderNameMale ( ) , shevchenko . getGenderNameFemale ( ) ] ; return genders . slice ( 0 ) ; * Get an array of available case names .", "commit_type": "fix"}
{"commit_tokens": ["Add", "watch", "flag", "to", "build"], "add_tokens": "yargs . options ( { watch : { default : false , description : 'Watch for changes and rebuild files automatically.' , type : 'boolean' , } , } ) let { disableSourceMaps , watch } = args if ( watch ) babelArgs . push ( '--watch' )", "del_tokens": "let { disableSourceMaps } = args", "commit_type": "add"}
{"commit_tokens": ["added", "args", "property", "handling", "for", "phantom", "object"], "add_tokens": "var timeoutInterval = 100 ; console . log ( 'timeout: ' + timeout ) ; timeout = timeout || 2000 ; //default timeout is 2 sec var newTimeout = timeout - timeoutInterval ; if ( newTimeout <= 0 ) { console . log ( 'fail' ) ; self . waitForSelector ( selector , callbackFn , newTimeout ) ; , timeoutInterval ) ;", "del_tokens": "var startTime = Date . now ; timeout = timeout || 2000 ; //default timeout is 2 sec if ( Date . now - startTime > timeout ) { self . waitForSelector ( selector , callbackFn ) ; , 100 ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "the", "version", "of", "deskpro", "sdk", "used", "for", "dist", "packaging"], "add_tokens": "replacement : destination == 'dist' ? '//unpkg.com/@deskproapps/deskproapps-sdk-react@1.0.0-alpha/dist/deskproapps-sdk-react.js' : '../assets/deskproapps-sdk-react.js'", "del_tokens": "replacement : destination == 'dist' ? '//unpkg.com/@deskproapps/deskproapps-sdk-react@0.1.4/dist/deskproapps-sdk-react.js' : '../assets/deskproapps-sdk-react.js'", "commit_type": "update"}
{"commit_tokens": ["Add", "document", "definition", "parameter", "that", "makes", "the", "entire", "document", "immutable"], "add_tokens": "immutableItemsDoc : { return doc . _id === 'immutableItemsDoc' ;", "del_tokens": "immutableDoc : { return doc . _id === 'immutableDoc' ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "where", "idle", "is", "emitted", "too", "often", "with", "a", "single", "worker", "."], "add_tokens": "if ( self . _working == 0 && self . _queue . length == 0 ) { self . emit ( 'idle' ) ; }", "del_tokens": "if ( self . _working == 0 ) { self . emit ( 'idle' ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Use", "youtube", "-", "dl", "binary", "directly"], "add_tokens": "const { path : youtubeDlPath } = require ( 'youtube-dl-installer' ) const execFile = promisify ( require ( 'child_process' ) . execFile ) const getInfo = async url => { const args = [ '--dump-json' , '-f' , 'best' , url ] const { stdout , stderr } = await execFile ( youtubeDlPath , args ) return stderr === '' ? JSON . parse ( stdout ) : { } } const isSupportedProvided = url => providers . includes ( parseDomain ( url ) . domain ) const info = await getInfo ( url ) cachedVideoInfoUrl = url cachedVideoInfo = info return info", "del_tokens": "const youtubedl = require ( 'youtube-dl' ) const getInfo = promisify ( youtubedl . getInfo ) const isSupportedProvided = url => providers . includes ( parseDomain ( url ) . domain ) try { const info = await getInfo ( url ) cachedVideoInfoUrl = url cachedVideoInfo = info return info } catch ( err ) { return { } }", "commit_type": "use"}
{"commit_tokens": ["add", "rule", "prefer", "-", "lodash", "-", "chain"], "add_tokens": "] ,", "del_tokens": "] ,", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "factory", "method", "to", "generate", "other", "bones", "objects", "."], "add_tokens": "var sys = require ( 'sys' ) , assert = require ( 'assert' ) , // Test the factory method ( function ( ) { var ky , o1 = { } , o2 ; o2 = web . Factory ( o1 ) ; for ( ky in web ) { if ( ky !== 'Factory' && typeof web [ ky ] === \"function\" ) { assert . ok ( typeof o1 [ ky ] === \"function\" , \"Should have o1 w/function \" + ky ) ; assert . ok ( typeof o2 [ ky ] === \"function\" , \"Should have o2 w/function \" + ky ) ; } } } ) ( ) ;", "del_tokens": "var assert = require ( 'assert' ) ,", "commit_type": "add"}
{"commit_tokens": ["Add", "additional", "test", "and", "ensure", "fulfil", "==", "fulfill"], "add_tokens": "* @ contributors * James Padolsey deferred . fulfil = deferred . fulfill ; var def = { } ; function fulfill ( r ) { return def ; function reject ( r ) { returnResult ( { isDeferred : true , action : 'reject' , arg : r } ) ; } def . fulfil = def . fulfill = fulfill ; def . reject = reject ; return def ;", "del_tokens": "function fulfil ( r ) { return { fulfil : fulfil , fulfill : fulfil , reject : function ( r ) { returnResult ( { isDeferred : true , action : 'reject' , arg : r } ) ; } } ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "a", "few", "redundant", "checks"], "add_tokens": "callResolver : function ( stackName , resolver ) resolver . call ( this ) ; function ( ) var expr = this . getCompatibleExpr ( CHARACTERS [ character ] ) ; ) ; function ( ) var expr = this . getCompatibleExpr ( CONSTANTS [ constant ] ) ; if ( expr === undefined ) { throw new SyntaxError ( 'Undefined symbol: ' + constant ) ; } ) ; function ( ) SIMPLE [ simple ] = value = Object ( this . replace ( value ) ) ; ) ;", "del_tokens": "callResolver : function ( stackName , expr , resolver ) if ( expr === undefined ) { throw new SyntaxError ( 'Undefined symbol: ' + stackName ) ; } resolver . call ( this , expr ) ; this . getCompatibleExpr ( CHARACTERS [ character ] ) || null , function ( expr ) ) ; this . getCompatibleExpr ( CONSTANTS [ constant ] ) , function ( expr ) ) ; value , function ( expr ) SIMPLE [ simple ] = value = Object ( this . replace ( expr ) ) ; ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "get", "-", "erc721", "-", "property", "-", "news", "example", "."], "add_tokens": "const WH = require ( \"../../../lib/Wormhole\" ) . default", "del_tokens": "const WH = require ( \"../../lib/Wormhole\" ) . default", "commit_type": "add"}
{"commit_tokens": ["Implemented", "some", "small", "secure", "improvements", "."], "add_tokens": "this . app . disable ( 'x-powered-by' ) ; //Disables the 'X-Powered-By: Express' on the HTTP header secret : this . config . session . sessionSecret , key : 'sessionID' , cookie : { httpOnly : true }", "del_tokens": "secret : this . config . session . sessionSecret", "commit_type": "implement"}
{"commit_tokens": ["adding", "jslint", "and", "running", "it", "against", "the", "code"], "add_tokens": "} ; } ; } ; } ; } ; } ; } ; } ; } ; } ;", "del_tokens": "} } } } } } } } } }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "simple", "part", "of", "bug", "(", "clearingImmediates", "/", "clearingTimeouts", "interspersing", ")"], "add_tokens": "this . forwardingOngoing = false ; this . immediateInterceptor . restore ( ) ; this . processTimerInterceptor . restore ( ) ; this . timerInterceptor . restore ( ) ; this . forwardingOngoing = false ;", "del_tokens": "this . timerInterceptor . restore ( ) ; this . processTimerInterceptor . restore ( ) ; this . immediateInterceptor . restore ( ) ; this . stopForwarding ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "trigger", "function", "for", "custom", "events"], "add_tokens": "var page = require ( 'webpage' ) . create ( ) ; var system = require ( 'system' ) ; //var createHAR = require('./createHAR.js'); var createHooks = require ( './createHooks.js' ) ; var hooksApi = require ( './hooksApi.js' ) ; var api = hooksApi ( phantom , page ) ; var triggerHook = createHooks ( page , page . options . files , api ) ; // todo move to options triggerHook ( 'onBeforeExit' ) ;", "del_tokens": "var page = require ( 'webpage' ) . create ( ) ; var system = require ( 'system' ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "linter", "pass", "."], "add_tokens": "} route . locals [ k ] = $injector . get ( resolver ) ; route . locals [ k ] = $injector . invoke (", "del_tokens": "} ; route . locals [ k ] = injector . get ( resolver ) ; route . locals [ k ] = injector . invoke (", "commit_type": "make"}
{"commit_tokens": ["moved", "to", "babel", ".", "updated", "to", "react", "14", "react", "-", "dom", "14", ".", "fixed", "src", "/", "tests", "/", "fixtures", "after", "update", "broke", "them", "."], "add_tokens": "/*! React Starter Kit | MIT License */ import React from 'react' ; const anotherValidComponent = React . createClass ( { getDefaultProps : function getDefaultProps ( ) { some : 'prop' , render : function render ( ) { let id = 0 ; React . createElement ( 'ul' , null , Object . keys ( this . props ) . map ( ( key ) => { return ( React . createElement ( 'li' , { key : id ++ } , key , ' : ' , this . props [ key ] ) ) ; } , export default anotherValidComponent ;", "del_tokens": "var React = require ( 'react' ) ; var anotherValidComponent = React . createClass ( { getDefaultProps : function ( ) { some : 'prop' render : function ( ) { var id = 0 ; React . createElement ( \"ul\" , null , Object . keys ( this . props ) . map ( function ( key ) { return ( React . createElement ( \"li\" , { key : ++ id } , key , \" : \" , this . props [ key ] ) ) ; } module . exports = anotherValidComponent ;", "commit_type": "move"}
{"commit_tokens": ["added", "10mb", "limit", "to", "json", "body"], "add_tokens": "//app.use(express.bodyParser({limit: '50mb'})) app . use ( express . json ( { limit : '10mb' } ) ) ;", "del_tokens": "app . use ( express . json ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Makes", "mouseenter", "and", "mouseleave", "events", "capturable", "and", "adds", "mouseover", "and", "mouseout", "."], "add_tokens": "'focus' : true , 'mouseenter' : true , 'mouseleave' : true 'mouseout' , 'mouseover' ,", "del_tokens": "'focus' : true", "commit_type": "make"}
{"commit_tokens": ["Updating", "README", "fixing", "reconnection", "strategies", "and", "exposing", "client", "state"], "add_tokens": "this . _isConnected = false ; strategy : [ 'online' , 'disconnect' ] / ** * Returns true if the client is currently connected to the server , false if * it is not . * * @ returns { Boolean } Whether the client is connected to the server or not . * / get isConnected ( ) { return this . _isConnected ; }", "del_tokens": "strategy : 'offline,disconnected'", "commit_type": "update"}
{"commit_tokens": ["Adds", "detect", "indentation", "and", "CLI", "option", "to", "set", "indent", "size", "."], "add_tokens": "const detectIndent = require ( 'detect-indent' ) ; const DEFAULT_INDENT_SIZE = 2 ; let fileContent = null ; fileContent = fs . readFileSync ( path , 'utf8' ) ; newData = visit ( JSON . parse ( fileContent ) , options ) ; let indent ; if ( options && options . indentSize ) { indent = options . indentSize ; } else { indent = detectIndent ( fileContent ) . indent || DEFAULT_INDENT_SIZE ; } const newJson = JSON . stringify ( newData , null , indent ) ;", "del_tokens": "newData = visit ( JSON . parse ( fs . readFileSync ( path , 'utf8' ) ) , options ) ; const newJson = JSON . stringify ( newData , null , 2 ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "parsing", "of", "seconds", "/", "milliseconds"], "add_tokens": "var isoMatch = value . match ( / ^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}).(\\d{3})Z$ / ) ; date . setUTCMilliseconds ( isoMatch [ 7 ] ) ;", "del_tokens": "var isoMatch = value . match ( / ^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}.\\d{3})Z$ / ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "a", "more", "general", "get", "function", "with", "less", "code", "duplication"], "add_tokens": "return await this . request ( this . url )", "del_tokens": "throw new Error ( '\"get\" is only available for bulk expanding endpoints' )", "commit_type": "use"}
{"commit_tokens": ["fix", ":", "quest", ".", "fetch", "empty", "response"], "add_tokens": "concat ( res ) . on ( 'data' , resolve ) . on ( 'end' , resolve )", "del_tokens": "concat ( res ) . on ( 'data' , resolve )", "commit_type": "fix"}
{"commit_tokens": ["Adding", "better", "error", "handling", "around", "a", "queue", "not", "existing", "."], "add_tokens": "err = err || job . Error ; if ( err ) { console . log ( err ) ; _this . _processSQSMessage ( ) ; return ; } if ( ! job . ReceiveMessageResult . Message ) {", "del_tokens": "// there are currently no messages available. if ( err || ! job . ReceiveMessageResult . Message ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "<input", "type", "=", "email", ">"], "add_tokens": "dom ( 'input type=email placeholder=you@yourdomain.com '", "del_tokens": "dom ( 'input type=text placeholder=you@yourdomain.com '", "commit_type": "use"}
{"commit_tokens": ["Adding", "background", "refresh", "feature", "."], "add_tokens": "var refresh = function ( key , cb ) {", "del_tokens": "var refresh = function ( cb ) {", "commit_type": "add"}
{"commit_tokens": ["Made", "it", "possible", "to", "document", "two", "components", "in", "the", "same", "file"], "add_tokens": "this . components = [ ] ; var count = 0 ; this . mess . forEach ( function ( section , i ) { this . components [ count ] = { } ; } . bind ( this ) ) ; this . keys . forEach ( function ( key , i ) { if ( this . components [ count ] . hasOwnProperty ( key ) ) { count ++ ; this . components [ count ] = { } ; } this . components [ count ] [ key ] = this . values [ i ] ; return this . components ;", "del_tokens": "this . obj = { } ; this . mess . forEach ( function ( section ) { this . keys . forEach ( function ( key , i ) { this . obj [ key ] = this . values [ i ] ; } . bind ( this ) ) ; return this . obj ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "command", "name", "in", "usage", "docs"], "add_tokens": "vtshaver - filters [ args ] vtshaver - filters -- style style . json > meta . json", "del_tokens": "collapse - filters [ args ] collapse - filters -- style style . json > meta . json", "commit_type": "fix"}
{"commit_tokens": ["use", "package", ".", "json", "defined", "version", "in", "commander"], "add_tokens": "var pkg = require ( './package.json' ) ; . version ( pkg . version )", "del_tokens": ". version ( '0.0.9' )", "commit_type": "use"}
{"commit_tokens": ["Changed", "data", "backend", "to", "jugglingdb"], "add_tokens": "var users = require ( './lib/users' ) ; var posts = require ( './lib/posts' ) ; if ( ! req . cookies . token ) { next ( ) ; } else { users . findByToken ( req . cookies . token , function ( err , user ) { } ) ; } } ) ; app . resource ( 'users' , users ) ;", "del_tokens": "var db = require ( 'riak-js' ) . getClient ( ) ; if ( ! req . cookies . token ) { return next ( ) ; } db . get ( 'tokens' , req . cookies . token , function ( err , user ) { if ( ! err && user ) { } else if ( err && err . statusCode === 404 ) { next ( ) ; } else { next ( err ) ; } } ) ; } ) var users = require ( './lib/users' ) ; app . resource ( 'users' , users ) ; var posts = require ( './lib/posts' ) ;", "commit_type": "change"}
{"commit_tokens": ["added", "countonmejs", ";", "deleted", "utils", ".", "stopwatch"], "add_tokens": "'bower_components/againjs/dist/againjs.min.js' , 'bower_components/countonmejs/dist/countonmejs.min.js' ,", "del_tokens": "'bower_components/againjs/dist/again.min.js' , 'src/main/utils/vissense.utils.stopwatch.js' ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "months", "and", "years", "calculation"], "add_tokens": "$scope . months = Math . floor ( ( ( $scope . millis / ( 3600000 ) ) / 24 / 30 ) % 12 ) ; $scope . years = Math . floor ( ( $scope . millis / ( 3600000 ) ) / 24 / 365 ) ;", "del_tokens": "$scope . months = Math . floor ( ( $scope . millis / ( 3600000 ) ) / 24 / 30 ) ; $scope . years = Math . floor ( ( $scope . millis / ( 3600000 ) ) / 24 / 30 / 12 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "a", "global", "mouse", "clicked", "construction", "parameter"], "add_tokens": "$scope . globalMouseClicked = function ( dx , x , dy , y ) { var hexagonalCoordinates = $scope . hexDimensions . getReferencePoint ( x - dx , y - dy ) ; $rootScope . $broadcast ( 'addAlert' , { type : 'info' , msg : 'Clicked U:' + hexagonalCoordinates . u + ' V:' + hexagonalCoordinates . v } ) ; } ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Use", "in", "-", "place", "BN", "operators"], "add_tokens": "num = new BN ( '10000000000000000000000000000000000000000000000000000000000000000' , 16 ) . isub ( num . iabs ( ) ) ;", "del_tokens": "num = new BN ( '10000000000000000000000000000000000000000000000000000000000000000' , 16 ) . sub ( num . abs ( ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "helpful", "errors", "for", "JSON", "parse", "errors"], "add_tokens": "var jph = require ( 'json-parse-helpfulerror' ) if ( e instanceof SyntaxError ) e . message = 'Malformed JSON in file: ' + file + '\\n' + e . message ; return jph . parse ( str )", "del_tokens": "if ( e instanceof SyntaxError ) e . message = 'Malformed JSON' e . message += ' in file:' + file return JSON . parse ( str )", "commit_type": "add"}
{"commit_tokens": ["adds", "option", "for", "versions", "of", "less", ".", "js"], "add_tokens": "var path = require ( 'path' ) ; //var less = require('less'); var fs = require ( 'fs' ) ; version : \"less\" , var less = require ( options . version ) ; } ;", "del_tokens": "var path = require ( 'path' ) ; var less = require ( 'less' ) ; var fs = require ( 'fs' ) ; } ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "a", "bug", "with", "DOMEvents", "transitions", "on", "StatefulView", "+", "fixed", "examples"], "add_tokens": "startStateMachine : function ( ) { // Remembers the events registered using `transition`, so that // they are not bound twice. this . _eventRegistry = [ ] ; Backbone . StateMachine . startStateMachine . apply ( this , arguments ) ; } , } else events = this . events = { } ; if ( this . _eventRegistry . indexOf ( event ) == - 1 ) { var newEventCb = _ . bind ( function ( DOMEvent ) { if ( eventCb ) eventCb . apply ( this , arguments ) ; this . _receive ( event , DOMEvent ) ; if ( data . preventDefault ) DOMEvent . preventDefault ( ) ; } , this ) ; events [ event ] = newEventCb ; this . delegateEvents ( events ) ; this . _eventRegistry . push ( event ) ; }", "del_tokens": "} else events = { } ; var newEventCb = _ . bind ( function ( DOMEvent ) { if ( eventCb ) eventCb . apply ( this , arguments ) ; this . _doTransition ( data , DOMEvent ) ; } , this ) ; events [ event ] = newEventCb ; this . delegateEvents ( events ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "scroll", "offsets", "in", "bb", ".", "js"], "add_tokens": "top : pos . y + offset . top , left : pos . x + offset . left , right : pos . x + dims . w + offset . left , bottom : pos . y + dims . h + offset . top ,", "del_tokens": "var scrollY = window . pageYOffset ; var scrollX = window . pageXOffset ; top : pos . y + offset . top + scrollY , left : pos . x + offset . left + scrollX , right : pos . x + dims . w + offset . left + scrollX , bottom : pos . y + dims . h + offset . top + scrollY ,", "commit_type": "remove"}
{"commit_tokens": ["Make", "Animated", "Value", "persist", "its", "value", "after", "reattaching"], "add_tokens": "ReanimatedModule . createNode ( this . __nodeID , { ... this . __nodeConfig } ) ;", "del_tokens": "ReanimatedModule . createNode ( this . __nodeID , this . __nodeConfig ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "automatic", "refreshing", "of", "tokens"], "add_tokens": "redirect_uri : redirect_uri , access_type : 'offline' var client_id = factory . metadata . auth . client_id || params . client_id ; var client_secret = factory . metadata . auth . client_secret || rot13 ( params . client_secret ) ; var auth = new oauth . OAuth2 ( client_id , client_secret , '' , params . authorize , params . get_access_token ) ; auth . useAuthorizationHeaderforGET ( true ) ; var redirect_uri ;", "del_tokens": "redirect_uri : redirect_uri var refreshToken = result [ 1 ] ; device . state . refreshToken = refreshToken ;", "commit_type": "fix"}
{"commit_tokens": ["Move", "the", "config", "param", "extraction", "to", "a", "function"], "add_tokens": "function prepareConfig ( ) { } window . addEventListener ( 'hashchange' , function ( e ) { prepareConfig ( ) ; prepareConfig ( ) ; var containers = document . querySelectorAll ( tagContent + ':not([' + specialHideAttribute + '])' ) ;", "del_tokens": "window . addEventListener ( 'hashchange' , function ( e ) { var containers = document . querySelectorAll ( tagContent + ':not([hidden])' ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "a", "level", "of", "abstraction", "to", "hide", "transmit", "protocol", "implementation"], "add_tokens": "socketPromise = new Promise ( function ( resolve ) { // XXX note that we do not reject explicitly resolve ( function transmit ( payload , callback ) { socket . write ( JSON . stringify ( payload ) + '\\n' , callback ) ; } ) ;", "del_tokens": "socketPromise = new Promise ( function ( resolve , reject ) { resolve ( socket ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "regression", "when", "adding", "data", "-", "attributes", "to", "DOM", "elements"], "add_tokens": "// elem[key] = value; elem . attr ( key , value ) ; return elem ;", "del_tokens": "elem [ key ] = value ; return $ ( elem ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "6to5", "loader", "in", "webpack", "configs"], "add_tokens": "loader : '<% if (es6) { %>6to5!<% }%>jsx-loader?harmony'", "del_tokens": "loader : 'jsx-loader?harmony'", "commit_type": "add"}
{"commit_tokens": ["fixed", "a", "grip", "/", "pubcontrol", "issue", "related", "to", "pcccbhandlers"], "add_tokens": "isPubControlClientCallbackHandler : function ( ) { return true ; } , if ( cb && cb . isPubControlClientCallbackHandler ) {", "del_tokens": "if ( cb instanceof PubControlClientCallbackHandler ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "some", "digit", "specific", "functions"], "add_tokens": "'DEVICE_NAME_DEFAULT' : 'TEST_DEVICE' var port = 0 ; port = 502 ; self . devAttr . port = port ;", "del_tokens": "self . devAttr . port = 502 ;", "commit_type": "add"}
{"commit_tokens": ["Added", "providers", "to", "umbrella", "package", "."], "add_tokens": "var providers = require ( './providers/index.js' ) ; providers : providers ,", "del_tokens": "//var providers = require('providers'); // providers: providers,", "commit_type": "add"}
{"commit_tokens": ["fixed", "a", "bug", "with", "custom", "ports", "on", "API", "host", "for", "Node", ".", "js"], "add_tokens": "statusCode = err . status || err . statusCode ; statusMessage = err . statusText || err . message || 'No error message' ; else { if ( typeof console !== 'undefined' && console . log ) { console . log ( statusCode , statusMessage , type ) ; } } port : url_parsed . port || 80 ,", "del_tokens": "statusCode = err . status ; statusMessage = err . statusText ; else port : opts . port || 80 ,", "commit_type": "fix"}
{"commit_tokens": ["Remove", "logging", "and", "rename", "variables"], "add_tokens": "console . error ( types ) ; console . error ( err ) ; RED . loader . load ( ) . then ( ( nodeFiles ) => { // console.log(nodeFiles['node-red']['nodes']['mqtt'].js); for ( let nodeFile in nodeFiles ) { for ( let node in nodeFiles [ nodeFile ] [ 'nodes' ] ) { const js = 'const RED = this.RED;' + nodeFiles [ nodeFile ] [ 'nodes' ] [ node ] . js ; console . error ( err ) ; console . error ( err ) ;", "del_tokens": "console . log ( '***' ) ; console . log ( types ) ; console . log ( err ) ; console . log ( '***' ) ; RED . loader . load ( ) . then ( ( x ) => { console . log ( x [ 'node-red' ] [ 'nodes' ] [ 'mqtt' ] . js ) ; for ( let package in x ) { for ( let node in x [ package ] [ 'nodes' ] ) { const js = 'const RED = this.RED;' + x [ package ] [ 'nodes' ] [ node ] . js ; console . log ( err ) ; console . log ( 'Resolve1' ) ; console . log ( 'Resolve2' ) ; console . log ( err ) ;", "commit_type": "remove"}
{"commit_tokens": ["fix", "issue", "with", "expandHomeDir", "resolving", "absolute", "path"], "add_tokens": "if ( path === '~' ) { if ( ! homeDir ) { return false ; } return homeDir ; } if ( ! path || ath[ 0 ] == ~')", "del_tokens": "if ( ! path ) { if ( path === '~' ) { return homeDir ; } if ( path . slice ( 0 , 2 ) !== '~/' ) { return path ; }", "commit_type": "fix"}
{"commit_tokens": ["fix", "issue", "with", "wrong", "type", "for", "typed", "arrays"], "add_tokens": "if ( array instanceof WebGLBuffer ) { return array ; } return a && a . buffer && a . buffer instanceof ArrayBuffer ; if ( isArrayBuffer ( array . data ) ) { return array . data ; }", "del_tokens": "return a . buffer && a . buffer instanceof ArrayBuffer ;", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "fetch", "()", "for", "collections", "then", "made", "it", "work", "."], "add_tokens": "var self = this ; this . __items . length = 0 ; item = new this . __model ( ) ; item . update ( data [ i ] ) ; Sculpy . Collection . prototype . fetch = function ( success , failure ) { var self = this ; var winning = function ( data , textStatus , jqXHR ) { self . reset ( data ) ; } ; var losing = function ( jqXHR , textStatus , errorThrown ) { // TODO } ; $ . ajax ( { url : this . url ( ) , type : 'GET' , success : winning , error : losing } ) ; } ;", "del_tokens": "return this ; this . __items . clear ( ) ; item = this . __model ( ) ; item . update ( data ) ;", "commit_type": "implement"}
{"commit_tokens": ["add", "es6", "flag", "for", "jshint", ".", "export", "test", "functions", "individually"], "add_tokens": "//The connection string will be of the form mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] assert . notEqual ( result . database . port , 0 , 'at least one port must be specified in the mongodb connection string' ) ; return result", "del_tokens": "//The connection string will be of the form mongodb://username:pass@db1.prv.mbaas2.cluster.feedhenry.net,db2.prv.mbaas2.cluster.feedhenry.net:27017/domain-vvuq7douloe2zkyktub7fcmt-demos-dev?replicaSet=cluster-mbaas2_rs1 assert . notEqual ( result . database . port , 0 , 'at least one host must be specified in the mongodb connection string' ) ; return result ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "typo", "in", "names", "now", "using", "more", "international", "spelling"], "add_tokens": "const { String : { kebabToPascal } } = Utilities ; const modelName = definition . name || kebabToPascal ( name . toLocaleLowerCase ( ) ) ;", "del_tokens": "const { String : { kebapToPascal } } = Utilities ; const modelName = definition . name || kebapToPascal ( name . toLocaleLowerCase ( ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "test", "and", "unwrapped", "blobs", ".", "add", "in", "inject", ".", "js"], "add_tokens": "add : blobs . add , if ( ! isBlobId ( id ) )", "del_tokens": "add : wrap ( blobs . add ) , if ( ! isBlobId ( id ) )", "commit_type": "fix"}
{"commit_tokens": ["Made", "all", "logo", "links", "consistent"], "add_tokens": "var my_skins = [ \"skin-blue\" , \"skin-black\" , \"skin-red\" , \"skin-yellow\" , \"skin-purple\" , \"skin-green\" ] ; function change_skin ( cls ) { $ . each ( my_skins , function ( i ) { $ ( \"body\" ) . removeClass ( my_skins [ i ] ) ; var tmp = get ( 'skin' ) ; if ( tmp && $ . inArray ( tmp , my_skins ) ) change_skin ( tmp ) ;", "del_tokens": "function change_skin ( cls ) { var skins = [ \"skin-blue\" , \"skin-black\" , \"skin-red\" , \"skin-yellow\" , \"skin-purple\" , \"skin-green\" ] ; $ . each ( skins , function ( i ) { $ ( \"body\" ) . removeClass ( skins [ i ] ) ; if ( get ( 'skin' ) ) change_skin ( get ( 'skin' ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "strings", "when", "instantiating", "an", "error"], "add_tokens": "* Erroz class , as described in this article : * ErrozError function Erroz ( constr ) { util . inherits ( Erroz , Error ) ; Erroz . prototype . name = \"Erroz\" ; module . exports = Erroz ;", "del_tokens": "* AbstractError class , as described in this article : * AbstractError function AbstractError ( constr ) { util . inherits ( AbstractError , Error ) ; AbstractError . prototype . name = \"AbstractError\" ; module . exports = AbstractError ;", "commit_type": "add"}
{"commit_tokens": ["add", "error", "event", "handler", "on", "the", "xml", "parser"], "add_tokens": "OrderReporting = require ( './order-reporting' ) ; self . OrderReporting = new OrderReporting ( self ) ; parser . on ( 'end' , function ( result ) { parser . on ( 'error' , function ( error ) { return callback ( error , body ) ; } ) ;", "del_tokens": "OrderReporting = require ( './order-reporting' ) parser . addListener ( 'end' , function ( result ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "package", "main", "shorthand", "in", "module", "names"], "add_tokens": "return module . indexOf ( p + '/' ) === 0 || module === p ;", "del_tokens": "return module . indexOf ( p + '/' ) === 0 ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "documentation", "and", "updated", "for", "npm"], "add_tokens": "destination : 'doc/html' , configure : 'jsdoc.json'", "del_tokens": "destination : 'doc/html'", "commit_type": "fix"}
{"commit_tokens": ["fixing", "a", "bug", "at", ".", "keys", "()"], "add_tokens": "newArr . push ( arr [ l ] ) ;", "del_tokens": "newArr . push ( iteratee ) ; // console.log(key) // console.log(this.keys(key))", "commit_type": "fix"}
{"commit_tokens": ["Use", "data", "-", "attributes", "for", "js"], "add_tokens": "< div class = \"connection\" data-connection > < div class = \"connection-start\" data-connection-start > < / div > < div class = \"connection-end\" data-connection-end > < / div > q . all ( '[data-block-input]:not([hidden])' , app . container ) . forEach ( function ( el ) { var blockEl = el . closest ( '[data-block]' ) ;", "del_tokens": "< div class = \"connection\" > < div class = \"connection-start\" > < / div > < div class = \"connection-end\" > < / div > q . all ( '.block-in:not([hidden])' , app . container ) . forEach ( function ( el ) { var blockEl = el . closest ( '.block' ) ;", "commit_type": "use"}
{"commit_tokens": ["Adding", "article", "tokenizer", "to", "clean", "api", "endpoint"], "add_tokens": "'/api/text/clean' : 'TextController.clean' ,", "del_tokens": "'/api/text/tokenize' : 'TextController.tokenize' ,", "commit_type": "add"}
{"commit_tokens": ["Add", "name", "attributes", "to", "form", "inputs", "so", "JSON", "Editor", "can", "be", "embedded", "in", "an", "HTML", "form", "."], "add_tokens": "register : function ( ) { this . _super ( ) ; if ( ! this . input ) return ; this . input . setAttribute ( 'name' , this . formname ) ; } , unregister : function ( ) { this . _super ( ) ; if ( ! this . input ) return ; this . input . removeAttribute ( 'name' ) ; } , this . enum_display = [ ] ; self . enum_display [ i ] = \"\" + option ; self . enum_display = [ 'true' , 'false' ] ; self . enum_options = [ '1' , '' ] ; this . theme . setSelectOptions ( this . input , this . enum_options , this . enum_display ) ; this . register ( ) ;", "del_tokens": "self . enum_options = [ 'true' , 'false' ] ;", "commit_type": "add"}
{"commit_tokens": ["Added", "initial", "css", "selectors", "ofr", "coe", "."], "add_tokens": "// TODO // might be able to scrape events off facebook pages for more info on when they are meeting // looks like a lot of them havae outdated/missing/incorrect/unparssable timestamps of when they are meeting on here ewwww // but there is probably enough to get a proof of concept working // could email to verify // // http://neu.orgsync.com/student_orgs async function scrapeLetterAndPage ( letter , pageNum ) { const resp = await request . post ( ` ${ letter . toUpperCase ( ) } ${ pageNum } ` ) ; async function scrapeLetter ( letter ) { var totalOrgs = [ ] var pageNum = 1 // Each letter is pagenated // Increment the page number until hit a page with no results while ( true ) { var orgs = await scrapeLetterAndPage ( letter , pageNum ) console . log ( letter , 'page#' , pageNum , 'had' , orgs . length , 'orgs now at ' , orgs . length ) ; pageNum ++ if ( orgs . length === 0 ) { return totalOrgs } if ( pageNum > 30 ) { console . log ( 'Warning! Hit 30 page max, returning' ) return totalOrgs } totalOrgs = totalOrgs . concat ( orgs ) } }", "del_tokens": "async function scrapeLetter ( letter ) { const resp = await request . post ( ` ${ letter . toUpperCase ( ) } ` ) ; console . log ( letter , 'had' , someOrgs . length , 'orgs now at ' , orgs . length ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "#", ".", "inspect", "output"], "add_tokens": "// TODO: lazily create attributes object if ( this . hasOwnProperty ( k ) && ! EMITTER_PROPS . has ( k ) && typeof this [ k ] !== 'function' )", "del_tokens": "// TODO: fix result of #.inspect if ( this . hasOwnProperty ( k ) && ! EMITTER_PROPS . has ( k ) )", "commit_type": "fix"}
{"commit_tokens": ["Added", "new", "chainable", "View", "class", "for", "generating", "instances", "of", "pages", "and", "UI", "view", "to", "reduce", "test", "code", "duplication", ".", "Added", "new", "test", "dependencies"], "add_tokens": "// Expose the View class globally so that loaded test files have access to it global . View = require ( '../lib/View' ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "jsdoc", "typo", "in", "unregisterServiceAsync", "definition"], "add_tokens": "* Unregisters ( removes ) a DXL service from the fabric asynchronously . The", "del_tokens": "* Unregisters ( removes ) a DXL service with from the fabric asynchronously . The", "commit_type": "fix"}
{"commit_tokens": ["Changed", "error", "message", "color", "to", "bold", "red"], "add_tokens": "var LEVEL_COLORS = [ [ 'red' , 'bold' ] , 'yellow' , 'green' , null ] ; if ( Array . isArray ( color ) ) { for ( var i = 0 , len = color . length ; i < len ; i ++ ) { message = message [ color [ i ] ] ; } } else { message = message [ color ] ; }", "del_tokens": "var LEVEL_COLORS = [ 'red' , 'yellow' , 'green' , null ] ; message = message [ color ] ;", "commit_type": "change"}
{"commit_tokens": ["Added", "some", "tests", "to", "Requestify", "tests"], "add_tokens": "var cacheStub ; beforeEach ( function ( ) { cacheStub = { setCacheTransporter : sinon . stub ( ) , get : sinon . stub ( ) , set : sinon . stub ( ) , purge : sinon . stub ( ) , isTransportAvailable : sinon . stub ( ) } ; requestify . __set__ ( 'cache' , cacheStub ) ; } ) ; httpsStub , cacheStub ; describe ( '#cacheTransporter()' , function ( ) { it ( 'should do nothing since called it without any transporter' , function ( ) { requestify . cacheTransporter ( ) ; expect ( cacheStub . setCacheTransporter . called ) . to . equal ( false ) ; } ) ; it ( 'should call cache.setCacheTransporter with the transporter' , function ( ) { requestify . cacheTransporter ( { } ) ; expect ( cacheStub . setCacheTransporter . called ) . to . equal ( true ) ; } ) ; } ) ;", "del_tokens": "httpsStub ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "multiple", "usage", "types"], "add_tokens": "var first = arguments [ 0 ] ; if ( arguments . length === 1 && ( argumentList . length !== 1 || ( first instanceof Object && first [ argumentList [ 0 ] ] ) ) ) { options = first ;", "del_tokens": "if ( typeof arguments [ 0 ] === 'object' ) { options = arguments [ 0 ] ;", "commit_type": "fix"}
{"commit_tokens": ["added", "error", "tree", "flattener", "for", "express", "/", "jade", "error", "reporting"], "add_tokens": ", tsa = require ( '../' ) res . render ( 'index' , { result : null , errors : tsa . flattenErrors ( err ) } ) ;", "del_tokens": "res . render ( 'index' , { result : null , errors : err . map ( function ( e ) { return JSON . stringify ( e ) ; } ) } ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "small", "bug", "in", "hooks"], "add_tokens": "var split = hook . split ( '|' ) ; return hooks [ split [ 0 ] ] . call ( gdt , split [ 1 ] || '' ) ; return dexec ( 'cd ' + this . settings . git + '; npm install' ) . done ( function ( stdout , stderr ) { grunt : function ( tasks ) { return hooks . _grunt . call ( this , tasks , 'grunt' ) ; } , bbb : function ( tasks ) { return hooks . _grunt . call ( this , tasks , 'bbb' ) ; } , _grunt : function ( tasks , gruntCmd ) { tasks = tasks || '' ; return dexec ( 'cd ' + this . settings . git + '; ' + gruntCmd + ' --no-color ' + tasks )", "del_tokens": "return hook . apply ( gdt , arguments ) ; return dexec ( 'cd ' + site . git + '; npm install' ) . done ( function ( stdout ) { grunt : function ( tasks , gruntCmd ) { if ( tasks === \"object\" && tasks . length ) { tasks = tasks . join ( ' ' ) ; } return dexec ( 'cd ' + site . git + '; ' + gruntCmd + ' --no-color ' + tasks )", "commit_type": "fix"}
{"commit_tokens": ["improve", "context", "sharing", "for", "beforeEach", "/", "afterEach"], "add_tokens": "// wrapper to allow context to be a primitive value var contextWrapper = { context : { } } ; Object . defineProperty ( test , 'context' , { get : function ( ) { return contextWrapper . context ; } , set : function ( val ) { contextWrapper . context = val ; } } ) ; return this . _runTest ( test ) ; Runner . prototype . _runTest = function ( test ) {", "del_tokens": "var context = { } ; return this . _runTest ( test , context ) ; Runner . prototype . _runTest = function ( test , context ) { // shared context (only applies to tests with hooks around them) // set only if `context` is an object (can be index number) if ( typeof context === 'object' ) { test . context = context ; }", "commit_type": "improve"}
{"commit_tokens": ["Create", "proper", "Content", "-", "type", "header", "with", "charset"], "add_tokens": "var mime = require ( 'mime-types' ) ; var type = options . mime [ object . src ] || object . params . ContentType || mime . contentType ( object . src ) ;", "del_tokens": "var mime = require ( 'mime' ) ; var type = options . mime [ object . src ] || object . params . ContentType || mime . lookup ( object . src ) ;", "commit_type": "create"}
{"commit_tokens": ["Fix", "scope", "ending", "logic", "."], "add_tokens": "function check ( character , expected ) { return error ( '`' + character + '`' , '`' + expected + '`' ) ; check ( character , terminators [ scope ] ) ; if ( character === terminators [ scope ] ) { emitter . emit ( 'end-' + scopes . pop ( ) ) ; }", "del_tokens": "function check ( character , expected , event ) { return error ( '`' + character + '`' , expected ) ; } if ( event ) { emitter . emit ( event ) ; check ( character , terminators [ scope ] , 'end-' + scope ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "spread", "arg", "rather", "than", "arguments", "variable"], "add_tokens": "function elt ( name , ... children ) { for ( let i = 0 ; i < children . length ; i ++ ) { let child = children [ i ] dom . appendChild ( typeof child == \"string\" ? doc . createTextNode ( child ) : child )", "del_tokens": "function elt ( name ) { for ( let i = 1 ; i < arguments . length ; i ++ ) { let arg = arguments [ i ] dom . appendChild ( typeof arg == \"string\" ? doc . createTextNode ( arg ) : arg )", "commit_type": "use"}
{"commit_tokens": ["remove", "console", "line", "in", "tests", "."], "add_tokens": "assert . ok ( content ) ;", "del_tokens": "console . log ( arguments )", "commit_type": "remove"}
{"commit_tokens": ["Updated", "test", "for", "negative", "values"], "add_tokens": "const currencies = new Currencies ( { keys : - 1 , metal : - 4.77 } ) ; assert . strictEqual ( currencies . toValue ( 33 ) , - 340 ) ;", "del_tokens": "const currencies = new Currencies ( { keys : - 1 , metal : - 1 } ) ; assert . strictEqual ( currencies . toValue ( 33 ) , - 306 ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "text", "label", "in", "Point", "layer"], "add_tokens": "visConfig : { } , textLabel : { field : null , color : [ 255 , 255 , 255 ] , size : 50 , offset : [ 0 , 0 ] , anchor : 'middle' }", "del_tokens": "visConfig : { }", "commit_type": "add"}
{"commit_tokens": ["Adding", "a", "parameter", "to", "optionally", "allow", "debounce", "to", "occur", "without", "triggering", "a", "digest", "cycle", ".", "Also", "explicitly", "listing", "dependencies", "to", "comply", "with", "strict", "mode", "."], "add_tokens": "angular . module ( 'rt.debounce' , [ ] ) . factory ( 'debounce' , [ '$timeout' , function ( $timeout ) { return function ( wait , fn , no_postpone , skipApply ) { timeout = $timeout ( ping , wait , ! skipApply ) ; timeout = $timeout ( ping , wait , ! skipApply ) ; } ] ) ;", "del_tokens": "angular . module ( 'rt.debounce' , [ ] ) . factory ( 'debounce' , function ( $timeout ) { return function ( wait , fn , no_postpone ) { timeout = $timeout ( ping , wait ) ; timeout = $timeout ( ping , wait ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "bit", "of", "padding", "to", "inputs"], "add_tokens": "width : '50%' , paddingLeft : '10px' , paddingRight : '10px'", "del_tokens": "width : '50%'", "commit_type": "add"}
{"commit_tokens": ["Add", ".", "jshintrc", "AUTHORS", "CHANGELOG", "CONTRIBUTING", ".", "md", ".", "Update", "Gruntfile", ".", "js", "package", ".", "json"], "add_tokens": "if ( state === 'failed' ) {", "del_tokens": "if ( state == 'failed' ) {", "commit_type": "add"}
{"commit_tokens": ["Allow", "file", "to", "be", "passed", "in", "cli", "to", "publish"], "add_tokens": ". command ( 'publish [file]' , 'Publishes the extension to the Rung store' )", "del_tokens": ". command ( 'publish' , 'Publishes the extension to the Rung store' )", "commit_type": "allow"}
{"commit_tokens": ["Added", "check", "that", "extractor", "is", "truable", "if", "not", "the", "result", "returned", "by", "get", "()", "will", "be", "undefined", "so", "get", "()", "does", "not", "throw", "any", "error"], "add_tokens": "var result ; if ( extractor ) { result = extractor . operation ( this . $ , this . url ) ; } return result ;", "del_tokens": "return extractor . operation ( this . $ , this . url ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "and", "merge", "in", "new", "parser"], "add_tokens": "while ( defaultGroup . lastChild ) { defaultGroup . removeChild ( defaultGroup . lastChild ) ; } 0 , 0 , 0 , 1 , 0 ,", "del_tokens": "defaultGroup . innerHTML = \"\" ; 0 , 0 , 0 , 0 , 1 ,", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "of", "custom", "parens"], "add_tokens": "assert . deepEqual ( paren . parse ( 'a(b[c{d}])' , [ '{}' , '[]' , '()' ] ) , [ 'a(\\\\3)' , 'd' , 'c{\\\\1}' , 'b[\\\\2]' ] ) ;", "del_tokens": "assert . deepEqual ( paren ( 'a(b[c{d}])' ) , [ 'a(\\\\3)' , 'd' , 'c{\\\\1}' , 'b[\\\\2]' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["using", "process", ".", "umask", "()", "using", "mkdirp", "for", "paths", "not", "yet", "initialized", "in", "origin", "json", "adding", "miniscule", "test", "for", "json2dir"], "add_tokens": "if ( typeof options === 'function' ) { callback = options ; options = { } ; } var count = 1 ; if ( typeof options === 'function' ) { callback = options ; options = { } ; } // json2dir({ // \"-path\": \"test/output\", // }, function(err) { // if (err) throw err; // console.log(\":D\"); // });", "del_tokens": "options = options || { } ; var count = 0 ; options = options || { } ; json2dir ( { \"-path\" : \"output\" , \"-mode\" : { value : 511 , inherit : true } , \"test\" : { \"a\" : { } , \"b\" : { \"-type\" : \"d\" } , \"c\" : { } } } , { overwrite : true } , function ( err ) { if ( err ) throw err ; console . log ( \":D\" ) ; } ) ;", "commit_type": "use"}
{"commit_tokens": ["Update", "to", "newest", "prelude", "from", "browser", "-", "pack"], "add_tokens": "( function outer ( modules , cache , entry ) { modules [ name ] [ 0 ] . call ( m . exports , function ( x ) { } , m , m . exports , outer , modules , cache , entry ) ;", "del_tokens": "( function ( modules , cache , entry ) { modules [ name ] [ 0 ] ( function ( x ) { } , m , m . exports ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "function", "to", "fill", "a", "form", "check", "for", "selector", "value", "and", "submit", "a", "form"], "add_tokens": "} ) ; it ( 'Can fill a form and query a form for its value' , function ( done ) { var browser = new PhantomHigh ( ) ; var url = testUrls [ 2 ] ; const USERNAME_SELECTOR = '#form-username' ; const PASSWORD_SELECTOR = '#form-password' ; const USERNAME = 'user123' ; browser . openPage ( url ) . fillForm ( USERNAME_SELECTOR , USERNAME ) . getSelectorValue ( USERNAME_SELECTOR , function ( error , result ) { assert . equal ( result , USERNAME , 'Username should be equal to filled value' ) ; browser . done ( ) ; done ( error ) ; } ) } )", "del_tokens": "} )", "commit_type": "add"}
{"commit_tokens": ["adding", "cli", "--", "file", "support", "to", "load", "options", "files", "from", "the", "command", "line"], "add_tokens": ", loadCompleteOptions = require ( './loadCompleteOptionsCmd.js' ) runServer ( cli . options ) } function runServer ( options ) { options = loadCompleteOptions ( options ) startServer ( options )", "del_tokens": "startServer ( cli . options )", "commit_type": "add"}
{"commit_tokens": ["Add", "watchOnce", "method", "for", "single", "use", "watchers"], "add_tokens": "/ ** * Watch for changes on a given key once , and execute the provided callback * when there are changes . Callback removes itself after the first call so * that it is never called again . * * @ param { String [ ] | String } String path or array of paths to watch * @ param { Function } callback to execute when there are changes * @ param { Object } options Options * @ param { Number } options . priority Controls the order the provided callback is called when multiple watches exist on the same key . * / function watchOnce ( paths , callback ) { var options = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { priority : 0 } ; var onceCallback = function _watchOnceCallback ( ) { callback . apply ( undefined , arguments ) ; unwatch ( onceCallback ) ; } ; return watch ( paths , onceCallback , options ) ; } if ( index !== - 1 ) { watchOnce : watchOnce ,", "del_tokens": "if ( index ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "an", "issue", "with", "assigning", "optional", "parameters"], "add_tokens": "", "del_tokens": "if ( ! returnLimit || returnLimit instanceof Function ) { callback = returnLimit ; returnLimit = null ; }", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "extra", "services", "and", "weather", "forecast"], "add_tokens": "// return reject('Can\\'t parse JSON');", "del_tokens": "return reject ( 'Can\\'t parse JSON' ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "apns", "module", "more", "resilient"], "add_tokens": "var apns = require ( \"apns\" ) ; certFile : this . config . cert , keyFile : this . config . key , enhanced : true , debug : true this . errorCallback . call ( this , { errorCode : errorCode , notification : notification } , 'apn' ) ; delete data . sound ; data . alert = \"\" ;", "del_tokens": "var apns = require ( \"apn\" ) ; cert : this . config . cert , key : this . config . key , enhanced : true this . errorCallback . call ( this , notification , 'apn' ) ; //delete data.sound; //data.alert = \"\";", "commit_type": "use"}
{"commit_tokens": ["Add", "plumbing", "for", "settings", "api", "so", "tests", "don", "t", "fail"], "add_tokens": "import { BaseDriver , DeviceSettings } from 'appium-base-driver' ; this . settings = new DeviceSettings ( { } , _ . noop ) ;", "del_tokens": "import { BaseDriver } from 'appium-base-driver' ;", "commit_type": "add"}
{"commit_tokens": ["add", "config", "option", "to", "fit", "svg", "on", "init"], "add_tokens": ", fit : true // enable or disable image fit into containig element (default true) if ( this . options . fit ) { if ( svgViewBox ) { // Fit using viewBox dimensions console . log ( svgViewBox ) var boundingClientRect = this . svg . getBoundingClientRect ( ) , viewBoxValues = svgViewBox . split ( ' ' ) . map ( parseFloat ) , viewBoxWidth = viewBoxValues [ 2 ] , viewBoxHeight = viewBoxValues [ 3 ] this . svg . removeAttribute ( 'viewBox' ) } else { console . log ( 'viewport' ) // Fit using viewport dimensions var boundingClientRect = this . viewport . getBoundingClientRect ( ) , viewBoxWidth = boundingClientRect . width , viewBoxHeight = boundingClientRect . height } console . log ( newCTM . a , newCTM . d ) } else { // Leave sizes as they are this . svg . removeAttribute ( 'viewBox' )", "del_tokens": "if ( svgViewBox ) { var boundingClientRect = this . svg . getBoundingClientRect ( ) , viewBoxValues = svgViewBox . split ( ' ' ) . map ( parseFloat ) , viewBoxWidth = viewBoxValues [ 2 ] , viewBoxHeight = viewBoxValues [ 3 ] this . svg . removeAttribute ( 'viewBox' ) ; } else {", "commit_type": "add"}
{"commit_tokens": ["Removing", "Error", "constructors", "they", "re", "pretty", "useless"], "add_tokens": "// Checkit.js 0.6.0 var Promise = require ( 'when' ) . Promise function Checkit ( validations , options ) { } fieldError = errors [ key ] = new FieldError ( err . message ) // Error Types // --------------- function ValidationError ( message ) { this . message = message } ValidationError . prototype . toString = function ( ) { return this . message } function FieldError ( message ) { this . message = message this . errors = [ ] } function CheckitError ( message ) { this . message = message ; this . errors = { } }", "del_tokens": "// Checkit.js 0.5.0 var createError = require ( 'create-error' ) var Promise = require ( 'when/es6-shim/Promise' ) var Checkit = function ( validations , options ) { } ; fieldError = errors [ key ] = new FieldError ( err ) var ValidationError = createError ( 'ValidationError' ) ; var FieldError = createError ( 'FieldError' , { errors : [ ] } ) ; var CheckitError = createError ( 'CheckitError' , { errors : { } } ) ; // feel free to swap this out if you'd like", "commit_type": "remove"}
{"commit_tokens": ["Added", "translate", "helpers", "and", "matchers"], "add_tokens": "// Translation helpers Helpers . prototype . translate = function ( key , values ) { return browser . executeScript ( function ( key , values ) { var $translate = angular . element ( document . body ) . injector ( ) . get ( '$translate' ) ; return $translate ( key , values ) ; } , key , values ) ; } ; return element . isDisplayed ( ) ; var _this = this ; return _this . not ( element . isDisplayed ( ) ) ; // For matchers } , toMatchTranslated : function ( key , values ) { var _this = this ; return helpers . translate ( key , values ) . then ( function ( translatedStr ) { helpers . createMessage ( _this , 'Expected {{actual}}{{not}} to match ' + translatedStr + ' (translated from ' + key + ', values: ' + JSON . stringify ( values ) + ')' ) ; var re = new RegExp ( translatedStr ) ; return re . test ( _this . actual ) ; } ) ;", "del_tokens": "return element . isDisplayed ( ) . then ( function ( isDisplayed ) { return isDisplayed ; } ) ; return element . isDisplayed ( ) . then ( function ( isDisplayed ) { return ! isDisplayed ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "bindings", "to", "be", "setup", "by", "the", "component", "s", "tagData"], "add_tokens": "var setupFn = componentTagData . setupBindings || function ( el , callback , data ) { return stacheBindings . behaviors . viewModel ( el , componentTagData , callback , data ) ; } ; teardownBindings = setupFn ( el , function ( initialViewModelData ) {", "del_tokens": "teardownBindings = stacheBindings . behaviors . viewModel ( el , componentTagData , function ( initialViewModelData ) {", "commit_type": "allow"}
{"commit_tokens": ["Fix", "issue", "that", "is", "crashing", "the", "node", "sdk", "tests"], "add_tokens": "if ( web && web . spa && web . spa . enabled && web . spa . view === null ) { return newError ( \"SPA mode is enabled but stormpath.web.spa.view isn't set. This needs to be the absolute path to the file that you want to serve as your SPA entry.\" ) ;", "del_tokens": "if ( web . spa && web . spa . enabled && web . spa . view === null ) { return newError ( \"SPA mode is enabled but web.spa.view isn't set. This needs to be the absolute path to the file that you want to serve.\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "sub", "subDoc", "Query", "create", "support"], "add_tokens": "var parent = doc ; var lastPath ; lastPath = config . subDoc . path ; cb ( err , doc , parent , lastPath ) ; var create = function ( config , data , cb ) { var callback = function ( err , children , parent , lastPath ) { cb = config . callback || cb ; //push the new doc children . push ( data ) ; parent . save ( function ( err , doc ) { if ( doc ) { cb ( err , _ . last ( children ) ) ; } else { cb ( err ) ; } } ) ; } ; findSubDoc ( config , callback ) ;", "del_tokens": "// doc = doc[config.subDoc.path]; // if (config.subDoc.conditions) { // doc = _.findWhere(doc, config.subDoc.conditions); // } cb ( err , doc ) ; var create = function ( data , cb ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "basic", "link", "label", "feature", "to", "show", "link", "values", "on", "diagram"], "add_tokens": "let linkLabel = defaultLinkLabel linkEnter . append ( 'text' ) . attr ( 'class' , 'label' ) . attr ( 'dy' , '0.35em' ) . attr ( 'x' , d => d . points [ 0 ] . x + 4 ) . attr ( 'y' , d => d . points [ 0 ] . y ) // Non-transition updates linkSel . classed ( 'selected' , ( d ) => d . id === selectedEdge ) linkSel . sort ( linkOrder ) // Transition updates, if available linkSel = linkSel . transition ( context ) linkSel . select ( '.label' ) . text ( linkLabel ) . attr ( 'x' , d => d . points [ 0 ] . x + 4 ) . attr ( 'y' , d => d . points [ 0 ] . y ) exports . linkLabel = function ( _x ) { if ( ! arguments . length ) return linkLabel linkLabel = _x return this } function defaultLinkLabel ( d ) { return null }", "del_tokens": ". transition ( context ) linkSel . classed ( 'selected' , ( d ) => d . id === selectedEdge ) linkSel . sort ( linkOrder )", "commit_type": "add"}
{"commit_tokens": ["Update", "streamy", "-", "dom", ".", "js"], "add_tokens": "if ( value === null || value === undefined ) { }", "del_tokens": "if ( value === null ) { }", "commit_type": "update"}
{"commit_tokens": ["added", "command", "getConnectionInformation", "to", "receive", "information", "about", "WebRTC", "connection", "(", "remote", "/", "local", "ip", "address", "port", "and", "transport", "type", ")"], "add_tokens": "self . connection = res . value ; callback ( err , self . connection ) ;", "del_tokens": "self . connectionType = res . value ; callback ( err , self . connectionType ) ;", "commit_type": "add"}
{"commit_tokens": ["Removing", "logging", "for", "invalid", "token", "for", "now"], "add_tokens": "// if error continue on as anonymous //log.debug('Problem verifying token: ' + token);", "del_tokens": "// if error, then log it, but continue on as anonymous log . debug ( 'Problem verifying token: ' + token ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "api", "calls", "to", "views"], "add_tokens": "db = '' ;", "del_tokens": "db = 'http://localhost:5984/foobar' ; console . log ( db ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "Collection#create", "success", "callback", "passing", "the", "model", "parameter", "through", "."], "add_tokens": "var coll = model . collection = this ; var success = function ( nextModel , resp ) { coll . add ( nextModel ) ; if ( options . success ) options . success ( nextModel , resp ) ;", "del_tokens": "model . collection = this ; var success = function ( resp ) { model . collection . add ( model ) ; if ( options . success ) options . success ( model , resp ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "totalCost", "argument", "to", "Calculator", ".", "calc", "()", "method"], "add_tokens": "* @ param { String } destination * @ param { Array } packages * @ param { Number } [ totalCost ] Calculator . prototype . calc = function ( destination , packages , totalCost ) { totalCost = parseFloat ( totalCost ) ; if ( ! ( totalCost > 0 ) ) { totalCost = 0 } packages : packages , total_cost : totalCost", "del_tokens": "* @ param destination * @ param packages Calculator . prototype . calc = function ( destination , packages ) { packages : packages", "commit_type": "add"}
{"commit_tokens": ["Fix", "setting", "of", "default", "version"], "add_tokens": "version : '1'", "del_tokens": "apiVersion : '1'", "commit_type": "fix"}
{"commit_tokens": ["Use", "UTC", "date", "for", "timestamps", "."], "add_tokens": "grunt . shipit . releaseDirname = grunt . template . date ( 'UTC:yyyymmddHHMMss' ) ;", "del_tokens": "grunt . shipit . releaseDirname = grunt . template . date ( 'yyyymmddHHMMss' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixed", "an", "error", "in", "the", "error", "checking", "."], "add_tokens": "throw new Error ( \"Handler not registered for url: \" + urlToTest ) ;", "del_tokens": "throw new Error ( \"Handler not registered for url: \" + url - to - test ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "new", "bgproj", "just", "for", "programming", "."], "add_tokens": "\"c/config/project.bgproj\" : \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<project>\\n <gatt in=\\\"gatt.xml\\\" />\\n <hardware in=\\\"hardware.xml\\\" />\\n <config in=\\\"config.xml\\\" />\\n <config_dump out=\\\"config.bin\\\" start=\\\"0x38000\\\" />\\n <device type=\\\"ble113-m256k\\\" />\\n <cheader out=\\\"attributes.h\\\" />\\n <!-- If you get a compilation error when running first time, please update MAC/license key inside license.xml -->\\n</project>\\n\" , \"c/project.bgproj\" : \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<project>\\n <gatt in=\\\".\\\\config\\\\gatt.xml\\\" />\\n <fw in=\\\".\\\\bgbuild\\\\Exe\\\\out\\\" />\\n <image out=\\\"out.hex\\\" /> \\n <hardware in=\\\".\\\\config\\\\hardware.xml\\\" />\\n <config in=\\\".\\\\config\\\\config.xml\\\" />\\n <config_dump out=\\\".\\\\config\\\\config.bin\\\" start=\\\"0x38000\\\" />\\n <device type=\\\"ble113-m256k\\\" />\\n <cheader out=\\\".\\\\config\\\\attributes.h\\\" />\\n <!-- If you get a compilation error when running first time, please update MAC/license key inside license.xml -->\\n <boot fw=\\\"bootota\\\" />\\n <ota out=\\\"myimage.ota\\\" />\\n</project>\\n\" ,", "del_tokens": "\"c/config/project.bgproj\" : \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<project>\\n <gatt in=\\\"gatt.xml\\\" />\\n <fw in=\\\"..\\\\bgbuild\\\\Exe\\\\out\\\" />\\n <image out=\\\"out.hex\\\" /> \\n <hardware in=\\\"hardware.xml\\\" />\\n <config in=\\\"config.xml\\\" />\\n <config_dump out=\\\"config.bin\\\" start=\\\"0x38000\\\" />\\n <device type=\\\"ble113-m256k\\\" />\\n <cheader out=\\\"attributes.h\\\" />\\n <!-- If you get a compilation error when running first time, please update MAC/license key inside license.xml -->\\n <boot fw=\\\"bootota\\\" />\\n <ota out=\\\"myimage.ota\\\" />\\n</project>\\n\" ,", "commit_type": "add"}
{"commit_tokens": ["update", "basic", "package", "-", "file", "testing"], "add_tokens": "var licenseFileExists = fs . existsSync ( __dirname + '/../LICENSE' ) ; expect ( ( licenseFileExists || fileContentReadme . indexOf ( '## License' ) !== - 1 ) , 'A LICENSE must exist as LICENSE file or as part of the README.md' ) . to . be . true ; if ( ! licenseFileExists ) { console . log ( 'Warning: The License should also exist as LICENSE file' ) ; console . log ( ) ; } if ( fileContentReadme . indexOf ( '## License' ) === - 1 ) { console . log ( 'Warning: The README.md should also have a section ## License to be shown in Admin3' ) ; console . log ( ) ; }", "del_tokens": "expect ( fs . existsSync ( __dirname + '/../LICENSE' ) , 'A LICENSE must exist' ) ; if ( fileContentReadme . indexOf ( '## License' ) === - 1 ) { console . log ( 'Warning: The README.md should have a section ## License' ) ; console . log ( ) ; }", "commit_type": "update"}
{"commit_tokens": ["Use", "trace", "instead", "of", "silly", "for", "bunyan", "compliance"], "add_tokens": "var url = require ( 'url' ) ; } else if ( value instanceof url . Url ) { return value . format ( ) ; this . logger . trace ( module . exports = Trace ;", "del_tokens": "this . logger . silly ( module . exports = Trace ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "exporting", "the", "right", "path", "for", "the", "json", "file"], "add_tokens": "this . info = { path : false } ; if ( typeof __dirname !== 'undefined' ) { this . info . path = __dirname + '/json-dry.js' ; }", "del_tokens": "this . info = { path : require . main . filename } ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "no", "-", "sync", "eslint", "warnings"], "add_tokens": "* // eslint-disable-next-line no-sync", "del_tokens": "*", "commit_type": "fix"}
{"commit_tokens": ["Improve", "tracer", "by", "using", "ready", "function", "."], "add_tokens": "import { initialView , updateView } from \"./view\" ; const meiosisTracer = ( createComponent , renderRoot , selector ) => createComponent ( { ready : initialView ( selector , renderRoot ) , receiveUpdate : receiveUpdate ( tracerModel , updateView ( selector , renderRoot ) )", "del_tokens": "import view from \"./view\" ; const meiosisTracer = ( createComponent , renderRoot , elementId ) => createComponent ( { receiveUpdate : receiveUpdate ( tracerModel , view ( elementId , renderRoot ) )", "commit_type": "improve"}
{"commit_tokens": ["Fixed", "bug", "-", "incorrect", "module", "reference", "in", "wait", "()"], "add_tokens": "return module . exports . getDelayedRunner ( function ( data ) {", "del_tokens": "return mod . getDelayedRunner ( function ( data ) {", "commit_type": "fix"}
{"commit_tokens": ["Remove", "unused", "texture", "coord", "attribute", "and", "varying", "from", "equirect", "shaders", "."], "add_tokens": "var attribList = [ 'aVertexPosition' ] ;", "del_tokens": "var attribList = [ 'aVertexPosition' , 'aTextureCoord' ] ; gl . vertexAttribPointer ( shaderProgram . aTextureCoord , 2 , gl . FLOAT , gl . FALSE , 0 , 0 ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "bootstrap", "components", "to", "local", "source", "."], "add_tokens": "bootstrap : { scss : './bower_components/bootstrap/scss' , js : './bower_components/bootstrap/dist/js' } , gulp . task ( 'bootstrap' , [ 'bower' ] , function ( ) { gulp . src ( config . bootstrap . scss + '/**/*' , { base : config . bootstrap . scss } ) . pipe ( gulp . dest ( config . src . scssPath + '/bootstrap' ) ) ; gulp . src ( config . bootstrap . js + '/bootstrap.js' , { base : config . bootstrap . js } ) . pipe ( gulp . dest ( config . src . jsPath + '/bootstrap' ) ) ; } ) ; gulp . task ( 'components' , [ 'bower' , 'fonts' , 'bootstrap' ] ) ; return gulp . src ( [ config . src . jsPath + '/**/*.js' ] )", "del_tokens": "gulp . task ( 'components' , [ 'bower' , 'fonts' ] ) ; return gulp . src ( [ config . src . jsPath + '/*.js' ] )", "commit_type": "add"}
{"commit_tokens": ["remove", "displaying", "empty", "obj", "+", "typo"], "add_tokens": "return yo ` ${ this . cssList } ${ label } ${ this . cssLabel } ${ item } `", "del_tokens": "if ( ! json || ! Object . keys ( json ) . length ) { json = { ' - ' : ' - ' } } return yo ` ${ this . cssList } ${ label } ${ this . cssLabel } ${ item } `", "commit_type": "remove"}
{"commit_tokens": ["Allow", "the", "features", "to", "supply", "a", "prepare", "function", "which", "will", "be", "called", "before", "the", "render", "occurs", ".", "This", "way", "the", "incoming", "data", "can", "be", "manipulated", "if", "necessary", "."], "add_tokens": "var prepareDataForFeature = function ( opts , name , data ) { var feature = opts . features [ name ] ; if ( d4 . isFunction ( feature . prepare ) ) { data = feature . prepare . bind ( opts ) ( data ) ; if ( typeof data === 'undefined' ) { err ( '\"feature.prepare()\" must return a data array. However, the prepare function for the \"{0}\" feature did not' , name ) ; } } return data ; } ; data = prepareDataForFeature ( opts , name , data ) ; var extractOverrides = function ( feature , name ) { return feature . overrides ( name ) ;", "del_tokens": "var extractOverrides = function ( feature ) { return feature . overrides ( this ) ;", "commit_type": "allow"}
{"commit_tokens": ["fix", "https", ":", "//", "github", ".", "com", "/", "fex", "-", "team", "/", "webuploader", "/", "issues", "/", "282"], "add_tokens": "uploader . on ( 'reset' , function ( ) { uploader . on ( 'reset' , function ( ) {", "del_tokens": "uploader . on ( 'uploadFinished reset' , function ( ) { uploader . on ( 'uploadFinished reset' , function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["remove", "superfluous", "examples", "fixed", "package", "and", "updated", "tests"], "add_tokens": "var prep = require ( 'string-prepend' ) / *! * test fixutres . * / var fixtures = [ 'hello' ] var getFixture = prep ( './test/fixture/' ) t . plan ( 1 ) var mapper = reapply ( [ 'There' ] ) var modules = [ getFixture ( 'hello' ) ] t . deepEqual ( modules . map ( mapper ) , [ 'Hello There' ] ) . map ( getFixture ) . map ( reapply ( [ 'There' ] ) ) t . equal ( message , 'Hello There' )", "del_tokens": "var path = require ( 'path' ) var mapper = reapply ( [ '%s world' , 'hello' ] ) var modules = [ 'format' , 'format' ] t . deepEqual ( modules . map ( mapper ) , [ 'hello world' , 'hello world' ] ) t . end ( ) var fixtures = [ 'hello' ] . map ( respref ( [ __dirname , 'test' , 'fixture' ] ) ) . map ( reapply ( [ 'Wil' ] ) ) t . equal ( message , 'Hello Wil' ) function respref ( prefix ) { return function ( file ) { return path . resolve . apply ( null , prefix . concat ( file ) ) } }", "commit_type": "remove"}
{"commit_tokens": ["Add", "very", "simple", "PPM", "-", "D", "compressor", "/", "decompressor", "implementation", "."], "add_tokens": "define ( [ './lib/freeze' , './lib/Context1Model' , './lib/DefSumModel' , './lib/FenwickModel' , './lib/MTFModel' , './lib/NoModel' , './lib/Huffman' , './lib/RangeCoder' , './lib/Dmc' , './lib/Lzjb' , './lib/Lzp3' , './lib/PPM' , './lib/Simple' ] , function ( freeze , Context1Model , DefSumModel , FenwickModel , MTFModel , NoModel , Huffman , RangeCoder , Dmc , Lzjb , Lzp3 , PPM , Simple ) { RangeCoder : RangeCoder , PPM : PPM ,", "del_tokens": "define ( [ './lib/freeze' , './lib/Context1Model' , './lib/DefSumModel' , './lib/FenwickModel' , './lib/MTFModel' , './lib/NoModel' , './lib/Huffman' , './lib/Dmc' , './lib/Lzjb' , './lib/Lzp3' , './lib/RangeCoder' , './lib/Simple' ] , function ( freeze , Context1Model , DefSumModel , FenwickModel , MTFModel , NoModel , Huffman , Dmc , Lzjb , Lzp3 , RangeCoder , Simple ) { RangeCoder : RangeCoder ,", "commit_type": "add"}
{"commit_tokens": ["Added", "ftp", "-", "connections", "collection"], "add_tokens": "* * The em function is used to log the data or error returned from the 'emFtpConnections' , ConsumptionPreview , FtpConnections , em . FtpConnections = FtpConnections ;", "del_tokens": "* * The em function is used to log the data or error returned from the ConsumptionPreview ,", "commit_type": "add"}
{"commit_tokens": ["changed", "over", "coe", "but", "cant", "test", "it", "because", "coe", "is", "down", "lol", "."], "add_tokens": "// import request from 'superagent'; import request from './request' const resp = await request . get ( ` ${ letter . toUpperCase ( ) } ` )", "del_tokens": "import request from 'superagent' ; import Throttle from 'superagent-throttle' ; let throttle = new Throttle ( { active : true , // set false to pause queue rate : 20 , // how many requests can be sent every `ratePer` ratePer : 10000 , // number of ms in which `rate` requests may be sent concurrent : 5 // how many requests can be sent concurrently } ) . on ( 'sent' , ( request ) => { console . log ( 'sent' ) } ) // sent a request . on ( 'received' , ( request ) => { console . log ( 'received' ) } ) // received a response . on ( 'drained' , ( ) => { console . log ( 'drained' ) } ) // received last response const resp = await request . get ( ` ${ letter . toUpperCase ( ) } ` ) . use ( throttle . plugin ( ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "background", "color", "to", "the", "timestamp", "column", "in", "the", "profiler"], "add_tokens": "'app/public/styles/main.css' : [ 'app/public/styles/less/main.less' ] , 'app/public/styles/index.css' : [ 'app/public/styles/less/index.less' ] , 'app/public/styles/launchTest.css' : [ 'app/public/styles/less/launchTest.less' ] , 'app/public/styles/results.css' : [ 'app/public/styles/less/results.less' ]", "del_tokens": "'app/public/styles/main.css' : [ //'app/public/styles/less/icons.less', 'app/public/styles/less/main.less' ]", "commit_type": "add"}
{"commit_tokens": ["added", "io", "-", "specific", "slow", "test", "folder"], "add_tokens": "/ * var Wordnet = require ( 'lib/natural/wordnet/wordnet' ) ; jasmine . asyncSpecWait . timeout = 30 * 1000 ; describe ( 'wordnet' , function ( ) { it ( 'should download files then' , function ( ) { var wordnet = new Wordnet ( './spec/test_data/wordnet/download/' , 'http://wordnet.naturalnode.com/' ) ; wordnet . lookup ( 'entity' , function ( records ) { expect ( records . length ) . toBe ( 1 ) ; expect ( records [ 0 ] . word ) . toBe ( 'entity' ) ; require ( 'path' ) . exists ( './spec/test_data/wordnet/download/index.noun' , function ( exists ) { expect ( exists ) . toBeTruthy ( ) ; asyncSpecDone ( ) ; } ) ; } ) ; asyncSpecWait ( ) ; } ) ; } ) ;", "del_tokens": "/ *", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "force", "option", "that", "will", "make", "sure", "the", "task", "is", "never", "failed", "."], "add_tokens": "writeToFile : { force : true ,", "del_tokens": "shouldFail_writeToFile : {", "commit_type": "add"}
{"commit_tokens": ["added", "backbone", "version", "check", "and", "pass", "in", "error", "message", "variable"], "add_tokens": "if ( Backbone . VERSION === \"0.9.10\" ) { options . success ( model , resp , options ) ; } else { options . success ( resp ) ; } if ( Backbone . VERSION === \"0.9.10\" ) { options . error ( model , errorMessage , options ) ; } else { options . error ( model , errorMessage , options ) ; }", "del_tokens": "options . success ( model , resp , options ) ; options . error ( model , \"Record not found\" , options ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "a", "separate", "StaticFileCompiler", "instead", "of", "staticFiles", "option"], "add_tokens": "exports . StaticFileCompiler = StaticFileCompiler function StaticFileCompiler ( options ) { this . options = options } StaticFileCompiler . prototype . compile = function ( srcDir , destDir , callback ) { helpers . linkRecursivelySync ( path . join ( srcDir , this . options . srcDir ) , path . join ( destDir , this . options . destDir ) ) callback ( ) }", "del_tokens": "this . copyStaticFiles ( srcDir , destDir , this . staticFiles ) CompilerCollection . prototype . copyStaticFiles = function ( srcDir , destDir , staticFiles ) { var paths = helpers . multiGlob ( staticFiles , { cwd : srcDir } ) for ( var i = 0 ; i < paths . length ; i ++ ) { var srcPath = path . join ( srcDir , paths [ i ] ) var destPath = path . join ( destDir , paths [ i ] ) var contents = fs . readFileSync ( srcPath ) mkdirp . sync ( path . dirname ( destPath ) ) fs . writeFileSync ( destPath , contents ) } }", "commit_type": "use"}
{"commit_tokens": ["fixed", "a", "display", "bug", "when", "both", "arguments", "and", "locals", "of", "a", "frame", "contain", "a", "variable", "of", "the", "same", "name"], "add_tokens": "var args = obj . arguments . map ( _decode ) ; args . forEach ( function ( arg ) { if ( ! props . some ( function ( p ) { return arg . name === p . name ; } ) ) { props . push ( arg ) ; } } ) ; try { WebInspector . Callback . processCallback ( arguments [ 0 ] , props ) ; } catch ( e ) { console . error ( JSON . stringify ( e ) ) ; }", "del_tokens": "props = props . concat ( obj . arguments . map ( _decode ) ) ; WebInspector . Callback . processCallback ( arguments [ 0 ] , props ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "coverage", "folder", "and", "solve", "new", "linting", "issue"], "add_tokens": "var schema = fs . readFileSync ( path . join ( __dirname , 'identify.proto' ) )", "del_tokens": "var schema = fs . readFileSync ( path . join ( __dirname , '/identify.proto' ) )", "commit_type": "remove"}
{"commit_tokens": ["Fix", "typo", "to", "clear", "socket", "timer", "instead", "of", "idle", "timer"], "add_tokens": "clearTimeout ( this . _socketTimeoutTimer ) ;", "del_tokens": "clearTimeout ( this . _idleTimer ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implement", "our", "own", "less", "error", "-", "prone", "watching", ";", "remove", "debounce", "logic"], "add_tokens": "done ( ) if ( callback != null ) callback ( )", "del_tokens": "// Debounce logic; should probably be extracted, or better, made unnecessary this . postBuildLock = { } this . lockReleaseTimer = null this . lockReleaseFunction = null this . lockReleaseFirstScheduledAt = null var debounceDelay = 0 if ( outputDir == null ) { // We are watching and serving; refactor this logic debounceDelay = 100 } function scheduleLockReleaseTimer ( ) { if ( ! self . lockReleaseFirstScheduledAt ) self . lockReleaseFirstScheduledAt = Date . now ( ) self . lockReleaseTimer = setTimeout ( self . lockReleaseFunction , debounceDelay ) } if ( self . lockReleaseTimer && Date . now ( ) < self . lockReleaseFirstScheduledAt + 1000 ) { // Reschedule running timer because we keep getting events, but never put // off more than 1000 milliseconds in total clearTimeout ( self . lockReleaseTimer ) scheduleLockReleaseTimer ( ) } releaseAfterDelay ( ) } function releaseAfterDelay ( ) { self . lockReleaseFunction = function ( ) { self . lockReleaseTimer = null self . lockReleaseFunction = null self . lockReleaseFirstScheduledAt = null done ( ) if ( callback != null ) callback ( ) } scheduleLockReleaseTimer ( )", "commit_type": "implement"}
{"commit_tokens": ["add", "--", "tunnel", "option", "to", "establish", "a", "localtunnel", "for", "--", "local"], "add_tokens": "// no localtunnel requested if ( ! config . tunnel ) { var url = 'http://localhost:' + app_port + '/__zuul' ; console . log ( 'open the following url in a browser:' ) ; console . log ( url ) ; return ; } tunnel ( app_port , function ( err , url ) { if ( err ) { return console . error ( err . stack ) ; } url = url + '/__zuul' ; console . log ( 'open the following url in a browser:' ) ; console . log ( url ) ; } ) ;", "del_tokens": "var url = 'http://localhost:' + app_port + '/__zuul' ; console . log ( 'open the following url in a browser:' ) ; console . log ( url ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "the", "examples", "to", "explicitly", "exit", "the", "process"], "add_tokens": "broker . on ( \"connected\" , function ( ) { broker . on ( \"subscribed\" , function ( subscription ) { // Simplest way to deal with errors: abort the process. // Assuming of course that you have a scheduler or process manager (kubernetes, // pm2, forever etc) in place to restart your process. // // NOTE: See the \"subcribe-reconnect\" example on how to handle errors without // restarting the process. broker . on ( \"error\" , function ( error ) { console . error ( \"Amqp error\" , error , \", aborting process.\" ) ; process . exit ( 1 ) ; } ) ; setInterval ( function ( ) { } , 1000 ) ;", "del_tokens": "// Simplest way to subscribe. Start the subscription and don't listen to \"error\" events // from the broker. This will cause the process to crash in case of errors. // This of course requires a process manager such as \"pm2\" or \"forever\" in place // to restart the process. broker . on ( \"connected\" , function ( ) { broker . on ( \"subscribed\" , function ( subscription ) { setInterval ( function ( ) { } , 1000 ) ;", "commit_type": "update"}
{"commit_tokens": ["fix", "req", ".", "url", "for", "subpath", "middlewares"], "add_tokens": "if ( ! req . originalUrl ) req . originalUrl = req . url ; req . url = req . originalUrl . substring ( route . path . length ) || \"/\" ; * @ param { Object ? } action sendResponse ( ctx , route , req , res , data , action = { } ) {", "del_tokens": "* @ param { Object } action sendResponse ( ctx , route , req , res , data , action ) {", "commit_type": "fix"}
{"commit_tokens": ["using", "polymer", "instead", "of", "native", "web", "components"], "add_tokens": "return preprocess . then ( function ( ) { // inline all stylesheets for polymer shared styles to work // @see https://www.polymer-project.org/1.0/docs/devguide/styling#style-modules return utils . readFiles ( context . stylesheets , function ( data , file ) { context . parsedStylesheets = context . parsedStylesheets || [ ] ; context . parsedStylesheets . push ( data ) ; } ) ; } ) . then ( function success ( ) { . catch ( function ( err ) { if ( err ) { console . error ( err . stack ) ; } } ) ;", "del_tokens": "return preprocess . then ( function success ( ) { . catch ( function ( err ) { if ( err ) { console . error ( err . stack ) ; } } ) ;", "commit_type": "use"}
{"commit_tokens": ["remove", "pow", "unit", "round", "check", "for", "now"], "add_tokens": "conn . query ( \"SELECT level, witnessed_level,pow_type,round_index, best_parent_unit, witness_list_unit FROM units WHERE unit=?\" , [ unit ] , function ( rows ) {", "del_tokens": "conn . query ( \"SELECT level, witnessed_level,pow_type, best_parent_unit, witness_list_unit FROM units WHERE unit=?\" , [ unit ] , function ( rows ) {", "commit_type": "remove"}
{"commit_tokens": ["fixed", ":", "build", "scripts", "."], "add_tokens": "// var webpack = require('webpack'); //root: './dist', //alias: { // 'cdp/core': './cdp/core', //}, } , //plugins: [ // new webpack.optimize.LimitChunkCountPlugin({ // maxChunks: 1, // }), //],", "del_tokens": "alias : { jqueryI18next : \"../node_modules/jquery-i18next/dist/umd/jquery-i18next.js\" , i18nextXHRBackend : \"../node_modules/i18next-xhr-backend/dist/umd/i18nextXHRBackend.js\" , i18nextLocalStorageCache : \"../node_modules/i18next-localstorage-cache/dist/umd/i18nextLocalStorageCache.js\" , i18nextSprintfPostProcessor : \"../node_modules/i18next-sprintf-postprocessor/dist/umd/i18nextSprintfPostProcessor.js\" , i18nextBrowserLanguageDetector : \"../node_modules/i18next-browser-languagedetector/dist/umd/i18nextBrowserLanguageDetector\" , } , } // TODO: cdp.framework.jqm と cdp.ui.jqm にて // // })(this, function(CDP) { // ↓ // })((this || 0).self || global, function(CDP) { // // の対応を行わなければ CDP が global export されない // TODO: // amd の定義が解決できていない。常に undefined", "commit_type": "fix"}
{"commit_tokens": ["move", "plugins", "to", "separate", "file"], "add_tokens": "require = utils ; // eslint-disable-line require ( 'array-unique' , 'unique' ) ; require ( 'extend-shallow' , 'extend' ) ; require ( 'mixin-deep' , 'merge' ) ; require = fn ; // eslint-disable-line", "del_tokens": "require = utils ; require ( 'base-cwd' , 'cwd' ) ; require ( 'base-task' , 'task' ) ; require ( 'base-plugins' , 'plugin' ) ; require ( 'extend-shallow' , 'extend' ) ; require ( 'array-unique' , 'unique' ) ; require = fn ;", "commit_type": "move"}
{"commit_tokens": ["use", "path", ".", "join", "for", "joining", "path"], "add_tokens": "var path = require ( \"path\" ) ; loadArrayBuffer ( path . join ( dic_path , filename ) , function ( err , buffer ) { loadArrayBuffer ( path . join ( dic_path , filename ) , function ( err , buffer ) { loadArrayBuffer ( path . join ( dic_path , \"cc.dat.gz\" ) , function ( err , buffer ) { loadArrayBuffer ( path . join ( dic_path , filename ) , function ( err , buffer ) {", "del_tokens": "loadArrayBuffer ( dic_path + filename , function ( err , buffer ) { loadArrayBuffer ( dic_path + filename , function ( err , buffer ) { loadArrayBuffer ( dic_path + \"cc.dat.gz\" , function ( err , buffer ) { loadArrayBuffer ( dic_path + filename , function ( err , buffer ) {", "commit_type": "use"}
{"commit_tokens": ["Add", "simple", "self", "-", "test", "to", "EscModel", "."], "add_tokens": "define ( [ './lib/freeze' , './lib/EscModel' , './lib/Huffman' , './lib/Lzjb' , './lib/Lzp3' , './lib/RangeCoder' , './lib/Simple' ] , function ( freeze , EscModel , Huffman , Lzjb , Lzp3 , RangeCoder , Simple ) { EscModel : EscModel ,", "del_tokens": "define ( [ './lib/freeze' , './lib/Huffman' , './lib/Lzjb' , './lib/Lzp3' , './lib/RangeCoder' , './lib/Simple' ] , function ( freeze , Huffman , Lzjb , Lzp3 , RangeCoder , Simple ) {", "commit_type": "add"}
{"commit_tokens": ["update", "the", "package", "name", "of", "redis", "-", "commands"], "add_tokens": "var Redis = require ( '@yuanchuan/redis-commands' ) ;", "del_tokens": "var Redis = require ( 'redis-commands' ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "duration", "and", "uploader", "fields", "to", "MediaModel", "."], "add_tokens": "goog . addDependency ( 'ui/media/mediamodel.js' , [ 'goog.ui.media.MediaModel' , 'goog.ui.media.MediaModel.Category' , 'goog.ui.media.MediaModel.Credit' , 'goog.ui.media.MediaModel.Credit.Role' , 'goog.ui.media.MediaModel.Credit.Scheme' , 'goog.ui.media.MediaModel.MimeType' , 'goog.ui.media.MediaModel.Player' , 'goog.ui.media.MediaModel.Thumbnail' ] , [ 'goog.array' ] ) ;", "del_tokens": "goog . addDependency ( 'ui/media/mediamodel.js' , [ 'goog.ui.media.MediaModel' , 'goog.ui.media.MediaModel.Category' , 'goog.ui.media.MediaModel.MimeType' , 'goog.ui.media.MediaModel.Player' , 'goog.ui.media.MediaModel.Thumbnail' ] , [ 'goog.array' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "comments", "on", "neural", "network", "methods"], "add_tokens": "/ ** * Trains the neural network using the standard backpropagation algorithm with * gradient descent as the cost optimization method . * / * back propagation using the given alpha learning rate for the number of iterations . This is * done by computing the gradient via backpropagation and applying the difference between * the old weights and the partial derivative gradient times the learning rate alpha . * * W = W - alpha * partial - derivative - gradient [ via back - propagation ]", "del_tokens": "* back propagation using the given alpha learning rate for the number of iterations .", "commit_type": "update"}
{"commit_tokens": ["Fix", "resizing", "of", "pickers", "if", "any"], "add_tokens": "var isArray = require ( 'mutype/is-array' ) ; var isFn = require ( 'mutype/is-fn' ) ;", "del_tokens": "var isArray = require ( 'is-array' ) ; var isFn = require ( 'is-function' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "jsonlint", "and", "lintspaces", "tasks", "because", "they", "are", "not", "needed"], "add_tokens": "grunt . registerTask ( 'test' , [ 'jscs' , 'jshint' , 'karma' , 'coverage' ] ) ;", "del_tokens": "lintspaces : { options : { newline : true , newlineMaximum : 1 , trailingspaces : true } , all : { src : [ 'Gruntfile.js' , '<%= paths.src %>/{,**/}*.js' ] } , test : { src : [ 'test/{,**/}*.js' ] } } , jsonlint : { src : '<%= paths.test %>/mock/**/*.json' } , grunt . registerTask ( 'test' , [ 'jscs' , 'jshint' , 'lintspaces' , 'jsonlint' , 'karma' , 'coverage' ] ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "explicit", "tests", "for", "template", "-", "items"], "add_tokens": "if ( length == null ) return null if ( this . maxLength == null ) return null if ( this . minLength == null ) return null", "del_tokens": "if ( length == null ) return if ( this . maxLength == null ) return if ( this . minLength == null ) return", "commit_type": "add"}
{"commit_tokens": ["Added", "lenght", "guard", "for", "errorhandlers"], "add_tokens": "if ( U . errorHandlers . length > 0 ) { app . use ( U . errorHandlers ) ; }", "del_tokens": "app . use ( U . errorHandlers ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "stale", "while", "revalidate", "stale", "ttl", "logic"], "add_tokens": "ttl : '1m' , staleWhileRevalidate : '3m'", "del_tokens": "ttl : '10s' , staleWhileRevalidate : true", "commit_type": "fix"}
{"commit_tokens": ["Added", "comments", "for", "most", "fiels"], "add_tokens": "ArrayConstraint , MapConstraint , is_constraint , is_array , is_map , cjs = function ( arg0 , arg1 ) { // The star of the show! // Utility function that will look at the type of the first argument an create the proper kind of value if ( isArray ( arg0 ) ) { return new ArrayConstraint ( extend ( { value : arg0 } , arg1 ) ) ; } else if ( isObject ( arg0 ) ) { return new MapConstraint ( extend ( { value : arg0 } , arg1 ) ) ; } else { return new Constraint ( arg0 , arg1 ) ; } proto . get = bind ( constraint_solver . getValue , this ) ; this . get ( false ) ; // Make sure my current value is up to date but don't add outgoing constraints. That way, when it changes the callback will be called is_constraint = function ( obj ) { } else if ( is_array ( obj ) ) { } else if ( is_map ( obj ) ) {", "del_tokens": "cjs = function ( arg0 , arg1 , arg2 ) { // The star of the show! return new Constraint ( arg0 , arg1 , arg2 ) ; proto . get = function ( auto_add_outgoing ) { return constraint_solver . getValue ( this , auto_add_outgoing ) ; } ; var is_constraint = function ( obj ) { } else if ( cjs . is_array ( obj ) ) { } else if ( cjs . is_map ( obj ) ) {", "commit_type": "add"}
{"commit_tokens": ["fixing", "prefixes", "for", "future", "dates", "(", "German", "language", ")"], "add_tokens": "prefixFromNow : 'in' , suffixFromNow : null ,", "del_tokens": "prefixFromNow : null , suffixFromNow : 'from now' ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "net", ".", "ignoreNoBandwidth", "option"], "add_tokens": "ignoreNoIP : false , ignoreNoBandwidth : false , if ( _ . get ( self . settings , 'net.ignoreNoBandwidth' ) ) this . adapters = this . adapters . filter ( function ( adapter ) { return ( adapter . downSpeed || adapter . upSpeed ) ; } ) ;", "del_tokens": "ignoreNoIP : true ,", "commit_type": "add"}
{"commit_tokens": ["change", "argv", "property", "to", "orig"], "add_tokens": "res . orig = utils . extend ( { } , argv ) ;", "del_tokens": "res . argv = utils . extend ( { } , argv ) ;", "commit_type": "change"}
{"commit_tokens": ["removed", "string", "coercing", "Closes", "GH", "-", "2"], "add_tokens": "test . expect ( 4 ) ; // Object filter var tmpl4 = combyne ( '{{test|obj}}' , { test : { tmp : 'test' } } ) ; tmpl4 . filters . add ( 'obj' , function ( val ) { return val [ 'tmp' ] ; } ) ; test . equals ( tmpl4 . render ( ) , 'test' , 'Testing with an object passed as val' ) ;", "del_tokens": "test . expect ( 3 ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "back", "the", "ability", "to", "transition", "strings"], "add_tokens": "return buildTransitionDefinition ( paths , pathAnimations , stateFrom ) ; function buildTransitionDefinition ( paths , pathAnimations , state ) { var stateDef ; stateDef = state ; // if the value is a number the transition will be built from tweenFunction if ( typeof stateDef [ pathPart ] === 'number' ) { transitionsDef [ pathPart ] = tweenFunction ( { duration : aniDef . duration / overallDuration , delay : aniDef . delay / overallDuration , ease : aniDef . ease , cap : true } ) ; // if the value is a String we'll need to use this transition function } else if ( typeof stateDef [ pathPart ] === 'string' ) { transitionsDef [ pathPart ] = function ( time , start , end ) { if ( time < 1 ) { return start ; } else { return end ; } } ; } stateDef = stateDef [ pathPart ] ;", "del_tokens": "return buildTransitionDefinition ( paths , pathAnimations ) ; function buildTransitionDefinition ( paths , pathAnimations ) { transitionsDef [ pathPart ] = tweenFunction ( { duration : aniDef . duration / overallDuration , delay : aniDef . delay / overallDuration , ease : aniDef . ease , cap : true } ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "babel", "plugin", "instead", "of", "webpack", "loader", "to", "get", "more", "accurate", "coverage", "#"], "add_tokens": "statements : 81 , lines : 81 , functions : 82 , branches : 69 webpack : require ( './webpack/test.config' ) ( ) ,", "del_tokens": "statements : 91 , lines : 82 , functions : 89 , branches : 73 webpack : require ( './webpack/test.config' ) ( disableCoverage ) ,", "commit_type": "use"}
{"commit_tokens": ["Added", "--", "gradleArg", "=", "--", "no", "-", "daemon", "to", "Gulp", "script"], "add_tokens": "android : [ \"--release\" , \"--device\" , \"--gradleArg=--no-daemon\" ] , // Warning: Omit the extra \"--\" when referencing platform", "del_tokens": "android : [ \"--release\" , \"--device\" ] , // Warning: Omit the extra \"--\" when referencing platform", "commit_type": "add"}
{"commit_tokens": ["Added", "visual", "examples", "related", "to", "the", "dynamic", "template", "style"], "add_tokens": "// beforeEach(module('tpl/tabs.html', 'tpl/pane.html')) // TODO move the HTML template in tests/templates and make it dry", "del_tokens": "// beforeEach(module('tpl/tabs.html', 'tpl/pane.html')); // TODO move this template in tests/templates and make it dry.", "commit_type": "add"}
{"commit_tokens": ["Fix", "to", "advice", "to", "add", "to", "prototype"], "add_tokens": "define ( [ 'chai' , 'advice' , 'backbone' ] , function ( chai , Advice , Backbone ) { Advice . addAdvice ( Backbone . View ) ;", "del_tokens": "define ( [ 'chai' , 'advice' ] , function ( chai , Advice , Backbone ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "perfectapi", ".", "js", "fix", "IE9", "support"], "add_tokens": "//console.log(req.body); //console.log(req.headers); && ( req . accepts ( 'application/json' ) || req . accepts ( 'application/javascript' ) ) ) { //console.log(query) //console.log(req.perfectapi); } else { console . log ( 'Not an API request' ) ;", "del_tokens": "&& req . accepts ( 'application/json' ) ) { console . log ( query ) console . log ( req . perfectapi ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "WooCommerce", "API", "v1", "and", "v2", "oAuth"], "add_tokens": "var data = { } ; if ( 'v3' !== this . version ) { data . last_ampersand = false ; } return new OAuth ( data ) ;", "del_tokens": "return new OAuth ( { } ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "yielding", "of", "arrays", "for", "implicit", "Promise", ".", "all"], "add_tokens": "var isArray = util . isArray ; if ( isArray ( maybePromise ) ) { maybePromise = Promise . all ( maybePromise ) ; } else { this . _throw ( new TypeError ( \"A value was yielded that could not be treated as a promise\" ) ) ; return ; } } ;", "del_tokens": "this . _throw ( new TypeError ( \"A value was yielded that could not be treated as a promise\" ) ) ; return ; } ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "new", "onExit", "option", "that", "if", "set", "to", "true", "will", "send", "immediately", "on", "process", "exit"], "add_tokens": "onExit : false , var self = this ; if ( this . options . onExit ) { process . on ( \"exit\" , function ( ) { self . send ( ) ; } ) } if ( this . interval || this . options . skipArchive || ! this . options . archiveInterval ) {", "del_tokens": "if ( this . interval || this . options . skipArchive ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "harnessless", "invocation", "in", "new", "scaffold", "."], "add_tokens": "expected = expect ( count ) inner . call ( context , assert , callback ) if ( inner . length == 1 ) callback ( )", "del_tokens": "return function ( count , inner ) { expected = expect ( count ) inner . call ( context , assert , callback ) if ( inner . length == 1 ) callback ( ) }", "commit_type": "fix"}
{"commit_tokens": ["Fix", "problem", "with", "cache", "in", "find", "and", "findBy", "methods"], "add_tokens": "instance : null isCacheExpired : function ( key , timeKey ) { if ( this . _cacheTimeToLive . hasOwnProperty ( timeKey ) ) { return this . _cacheTimeToLive [ timeKey ] !== null && ( ( new Date ( ) - this . _cache [ key ] . cachedAt ) > this . _cacheTimeToLive [ timeKey ] ) ; if ( this . isCached ( 'all' ) && ! this . isCacheExpired ( 'all' , 'all' ) ) { if ( this . isCached ( key ) && ! this . isCacheExpired ( key , 'instance' ) ) { if ( this . isCached ( key ) && ! this . isCacheExpired ( key , 'instance' ) ) {", "del_tokens": "instance : null , first : null , last : null isCacheExpired : function ( key ) { if ( this . _cacheTimeToLive . hasOwnProperty ( key ) ) { return this . _cacheTimeToLive [ key ] !== null && ( ( new Date ( ) - this . _cache [ key ] . cachedAt ) > this . _cacheTimeToLive [ key ] ) ; if ( this . isCached ( 'all' ) && ! this . isCacheExpired ( 'all' ) ) { if ( this . isCached ( key ) && ! this . isCacheExpired ( key ) ) { if ( this . isCached ( key ) && ! this . isCacheExpired ( key ) ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "constructor", "when", "array", "is", "passed"], "add_tokens": "arr . push . apply ( this , arg && ( arg . nodeType || / ^o / . test ( typeof arg ) ) && ! u . isArray ( arg ) && arg !== null ? [ arg ] : u . isArray ( arg ) ? arg : '' + arg === arg ? doc . querySelectorAll ( arg ) : undef ) ; currentElement = this [ 0 ] ; return u ( parents ) ;", "del_tokens": "arr . push . apply ( this , arg && ( arg . nodeType || / ^o / . test ( typeof arg ) ) && arg !== null ? [ arg ] : u . isArray ( arg ) ? arg : '' + arg === arg ? doc . querySelectorAll ( arg ) : undef ) ; currentElement = this [ 0 ] , currentParent = false ; return parents ;", "commit_type": "fix"}
{"commit_tokens": ["add", "ability", "to", "pass", "in", "child", "process", "options"], "add_tokens": "// build a list of options/arguments for the p4 command // filter passed-in options to get a hash of child process options // (i.e., not p4 command arguments) function execOptionBuilder ( options ) { var validKeys = { cwd : true , env : true , encoding : true , shell : true , timeout : true , maxBuffer : true , killSignal : true , uid : true , gid : true } ; options = options || { } ; return Object . keys ( options ) . reduce ( function ( result , key ) { if ( validKeys [ key ] ) { result [ key ] = options [ key ] ; } return result ; } , options ) ; } var childProcessOptions = execOptionBuilder ( options ) ; var child = exec ( cmd . join ( ' ' ) , childProcessOptions , function ( err , stdout , stderr ) { NodeP4 . prototype . info = function ( options , callback ) { if ( typeof options === 'function' ) { callback = options ; options = undefined ; } execP4 ( 'info' , options , function ( err , stdout ) {", "del_tokens": "var child = exec ( cmd . join ( ' ' ) , function ( err , stdout , stderr ) { NodeP4 . prototype . info = function ( callback ) { execP4 ( 'info' , function ( err , stdout ) {", "commit_type": "add"}
{"commit_tokens": ["changing", "gitlab", "indentation", "to", "4", "-", "spaces"], "add_tokens": "var indentation = ( mode === 'bitbucket.org' || mode === 'gitlab.com' ) ? ' ' : ' ' ;", "del_tokens": "var indentation = mode === 'bitbucket.org' ? ' ' : ' ' ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "command", "line", "script", ";", "updated", "README"], "add_tokens": ". version ( '0.3.0' ) fs . writeFile ( program . outfile , uncss , function ( err ) { console . log ( 'uncss: wrote %s' , program . outfile ) ;", "del_tokens": ". version ( '0.1.0' ) console . log ( program . outfile ) ; fs . writeFile ( options . outfile , options , function ( err ) { console . log ( 'uncss: wrote %s' , options . outfile ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "sample", ".", "js", "to", "properly", "identify", "if", "running", "from", "within", "package", "."], "add_tokens": "try { var xl = require ( 'excel4node' ) ; } catch ( e ) { var xl = require ( './lib/index.js' ) ;", "del_tokens": "if ( require . resolve ( \"excel4node\" ) ) { var xl = require ( 'excel4node' ) ; } else { var xl = require ( './lib/index.js' ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "pre", "compiled", "binaries", "for", "all", "3", "major", "platforms", "."], "add_tokens": "var binary = require ( 'node-pre-gyp' ) ; var path = require ( 'path' ) ; var binding_path = binary . find ( path . resolve ( path . join ( __dirname , '../package.json' ) ) ) ; var binding = require ( binding_path ) ; //module.exports = require('../build/Release/opencv.node'); module . exports = binding ;", "del_tokens": "module . exports = require ( '../build/Release/opencv.node' ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "skipFirst", "handle", "functions", "of", "any", "#", "args"], "add_tokens": "__slice = [ ] . slice , return function ( ) { var args ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; return f . apply ( null , args ) ;", "del_tokens": "__slice = [ ] . slice , return function ( x ) { return f ( x ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "typo", "in", "exported", "reflectN", "method", "on", "Vector"], "add_tokens": "Vector . prototype [ 'reflectN' ] = Vector . prototype . reflectN ;", "del_tokens": "Vector . prototype [ 'relectN' ] = Vector . prototype . reflectN ;", "commit_type": "fix"}
{"commit_tokens": ["add", "trim", "for", "Prefer", "header", "items", "update", "readme"], "add_tokens": "var item = prefer [ i ] . trim ( ) ; if ( item === DWA . Prefer . ReturnRepresentation ) { else if ( item . startsWith ( \"odata.include-annotations=\" ) ) { includeAnnotations = item . replace ( 'odata.include-annotations=' , '' ) . replace ( / \" / g , '' ) ; else if ( item . startsWith ( \"odata.maxpagesize=\" ) ) { maxPageSize = item . replace ( 'odata.maxpagesize=' , '' ) . replace ( / \" / g , '' ) ;", "del_tokens": "if ( prefer [ i ] === DWA . Prefer . ReturnRepresentation ) { else if ( prefer [ i ] . startsWith ( \"odata.include-annotations=\" ) ) { includeAnnotations = prefer [ i ] . replace ( 'odata.include-annotations=' , '' ) . replace ( / \" / g , '' ) ; else if ( prefer [ i ] . startsWith ( \"odata.maxpagesize=\" ) ) { maxPageSize = prefer [ i ] . replace ( 'odata.maxpagesize=' , '' ) . replace ( / \" / g , '' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "the", "lua", "script", "type", "integer", "to", "the", "getAddressInfo", "function", "."], "add_tokens": "// console.log('HERE', info);", "del_tokens": "console . log ( 'HERE' , info ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "feature", "to", "center", "teoast", "messages", "in", "desktop"], "add_tokens": "position : 'left' , position : 'center' , position : 'left' ,", "del_tokens": "positionLeft : true , positionLeft : true , positionLeft : true ,", "commit_type": "add"}
{"commit_tokens": ["Adding", "index", ".", "js", "and", "a", "Passport", "strategy", "."], "add_tokens": "var timestamp = new Date ( ) . getTime ( ) ;", "del_tokens": "var timestamp = new Date . getTime ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "linkage", "for", "module", "export", "."], "add_tokens": "module . exports = require ( './lib/jsonpath-object-transform.js' ) ;", "del_tokens": "module . exports = require ( 'lib/jsonpath-object-transform.js' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "more", "one", "test", "for", "getConfig", "method"], "add_tokens": "grunt . fatal ( \"\\\"\" + filePath + \"\\\" config is empty\" ) ;", "del_tokens": "grunt . fatal ( \"\\\"\" + filePath + \"\\\" is empty\" ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "foo", "(", "_", ")", "calls", "in", "top", "level", "script"], "add_tokens": "var _rootTemplate = new Template ( function _t ( ) { ( function ( _ ) { script } ) ( ) ; } ) ; function _canonicalizeRoot ( node ) { if ( node . _async ) { node = _rootTemplate . generate ( false , { script : node , scope : node . _scope } ) ; node . _async = false ; } return _canonicalize ( node ) ; } node = _canonicalizeRoot ( node ) ;", "del_tokens": "node = _canonicalize ( node ) ;", "commit_type": "allow"}
{"commit_tokens": ["moved", "yy", "-", "fps", "from", "dependences", "to", "devDependencies"], "add_tokens": "const Plugin = require ( './plugin' ) module . exports = class HitArea extends Plugin { constructor ( parent , rect ) { super ( parent ) this . rect = rect this . resize ( ) } resize ( ) { this . parent . container . hitArea = this . rect || this . parent . container . getBounds ( ) }", "del_tokens": "const Plugin = require ( './plugin' ) module . exports = class HitArea extends Plugin { constructor ( parent , rect ) { super ( parent ) this . rect = rect this . resize ( ) } resize ( ) { this . parent . container . hitArea = this . rect || this . parent . container . getBounds ( ) }", "commit_type": "move"}
{"commit_tokens": ["Using", "a", "fixed", "dataset", "for", "test4Select", "perf", "regression", "test", "."], "add_tokens": "goog . require ( 'goog.net.XhrIo' ) ; goog . require ( 'lf.testing.hrSchema.MockDataGenerator' ) ; return loadSampleDatafromJson ( 'test4_mock_data_30k.json' ) ; } ) . then ( function ( sampleData ) { var dataGenerator = lf . testing . hrSchema . MockDataGenerator . fromExportData ( db . getSchema ( ) , sampleData ) ; selectBenchmark = new lf . testing . perf . SelectBenchmark ( db , dataGenerator ) ; / ** * Reads the sample data from a JSON file . * @ param { string } filename The name of the JSON file holding the data . Has to * reside in the same folder as this test . * @ return { ! IThenable } * / function loadSampleDatafromJson ( filename ) { return new goog . Promise ( function ( resolve , reject ) { goog . net . XhrIo . send ( filename , function ( e ) { var xhr = e . target ; resolve ( JSON . parse ( xhr . getResponseText ( ) ) ) ; } ) ; } ) ; }", "del_tokens": "selectBenchmark = new lf . testing . perf . SelectBenchmark ( db ) ;", "commit_type": "use"}
{"commit_tokens": ["Improve", "behavior", "error", ".", "Add", "comments", "about", "IE", "rounding", "bug"], "add_tokens": "var SCROLL_TIME = 468 ; / * * IE has rounding bug rounding down clientHeight and clientWidth and * rounding up scrollHeight and scrollWidth causing false positives * on hasScrollableSpace * / throw new TypeError ( 'behavior member of ScrollOptions ' + firstArg . behavior + ' is not a valid value for enumeration ScrollBehavior.' ) ;", "del_tokens": "var SCROLL_TIME = typeof w . __smoothScrollPolyfillSpeed__ === 'number' ? w . __smoothScrollPolyfillSpeed__ : 468 ; throw new TypeError ( 'behavior not valid' ) ;", "commit_type": "improve"}
{"commit_tokens": ["fix", "parallel", "line", "detection", "bug"], "add_tokens": "if ( Math . abs ( denom ) > 0.01 ) {", "del_tokens": "if ( denom > 0.01 ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "client", "side", "crud", "on", "generator"], "add_tokens": "$scope . { { schema | lower } } . new { { field . fullPathCc | capitalize } } Mode = 'create' ; if ( $scope . { { schema | lower } } . new { { field . fullPathCc | capitalize } } Mode == 'create' ) $scope . { { field . fullPath } } . push ( $scope . { { schema | lower } } . new { { field . fullPathCc | capitalize } } ) ; $scope . clear { { field . fullPathCc } } ( ) $scope . { { schema | lower } } . new { { field . fullPathCc | capitalize } } Mode = 'create' ; $scope . { { schema | lower } } . new { { field . fullPathCc | capitalize } } Mode = 'update' ; $scope . destroy { { field . fullPathCc } } ByIndex = function ( index ) {", "del_tokens": "$scope . { { field . fullPath } } . push ( $scope . { { schema | lower } } . new { { field . fullPathCc | capitalize } } ) ; $scope . destroy { { field . fullPathCc } } ByIndex = function ( index ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "bug", "where", "default", ":", "false", "was", "misinterpreted", "as", "no", "default", "."], "add_tokens": "if ( schema . default !== undefined ) { // If function has no arguments it is assumed sync. if ( schema . default . length == 0 ) { return finalize ( schema . default ( ) , fn ) ; } else { return schema . default ( function ( defaultValue ) { finalize ( defaultValue , fn ) ; } ) ; } // Else just apply default value.", "del_tokens": "if ( schema . default ) { return schema . default ( function ( defaultValue ) { finalize ( defaultValue , fn ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "path", ".", "join", "again"], "add_tokens": "const { join } = require ( \"path\" ) ; return dir === \".\" ? entry . name : ` ${ join ( dir , entry . name ) } ` ;", "del_tokens": "const { sep } = require ( \"path\" ) ; return dir === \".\" ? entry . name : ` ${ dir } ${ sep } ${ entry . name } ` ;", "commit_type": "use"}
{"commit_tokens": ["Added", "lightMap", "controls", "to", "uniforms"], "add_tokens": "//material3d = new THREE.MeshPhongMaterial({ opacity: 0.5, transparent: true})", "del_tokens": "/*material3d = new THREE.MeshPhongMaterial({ opacity: 0.5, transparent: true})*/", "commit_type": "add"}
{"commit_tokens": ["added", "rejected", "promises", "handling", "&", "open&silent", "options", "&", "default", "error", "handler"], "add_tokens": "return async function ( req , res , next ) {", "del_tokens": "return function ( req , res , next ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "exception", "in", "Firefox", "after", "paste", "files"], "add_tokens": "clipboardData = e . clipboardData , items ; if ( typeof clipboardData === \"object\" ) { items = clipboardData . items || clipboardData . files || [ ] ; for ( var i = 0 ; i < items . length ; i ++ ) { var item = items [ i ] ;", "del_tokens": "clipboardData = e . clipboardData ; if ( typeof clipboardData === \"object\" && clipboardData . items !== null ) { for ( var i = 0 ; i < clipboardData . items . length ; i ++ ) { var item = clipboardData . items [ i ] ;", "commit_type": "fix"}
{"commit_tokens": ["add", "comment", "explaining", "division", "by", "1000"], "add_tokens": "var timeNow = Date . now ( ) / 1000 ; // https://nodejs.org/docs/latest/api/fs.html#fs_fs_utimes_path_atime_mtime_callback", "del_tokens": "var timeNow = Date . now ( ) / 1000 ;", "commit_type": "add"}
{"commit_tokens": ["move", "browser", "flattening", "per", "config", "out", "of", "lib", "/", "zuul", "into", "bin"], "add_tokens": "var formatted = format ( JSON . parse ( body ) ) ; cb ( null , formatted ) ; res . once ( 'error' , cb ) ;", "del_tokens": "cb ( null , format ( JSON . parse ( body ) ) ) ; // common mappings for some of us senile folks browsers . iexplore = browsers [ 'internet explorer' ] ; browsers . ie = browsers [ 'internet explorer' ] ; browsers . googlechrome = browsers . chrome ;", "commit_type": "move"}
{"commit_tokens": ["uses", "_", ".", "defaults", "instead", "of", "_", ".", "extend"], "add_tokens": "_configData = _ . defaults ( configData , _configData ) ;", "del_tokens": "// use config.when( env ).useFile() _configData = _ . extend ( { } , _configData , configData ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "nconf", "to", "source", "multiple", "files"], "add_tokens": "nconf . use ( 'memory' ) ; nconf . file ( 'overrides' , overrides ) ; nconf . argv ( ) . env ( ) . file ( 'config' , defaults ) ; }", "del_tokens": "nconf . use ( 'memory' ) . argv ( ) . env ( ) . defaults ( require ( defaults ) ) ; nconf . defaults ( require ( overrides ) ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Move", "output", "helper", "into", "support", "directory"], "add_tokens": "var stdio = require ( './support' ) ; var stdout = new stdio . Output ( ) ; app . run ( [ ] , stdout ) . on ( 'finish' , function ( ) { assert . equal ( stdout . data , 'OK\\n' ) ;", "del_tokens": "var Output = require ( './output' ) ; var out = new Output ( ) ; app . run ( [ ] , out ) . on ( 'finish' , function ( ) { assert . equal ( out . data , 'OK\\n' ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "--", "listen", "-", "http", "option"], "add_tokens": "var appArgs = utilex . tidyArgs ( ) , // args appConfig = { // config isHeapdump : false , listenOpt : { http : { hostname : 'localhost' , port : 12080 } } } if ( typeof appArgs [ 'listen-http' ] !== 'undefined' ) { var httpAddr = ( '' + appArgs [ 'listen-http' ] ) . split ( ':' , 2 ) ; if ( httpAddr [ 0 ] ) { appConfig . listenOpt . http . hostname = httpAddr [ 0 ] . trim ( ) ; appConfig . listenOpt . http . port = ( httpAddr [ 1 ] || null ) ; } } ip2co . listenHTTP ( { hostname : appConfig . listenOpt . http . hostname , port : appConfig . listenOpt . http . port } ) ;", "del_tokens": "var appArgs = utilex . tidyArgs ( ) , // args appConfig = { isHeapdump : false } // config ip2co . listenHTTP ( { hostname : 'localhost' , 'port' : 12080 } ) ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "anonymous", "func", "for", "scoping"], "add_tokens": "Express . Session = { }", "del_tokens": "( function ( ) { Express . Session = { } } ) ( )", "commit_type": "remove"}
{"commit_tokens": ["made", "pouchdb", "require", "-", "loading", "optional"], "add_tokens": "var SERVER_ENV = false ; if ( SERVER_ENV ) { var PouchDB = require ( 'pouchdb' ) ; PouchDB . plugin ( require ( 'pouchdb-find' ) ) ; }", "del_tokens": "var PouchDB = require ( 'pouchdb' ) ; PouchDB . plugin ( require ( 'pouchdb-find' ) ) ;", "commit_type": "make"}
{"commit_tokens": ["remove", "simple", "javascript", "inheritance", "library"], "add_tokens": "}", "del_tokens": "} , Class : require ( './src/class' )", "commit_type": "remove"}
{"commit_tokens": ["fixed", "a", "minor", "bug", "when", "running", "REPL"], "add_tokens": "// unknown case are produced when running REPL self . app = path . basename ( process . argv [ 1 ] || '(unknown)' ) ;", "del_tokens": "self . app = path . basename ( process . argv [ 1 ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["made", "the", "url", "change", "in", "the", "address", "bar", "appear", "faster", "in", "Chrome"], "add_tokens": "// client.express.js JavaScript Routing, version: 0.7.4", "del_tokens": "// client.express.js JavaScript Routing, version: 0.7.3", "commit_type": "make"}
{"commit_tokens": ["updated", "lodash", "usage", ";", "added", "jshint"], "add_tokens": "Error . captureStackTrace ( this , constr || this ) ; } }", "del_tokens": "Error . captureStackTrace ( this , constr || this ) } ; } ;", "commit_type": "update"}
{"commit_tokens": ["Allow", "postcss", "-", "font", "-", "family", "to", "be", "disabled", "."], "add_tokens": "fontFamily : { fn : require ( 'postcss-font-family' ) , ns : 'fonts' } ,", "del_tokens": "fontFamily : require ( 'postcss-font-family' ) ,", "commit_type": "allow"}
{"commit_tokens": ["change", "3d", "&", "flip", "slide", "dictionary", "when", "is", "Vertical"], "add_tokens": "if ( this . isVertical ) { offset = - offset ; } if ( this . isVertical ) { offset = - offset ; } if ( this . isVertical && ( this . _opts . animateType == '3d' || this . _opts . animateType == 'flip' ) ) { if ( n > 0 ) { sEle = els . pop ( ) ; els . unshift ( sEle ) ; } else if ( n < 0 ) { sEle = els . shift ( ) ; els . push ( sEle ) ; } } else { if ( n > 0 ) { sEle = els . shift ( ) ; els . push ( sEle ) ; } else if ( n < 0 ) { sEle = els . pop ( ) ; els . unshift ( sEle ) ; } }", "del_tokens": "if ( n > 0 ) { sEle = els . shift ( ) ; els . push ( sEle ) ; } else if ( n < 0 ) { sEle = els . pop ( ) ; els . unshift ( sEle ) ; }", "commit_type": "change"}
{"commit_tokens": ["Remove", "useless", "local", "variables", "in", "Graph", "constructor"], "add_tokens": "this . nodes = [ ] ; this . diagonal = ! ! diagonal ; // Optionally find diagonal neighbors as well (false by default). this . grid = [ ] ; this . grid [ x ] = [ ] ; var node = new GraphNode ( x , y , row [ y ] ) ; this . grid [ x ] [ y ] = node ; this . nodes . push ( node ) ;", "del_tokens": "var nodes = [ ] ; var grid = [ ] , node ; grid [ x ] = [ ] ; node = new GraphNode ( x , y , row [ y ] ) ; grid [ x ] [ y ] = node ; nodes . push ( node ) ; this . grid = grid ; this . nodes = nodes ; this . diagonal = ! ! diagonal ; // Optionally find diagonal neighbors as well (false by default).", "commit_type": "remove"}
{"commit_tokens": ["Updated", "event", "delegation", "to", "use", "AngularJS", "$rootScope"], "add_tokens": "module . exports = [ '$state' , function ( $state ) {", "del_tokens": "var process = require ( '../utils/process' ) ; module . exports = [ '$state' , '$rootScope' , function ( $state , $rootScope ) { $state . on ( 'change:complete' , function ( ) { $rootScope . $apply ( ) ; } ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "suport", "and", "test", "for", "base", "of", "values", "other", "than", "1"], "add_tokens": "if ( typeof tokenConfig . step . exponent !== 'number' || tokenConfig . step . exponent % 1 !== 0 ) { throw new XError ( XError . INVALID_ARGUMENT , 'exponent must be an integer' ) ; } this . steps . push ( tokenConfig . step . base * Math . pow ( tokenConfig . step . exponent , i ) ) ;", "del_tokens": "this . steps . push ( Math . pow ( tokenConfig . step . base , i ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "getApiKey", "nd", "getId", "to", "look", "in", "app", "object", "opposed", "to", "setttings", "object"], "add_tokens": "return this . getAppValue ( 'app_id' ) ; getAppValue : function ( k ) { return app [ k ] ; } , return this . getAppValue ( 'api_key' ) ;", "del_tokens": "return this . getValue ( 'app_id' ) ; return this . getValue ( 'api_key' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "setting", "the", "RPM", "destination"], "add_tokens": "rpmDest : process . cwd ( ) , var rpmDestination = path . join ( options . rpmDest , path . basename ( rpm [ 0 ] ) ) ; console . log ( chalk . cyan ( 'Copying RPM package to:' ) , rpmDestination ) ; fsx . copySync ( rpm [ 0 ] , rpmDestination ) ; return cb ( null , rpmDestination ) ;", "del_tokens": "var rpmDest = path . join ( process . cwd ( ) , path . basename ( rpm [ 0 ] ) ) ; console . log ( chalk . cyan ( 'Copying RPM package to:' ) , rpmDest ) ; fsx . copySync ( rpm [ 0 ] , rpmDest ) ; return cb ( null , rpmDest ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "anonymousUserIdPrefix", "+", "ip", "to", "identify", "anonymous", "user"], "add_tokens": "database : 'wilddog' , siteId : 'wd2231595668ouosqu' // const wildfireConfig = { // database: 'firebase', // databaseConfig: { // apiKey: 'AIzaSyCLsuRlCYjLyetc40v0-yFKHZVhumi85bs', // authDomain: 'wildfirewebsite-35a4f.firebaseapp.com', // databaseURL: 'https://wildfirewebsite-35a4f.firebaseio.com', // projectId: 'wildfirewebsite-35a4f', // storageBucket: '', // messagingSenderId: '911552849262' // }, // pageURL: 'http://chengkang.me/wildfire', // pageTitle: 'Wildfire Demo', // locale: 'zh-CN' // } anonymousUserIdPrefix : 'ANON:'", "del_tokens": "// const wildfireConfig = { // database: 'wilddog', // databaseConfig: { // siteId: 'wd2231595668ouosqu' // }, // pageURL: 'http://chengkang.me/wildfire', // pageTitle: 'Wildfire Demo', // locale: 'zh-CN' // } database : 'firebase' , apiKey : 'AIzaSyCLsuRlCYjLyetc40v0-yFKHZVhumi85bs' , authDomain : 'wildfirewebsite-35a4f.firebaseapp.com' , databaseURL : 'https://wildfirewebsite-35a4f.firebaseio.com' , projectId : 'wildfirewebsite-35a4f' , storageBucket : '' , messagingSenderId : '911552849262' anonymousUserId : 'anonymous'", "commit_type": "use"}
{"commit_tokens": ["add", "unit", "test", "for", "object", "-", "ops"], "add_tokens": "sortByPropertyKey", "del_tokens": "function slice ( obj , start , end ) { let sliced = new Object ( ) let keys = Object . keys ( obj ) let length = keys . length for ( let i = start ; i < end ; i ++ ) { let key = keys [ i ] sliced [ key ] = this [ key ] } return sliced } sortByPropertyKey , slice", "commit_type": "add"}
{"commit_tokens": ["Add", "auth", ".", "parse", "for", "low", "-", "level", "string", "parsing"], "add_tokens": "* Copyright ( c ) 2015 - 2016 Douglas Christopher Wilson module . exports . parse = parse return parse ( header ) / ** * Parse basic auth to object . * * @ param { string } string * @ return { object } * @ public * / function parse ( string ) { if ( typeof string !== 'string' ) { return undefined } // parse header var match = CREDENTIALS_REGEXP . exec ( string ) if ( ! match ) { return undefined } // decode user pass var userPass = USER_PASS_REGEXP . exec ( decodeBase64 ( match [ 1 ] ) ) if ( ! userPass ) { return undefined } // return credentials object return new Credentials ( userPass [ 1 ] , userPass [ 2 ] ) }", "del_tokens": "* Copyright ( c ) 2015 Douglas Christopher Wilson var match = CREDENTIALS_REGEXP . exec ( header || '' ) if ( ! match ) { return } // decode user pass var userPass = USER_PASS_REGEXP . exec ( decodeBase64 ( match [ 1 ] ) ) if ( ! userPass ) { return } // return credentials object return new Credentials ( userPass [ 1 ] , userPass [ 2 ] )", "commit_type": "add"}
{"commit_tokens": ["Remove", "try", "-", "catch", "."], "add_tokens": "socket . send ( chunk , next )", "del_tokens": "try { socket . send ( chunk ) next ( ) } catch ( err ) { onerror ( err ) }", "commit_type": "remove"}
{"commit_tokens": ["fixing", "export", "of", "index", "to", "correct", "es6", "way"], "add_tokens": "\"use strict\" ; function _interopRequireDefault ( e ) { return e && e . __esModule ? e : { \"default\" : e } } Object . defineProperty ( exports , \"__esModule\" , { value : ! 0 } ) , exports . I18nextProvider = exports . Interpolate = exports . translate = void 0 ; var _translate = require ( \"./translate\" ) , _translate2 = _interopRequireDefault ( _translate ) , _interpolate = require ( \"./interpolate\" ) , _interpolate2 = _interopRequireDefault ( _interpolate ) , _I18nextProvider = require ( \"./I18nextProvider\" ) , _I18nextProvider2 = _interopRequireDefault ( _I18nextProvider ) ; exports . translate = _translate2 [ \"default\" ] , exports . Interpolate = _interpolate2 [ \"default\" ] , exports . I18nextProvider = _I18nextProvider2 [ \"default\" ] ;", "del_tokens": "\"use strict\" ; function _interopRequireDefault ( e ) { return e && e . __esModule ? e : { \"default\" : e } } Object . defineProperty ( exports , \"__esModule\" , { value : ! 0 } ) ; var _translate = require ( \"./translate\" ) , _translate2 = _interopRequireDefault ( _translate ) , _interpolate = require ( \"./interpolate\" ) , _interpolate2 = _interopRequireDefault ( _interpolate ) , _I18nextProvider = require ( \"./I18nextProvider\" ) , _I18nextProvider2 = _interopRequireDefault ( _I18nextProvider ) ; exports [ \"default\" ] = { translate : _translate2 [ \"default\" ] , Interpolate : _interpolate2 [ \"default\" ] , I18nextProvider : _I18nextProvider2 [ \"default\" ] } ;", "commit_type": "fix"}
{"commit_tokens": ["moved", "cluster", "-", "config", "to", "serverassist"], "add_tokens": "_ . each ( require ( './sa-modules/serviceFinder' ) , ( v , k ) => { lib [ k ] = v ; } ) ; _ . each ( require ( './sa-modules/cluster-config' ) , ( v , k ) => { lib [ k ] = v ; } ) ;", "del_tokens": "_ . each ( require ( './sa-modules/serviceFinder' ) , ( v , k ) => { lib [ k ] = v ; } ) ;", "commit_type": "move"}
{"commit_tokens": ["add", "pgt", "invalid", "handler", "in", "getProxyTicket", ".", "js"], "add_tokens": "requestPT ( proxyPath , function ( err , pt ) { if ( err && err . message . indexOf ( 'Request for PT succeed, but the response is invalid' ) !== - 1 ) { logger . error ( 'As pgt is invalid, so just redirect to login page!' ) ; req . session && req . session . destroy && req . session . destroy ( ) ; return res . redirect ( utils . getPath ( 'login' , options ) ) ; }", "del_tokens": "requestPT ( proxyPath , function ( err , pt ) {", "commit_type": "add"}
{"commit_tokens": ["allow", "for", "single", "-", "quoted", "JSON", "thanks", "to", "ALCE"], "add_tokens": "} tests : [ 'test/*_test.js' ] }", "del_tokens": "} , tests : [ 'test/*_test.js' ] , } ,", "commit_type": "allow"}
{"commit_tokens": ["Fixed", "length", "for", "old", "browsers"], "add_tokens": "if ( cbLength [ lengthKey ] == null || opt_reset ) { if ( fLength [ lengthKey ] == null || opt_reset ) {", "del_tokens": "if ( lengthKey in cbLength === false || opt_reset ) { if ( lengthKey in fLength === false || opt_reset ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "Protractor", "4", ".", "x", "support"], "add_tokens": "return browser . executeScriptWithDescription ( data , 'a11y developer tool rules' ) . then ( function ( results ) {", "del_tokens": "return browser . executeScript_ ( data , 'a11y developer tool rules' ) . then ( function ( results ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "use", "of", "mime", "-", "codec", "API"], "add_tokens": "lines . push ( base64Encode ( this . content , typeof this . content === 'object' ? 'binary' : undefined ) )", "del_tokens": "lines . push ( base64Encode ( this . content , ( typeof this . content === 'object' && 'binary' ) || false ) )", "commit_type": "fix"}
{"commit_tokens": ["Add", "callback", "to", "async", "integration", "tests"], "add_tokens": "it ( 'validates JSON and YAML files' , function ( done ) { done ( ) ; it ( 'validates from stdin' , function ( done ) { done ( ) ; it ( 'handles validation failures' , function ( done ) { done ( ) ; it ( 'handles unreadable file errors' , function ( done ) { done ( ) ;", "del_tokens": "it ( 'validates JSON and YAML files' , function ( ) { it ( 'validates from stdin' , function ( ) { it ( 'handles validation failures' , function ( ) { it ( 'handles unreadable file errors' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Allow", "false", "value", "for", "the", "data", "argument", "for", "raw", "body", "request", "."], "add_tokens": "data = ( args [ 0 ] === false || typeof args [ 0 ] === 'object' ) && args . shift ( ) ,", "del_tokens": "data = typeof args [ 0 ] === 'object' && args . shift ( ) ,", "commit_type": "allow"}
{"commit_tokens": ["Added", "support", "for", "running", "many", "browsers"], "add_tokens": ". option ( '-s, --selenium <serverURL>' , 'Specify Selenium Server, like localhost:4444 or ondemand.saucelabs.com:80' , 'ondemand.saucelabs.com:80' ) . option ( '-u --username' , 'Sauce or Selenium User Name' ) . option ( '-a --accesskey' , 'Sauce or Selenium Access Key' ) . option ( '-b --browsers <list of browsers>' , 'Browsers to run the test on' , function ( val ) { return val . split ( ',' ) ; } ) program . username = program . username || process . env . SAUCE_USERNAME ; program . accesskey = program . accesskey || process . env . SAUCE_ACCESS_KEY ; if ( program . selenium . match ( 'ondemand.saucelabs' ) && ( ! program . username || ! program . accesskey ) ) { log . error ( 'Saucelabs is used but no username or password is specified' ) ; return ; } log . info ( \"RESULT \\n\" , data ) ; browsers : program . browsers , selenium : { host : program . selenium , user : program . username , pwd : program . accesskey , } ,", "del_tokens": ". option ( '-s, --selenium [type]' , 'Specify Selenium Server [http://localhost:4444/wd/hub]' , 'http://localhost:4444/wd/hub' ) log . info ( data ) selenium : program . selenium ,", "commit_type": "add"}
{"commit_tokens": ["added", ".", "travis", ".", "yml"], "add_tokens": "const Wallet = require ( './wallet' ) ; const KeyPair = require ( './keypairs' ) ;", "del_tokens": "const Wallet = require ( './src/wallet' ) ; const KeyPair = require ( './src/keypairs' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "title", "to", "close", "button", "by", "default", "as", "well", "as", "hidden", "text", "for", "screen", "readers"], "add_tokens": "* Date : Wed Sep 8 18 : 14 : 46 2010 + 0100 'class' : 'ui-state-default' , 'text' : 'Close tooltip' , 'title' : 'Close tooltip' , 'css' : { 'text-indent' : '-10000em' } . prepend (", "del_tokens": "* Date : Tue Sep 7 00 : 34 : 35 2010 + 0100 'class' : 'ui-state-default' . append (", "commit_type": "add"}
{"commit_tokens": ["Improve", "debugging", "tools", "for", "testing", "in", "QA"], "add_tokens": "//$scope.lfToken = \"eyJhbGciOiJIUzI1NiJ9.eyJkb21haW4iOiJjbm4uZnlyZS5jbyIsInVzZXJfaWQiOiI3MCIsImRpc3BsYXlfbmFtZSI6IiIsImV4cGlyZXMiOjI4NzIxMDczMzR9.BZr2LNa8H0TTB8DgZDr5HTVkaaPBn-f3B1P3mZHOY18\"; $scope . domain = \"cnn.fyre.co\" $scope . userId = \"42\" $scope . streamId = \"urn:livefyre:cnn.fyre.co:topic=7\" ; function makeToken ( ) { var json = { domain : $scope . domain , user_id : $scope . userId } return \"eyJhbGciOiJIUzI1NiJ9.eyJkb21haW4iOiJjbm4uZnlyZS5jbyIsInVzZXJfaWQiOiI3MCIsImRpc3BsYXlfbmFtZSI6IiIsImV4cGlyZXMiOjI4NzIxMDczMzR9.\" + btoa ( JSON . stringify ( json ) ) } $scope . sessionId = sc . sessionId ; $scope . sessionId = null ; sc . connect ( makeToken ( ) , $scope . streamId )", "del_tokens": "sc . connect ( \"eyJhbGciOiJIUzI1NiJ9.eyJkb21haW4iOiJjbm4uZnlyZS5jbyIsInVzZXJfaWQiOiI3MCIsImRpc3BsYXlfbmFtZSI6IiIsImV4cGlyZXMiOjI4NzIxMDczMzR9.BZr2LNa8H0TTB8DgZDr5HTVkaaPBn-f3B1P3mZHOY18\" , \"urn:livefyre:cnn.fyre.co:topic=7\" )", "commit_type": "improve"}
{"commit_tokens": ["Remove", "uncompressed", "Javascript", "-", "file", "from", "the", "dist", "-", "folder", "after", "compiling", "."], "add_tokens": "grunt . loadTasks ( modules + 'grunt-contrib-clean/tasks/' ) ; grunt . task . run ( 'cleanup' ) ; function taskCleanup ( ) { var settings = { all : [ 'dist/' + ff . getConfig ( 'name' ) + '.js' ] } ; grunt . config . set ( 'clean' , settings ) ; grunt . task . run ( 'clean' ) ; } grunt . registerTask ( 'cleanup' , 'Remove unnecessary files.' , taskCleanup ) ; 'csslint' , 'nodeunit' , 'shell' , 'prerelease' , 'postrelease' , 'jsdoc' , 'clean' , 'cleanup' ] ;", "del_tokens": "'csslint' , 'nodeunit' , 'shell' , 'prerelease' , 'postrelease' , 'jsdoc' ] ;", "commit_type": "remove"}
{"commit_tokens": ["added", "get", "and", "set", "methods", "to", "Attribute", "coupled", "with", "model", "change", "with", "it", "and", "emitted", "statechange", "on", "set"], "add_tokens": "version : '0.4.3' , function Attribute ( args , arg2 ) { Attribute . prototype . get = function ( ) { return this . value ; } ; Attribute . prototype . set = function ( newValue ) { this . value = newValue ; this . _emitEvent ( 'StateChange' ) ; return this . value ; } ; return this . attributes [ i ] . get ( ) ; this . attributes [ i ] . set ( value ) ; this . _emitEvent ( 'StateChange' ) ;", "del_tokens": "version : '0.4.2' , function Attribute ( args , arg2 ) { return this . attributes [ i ] . value ; this . attributes [ i ] . value = value ;", "commit_type": "add"}
{"commit_tokens": ["updated", "hc_staff", ".", "xml", ".", "js"], "add_tokens": "entities . setNamedItem ( new Entity ( \"alpha\" , \"&#945;\" ) ) ; entities . setNamedItem ( new Entity ( \"gamma\" , \"&#947;\" ) ) ; entities . setNamedItem ( new Entity ( \"alpha\" , \"&#950;\" ) ) ; doc . appendChild ( new Comment ( \" This is comment number 1.\" ) ) ; var html = doc . createElement ( \"html\" ) ; var html = doc . appendChild ( html ) ; var head = doc . createElement ( \"head\" ) ; var head = html . appendChild ( head ) ; var title = head . appendChild ( title ) ;", "del_tokens": "var alpha = new Entity ( \"alpha\" ) ; alpha . appendChild ( new Text ( \"&#945;\" ) ) ; entities . setNamedItem ( alpha ) ; var gamma = new Entity ( \"gamma\" , null , null , \"notation name?\" , new Text ( \"&#947;\" ) ) ; entities . setNamedItem ( gamma ) ; entities . setNamedItem ( new Entity ( \"epsilon\" , \"&#949;\" ) ) ; var head = doc . createElement ( \"head\" ) . appendChild ( title ) ; var html = doc . createElement ( \"html\" ) . appendChild ( head ) ;", "commit_type": "update"}
{"commit_tokens": ["Make", "faster", "local", "test", "fails"], "add_tokens": "waitforTimeout : 10000 , timeout : 20000 ,", "del_tokens": "waitforTimeout : 20000 , timeout : 40000 ,", "commit_type": "make"}
{"commit_tokens": ["Adds", "quadrant", "limit", "option", "to", "constructor", "."], "add_tokens": "if ( result . objects [ id ] ) { continue ; }", "del_tokens": "if ( result . objects [ id ] ) { return ; } if ( ! dir || dir === 1 ) { if ( this . parent_ ) { this . parent_ . getObjects ( result , 1 ) ; } } if ( ! dir || dir === - 1 ) { this . children_ . forEach ( function ( child ) { child . getObjects ( result , - 1 ) ; } ) ; }", "commit_type": "add"}
{"commit_tokens": ["fix", "postgres", "unique", "index", "on", "table", "creation"], "add_tokens": "it ( 'supports basic things' , ( ) => { expect ( getParsedSql ( ` ` , { database : 'postgresql' } ) ) . to . equal ( 'CREATE TABLE \"foo\" (\"id\" UUID)' ) expect ( getParsedSql ( ` ` , { database : 'postgresql' } ) ) . to . equal ( 'CREATE TABLE \"foo\" (\"value\" TEXT UNIQUE)' ) expect ( getParsedSql ( ` CREATE TABLE accounts ( id UUID DEFAULT uuid_generate_v4 ( ) NOT NULL , email TEXT NOT NULL , password TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT NOW ( ) , updated_at TIMESTAMP NULL , PRIMARY KEY ( id ) ) ; ` , { database : 'postgresql' } ) ) . to . equal ( 'CREATE TABLE \"accounts\" (\"id\" UUID NOT NULL DEFAULT uuid_generate_v4(), \"email\" TEXT NOT NULL, \"password\" TEXT NOT NULL, \"created_at\" TIMESTAMP NOT NULL DEFAULT NOW(), \"updated_at\" TIMESTAMP NULL, PRIMARY KEY (\"id\"))' ) ; } ) it ( 'throw error when create type is unknow' , ( ) => {", "del_tokens": "expect ( getParsedSql ( ` ` , { database : 'postgresql' } ) ) . to . equal ( 'CREATE TABLE \"foo\" (\"id\" UUID)' ) expect ( getParsedSql ( ` CREATE TABLE accounts ( id UUID DEFAULT uuid_generate_v4 ( ) NOT NULL , email TEXT NOT NULL , password TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT NOW ( ) , updated_at TIMESTAMP NULL , PRIMARY KEY ( id ) ) ; ` , { database : 'postgresql' } ) ) . to . equal ( 'CREATE TABLE \"accounts\" (\"id\" UUID NOT NULL DEFAULT uuid_generate_v4(), \"email\" TEXT NOT NULL, \"password\" TEXT NOT NULL, \"created_at\" TIMESTAMP NOT NULL DEFAULT NOW(), \"updated_at\" TIMESTAMP NULL, PRIMARY KEY (\"id\"))' ) describe ( 'throw error when create type is unknow' , ( ) => {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "issue", "using", "VS", "2013", "version", "of", "MSBuild"], "add_tokens": "var fail_msg = 'The command `msbuild` failed. Make sure you have the latest Windows 8 SDKs installed, and the `msbuild.exe` command (inside C:\\\\Windows\\\\Microsoft.NET\\\\Framework\\\\v4.0.30319) is added to your path.' var msversion = output . match ( / Microsoft\\s\\(R\\)\\s+Build\\sEngine,?\\s[a-z]+\\s4\\.0 / i ) ; Log ( 'Please install the .NET Framwork v4.0.30319 (in the latest windows 8 SDK\\'s).' , true ) ;", "del_tokens": "var fail_msg = 'The command `msbuild` failed. Make sure you have the latest Windows Phone SDKs installed, and the `msbuild.exe` command (inside C:\\\\Windows\\\\Microsoft.NET\\\\Framework\\\\v4.0.30319) is added to your path.' var msversion = output . match ( / Microsoft\\s\\(R\\)\\s+Build\\sEngine\\s[a-z]+\\s4\\.0 / i ) ; Log ( 'Please install the .NET Framwork v4.0.30319 (in the latest windows phone SDK\\'s).' , true ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "for", "Refresh", "not", "working"], "add_tokens": "if ( ( err ) || ! ( processes ) ) return cb ( err , null ) ; this . log . info ( \"Started: Forever web Console\" ) ; this . log . info ( \"Server listening on Port: 8085\" ) ;", "del_tokens": "if ( err ) return cb ( err , null ) ; this . log . info ( \"Started: Forever web UI app server!!\" ) ; this . log . info ( \"Listening on localhost:8085\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "bypassCache", "option", "&", "improve", "docs"], "add_tokens": "onlyFiles : false , bypassCache : false , options = { ... DEFAULT_OPTIONS , ... options } ; const pathMatcher = ! options . bypassCache ? pathMatcherCache . get ( pathMoveRules ) : new PathMatcher ( pathMoveRules ) ; return new FileMoveTransform ( pathMatcher , options ) ;", "del_tokens": "onlyFiles : false const pathMatcher = pathMatcherCache . get ( pathMoveRules ) ; return new FileMoveTransform ( pathMatcher , { ... DEFAULT_OPTIONS , ... options } ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "functionality", "for", "view", "to", "be", "a", "path", "to", "json", "file", ".", "Added", "tests", "with", "both", "valid", "and", "invalid", "json", "."], "add_tokens": "var fs = require ( 'fs' ) ; var err = null ; //If view is string, interpret as path to json filename if ( typeof view === \"string\" ) { try { view = JSON . parse ( fs . readFileSync ( view , 'utf8' ) ) ; } catch ( e ) { err = e ; } } function renderFile ( file ) { if ( err ) { return this . emit ( 'error' , new Error ( err . message ) ) ; } else { file . contents = new Buffer ( mustache . render ( file . contents . toString ( ) , view ) ) ; file . path = gutil . replaceExtension ( file . path , options . extension ) ; return this . emit ( 'data' , file ) ; } } return es . through ( renderFile ) ; }", "del_tokens": "return es . map ( function ( file , cb ) { file . contents = new Buffer ( mustache . render ( file . contents . toString ( ) , view ) ) ; file . path = gutil . replaceExtension ( file . path , options . extension ) ; cb ( null , file ) ; } ) ; } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "the", "fontweight", "attribute", "to", "custom", "themes", "drawn", "with", "svg"], "add_tokens": "\"font-weight\" : props . font_weight , var font_weight = template . fontweight ? template . fontweight : \"bold\" ; font : font , font_weight : font_weight ,", "del_tokens": "\"font-weight\" : \"bold\" , font : font ,", "commit_type": "add"}
{"commit_tokens": ["add", "async", "func", "call", "caching", "management", "class"], "add_tokens": "Query = require ( './query' ) , Cache = require ( './cache' ) ; conn . _cache . enableCaching ( this , \"describe\" , { key : \"describe.\" + this . type } ) ;", "del_tokens": "Query = require ( './query' ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "type", "comments", "and", "some", "more", "tree", "nodes"], "add_tokens": "* The types of concrete parse trees . * The name of the ParseTreeType must match the name of the class that it applies to . * For example the DerivedTree class should use ParseTreeType . DERIVED . * * @ enum { string }", "del_tokens": "* An abstract syntax tree for JavaScript parse trees . * Immutable . * A plain old data structure . Should include data members and simple * accessors only . * Derived classes should have a 'Tree' suffix . Each concrete derived class * should have a ParseTreeType whose name matches the derived class name . * * A parse tree derived from source should have a non - null location . A parse * tree that is synthesized by the compiler may have a null location . * * When adding a new subclass of ParseTree you must also do the following : * - add a new entry to ParseTreeType * - add ParseTree . asXTree ( ) * - modify ParseTreeVisitor . visit ( ParseTree ) for new ParseTreeType * - add ParseTreeVisitor . visit ( XTree ) * - modify ParseTreeTransformer . transform ( ParseTree ) for new ParseTreeType * - add ParseTreeTransformer . transform ( XTree ) * - add ParseTreeWriter . visit ( XTree ) * - add ParseTreeValidator . visit ( XTree )", "commit_type": "add"}
{"commit_tokens": ["Move", "config", "into", "tasks", "/", "options", "and", "setup", "locking"], "add_tokens": "function loadFrom ( path , config ) { var glob = require ( 'glob' ) , object = { } ; glob . sync ( '*' , { cwd : path } ) . forEach ( function ( option ) { var key = option . replace ( / \\.js$ / , '' ) ; config [ key ] = require ( path + option ) ; } ) ; } var config = { pkg : grunt . file . readJSON ( 'package.json' ) , env : process . env , clean : [ 'tmp' ] } ; loadFrom ( './tasks/options/' , config ) ; grunt . initConfig ( config ) ; grunt . loadTasks ( 'tasks' ) ;", "del_tokens": "function config ( configFileName ) { return require ( './configurations/' + configFileName ) ; } grunt . initConfig ( { pkg : grunt . file . readJSON ( 'package.json' ) , transpile : config ( 'transpile' ) , clean : [ 'tmp' ] , ember_handlebars : config ( 'ember_handlebars' ) , jshint : config ( 'jshint' ) , concat : config ( 'concat' ) , watch : config ( 'watch' ) , connect : config ( 'connect' ) , copy : config ( 'copy' ) , qunit : config ( 'qunit' ) } ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "undefined", "aid", "on", "disconnect"], "add_tokens": "if ( sock . identity ) { _this . emit ( 'disconnected' , sock . identity ) ; hubiquitus . removeActor ( sock . identity ) ; }", "del_tokens": "_this . emit ( 'disconnected' , sock . identity ) ; sock . identity && hubiquitus . removeActor ( sock . identity ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "webpack", "server", "for", "development"], "add_tokens": "* vue - paginate v3 .3 .1", "del_tokens": "* vue - paginate v3 .3 .0", "commit_type": "add"}
{"commit_tokens": ["Remove", "not", "called", "messageHandlers", "after", "a", "timeout"], "add_tokens": "this . messageHandlerTimeout = 45000 ; // 45 sec * @ param { Number } [ options . messageHandlerTimeout ] Message handlers not called will be removed after this delay in ms messageHandlerTimeout : 45000 , if ( typeof opts . messageHandlerTimeout !== 'number' ) { throw new TypeError ( 'LIFX messageHandlerTimeout option must be a number' ) ; } this . messageHandlerTimeout = opts . messageHandlerTimeout ; // We want to remove expired request handlers for specific packages after the // messageHandlerTimeout set in options if ( handler . sequenceNumber !== undefined ) { if ( Date . now ( ) > ( handler . timestamp + this . messageHandlerTimeout ) ) { this . messageHandlers . splice ( index , 1 ) ; } } callback : callback . bind ( this ) , timestamp : Date . now ( ) ,", "del_tokens": "callback : callback . bind ( this )", "commit_type": "remove"}
{"commit_tokens": ["Improve", "a", "test", "-", "check", "stamp", "contents", "on", "incorrect", "options", "to", "stampit", "()", "."], "add_tokens": "function addRefs ( fixed , refs ) { var args = [ fixed . refs || fixed . state ] . concat ( refs ) ;", "del_tokens": "function addRefs ( fixed , states ) { var args = [ fixed . refs || fixed . state ] . concat ( states ) ;", "commit_type": "improve"}
{"commit_tokens": ["fixed", "cycle", "and", "added", "tests"], "add_tokens": "let initialRender = oldVersion === - 1 // text nodes we don't want to handle children like with other elements // and for isolated components we want to skip all updates after the first render if ( tag !== TEXT_NODE && ( ! isolated || initialRender ) ) { console . warn ( \"ZLIQ: Something other then ZLIQ has manipulated the children of the element\" , parentElements , \". This can lead to sideffects. Consider using the 'isolated' attribute for this element to prevent updates.\" ) ; let { cycle } = oldChildren [ remaining - 1 ] ; triggerLifecycle ( childToRemove , { cycle } , 'removed' ) ; if ( props && props . cycle && props . cycle . mounted && ! props . id ) { function triggerLifecycle ( element , { cycle } = { } , event ) { if ( cycle && cycle [ event ] ) { cycle [ event ] ( element ) ;", "del_tokens": "let initialRender = oldChildren === undefined // text nodes have no real child-nodes, but have a string value as first child if ( tag !== TEXT_NODE && ! ( isolated && ! initialRender ) ) { console . warn ( \"ZLIQ: Something other then ZLIQ has manipulated the children of the element\" , parentElements , \". This can lead to sideffects. Please check your code.\" ) ; let { props } = oldChildren [ remaining - 1 ] ; triggerLifecycle ( childToRemove , props , 'removed' ) ; if ( props && props . cycle && props . cycle . mounted ) { function triggerLifecycle ( element , props , event ) { if ( props && props . cycle && props . cycle [ event ] ) { props . cycle [ event ] ( element ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "targetname", "option", "in", "unit", "test", "."], "add_tokens": "pdf2img . setOptions ( { outputdir : __dirname + '/output' , targetname : 'test' } ) ;", "del_tokens": "pdf2img . setOptions ( { outputdir : __dirname + '/output' } ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "reversal", "test", "+", "removed", "extra", "spaces"], "add_tokens": "typeof cue . identifier !== 'number' && cue . identifier !== null ) { output += ` ${ startTimestamp } ${ endTimestamp } ` ; output += cue . styles ? ` ${ cue . styles } ` : '' ; output += ` \\n ${ cue . text } ` ;", "del_tokens": "typeof cue . identifier !== 'number' && cue . identifier !== null ) { output += ` ${ startTimestamp } ${ endTimestamp } ${ cue . styles } \\n ${ cue . text } ` ;", "commit_type": "add"}
{"commit_tokens": ["Add", "plugin", "support", "for", "summarizers"], "add_tokens": "/* Collection of plugins to run to compute cell style, cell class name, column summaries */ plugins : React . PropTypes . array , const { columns , data , plugins } = this . props ; let result ; // run the summarize from each plugin if ( plugins ) { plugins . forEach ( plugin => { // if the plugin has summarize and this column matches the column test (if provided) if ( plugin . summarize && ( ! plugin . columnTest || plugin . columnTest ( column ) ) ) { const pluginResult = plugin . summarize ( column , data , columns ) ; if ( pluginResult ) { if ( ! result ) { result = pluginResult ; } else { Object . assign ( result , pluginResult ) ; } } } } ) ; } // run the column summarize last to potentially override plugins if ( column . summarize ) { const columnResult = column . summarize ( column , data , columns ) ; if ( ! result ) { result = columnResult ; } else { Object . assign ( result , columnResult ) ; } return result ; console . log ( 'summaries are' , summaries ) ;", "del_tokens": "const { columns , data } = this . props ; if ( ! column . summarize ) { return null ; return column . summarize ( column , data , columns ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "removeLayer", "updating", "count", "on", "icon"], "add_tokens": "if ( ! ( '_zoom' in this ) ) { if ( ! ( '_zoom' in this ) ) { this . setIcon ( group . options . iconCreateFunction ( this . _childCount ) ) ; }", "del_tokens": "if ( this . _icon ) {", "commit_type": "fix"}
{"commit_tokens": ["remove", "wrong", "checking", "of", "active", "link", "in", "sidebar"], "add_tokens": "return this . href == url ;", "del_tokens": "return this . href == url || url . href . indexOf ( this . href ) == 0 ;", "commit_type": "remove"}
{"commit_tokens": ["allow", "for", "no", "token", "in", "configuration"], "add_tokens": "this . config = config || { } ; if ( this . config . token && ( ! body . token || body . token !== this . config . token ) ) {", "del_tokens": "this . config = config ; var token = this . config . token ; if ( ! body . token || body . token !== token ) {", "commit_type": "allow"}
{"commit_tokens": ["Added", "normalize", "method", "and", "added", "the", "beginning", "of", "unit", "tests"], "add_tokens": "open = require ( 'open' ) , normalize = require ( './normalize' ) ; var testSuites = normalize ( results , { fromXML : false , hideSuccess : opts . hideSuccess } ) ;", "del_tokens": "open = require ( 'open' ) ; var testSuites = [ ] ; // Module keys are test file names (e.g. 'component_guide_tests/ButtonTest') Object . keys ( results . modules ) . forEach ( function ( moduleKey ) { var testModule = results . modules [ moduleKey ] ; Object . keys ( testModule ) . forEach ( function ( testKey ) { var testResult = testModule [ testKey ] ; testResult . name = testKey ; var suite = new TestSuite ( testResult , moduleKey , _ ) ; if ( ! opts . hideSuccess || ( opts . hideSuccess && suite . isFailure ) ) testSuites . push ( suite ) ; } ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "specs", "for", "up", "and", "down", "and", "fix", "the", "issues", "they", "revealed", "."], "add_tokens": "return this . selectionDirection = caret . start === caret . end ? null : 'left' ; PanField . prototype . moveDown = function ( event ) { PanField . prototype . moveDownAndModifySelection = function ( event ) { return this . selectionDirection = caret . start === caret . end ? null : 'right' ;", "del_tokens": "return this . selectionDirection = 'left' ; PanField . prototype . moveDown = function ( ) { PanField . prototype . moveDownAndModifySelection = function ( ) { return this . selectionDirection = 'right' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "hack", "to", "hide", "internal", "tables", "from", "the", "bucket", "listing"], "add_tokens": "var tables = this . registry [ req . params . domain ] . tables ; var listedTables = [ ] ; Object . keys ( tables ) . forEach ( function ( table ) { // TODO: hide private tables using the .acl member! // HACK: hide all tables with a dot in them if ( ! / \\. / . test ( table ) ) { listedTables . push ( table ) ; } } ) ; items : listedTables", "del_tokens": "items : Object . keys ( this . registry [ req . params . domain ] . tables )", "commit_type": "add"}
{"commit_tokens": ["Add", "charset", "options", "lc_type", "and", "lc_decode", "to", "createConnection"], "add_tokens": "exports . createConnection = function ( options ) { var c = new Connection ( options ) ;", "del_tokens": "exports . createConnection = function ( ) { var c = new Connection ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "messages", "in", "custom", "formats", "to", "be", "sent", "and", "received", ".", "To", "send", "such", "a", "message", "specify"], "add_tokens": "Sender . prototype . send = function ( msg , tag , format ) { var payload = format === undefined ? message . encode ( msg ) : msg ; var delivery = this . session . send ( this , tag ? tag : this . next_tag ( ) , payload , format ) ;", "del_tokens": "Sender . prototype . send = function ( msg , tag ) { var delivery = this . session . send ( this , tag ? tag : this . next_tag ( ) , message . encode ( msg ) , 0 ) ;", "commit_type": "allow"}
{"commit_tokens": ["implemented", "findEvents", "()", ";", "minor", "cleanups"], "add_tokens": "* Version : 0.0 .17 , build : 785", "del_tokens": "* Version : 0.0 .17 , build : 779", "commit_type": "implement"}
{"commit_tokens": ["Remove", "outdated", "examples", ";", "Support", "getting", "registration", "as", "an", "Object"], "add_tokens": "var reg = this . getOutput ( ) ; fs . writeFileSync ( filename , yaml . safeDump ( reg ) ) ; } ; / ** * Get the key - value output which should be written to a YAML file . * @ return { Object } * @ throws If required fields hs_token , as - token , url , sender_localpart are missing . * / AppServiceRegistration . prototype . getOutput = function ( ) { return {", "del_tokens": "var reg = { fs . writeFileSync ( filename , yaml . safeDump ( reg ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixing", "big", "with", "page", "caching"], "add_tokens": "var response = reply ( renderedPage ) ; // add content type if in the route info if ( routeInfo . contentType ) { response . header ( 'Content-Type' , routeInfo . contentType ) ; } // as long as the nocache attribute is NOT set, add cache headers (sorry for double negative :-)) if ( ! routeInfo . nocache ) { response . header ( 'cache-control' , 'public, max-age=60' ) ; }", "del_tokens": "config : { cache : { privacy : 'public' , expiresIn : 60000 // 1 minute cache expiry } } , routeInfo . contentType ? reply ( renderedPage ) . header ( 'Content-Type' , routeInfo . contentType ) : reply ( renderedPage ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "playing", "audio", "from", "base64", "encoded", "strings", "(", "add", "the", "base64", "string", "to", "the", "array", "of", "urls", "just", "like", "you", "would", "a", "source", "url", ")"], "add_tokens": "var ext = self . _urls [ i ] . toLowerCase ( ) . match ( / .+\\.([^?]+)(\\?|$) / ) , // figure out the filetype (whether an extension or base64 data) ext = ( ext && ext . length >= 2 ) ? ext [ 1 ] : self . _urls [ i ] . toLowerCase ( ) . match ( / data\\:audio\\/([^?]+); / ) [ 1 ] ;", "del_tokens": "var ext = self . _urls [ i ] . toLowerCase ( ) . match ( / .+\\.([^?]+)(\\?|$) / ) [ 1 ] ,", "commit_type": "add"}
{"commit_tokens": ["Added", "predicates", "(", "no", "tests", "or", "docs", "yet", ")"], "add_tokens": "exists : function ( x ) { return x != null ; } , truthy : function ( x ) { return ( x !== false ) && L . existy ( x ) ; } , falsey : function ( x ) { return ! L . truthy ( x ) ; } , isInstanceOf : function ( x , t ) { return ( x instanceof t ) ; } , isAssociative : function ( x ) { return _ . isArray ( x ) || _ . isObject ( x ) || _ . isArguments ( x ) ; } , isIndexed : function ( x ) { return _ . isArray ( data ) || _ . isString ( data ) || _ . isArguments ( x ) ; } , isSequential : function ( x ) { return ( _ . isArray ( x ) ) || ( _ . isArguments ( x ) ) ; } , isZero : function ( x ) { return 0 === x ; } , isEven : function ( x ) { return ( x & 1 ) === 0 ; } , isOdd : function ( x ) { return ! L . isEven ( x ) ; } , isPositive : function ( x ) { return x > 0 ; } , isNegative : function ( x ) { return x < 0 ; }", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["fix", "comfirm", "modal", "default", "btn", "classname"], "add_tokens": "className : \"default\" ,", "del_tokens": "className : \"defaultl\" ,", "commit_type": "fix"}
{"commit_tokens": ["added", "more", "examples", "for", "LT"], "add_tokens": "form : omit ( params , [ 'dialog_id' ] ) ,", "del_tokens": "formData : omit ( params , [ 'dialog_id' ] ) ,", "commit_type": "add"}
{"commit_tokens": ["use", "24h", "format", "for", "releaseDirname", "instead", "of", "12h"], "add_tokens": "grunt . shipit . releaseDirname = grunt . template . date ( 'yyyymmddHHMMss' ) ;", "del_tokens": "grunt . shipit . releaseDirname = grunt . template . date ( 'yyyymmddhhMMss' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "IE", "with", "JS", "since", "object", "keys", "must", "be", "defined", "but", "only", "in", "IE"], "add_tokens": "return { data : formData , honeypot : honeypot } ; } ) ( ) ;", "del_tokens": "return { data : formData , honeypot } ; } ) ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "_page", "param", "on", "server"], "add_tokens": "mainModel . set ( '_page' , req . params . page ) ;", "del_tokens": "mainModel . set ( '_page' , '/pages/' + req . params . page ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "possibility", "to", "mock", "undefined", "implicit", "globals"], "add_tokens": "try { // Allow tests to mock implicit globals // @see https://github.com/jhnns/rewire/issues/35 arguments . revertArgs [ 0 ] [ arguments . varName ] = eval ( arguments . varName ) ; } catch ( err ) { arguments . revertArgs [ 0 ] [ arguments . varName ] = undefined ; } try { // Allow tests to mock implicit globals // @see https://github.com/jhnns/rewire/issues/35 arguments . revertArgs = [ arguments . varName , eval ( arguments . varName ) ] ; } catch ( err ) { arguments . revertArgs = [ arguments . varName , undefined ] ; }", "del_tokens": "arguments . revertArgs [ 0 ] [ arguments . varName ] = eval ( arguments . varName ) ; arguments . revertArgs = [ arguments . varName , eval ( arguments . varName ) ] ;", "commit_type": "add"}
{"commit_tokens": ["Change", "build", "-", "component", "package", "to", "use", "new", "preprocess", "options"], "add_tokens": "// warning_level: 'VERBOSE', // jscomp_off: 'duplicate', // FIXME: Deprecated `method` var markup : preprocessMarkup ( { level : 2 } ) , compiler ( compilerOpts ) , // markup: preprocessMarkup({ level 2 }), markup : preprocessMarkup ( { level : 2 } ) ,", "del_tokens": "warning_level : 'VERBOSE' , jscomp_off : 'duplicate' , // FIXME: Deprecated `method` var markup : preprocessMarkup ( ) , compiler ( { ... compilerOpts } ) , // markup: preprocessMarkup(), markup : preprocessMarkup ( ) ,", "commit_type": "change"}
{"commit_tokens": ["fix", "problems", "with", "non", "-", "existant", "files"], "add_tokens": ") ; var mtime = fs . statSync ( path . join ( options . prefixes [ 0 ] , fileName ) ) . mtime return Promise . all (", "del_tokens": ") , mtime = fs . statSync ( path . join ( options . prefixes [ 0 ] , fileName ) ) . mtime ; return Promise . all (", "commit_type": "fix"}
{"commit_tokens": ["Fix", "problems", "with", "certain", "call", "sites"], "add_tokens": ". att ( 'method' , callSite . getFunctionName ( ) || '' ) . att ( 'file' , callSite . getFileName ( ) || '' ) . att ( 'number' , callSite . getLineNumber ( ) || '' )", "del_tokens": ". att ( 'method' , callSite . getFunctionName ( ) ) . att ( 'file' , callSite . getFileName ( ) ) . att ( 'number' , callSite . getLineNumber ( ) )", "commit_type": "fix"}
{"commit_tokens": ["using", "node", "binary", "which", "meteor", "or", "meteorite", "uses"], "add_tokens": "this . meteorApp = spawn ( config . nodeBinary , args , {", "del_tokens": "this . meteorApp = spawn ( 'node' , args , {", "commit_type": "use"}
{"commit_tokens": ["Fixed", "test", ".", "conf", "reference", "to", "tinymce", ".", "js"], "add_tokens": "'components/tinymce-release/tiny_mce.js' ,", "del_tokens": "'test/lib/tinymce358.js' ,", "commit_type": "fix"}
{"commit_tokens": ["Make", "snapshot", "titles", "a", "little", "smaller"], "add_tokens": "__$styleInject ( \".snapshots > li {\\n margin-top: 8px;\\n}\\n.snapshots > li > .snapshot__heading::before {\\n content: '▶';\\n display: inline-block;\\n position: relative;\\n top: -3px;\\n margin-right: 6px;\\n font-size: 50%;\\n transition: transform 0.15s;\\n}\\n.snapshots > li:hover > .snapshot__heading::before {\\n color: #f8f8f8;\\n}\\n.snapshots > li.selected > .snapshot__heading::before {\\n transform: rotate(90deg);\\n}\\n.snapshots > li.selected > .snapshot__content {\\n display: block;\\n}\\n.snapshots > li.selected > .snapshot__content pre.midas {\\n padding: 8px 16px;\\n margin: 0;\\n}\\n.snapshots > li.selected > h3 > .snapshot__timing {\\n color: #f8f8f8;\\n}\\n.snapshots > li > .snapshot__content {\\n display: none;\\n max-height: 1000px;\\n overflow: auto;\\n}\\n.snapshots > li > h3 {\\n font-size: 22px;\\n margin: 0;\\n}\\n.snapshots > li > h3 > .snapshot__timing {\\n float: right;\\n color: #666;\\n font-size: 16px;\\n}\\n\");", "del_tokens": "__$styleInject ( \".snapshots > li {\\n margin-top: 8px;\\n}\\n.snapshots > li > .snapshot__heading::before {\\n content: '▶';\\n display: inline-block;\\n position: relative;\\n top: -4px;\\n margin-right: 6px;\\n font-size: 50%;\\n transition: transform 0.15s;\\n}\\n.snapshots > li:hover > .snapshot__heading::before {\\n color: #f8f8f8;\\n}\\n.snapshots > li.selected > .snapshot__heading::before {\\n transform: rotate(90deg);\\n}\\n.snapshots > li.selected > .snapshot__content {\\n display: block;\\n}\\n.snapshots > li.selected > .snapshot__content pre.midas {\\n padding: 8px 16px;\\n margin: 0;\\n}\\n.snapshots > li.selected > h3 > .snapshot__timing {\\n color: #f8f8f8;\\n}\\n.snapshots > li > .snapshot__content {\\n display: none;\\n max-height: 1000px;\\n overflow: auto;\\n}\\n.snapshots > li > h3 {\\n margin: 0;\\n}\\n.snapshots > li > h3 > .snapshot__timing {\\n float: right;\\n color: #666;\\n font-size: 16px;\\n}\\n\");", "commit_type": "make"}
{"commit_tokens": ["Removed", "mounting", "event", "new", "style", "settings"], "add_tokens": "var settings = require ( 'captainjs-core' ) . getSettings ( ) ; app . use ( express . static ( __dirname + '/public' ) ) ; app . use ( express . static ( settings . get ( 'MEDIA_ROOT' ) ) ) ; app . get ( '/' , function ( req , res ) { res . sendfile ( __dirname + '/views/layout.html' ) ;", "del_tokens": "app . on ( 'mount' , function ( ) { var settings = require ( 'captainjs-core' ) . settings ; app . use ( express . static ( __dirname + '/public' ) ) ; app . use ( express . static ( settings . get ( 'MEDIA_ROOT' ) ) ) ; app . get ( '/' , function ( req , res ) { res . sendfile ( __dirname + '/views/layout.html' ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "options", ".", "url", "handling", "of", "url", ".", "parse", "object"], "add_tokens": "// http.request and https.request only accept string or URL as url argument. // This module allows url object since it is unambiguous in named options. // If url is not a URL, combine with options. const req = url instanceof URL ? proto . request ( url , options ) : proto . request ( { ... url , ... options , } ) ; req", "del_tokens": "const req = proto . request ( url , options )", "commit_type": "fix"}
{"commit_tokens": ["Add", "Lossy", "behavior", "to", "remove", "non", "-", "significant", "whitespace"], "add_tokens": "process ( selectors , options = { } ) { options : options ,", "del_tokens": "process ( selectors ) {", "commit_type": "add"}
{"commit_tokens": ["Improved", "IE", "document", "mode", "detection"], "add_tokens": "// (also in document modes emulating IE7) it is defined // and readonly. var document = Aria . $frameworkWindow . document ; var detectedIEVersion = document . documentMode || 7 ;", "del_tokens": "var detectedIEVersion ; // (also in document mode emulating IE7) it is defined. if ( typeof ( document . documentMode ) === \"undefined\" ) { detectedIEVersion = 7 ; } else { detectedIEVersion = document . documentMode ; }", "commit_type": "improve"}
{"commit_tokens": ["Make", "logic", "even", "easier", "across", "all", "platforms", "and", "modify", "tests", "to", "suit", "new", "logic"], "add_tokens": "// Change the file permissions so we can over-write the package. Then we'll write the package // and then change the file permissions back to read-only. Fs . chmodSync ( packagePath , \"0644\" ) ; Fs . writeFile ( packagePath , JSON . stringify ( packageContents , null , 2 ) , done ) ; Fs . chmodSync ( packagePath , \"0444\" ) ;", "del_tokens": "// The generated package.json is read-only, but removing it prior to writing // will allow updates. // Node 0.10.xx + Windows Hack .. Windows does not allow an unlink of a Read-Only file .. // So we chmod it to be rw by owner... // This was fixed in node 0.12 + but still is an issue in 0.10.XX which Meteor uses.. if ( FindNodeVersion ( options ) . substring ( 0 , 4 ) === \"0.10\" && process . platform === \"win32\" ) { Fs . chmodSync ( packagePath , \"0644\" ) ; } Fs . unlinkSync ( packagePath ) ; Fs . writeFile ( packagePath , JSON . stringify ( packageContents , null , 2 ) , done ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "multi", "filter", "(", "and", "or", ")"], "add_tokens": "/ *! OpenCrisp PathJS - v0.5.1 - 2015-10-31 var End = $$ . ns ( 'util.control.End' ) ; throw new End ( ) ; throw new End ( ) ;", "del_tokens": "/ *! OpenCrisp PathJS - v0.5.0 - 2015-10-31 // var End = $$.ns('util.control.End'); throw new EndPath ( ) ; throw new EndPath ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "where", "self", "was", "not", "returned", "from", "setter", "invocation", "."], "add_tokens": "return parent . me ;", "del_tokens": "return ;", "commit_type": "fix"}
{"commit_tokens": ["use", "@rebuild", "s", "standard", "Logger"], "add_tokens": "const { Logger } = require ( '@rebuild/build/utils/Logger' ) ; isoBuilder . logger = Logger ( { log_config_and_stats : log_option } ) ;", "del_tokens": "//const log_title = require('@rebuild/build/utils/log_title'); isoBuilder . log = log_option ;", "commit_type": "use"}
{"commit_tokens": ["make", "tests", "work", "with", "the", "new", "dir", "layout"], "add_tokens": "var Compiler = require ( '../../lib/compiler.js' ) ;", "del_tokens": "var Compiler = require ( '../../../js/compiler.js' ) ;", "commit_type": "make"}
{"commit_tokens": ["Moved", "debugEnabled", "to", "attributes", "object", "."], "add_tokens": "debugEnabled : false , if ( attributes . debugEnabled ) console . log ( q ) ; attributes . debugEnabled = enable ;", "del_tokens": "var debugEnabled = false ; if ( debugEnabled ) console . log ( q ) ; debugEnabled = enable ;", "commit_type": "move"}
{"commit_tokens": ["use", "more", "descriptive", "function", "names"], "add_tokens": "Vue . prototype . _updateFromParent = function ( parentData , children , key ) { if ( parentDataChanged ( parentData , oldParentData ) ) { function parentDataChanged ( data , oldData ) {", "del_tokens": "Vue . prototype . _tryUpdate = function ( parentData , children , key ) { if ( diffParentData ( parentData , oldParentData ) ) { function diffParentData ( data , oldData ) {", "commit_type": "use"}
{"commit_tokens": ["Update", "complex", "example", "to", "latest", "lib", "changes"], "add_tokens": "return await App . deploy ( initialVersion , 0x0 , txParams )", "del_tokens": "return await App . deploy ( initialVersion , txParams )", "commit_type": "update"}
{"commit_tokens": ["adding", "iojs", "and", "removing", "unnecessary", "deps"], "add_tokens": "var config = require ( './config' ) ;", "del_tokens": "var config = require ( './config.js' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "clean", "task", "so", "it", "doesn", "t", "delete", "the", "production", "files"], "add_tokens": "var delDir = args . production ? dirs . destination : dirs . temporary ; del . sync ( delDir ) ;", "del_tokens": "del . sync ( [ path . join ( dirs . temporary ) , path . join ( dirs . destination ) , ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "#split", "to", "the", "public", "API"], "add_tokens": ". and . to . have . all . keys ( 'split' , 'first' , 'forEach' , 'wait' ) ; expect ( index . split ) . to . be . a ( 'function' ) . and . to . have . length ( 3 ) ;", "del_tokens": ". and . to . have . all . keys ( 'first' , 'forEach' , 'wait' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "code", "coverage", "scripts", "for", "travis", "-", "ci"], "add_tokens": "'!node_modules/**/*.{js,json}' , '!lib-cov/**/*.{js,json}'", "del_tokens": "'!node_modules/**/*.{js,json}'", "commit_type": "add"}
{"commit_tokens": ["Adding", "support", "for", "more", "subdevices"], "add_tokens": "// Temperature and Humidity sensor // Switch (button) // Cube controller 'cube' : require ( './gateway/cube' ) , // Motion sensor 'motion' : require ( './gateway/motion' ) , // Magnet sensor for windows and doors 'magnet' : require ( './gateway/magnet' ) , // Simple plug for sockets 'plug' : require ( './gateway/plug' ) , // Plugs for light switches 'ctrl_neutral1' : require ( './gateway/ctrl_neutral1' ) , 'ctrl_neutral2' : require ( './gateway/ctrl_neutral2' ) * So to work around this we activate the local developer connection and use * that together with the regular calls for changing things on the gateway . static get SubDevice ( ) { return SubDevice } static registerSubDevice ( id , deviceClass ) { devices [ id ] = deviceClass ; }", "del_tokens": "const crypto = require ( 'crypto' ) ; 'cube' : require ( './gateway/cube' )", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "matcher", "that", "tolerates", "un", "-", "escaped", "<", "in", "attribute", "values"], "add_tokens": "var customElement = \"<test-element foo='bar <figure >' baz=\\\"booz\\\">\" foo : 'bar <figure >' ,", "del_tokens": "var customElement = \"<test-element foo='bar' baz=\\\"booz\\\">\" foo : 'bar' ,", "commit_type": "add"}
{"commit_tokens": ["Added", "recursive", "method", "for", "getting", "inherited", "colors"], "add_tokens": "'<!doctype html><html lang=\"en\"><head><title>titulo test</title></head><body style=\"background-color: white;\"> <h1 style=\"color: black;\">hola</h1><img src=\"asdf.jpg\" alt=\"woop\" /> <div class=\"entry\"> <p>{{title}}</p> <h2>By {{author.name}}</h2> <div class=\"body\">{{body}}</div></div> </body> </html>'", "del_tokens": "'<!doctype html><html lang=\"en\"><head><title>titulo test</title></head><body style=\"background-color: white;\"> <h1 style=\"color: black;\">hola</h1><img src=\"asdf.jpg\" alt=\"woop\" /> </body> </html>'", "commit_type": "add"}
{"commit_tokens": ["Fixing", "include", "files", "in", "strings"], "add_tokens": "page . content = transform . processString ( fileContents . body , fileInPath , page )", "del_tokens": "page . content = transform . processString ( fileContents . body , page )", "commit_type": "fix"}
{"commit_tokens": ["fixed", "context", "menu", "focus", "bug", "related", "to", "copy", "fix"], "add_tokens": "if ( ! self . hasFocus && e . target !== self . canvas ) {", "del_tokens": "if ( ! self . hasFocus ) {", "commit_type": "fix"}
{"commit_tokens": ["Made", "fixes", "to", "tests", "to", "get", "them", "working", "on", "a", "windows", "machine"], "add_tokens": "var expect , fileURL , fs , os , spawn , url ; os = require ( 'os' ) ; urlString = fullPath ; if ( process . platform !== 'win32' ) { urlString = url . format ( { protocol : 'file' , hostname : '' , pathname : fullPath } ) ; }", "del_tokens": "var expect , fileURL , fs , spawn , url ; urlString = url . format ( { protocol : 'file' , hostname : '' , pathname : fullPath } ) ;", "commit_type": "make"}
{"commit_tokens": ["use", "normalize", "-", "package", "-", "metadata", "to", "normalize", "pkgs"], "add_tokens": "const normalizeData = require ( 'normalize-package-data' ) const pkg = normalizeData ( readFileSync ( './package.json' ) )", "del_tokens": "const pkg = JSON . parse ( readFileSync ( './package.json' ) )", "commit_type": "use"}
{"commit_tokens": ["Fix", "fill", "color", "for", "md", "-", "chatboxes"], "add_tokens": "svg = svg . replace ( / __COLOR__ / g , '#{' + prefix + '-fix-color($color)}' )", "del_tokens": "svg = svg . replace ( '__COLOR__' , '#{' + prefix + '-fix-color($color)}' )", "commit_type": "fix"}
{"commit_tokens": ["Add", ".", "abort", "()", "method"], "add_tokens": "me . abort ( )", "del_tokens": "me . _aborted = true", "commit_type": "add"}
{"commit_tokens": ["Add", "additional", "callback", "methods", "for", "pushstate", "popstate", "and", "callback", "generically"], "add_tokens": "push : false , pop : true var key = conf . path . replace ( / ^\\/ / g , '' ) , method = conf . request . method ; if ( ! method || method == 'get' ) { conf . path = W . data . $private . getUrl ( conf . request ) ; } if ( conf . push && conf . pushstate ) { W . $exec ( conf . pushstate ) ; } if ( conf . pop && conf . popstate ) { W . $exec ( conf . popstate ) ; } if ( conf . callback ) { W . $exec ( conf . callback ) ; }", "del_tokens": "push : false var key = conf . path . replace ( / ^\\/ / g , '' ) ;", "commit_type": "add"}
{"commit_tokens": ["Adds", "diagonal", "path", "rendering", "func"], "add_tokens": "diagonalPath ( linkData ) { const diagonal = d3 . svg . diagonal ( ) . projection ( d => [ d . y , d . x ] ) return diagonal ( linkData ) < path className = { styles . linkBase } d = { this . diagonalPath ( this . props . linkData ) } > < / path >", "del_tokens": "diagonalPath ( ) { d3 . svg . diagonal ( ) . projection ( d => { return [ d . y , d . x ] } ) < path className = { styles . linkBase } d = { \"M0,0C0,71.9140625 -671.837109375,71.9140625 -671.837109375,143.828125\" } > < / path >", "commit_type": "add"}
{"commit_tokens": ["update", "navbar", "tabbar", ".", "fix", "searchbar"], "add_tokens": "$ ( document ) . on ( \"click touchstart\" , \".weui-search-bar__label\" , function ( e ) { / * * /", "del_tokens": "$ ( document ) . on ( \"click\" , \".weui-search-bar__label\" , function ( e ) {", "commit_type": "update"}
{"commit_tokens": ["Adds", "retrial", "policy", "for", "possible", "flaky", "tests", "."], "add_tokens": "var FLAKY_TEST_RETRIAL = 3 ; * @ param { ? number = } tries The number of trials so far for the current test . * This is used to retry flaky tests . var waitForTest = function ( done , fail , tries ) { // The default retrial policy. if ( typeof tries === 'undefined' ) { tries = FLAKY_TEST_RETRIAL ; } // Tests completed on the page but something failed. Retry a certain // number of times in case of flakiness. if ( status && status . isFinished && ! status . isSuccess && tries > 1 ) { // Try again in a few ms. setTimeout ( waitForTest . bind ( undefined , done , fail , tries - 1 ) , 300 ) ; } else if ( status && status . isFinished ) { setTimeout ( waitForTest . bind ( undefined , done , fail , tries ) , 300 ) ;", "del_tokens": "var waitForTest = function ( done , fail ) { if ( status && status . isFinished ) { setTimeout ( waitForTest . bind ( undefined , done , fail ) , 300 ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "mocha", "notifier", "on", "test", "watcher"], "add_tokens": "var mochaNotifier = require ( 'mocha-notifier-reporter' ) ; m = new Mocha ( { reporter : mochaNotifier . decorate ( 'spec' ) } ) ;", "del_tokens": "m = new Mocha ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Use", "the", "CamelCase", "for", "the", "option", "names", "but", "leave", "support", "for"], "add_tokens": "( ! options . html5embed . isAllowedMimeType || options . html5embed . isAllowedMimeType ( mimetype_matches ) ) ) { useImageSyntax : true if ( typeof options . html5embed . useImageSyntax === \"undefined\" ) { options . html5embed . useImageSyntax = options . html5embed . use_image_syntax ; } if ( typeof options . html5embed . useLinkSyntax === \"undefined\" ) { options . html5embed . useLinkSyntax = options . html5embed . use_link_syntax ; } if ( typeof options . html5embed . isAllowedMimeType === \"undefined\" ) { options . html5embed . isAllowedMimeType = options . html5embed . is_allowed_mime_type ; } if ( options . html5embed . useImageSyntax ) { if ( options . html5embed . useLinkSyntax ) {", "del_tokens": "( ! options . html5embed . is_allowed_mime_type || options . html5embed . is_allowed_mime_type ( mimetype_matches ) ) ) { use_image_syntax : true if ( options . html5embed . use_image_syntax ) { if ( options . html5embed . use_link_syntax ) {", "commit_type": "use"}
{"commit_tokens": ["removed", "all", "traces", "of", "extends", "--", "it", "s", "not", "any", "shorter", "or", "more", "convenient", "than", "just", "setting", "the", "prototype"], "add_tokens": "if ( day === bingo_day ) { go_to_bingo ( ) ; } ;", "del_tokens": "day === bingo_day ? go_to_bingo ( ) : null ;", "commit_type": "remove"}
{"commit_tokens": ["changed", "test", "in", "Controler_getParams", "()"], "add_tokens": "req . get = ( req . query ) ? JSON . parse ( JSON . stringify ( req . query ) ) : { } ; req . post = ( req . body ) ? JSON . parse ( JSON . stringify ( req . body ) ) : { } ;", "del_tokens": "//req.get = req.query || {}; //req.post = req.body || {}; req . get = JSON . parse ( JSON . stringify ( req . query ) ) || { } ; req . post = JSON . parse ( JSON . stringify ( req . body ) ) || { } ;", "commit_type": "change"}
{"commit_tokens": ["allow", "animations", "to", "be", "null"], "add_tokens": "var animation = get ( this , 'animation' ) ;", "del_tokens": "var animation = get ( this , 'animation' ) || 'scale' ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "wrong", "name", "of", "variable"], "add_tokens": "self . emit ( \"error\" , \"File not found!\" ) ;", "del_tokens": "self . emit ( \"error\" , err ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "name", "handling", "to", "shootshoot", "controller"], "add_tokens": "var playerNameHandler = new PlayerNameHandler ( g_client , $ ( \"name\" ) ) ;", "del_tokens": "function reloadPage ( ) { window . location . reload ( ) ; }", "commit_type": "add"}
{"commit_tokens": ["remove", "the", "needless", "last", "commas", "before", "closing", "map"], "add_tokens": "// remove last comma before closing map sassMapStr = sassMapStr . replace ( \",\\n\" + options . indention + \")\" , \"\\n\" + options . indention + \")\" ) ; // the slice removes the last comma return \"(\" + sassMapStr . slice ( 0 , - 1 ) + \"\\n)\" ;", "del_tokens": "return \"(\" + sassMapStr . replace ( \",)\" , \")\" ) + \"\\n)\" ;", "commit_type": "remove"}
{"commit_tokens": ["adding", "new", "new", "mongodb", "driver", "support"], "add_tokens": "module . exports = function ( collection ) { var addCreateDate = function ( params , callback ) { if ( params . obj ) { params . obj . createDate = now ; } else { params . objs . forEach ( function ( obj ) { obj . createDate = now ; } ) ; } } ; collection . on ( 'beforeInsertOne' , addCreateDate ) ; collection . on ( 'beforeInsertMany' , addCreateDate ) ;", "del_tokens": "var convertToArray = require ( './utils' ) . convertToArray ; // inject in every inserted object `createDate` field module . exports = function ( col ) { col . on ( 'beforeInsert' , function ( params , callback ) { params . objs = convertToArray ( params . objs ) ; params . objs . forEach ( function ( obj ) { obj . createDate = now ; } ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "curry", "bug", "this", "-", ">", "$this"], "add_tokens": "var scopeOuter = ( v [ 5 ] ? v [ 7 ] . toString ( ) : \"()\" ) ; var scopeInner = scopeOuter . replace ( / \\bthis\\b / , '$this' ) ; var ret = [ '(function' + scopeInner + '{return function' ] ; ret . push ( scopeOuter ) ;", "del_tokens": "var ret = [ '(function(){return function' ] ; ret . push ( v [ 5 ] ? v [ 7 ] . toString ( ) : \"()\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "test", "for", "this", "and", "futures"], "add_tokens": "asyncTest ( \"this\" , 10 , function ( ) { function delay2 ( val , _ ) { return delay ( _ , val ) ; } O . prototype . test4 = function ( _ ) { var self = this ; v1 = delay2 ( this . x + 1 ) ; v2 = delay2 ( 1 ) ; this . x = v1 ( _ ) + v2 ( _ ) ; strictEqual ( this , self ) ; } o . test4 ( _ ) ; } , 7 ) ;", "del_tokens": "asyncTest ( \"this\" , 8 , function ( ) { } , 5 ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "some", "naming", "in", "init", "command"], "add_tokens": "coerce : function resolveTemplateName ( tmpl ) { . check ( function validateApplicationName ( { name } ) { const isValidAppName = name . split ( '.' ) . length >= 2 if ( ! isValidAppName ) {", "del_tokens": "coerce : ( tmpl ) => { . check ( ( { name } ) => { const isValidPackageName = name . split ( '.' ) . length >= 2 if ( ! isValidPackageName ) {", "commit_type": "change"}
{"commit_tokens": ["Added", "support", "for", "start", "time"], "add_tokens": "var channel = params . channel || params . utm_content || result . channel ; delete params . utm_content ; delete params . channel ; return channel ; Twitch . prototype . parseParameters = function ( params ) { 'use strict' ; if ( params . t ) { params . start = getTime ( params . t ) ; delete params . t ; } return params ; } ; result . params = _this . parseParameters ( params ) ; if ( params . start ) { params . t = params . start + 's' ; delete params . start ; }", "del_tokens": "return params . channel || params . utm_content || result . channel ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "yarn", ".", "lock", "detection"], "add_tokens": "if ( ! await config . api . getFileContent ( yarnLockFileName ) ) {", "del_tokens": "if ( await config . api . getFileContent ( yarnLockFileName ) === false ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "binary", "frame", "for", "binary", "data"], "add_tokens": "if ( typeof _frame . body === 'object' && _frame . body instanceof Buffer ) { socket . send ( frame_str , { binary : true } ) ; } else { socket . send ( frame_str ) ; }", "del_tokens": "socket . send ( frame_str ) ;", "commit_type": "use"}
{"commit_tokens": ["Moving", "consts", "and", "linter", "object", "out", "of", "the", "map", "-", "loop", "."], "add_tokens": "// TSLint default options var options = { fix : pluginOptions . fix || false , formatter : pluginOptions . formatter || \"prose\" , formattersDirectory : pluginOptions . formattersDirectory || null , rulesDirectory : pluginOptions . rulesDirectory || null } ; var linter = getTslint ( pluginOptions ) ; var tslint = new linter . Linter ( options , pluginOptions . program ) ; tslint . failures = [ ] ; tslint . fixes = [ ] ;", "del_tokens": "var loader ; var tslint ; // TSLint default options var options = { fix : pluginOptions . fix || false , formatter : pluginOptions . formatter || \"prose\" , formattersDirectory : pluginOptions . formattersDirectory || null , rulesDirectory : pluginOptions . rulesDirectory || null } ; var linter = getTslint ( pluginOptions ) ; tslint = new linter . Linter ( options , pluginOptions . program ) ;", "commit_type": "move"}
{"commit_tokens": ["make", "first", "row", "/", "col", "on", "positive", "side", "be", "zero"], "add_tokens": "return Math . floor ( spacePosition / cellSize ) ;", "del_tokens": "if ( spacePosition >= 0 ) { return Math . floor ( spacePosition / cellSize ) + 1 ; } else { return Math . floor ( spacePosition / cellSize ) ; }", "commit_type": "make"}
{"commit_tokens": ["Update", "skeleton", "app", "default", "dependencies"], "add_tokens": "this . packageJson . dependencies . devtron = '1.4.0' ; this . packageJson . dependencies [ 'electron-debug' ] = '1.1.0' ;", "del_tokens": "this . packageJson . dependencies . devtron = '1.3.0' ; this . packageJson . dependencies [ 'electron-debug' ] = '0.6.0' ;", "commit_type": "update"}
{"commit_tokens": ["Adding", "doc", "and", "fixing", "broken", "references"], "add_tokens": "return Function ( \"val\" , \"return Savage.path.toString.call([\" + b + \"])\" ) ; A = Savage . path . toCubic ( a , b ) ;", "del_tokens": "return Function ( \"val\" , \"return Savage.path2string.call([\" + b + \"]);\" ) ; A = Savage . path2curve ( a , b ) ;", "commit_type": "add"}
{"commit_tokens": ["using", "gulp", "-", "watch", "instead", "of", "gulp", ".", "watch", "so", "new", "/", "deleted", "files", "get", "noted", "aswel"], "add_tokens": "watcher = require ( 'gulp-watch' ) , watcher ( watch , function ( ) { gulp . start ( name ) ; } ) ; // gulp.watch(watch, {debounceDelay: config.debounce}, [name]);", "del_tokens": "gulp . watch ( watch , { debounceDelay : config . debounce } , [ name ] ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "cancel", "of", "setTimeout", "for", "old", "sessions"], "add_tokens": "let algorithm , password , sessionTimeout , timeoutId ; // If another token was previously generated, // cancel the timeout for its session. if ( timeoutId ) clearTimeout ( timeoutId ) ; timeoutId = setTimeout (", "del_tokens": "let algorithm , password , sessionTimeout ; setTimeout (", "commit_type": "add"}
{"commit_tokens": ["Add", "new", "methods", "for", "setting", "abbreviations"], "add_tokens": "'/*! leipzig.js v0.8.0' ,", "del_tokens": "'/*! leipzig.js v0.7.0' ,", "commit_type": "add"}
{"commit_tokens": ["allow", "resultSet", "close", "at", "any", "time"], "add_tokens": "value = this . buffer . toString ( encoding , this . offset , this . offset + length ) ; return this . lobFactoy . createLob ( new LobDescriptor ( type , locatorId , options ,", "del_tokens": "value = this . buffer . toString ( encoding , this . offset , this . offset + length ) ; return this . lobFactoy . createLob ( new LobDescriptor ( type , locatorId , options ,", "commit_type": "allow"}
{"commit_tokens": ["use", "the", "original", "toJSON", "on", "the", "model", "as", "the", "basis", "of", "transformation", "."], "add_tokens": "let model = this . toObject ( ) // Call the original toJSON method on the model. if ( original ) { model = original . call ( this ) }", "del_tokens": "const model = this . toObject ( ) // Call the original toJSON method on the model. if ( original ) { return original . call ( this ) }", "commit_type": "use"}
{"commit_tokens": ["made", "it", "so", "that", "added", "(", "val", "index", ")", "and", "removed", "(", "val", "index", ")", "methods", "can", "be", "created", "that", "will", "be", "called", "after", "DefineList", "is", "changed"], "add_tokens": "canEvent . dispatch . call ( this , { canEvent . dispatch . call ( this , how , [ newVal , index ] ) ; if ( this [ \"*\" ] && typeof this [ \"*\" ] . added === 'function' ) { this [ \"*\" ] . added ( newVal , index ) ; } if ( this [ \"*\" ] && typeof this [ \"*\" ] . removed === 'function' ) { this [ \"*\" ] . removed ( oldVal , index ) ; }", "del_tokens": "canEvent . dispatch . call ( this , { canEvent . dispatch . call ( this , how , [ newVal , index ] ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "callback", "support", "for", "ListLayout"], "add_tokens": "this . verbose = false ;", "del_tokens": "this . verbose = true ;", "commit_type": "add"}
{"commit_tokens": ["Use", "only", "features", "supported", "in", "ie8"], "add_tokens": "var foreach = require ( 'foreach' ) var keys = require ( 'object-keys' ) foreach ( keys ( opts . headers ) , function ( name ) { var headers = keys ( fullHeaders ) . map ( function ( name ) { keys ( fullHeaders , function ( name ) {", "del_tokens": "Object . keys ( opts . headers ) . forEach ( function ( name ) { var headers = Object . keys ( fullHeaders ) . map ( function ( name ) { Object . keys ( fullHeaders , function ( name ) {", "commit_type": "use"}
{"commit_tokens": ["added", "npm", "-", "bin", "and", "gulp", "-", "bin", "to", "default", "configs"], "add_tokens": "prefs . definePreference ( 'npm-bin' , 'string' , '' ) ; prefs . definePreference ( 'gulp-bin' , 'string' , '' ) ; 'flags' : '' , 'flags' : '' , 'flags' : '' ,", "del_tokens": "'flags' : '' , 'flags' : '' , 'flags' : '' ,", "commit_type": "add"}
{"commit_tokens": ["Add", "async", "/", "await", "support"], "add_tokens": "\"node\" : true , \"es6\" : true", "del_tokens": "\"node\" : true", "commit_type": "add"}
{"commit_tokens": ["Fix", "prop", "isColumn", "validation", "on", "Column", "grid", "component"], "add_tokens": "isLast : PropTypes . bool , isColumn : PropTypes . bool ,", "del_tokens": "isLast : PropTypes . bool", "commit_type": "fix"}
{"commit_tokens": ["Added", "module", "lockdown", "after", "render"], "add_tokens": "MUnit . _event ( self ) ;", "del_tokens": "MUnit . Event ( self ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "stick", "-", "to", "-", "top", "and", "stick", "-", "to", "-", "bottom", "behavior", "options", "."], "add_tokens": "* Theia Sticky Sidebar v1 .4 .0 var sidebarWidth = o . sidebar . outerWidth ( o . sidebar . css ( 'float' ) == 'none' ) ; if ( sidebarWidth + 50 > o . container . width ( ) ) { if ( o . options . sidebarBehavior == 'stick-to-top' ) { top = options . additionalMarginTop ; } if ( o . options . sidebarBehavior == 'stick-to-bottom' ) {", "del_tokens": "* Theia Sticky Sidebar v1 .3 .1 if ( o . sidebar . outerWidth ( true ) + 50 > o . container . width ( ) ) { if ( o . options . sidebarBehavior == 'legacy' ) { top = Math . max ( top , windowOffsetBottom - o . stickySidebar . outerHeight ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "dependency", "on", "underscore", ".", "js"], "add_tokens": "options . prefixes = concat . apply ( [ ] , options . prefixes ) ; //\"flatten\" one layer options . manifests = concat . apply ( [ ] , options . manifests ) ; //\"flatten\" one layer", "del_tokens": "var _ = require ( 'underscore' ) ; options . prefixes = _ ( options . prefixes ) . flatten ( ) ; options . manifests = _ ( options . manifests ) . flatten ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["made", "_", ".", "nextTick", "take", "context", "arg"], "add_tokens": "_ . nextTick ( function ( ) { } , this ) ;", "del_tokens": "_ . nextTick ( ( function ( ) { } ) . bind ( this ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "ability", "to", "send", "pipe", "fields", "to", "the", "browser"], "add_tokens": "var ret = { name : table . name , label : table . label , labelPlural : table . labelPlural } ; //Check for field that start with prefix CLIENT_ which means that the connector expects the value to be sent to client _ . map ( table , function ( value , key ) { if ( _ . startsWith ( key , \"CLIENT_\" ) ) { ret [ key ] = value ; } } ) ; return ret ;", "del_tokens": "return { name : table . name , label : table . label , labelPlural : table . labelPlural } ;", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "run", "script", "the", "default"], "add_tokens": ". command ( 'run' , 'run Lambda based microservice locally' , { isDefault : true } )", "del_tokens": ". command ( 'run' , 'run Lambda based microservice locally' )", "commit_type": "make"}
{"commit_tokens": ["Update", "url", "of", "target", "file", "of", "download", "testing"], "add_tokens": "wget ( 'https://raw.githubusercontent.com/ajhsu/node-wget-promise/master/assets/nodejs-logo.png' , { wget ( 'https://raw.githubusercontent.com/ajhsu/node-wget-promise/master/assets/nodejs-logo.png' ) . then ( function ( result ) {", "del_tokens": "wget ( 'https://raw.githubusercontent.com/ajhsu/node-wget-promise/master/test/nodejs-logo.png' , { wget ( 'https://raw.githubusercontent.com/ajhsu/node-wget-promise/master/test/nodejs-logo.png' ) . then ( function ( result ) {", "commit_type": "update"}
{"commit_tokens": ["Use", "equality", "function", "when", "comparing", "selected", "nodes"], "add_tokens": "var pos = - 1 ; for ( var i = 0 ; i < $scope . selectedNodes . length ; i ++ ) { if ( $scope . options . equality ( selectedNode , $scope . selectedNodes [ i ] ) ) { pos = i ; break ; } } if ( ! $scope . options . equality ( selectedNode , $scope . selectedNode ) ) {", "del_tokens": "var pos = $scope . selectedNodes . indexOf ( selectedNode ) ; if ( $scope . selectedNode != selectedNode ) {", "commit_type": "use"}
{"commit_tokens": ["added", ".", "remove", "method", "for", "steps"], "add_tokens": "const S_EXPECTS = ` // this is the beginning { example : { of : 'stringifying a simple object' , that : 'only has objects and strings' , } , } // this is the end`; assert . strictEqual ( S_EXPECTS , s_output ) ; } ) ; it ( '.remove()' , function ( ) { k_builder . remove ( 'preamble' ) ; var s_output = k_builder . produce ( { indent : '\\t' , } ) ; assert . strictEqual ( S_EXPECTS . replace ( / ^[^\\n]*\\n / , '' ) , s_output ) ;", "del_tokens": "assert . strictEqual ( ` // this is the beginning { example : { of : 'stringifying a simple object' , that : 'only has objects and strings' , } , } // this is the end`, s_output);", "commit_type": "add"}
{"commit_tokens": ["added", "ActiveRoute", "support", "for", "flexibility", "."], "add_tokens": "var lastHandlerInstance ; var lastParams ; if ( lastHandlerInstance ) { props . activeRoute = lastHandlerInstance ; props . ActiveRoute = lastHandler ; if ( lastParams ) { props . activeParams = lastParams ; } lastParams = info . params ; lastHandler = info . route . props . handler ; lastHandlerInstance = info . route . props . handler ( props ) ; if ( lastParams ) { props . activeParams = lastParams ; } props . ActiveRoute = lastHandler ; props . activeRoute = lastHandlerInstance ;", "del_tokens": "if ( lastHandler ) { props . activeRoute = lastHandler ; lastHandler = info . route . props . handler ( props ) ; props . activeRoute = lastHandler ;", "commit_type": "add"}
{"commit_tokens": ["Update", "resize", "-", "stream", ".", "js"], "add_tokens": "var evObj = document . createEvent ( 'HTMLEvents' ) ; evObj . initEvent ( 'resize' , true , true ) ; window . dispatchEvent ( evObj ) ;", "del_tokens": "window . dispatchEvent ( new Event ( 'resize' ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Removed", "some", "console", ".", "log", "statements", "which", "should", "not", "have", "been", "there", "."], "add_tokens": "}", "del_tokens": "console . log ( req . linz . get ( 'models' ) ) ; console . log ( req . params . model ) ; }", "commit_type": "remove"}
{"commit_tokens": ["Fix", "a", "bug", "on", "windows", "."], "add_tokens": "} , function ( event , path ) { callback ( item ) ; } ) ;", "del_tokens": "} , callback ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "logging", "decorator", "to", "use", "JSON", ".", "stringify"], "add_tokens": "var args , context , logged , res ; logged = ( function ( ) { switch ( typeof res ) { case 'object' : return JSON . stringify ( res ) ; case 'string' : return res ; default : return res . toString ( ) ; } } ) ( ) ;", "del_tokens": "var args , context , res ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "TypeError", "when", "rawBody", "returns", "err"], "add_tokens": "} , function ( err , string ) { if ( err ) { pxLogger . debug ( ` ${ err . limit } ${ err . encoding } ${ err . status } ${ err . type } ` ) ; return resolve ( ) ; } req . rawBody = string . toString ( ) ; resolve ( ) ; } ) ;", "del_tokens": "} , function ( err , string ) { req . rawBody = string . toString ( ) ; resolve ( ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "comments", "and", "update", "screener", "-", "runner", "version"], "add_tokens": "// add tunnel details only when sauce object does not exist or it exists but launchSauceConnect flag is false", "del_tokens": "// add tunnel details", "commit_type": "add"}
{"commit_tokens": ["Adding", "new", "tests", "for", "Matrix3"], "add_tokens": "const Q = - b / ( 2 * a ) ;", "del_tokens": "const Q = - b / ( 2 * a ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "<label", ">", "to", "use", "ID", "instead", "of", "Name", "fo", "radio", "input"], "add_tokens": "var labelTag = t ( \"<label for='{id}'>{label}</label>\" , input )", "del_tokens": "var labelTag = t ( \"<label for='{name}'>{label}</label>\" , input )", "commit_type": "fix"}
{"commit_tokens": ["fixed", "card", "dialog", "performance", "issue"], "add_tokens": "self . $dialog . find ( '.note-holder' ) . each ( function ( ) { let $holder = $ ( this ) ; let $tabs = self . $dialog . find ( 'ul.tabs' ) ; $holder . append ( ui . palette ( { colors : options . colors , colorNames : options . colorNames , eventName : $holder . data ( 'event' ) , } ) . render ( ) ) ; // in this tabs initialization the indicator width will not be set since the plugin does not work // with hidden elements (display: none); // as a workaround the indicator width is forced to 50% in the css $tabs . tabs ( { //swipeable: true } ) ; } ) ;", "del_tokens": "self . $dialog . find ( '.note-holder' ) . each ( function ( ) { let $holder = $ ( this ) ; let $tabs = self . $dialog . find ( 'ul.tabs' ) ; $holder . append ( ui . palette ( { colors : options . colors , colorNames : options . colorNames , eventName : $holder . data ( 'event' ) , } ) . render ( ) ) ; // in this tabs initialization the indicator width will not be set since the plugin does not work // with hidden elements (display: none); // as a workaround the indicator width is forced to 50% in the css $tabs . tabs ( { //swipeable: true } ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "metadata", "when", "storing", "state", "."], "add_tokens": "var meta = { authorizationURL : this . _oauth2 . _authorizeUrl , tokenURL : this . _oauth2 . _accessTokenUrl , clientID : this . _oauth2 . _clientId } function stored ( err , state ) { } try { var arity = this . _stateStore . store . length ; if ( arity == 3 ) { this . _stateStore . store ( req , meta , stored ) ; } else { // arity == 2 this . _stateStore . store ( req , stored ) ; } } catch ( ex ) { return this . error ( ex ) ; }", "del_tokens": "this . _stateStore . store ( req , function ( err , state ) { } ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "back", "the", "message", "component"], "add_tokens": "var __param = ( this && this . __param ) || function ( paramIndex , decorator ) { return function ( target , key ) { decorator ( target , key , paramIndex ) ; } } ; import { Component , Inject } from '@angular/core' ; import { MessageService } from './message.service' ; providers : [ MessageService ] , } ) , __param ( 0 , Inject ( MessageService ) )", "del_tokens": "import { Component } from '@angular/core' ; var _this = this ; this . messageSubscription = this . messageService . getMessage ( ) . subscribe ( function ( message ) { return _this . message = message ; } ) ; } )", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "empty", "local", "storage"], "add_tokens": "volume = window . localStorage . plyr_volume || config . volume ;", "del_tokens": "volume = window . localStorage . plyr_volume ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "the", "modPath", "variable", "everywhere!"], "add_tokens": "fallback : [ modPath ]", "del_tokens": "fallback : [ path . join ( __dirname , \"..\" , \"node_modules\" ) ]", "commit_type": "use"}
{"commit_tokens": ["Add", "the", "method", "type", "to", "the", "request", "options", "object"], "add_tokens": "options : options , method : method", "del_tokens": "options : options", "commit_type": "add"}
{"commit_tokens": ["Fix", "lifecycle", "calls", "when", "child", "view", "counts", "change", "post", "-", "render", "@lukemelia", "/", "@stefanpenner", "/", "@kagemusha"], "add_tokens": "// check again for childViews, since rendering may have added some hasChildViews = this . _childViews . length > 0 ; } ) ;", "del_tokens": "} ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "regex", "examples", "and", "test"], "add_tokens": "plugins : [ regex ( [ [ / ^[\\r\\n]+export.* / m , '' ] ] ) ]", "del_tokens": "plugins : [ regex ( [ [ / \\n{2,}export.*$ / , '' ] ] ) ]", "commit_type": "update"}
{"commit_tokens": ["Add", "stampit", "as", "static", "property", "of", "library"], "add_tokens": "import * as stampit from 'stampit' ; const Entropy = stampit . compose ( EventEmitter , { statics : { stampit , } ,", "del_tokens": "import { compose } from 'stampit' ; const Entropy = compose ( EventEmitter , {", "commit_type": "add"}
{"commit_tokens": ["Add", "callback", "argument", "to", "authorize", "for", "consistency", "."], "add_tokens": "Passport . prototype . authorize = function ( strategy , options , callback ) { return authenticate ( strategy , options , callback ) . bind ( this ) ;", "del_tokens": "Passport . prototype . authorize = function ( strategy , options ) { return authenticate ( strategy , options ) . bind ( this ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "resize", "tests", "for", "smaller", "and", "bigger", "size"], "add_tokens": "if ( h < this . height ) { // Remove the buffer part above the size this . buffer . splice ( h ) ; } else { // Add empty lines this . insertLines ( ( h - this . height ) , 0 ) ; } var newScrollRegionY = h - 1 ;", "del_tokens": "// Remove the buffer part above the size this . buffer . splice ( h ) ; var newScrollRegionY = h ; console . log ( args ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "to", "turn", "on", "partial", "iOS", "support", "in", "HTML5"], "add_tokens": "/ ** * Allows users to enable HTML audio on IOS , which is disabled by default . * Note this needs to be set before HTMLAudioPlugin is registered with SoundJS . * This is not recommend because of severe limitations on IOS devices including : * < li > it can only have one &lt;audio&gt; tag < / li > * < li > can not preload or autoplay the audio < / li > * < li > can not cache the audio < / li > * < li > can not play the audio except inside a user initiated event < / li > * * @ property enableIOS * @ type { Boolean } * @ default false * / s . enableIOS = false ; if ( createjs . Sound . BrowserDetect . isIOS && ! s . enableIOS ) {", "del_tokens": "if ( createjs . Sound . BrowserDetect . isIOS ) {", "commit_type": "add"}
{"commit_tokens": ["removed", "cluster", "piece", "per", "Nodejitsu", "s", "recommendation"], "add_tokens": "// Start the server... http . createServer ( app ) . listen ( app . get ( 'port' ) , function ( ) { console . log ( \"Express server holdin it down on port \" + app . get ( 'port' ) ) ; } )", "del_tokens": ", os = require ( 'os' ) if ( cluster . isMaster ) { var numCPUs = os . cpus ( ) . length // Fork workers. for ( var i = 0 ; i < numCPUs ; i ++ ) { cluster . fork ( ) } cluster . on ( 'death' , function ( worker ) { // We need to spin back up on death. cluster . fork ( ) console . log ( 'Worker ' + worker . pid + ' died. :(' ) ; } ) } else { http . createServer ( app ) . listen ( app . get ( 'port' ) , function ( ) { console . log ( \"Express server holdin it down on port \" + app . get ( 'port' ) ) ; } ) }", "commit_type": "remove"}
{"commit_tokens": ["fix", "url", "shorten", "for", "short", "urls"], "add_tokens": "if ( ! Ember . isBlank ( url ) && url . length > length ) {", "del_tokens": "if ( ! Ember . isBlank ( url ) ) {", "commit_type": "fix"}
{"commit_tokens": ["added", "opt", ".", "allowAll", "on", "crudify", "find"], "add_tokens": "* - allowAll - > if we receive a limit_disable = true , do not apply limitation // Allow limit: false, to fetch all entries if ( opt . allowAll ) { fieldValidator [ 'limit_disable' ] = dispatcher . validate ( 'BOOLEAN' ) . default ( false ) ; } if ( input . limit_disable === true ) { input . limit = null ; } if ( opt . maxLimit !== false && input . limit !== null ) {", "del_tokens": "if ( opt . maxLimit !== false ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "command", "line", "options", "for", "changing", "theme"], "add_tokens": ". option ( '--theme <path>' , 'Path to theme directory' ) generator : options . generator , theme : options . theme . option ( '-g, --generator <name>' , 'Change generator, defaults to site, availables are: ' + _ . keys ( generators ) . join ( \", \" ) ) . option ( '--theme <path>' , 'Path to theme directory' )", "del_tokens": "generator : options . generator", "commit_type": "add"}
{"commit_tokens": ["fixed", "bug", "in", "including", "escodegen", ".", "browser", ".", "min", ".", "js"], "add_tokens": "instCode = proxy . rewriteHTML ( origCode , \"http://foo.com\" , rewriteInlineScript , \"\" ) ; var headerStr = '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">' ; headerStr += instUtil . getInlinedScripts ( analyses , extraAppScripts , EXTRA_SCRIPTS_DIR , getJalangiRoot ( ) ) ; // just inject our header code var headIndex = instCode . indexOf ( \"<head>\" ) ; if ( headIndex === - 1 ) { headIndex = instCode . indexOf ( \"<HEAD>\" ) ; if ( headIndex === - 1 ) { console . error ( \"WARNING: could not find <head> element in HTML file \" + this . filename ) ; instCode = headerStr + instCode ; } else { instCode = instCode . slice ( 0 , headIndex + 6 ) + headerStr + instCode . slice ( headIndex + 6 ) ; } } else { instCode = instCode . slice ( 0 , headIndex + 6 ) + headerStr + instCode . slice ( headIndex + 6 ) ; }", "del_tokens": "instCode = proxy . rewriteHTML ( origCode , \"http://foo.com\" , rewriteInlineScript , instUtil . getInlinedScripts ( analyses , extraAppScripts , EXTRA_SCRIPTS_DIR , getJalangiRoot ( ) ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "arrow", "key", "navigation", "to", "the", "examples"], "add_tokens": "import ArrowKeysReact from \"arrow-keys-react\" ; constructor ( props ) { super ( props ) ; ArrowKeysReact . config ( { left : ( ) => { this . getKeyOffset ( - 1 ) ; } , right : ( ) => { this . getKeyOffset ( 1 ) ; } , up : ( ) => { this . getKeyOffset ( - 7 ) ; } , down : ( ) => { this . getKeyOffset ( 7 ) ; } } ) ; } getKeyOffset ( number ) { const e = document . activeElement ; let buttons = document . querySelectorAll ( \"button\" ) ; buttons . forEach ( ( el , i ) => { const newNodeKey = i + number ; if ( el == e ) { if ( newNodeKey <= buttons . length - 1 && newNodeKey >= 0 ) { console . log ( buttons . length , newNodeKey ) ; buttons [ newNodeKey ] . focus ( ) ; } else { buttons [ 0 ] . focus ( ) ; } } } ) ; } < Calendar { ... ArrowKeysReact . events } >", "del_tokens": "< Calendar >", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "sass", "files"], "add_tokens": "var importRe = / \\@import ([.\\s\\S]+?);?$ / g ;", "del_tokens": "var importRe = / \\@import ([.\\s\\S]+?); / g ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "change", "events", "from", "nested", "models"], "add_tokens": "nestedModel . bind ( 'all' , function ( evt ) { this . onNestedModelChange ( this , attr , evt ) ; onNestedModelChange : function ( model , attr , evt ) { var matchData = evt . match ( / ^change(:(.+))?$ / ) ; if ( matchData ) { // change event var childAttr = matchData [ 2 ] ; if ( childAttr ) { // 'change:nested' this . trigger ( 'change:' + attr + '.' + childAttr , this , { } ) ; } else { // 'change' this . trigger ( 'change:' + attr , this ) ; this . change ( ) ; }", "del_tokens": "nestedModel . bind ( 'change' , function ( model ) { this . onNestedModelChange ( model , model . collection , attr ) ; onNestedModelChange : function ( model , collection , attr ) { var changedAttrs = model . changedAttributes ( ) ; // TODO for some reason this is returning all attributes, not just changed ones for ( var childAttr in changedAttrs ) { this . trigger ( 'change:' + attr + '.' + childAttr , this , { } ) ; this . trigger ( 'change:' + attr , this ) ; this . change ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "and", "switched", "to", "package", ".", "json"], "add_tokens": "var version = JSON . parse ( fs . readFileSync ( cwd + '/package.json' ) ) . version ;", "del_tokens": "var version = JSON . parse ( fs . readFileSync ( cwd + '/version.json' ) ) . version ;", "commit_type": "add"}
{"commit_tokens": ["Add", "load", "-", "grunt", "-", "tasks", "and", "time", "-", "grunt", "dev", "plugins", "."], "add_tokens": "// Load any grunt plugins found in package.json. require ( 'load-grunt-tasks' ) ( grunt ) ; require ( 'time-grunt' ) ( grunt ) ;", "del_tokens": "require ( 'matchdep' ) . filterDev ( 'grunt-*' ) . forEach ( grunt . loadNpmTasks ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "callback", "management", "to", "the", "executable", "instance", "."], "add_tokens": "var registry = Object . create ( null ) /** @type {Arguments} */ this . results = null / ** * @ param { function ( Error , Buffer , Buffer ) } callback * / Executable . prototype . addCallback = function ( callback ) { if ( this . results ) { callback . apply ( null , this . results ) } else { this . callbacks . push ( callback ) } } if ( opt_callback ) executable . addCallback ( opt_callback )", "del_tokens": "var registry = { } if ( opt_callback ) { if ( executable . results ) { opt_callback . apply ( null , executable . results ) } else { executable . callbacks . push ( opt_callback ) } }", "commit_type": "move"}
{"commit_tokens": ["Added", "forgotten", "revision", "to", "spec"], "add_tokens": "element = $compile ( '<form><textarea id=\"foo\" ui-tinymce=\"{foo: \\'bar\\', setup: setupFooBar() }\" ng-model=\"foo\"></textarea></form>' ) ( scope ) ; scope . $apply ( ) ; it ( 'should execute the passed `setup` option' , function ( ) { scope . setupFooBar = jasmine . createSpy ( 'setupFooBar' ) ; compile ( ) ; runs ( function ( ) { expect ( scope . setupFooBar ) . toHaveBeenCalled ( ) ; } ) ; } ) ; } ) ;", "del_tokens": "element = $compile ( '<form><textarea id=\"foo\" ui-tinymce=\"{foo: \\'bar\\'}\" ng-model=\"foo\"></textarea></form>' ) ( scope ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "async", "processing", "of", "templates", "option", "."], "add_tokens": "callbacks = require ( 'when/callbacks' ) , // If template function accepts more than one argument, then handle 2nd // argument as asynchronous callback function if ( template . length > 1 ) template = callbacks . call . bind ( callbacks , template ) ; return all ( [ template ( post . content ) , template ( post . preview ) ] ) . then ( function ( contents ) { post . content = contents [ 0 ] ; post . preview = contents [ 1 ] + options . readMoreLink ( post ) ; poet . posts [ post . slug ] = post ; } ) ;", "del_tokens": "post . content = template ( post . content ) ; post . preview = template ( post . preview ) + options . readMoreLink ( post ) ; poet . posts [ post . slug ] = post ;", "commit_type": "add"}
{"commit_tokens": ["Add", "type", "to", "all", "primary", "and", "linked", "resources"], "add_tokens": "relations : relations , typeName : opts . type", "del_tokens": "relations : relations", "commit_type": "add"}
{"commit_tokens": ["Remove", "leave", "transition", "on", "TabPanel", "and", "cache", "tab", "ids"], "add_tokens": "get tabIds ( ) { // cache tab ids for better performance and to prevent errors with animations const ids = this . _tabIds || [ ] let diff = ids . length - this . getTabsCount ( ) while ( diff ++ < 0 ) { ids . push ( shortid . generate ( ) ) } this . _tabIds = ids return ids } const ids = this . tabIds", "del_tokens": "const ids = React . Children . map ( this . props . children , shortid . generate )", "commit_type": "remove"}
{"commit_tokens": ["adding", "jsonp", "support", "to", "remoteModel", "s", ".", "This", "gets", "around", "the", "CORS", "issues", "."], "add_tokens": "asyncTest ( \"remoteModel\" , function ( ) { url : \"http://search.twitter.com/search.json?q=tennis&callback=$jsonpCallback\" , isJSONPurl : true , function callback ( oldValue , newValue , prop ) { ok ( test . remoteModel . query , \"remoteModel was modified to have a count property\" ) ;", "del_tokens": "asyncTest ( \"remoteModel\" , function ( ) { //This test depends on a local server serving remoteModel.json url : \"http://localhost:8080/modeljs/test/remoteModel.json\" , function callback ( ) { ok ( test . remoteModel . count , \"remoteModel was modified to have a count property\" ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "Wi", "-", "Fi", "to", "support", "TCP", "client", "or", "server"], "add_tokens": "controller : \"MKR1000\" , // \"WIFI_SHIELD_101\", WIFI_SHIELD\", \"MKR1000\", \"ESP8266\" //localIp: \"192.168.0.6\", //subnetMask: \"255.255.255.0\", //gatewayIp: \"0.0.0.0\", //serverIp: \"192.168.0.1\",", "del_tokens": "controller : \"WIFI_SHIELD_101\" , // \"WIFI_SHIELD\", \"MRK1000\" localIp : \"192.168.0.6\" ,", "commit_type": "update"}
{"commit_tokens": ["Moved", "oxd", "port", "to", "the", "top", "."], "add_tokens": "exports . oxd_port = 8099 ;", "del_tokens": "exports . oxd_port = 8099 ;", "commit_type": "move"}
{"commit_tokens": ["Add", "test", "for", "updating", "cluster", "radius"], "add_tokens": "let cluster = map . sources [ src_name ] ; expect ( cluster . getDistance ( ) ) . toBe ( 50 ) ; store . dispatch ( MapActions . setClusterRadius ( src_name , 10 ) ) ; cluster = map . sources [ src_name ] ; expect ( cluster . getDistance ( ) ) . toBe ( 10 ) ;", "del_tokens": "const cluster = map . sources [ src_name ] ;", "commit_type": "add"}
{"commit_tokens": ["Update", "the", "log", "class", "to", "use", "state", "instead", "of", "the", "impromptu", "instance", "."], "add_tokens": "this . log = new Impromptu . Log ( this . state )", "del_tokens": "this . log = new Impromptu . Log ( this )", "commit_type": "update"}
{"commit_tokens": ["move", "add", "-", "group", "into", "utils"], "add_tokens": "files = utils . addGroup ( group , structure , options ) ;", "del_tokens": "var addGroup = require ( './lib/add-group' ) ; files = addGroup . createFiles ( group , structure , options ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "regression", "when", "setting", "empty", "cookie", "value"], "add_tokens": "if ( value && ! fieldContentRegExp . test ( value ) ) {", "del_tokens": "if ( ! fieldContentRegExp . test ( value ) ) {", "commit_type": "fix"}
{"commit_tokens": ["remove", "proxy", "use", "to", "support", "ios9"], "add_tokens": "const methodNames = ( Object . getOwnPropertyNames ( CameraRollRNPhotosFramework . prototype ) . filter ( method => typeof method === 'function' ) . filter ( method => method !== 'constructor' && method !== 'cleanCache' ) ) ; methodNames . forEach ( methodName => { const originalMethod = this [ methodName ] ; this [ methodName ] = function ( ... args ) { return cleanCachePromise . then ( ( ) => originalMethod . apply ( this , args ) ) ; } } ) ; export default new CameraRollRNPhotosFramework ( ) ; ;", "del_tokens": "export default new Proxy ( new CameraRollRNPhotosFramework ( ) , { get : ( target , propKey , receiver ) => { const origMethod = target [ propKey ] ; return function ( ... args ) { return cleanCachePromise . then ( ( ) => origMethod . apply ( this , args ) ) ; } } } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "error", "setting", "compute", "type", "value", "to", "null", "or", "undefined"], "add_tokens": "if ( newValue && newValue . isComputed ) {", "del_tokens": "if ( newValue . isComputed ) {", "commit_type": "fix"}
{"commit_tokens": ["Improve", "warning", "messages", "on", "missing", "attributes"], "add_tokens": "document . querySelector ( '[role=banner]' ) . dataset . drawerVisible = drawerVisible console . warn ( ` ` ) console . warn ( ` ` )", "del_tokens": "const BANNER_SELECTOR = '[role=banner]' const bannerNode = document . querySelector ( BANNER_SELECTOR ) if ( ! bannerNode ) { console . warn ( ` ${ BANNER_SELECTOR } } else { bannerNode . dataset . drawerVisible = drawerVisible } console . warn ( ` ${ APP_SELECTOR } console . warn ( ` ${ APP_SELECTOR }", "commit_type": "improve"}
{"commit_tokens": ["Add", "passed", "vs", "total", "test", "count", "on", "the", "homepage"], "add_tokens": "t . result || 'pending' ) ;", "del_tokens": "t . result , t . details ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "some", "docs", "and", "point", "gql", "at", "the", "right", "place"], "add_tokens": "export const gql = dropLowest * A simple non operation ` ` function that can make writing and reading * A simple non operation ` ` function that can make writing and reading * A simple non operation ` ` function that can make writing and reading", "del_tokens": "export const gql = dedent * A simple non operation preWork function that can make writing and reading * A simple non operation preWork function that can make writing and reading * A simple non operation postWork function that can make writing and reading", "commit_type": "fix"}
{"commit_tokens": ["changed", ":", "belonging", "to", "previous", "commit"], "add_tokens": "var Promise = require ( 'lie' ) ; } ) ;", "del_tokens": "var Promise = require ( 'q' ) . Promise ; } ) ;", "commit_type": "change"}
{"commit_tokens": ["Update", "draggable", "and", "on", "-", "swipe", "tests"], "add_tokens": "expect ( instance . pointer . options . axis ) . to . equal ( 'x' ) ;", "del_tokens": "expect ( instance . pointer . axis ) . to . equal ( 'x' ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "restoring", "last", "deleted", "editable", "option", "in", "multiple", "mode"], "add_tokens": "if ( scope . backspaceFocus && scope . output && ( ! multiple || scope . output . length ) ) { //prevent restoring last deleted option", "del_tokens": "if ( scope . backspaceFocus && scope . output ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "self", "loops", "in", "layout"], "add_tokens": "e . dagre = { points : [ ] , source : nodeMap [ source ] , target : nodeMap [ target ] , } ; edgeMap [ id ] = e . dagre ;", "del_tokens": "edgeMap [ id ] = e . dagre = { points : [ ] , source : nodeMap [ source ] , target : nodeMap [ target ] , } ;", "commit_type": "fix"}
{"commit_tokens": ["Used", "path", ".", "resolve", "()", "for", "the", "appPath"], "add_tokens": "this . _appPath = path . resolve ( appPath ) ;", "del_tokens": "this . _appPath = appPath ;", "commit_type": "use"}
{"commit_tokens": ["changing", "to", "remembering", "window", "state", "by", "default"], "add_tokens": "const windowStateKeeper = require ( 'electron-window-state' ) ; rememberWindowState : true , autoMaximize : false , // If necessary, restore previous state if ( this . opts . rememberWindowState ) { this . setupRememberWindowState ( ) ; } // Actually create the new Browser window // If necessary, set the window state manager to manage the current // browser window // Keep track of all windows ipc . on ( 'mount:ready' , ev => { ipc . on ( '_log' , ( ev , payload ) => { // Open the DevTools if env variable set if ( process . env . ELMOED_DEBUGGING_DEV_TOOLS ) { browserWindow . webContents . openDevTools ( ) ; } // Prevent all navigation, instead opening links in browser", "del_tokens": "rememberWindowState : false , autoMaximize : true , const windowStateKeeper = require ( 'electron-window-state' ) ; // Restore previous state this . setupRememberWindowState ( ) ; ipc . on ( 'mount:ready' , ( event ) => { ipc . on ( '_log' , ( event , payload ) => { // Open the DevTools. //browserWindow.webContents.openDevTools(); // Prevent all navigation // console.log(`ipc channel: ${path}:${subchannel}`);", "commit_type": "change"}
{"commit_tokens": ["fixing", "incorrect", "ascender", "height", ";", "also", "adding", "a", "capHeight"], "add_tokens": "let text = ` a qUick Brown fox // text = 'one line some st' //cap height context . fillStyle = 'yellow' context . fillRect ( 110 , - layout . height + layout . ascender , 18 , layout . capHeight ) context . fillRect ( 140 , - layout . height , 36 , layout . baseline ) [ 'green' , 'descender' ] , [ 'yellow' , 'cap height' ]", "del_tokens": "let text = ` a quick brown fox context . fillRect ( 120 , - layout . height , 36 , layout . baseline ) [ 'green' , 'descender' ]", "commit_type": "fix"}
{"commit_tokens": ["fixed", "a", "bug", "in", "get", "(", "fn", ")"], "add_tokens": "return ( items . length ) ? items [ 0 ] : false ;", "del_tokens": "return ( items . length ) ? items . length [ 0 ] : false ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "$renderIf", "for", "undefined", "case", "."], "add_tokens": "//if (props && typeof props.$renderIf !== 'undefined') { if ( props && typeof props === 'object' && props . hasOwnProperty ( '$renderIf' ) ) {", "del_tokens": "if ( props && typeof props . $renderIf !== 'undefined' ) {", "commit_type": "fix"}
{"commit_tokens": ["remove", "setBounds", "from", "public", "API"], "add_tokens": "vect . _setBounds ( 0 , index + 1 ) . set ( index , value ) vect . _setBounds ( 0 , oldLength + values . length ) ; return this . _setBounds ( 0 , - 1 ) ; vect . _setBounds ( - values . length ) ; return this . _setBounds ( 1 ) ; return maxLength > merged . length ? merged . _setBounds ( 0 , maxLength ) : merged ; setLength ( length ) { return this . _setBounds ( 0 , length ) ; } _setBounds ( begin , end ) { sliceSequence . toVector = ( ) => sequence . _setBounds (", "del_tokens": "vect . setBounds ( 0 , index + 1 ) . set ( index , value ) vect . setBounds ( 0 , oldLength + values . length ) ; return this . setBounds ( 0 , - 1 ) ; vect . setBounds ( - values . length ) ; return this . setBounds ( 1 ) ; return maxLength > merged . length ? merged . setBounds ( 0 , maxLength ) : merged ; setBounds ( begin , end ) { setLength ( length ) { return this . setBounds ( 0 , length ) ; } sliceSequence . toVector = ( ) => sequence . setBounds (", "commit_type": "remove"}
{"commit_tokens": ["Removed", "the", "dependency", "on", "Node", "Security", "Platform"], "add_tokens": "gulp . task ( 'deps:security' , ( ) => _exec ( 'npm' , [ 'audit' ] ) ) ; gulp . task ( 'fix:js' , ( ) => gulp . src ( [ '*.js' , 'bin/*.js' , 'example/*.js' , 'lib/**/*.js' , 'test/**/*.js' ] , { base : '.' } ) gulp . task ( 'fix:security' , ( ) => _exec ( 'npm' , [ 'audit' , 'fix' ] ) ) ; gulp . task ( 'fix' , gulp . series ( 'fix:js' , 'fix:security' ) ) ;", "del_tokens": "gulp . task ( 'deps:security' , ( ) => _exec ( 'node_modules/.bin/nsp' , [ 'check' ] ) ) ; gulp . task ( 'fix' , ( ) => gulp . src ( [ '*.js' , 'bin/*.js' , 'example/*.js' , 'lib/**/*.js' , 'test/**/*.js' ] , { base : '.' } )", "commit_type": "remove"}
{"commit_tokens": ["Fix", "IE", "11", "fullscreen", "change", "bug"], "add_tokens": "if ( browserProperties [ prop ] [ i ] in testElement || browserProperties [ prop ] [ i ] in document || 'on' + browserProperties [ prop ] [ i ] . toLowerCase ( ) in document ) {", "del_tokens": "if ( browserProperties [ prop ] [ i ] in testElement || browserProperties [ prop ] [ i ] in document || 'on' + browserProperties [ prop ] [ i ] in document ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "example", "votebot", "by", "trigger"], "add_tokens": "block : props . head_block_number , commited_block : props . last_irreversible_block_num", "del_tokens": "block : lastCommitedBlock", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "variable", "naming", "issue"], "add_tokens": "* Get an array of rules . const rules = __rules__ ; return rules . slice ( 0 ) ;", "del_tokens": "* Get an array of Rules . const Rules = __rules__ ; return Rules . slice ( 0 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "mocha", ".", "opts", "files", "to", "be", "loaded", "from", "config"], "add_tokens": "/** Individually-specified file */ if ( stats . isFile ( ) ) { /** This is an options file, not a spec */ if ( / [\\\\/]mocha.opts$ / . test ( testPath ) ) opts . push ( testPath ) ; else specs . push ( testPath ) ; }", "del_tokens": "/** Individually-specified spec file */ if ( stats . isFile ( ) ) specs . push ( testPath ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "timezone", "validation", "to", "allow", "timezones", "with", "non", "-", "Region", "/", "City", "format", "."], "add_tokens": "import moment from 'moment-timezone' ; const validTimezones = moment . tz . names ( ) ;", "del_tokens": "import IANATimezoneData from 'iana-tz-data' ; const validTimezones = [ ] ; const regions = Object . keys ( IANATimezoneData . zoneData ) ; regions . forEach ( ( region ) => { Object . keys ( IANATimezoneData . zoneData [ region ] ) . forEach ( ( city ) => { validTimezones . push ( ` ${ region } ${ city } ` ) ; } ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "fucked", "up", "auto", "-", "indentation"], "add_tokens": "fs = require ( 'fs' ) ; 'meta' , 'img' , 'link' , 'br' , 'hr' , 'input' , 'area' , 'base'", "del_tokens": "fs = require ( 'fs' ) ; 'meta' , 'img' , 'link' , 'br' , 'hr' , 'input' , 'area' , 'base'", "commit_type": "fix"}
{"commit_tokens": ["Remove", "smooth", "-", "scroll", ".", "jquery", ".", "json", ".", "No", "longer", "used", "."], "add_tokens": "bower = grunt . file . readJSON ( bowerFile ) ; [ 'main' , 'dependencies' , 'keywords' ] . forEach ( function ( el ) {", "del_tokens": "bower = grunt . file . readJSON ( bowerFile ) , jqConfigFile = pkgBasename + '.jquery.json' , jqConfig = grunt . file . readJSON ( jqConfigFile ) ; [ 'main' , 'version' , 'dependencies' , 'keywords' ] . forEach ( function ( el ) { jqConfig [ el ] = pkg [ el ] ; [ 'author' , 'repository' , 'homepage' , 'docs' , 'bugs' , 'demo' , 'licenses' ] . forEach ( function ( el ) { jqConfig [ el ] = pkg [ el ] ; } ) ; jqConfig . keywords . shift ( ) ; jqConfig . name = pkgBasename ; while ( / jquery / i . test ( jqConfig . keywords [ 0 ] ) ) { jqConfig . keywords . shift ( ) ; } grunt . file . write ( jqConfigFile , JSON . stringify ( jqConfig , null , 2 ) + '\\n' ) ; grunt . log . writeln ( 'File \"' + jqConfigFile + '\" updated.\"' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "isFormValid", "(", "remove", "old", "links", "to", "lodash", ")", "."], "add_tokens": "return t . reduce ( function ( acc , obj ) { return acc && ! obj . length ; } , true , formErrors ) ;", "del_tokens": "if ( ! _ . isPlainObject ( formErrors ) ) return true ; var getNotNulls = _ . compose ( _ . compact , _ . values ) ; return getNotNulls ( formErrors ) . length === 0 ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "other", "paths", "for", "ipfs", "binary"], "add_tokens": "ipfs_bin = exec ( 'which ipfs' ) . output . split ( \"\\n\" ) [ 0 ] if ( ipfs_bin === 'ipfs not found' ) { console . log ( '=== WARNING: IPFS not in an executable path. Guessing ~/go/bin/ipfs for path' ) ipfs_bin = \"~/go/bin/ipfs\" ; } cmd = ipfs_bin + \" add -r \" + build_dir ;", "del_tokens": "ipfs_path = \"~/go/bin\" ; cmd = ipfs_path + \"/ipfs add -r \" + build_dir ;", "commit_type": "add"}
{"commit_tokens": ["Use", "partials", "for", "the", "top", "menus", "and", "the", "footer", "credits", "."], "add_tokens": "layoutdir : 'site/layouts' , partials : 'site/partials/*.html'", "del_tokens": "layoutdir : 'site/layouts'", "commit_type": "use"}
{"commit_tokens": ["Fixed", "bug", "when", "node", "id", "matches", "prototype", "property"], "add_tokens": "var nodes = typeof Object . create === 'function' ? Object . create ( null ) : { } , if ( callback ( nodes [ node ] ) ) { return ; // client doesn't want to proceed. return.", "del_tokens": "var nodes = { } , if ( nodes . hasOwnProperty ( node ) ) { if ( callback ( nodes [ node ] ) ) { return ; // client doesn't want to proceed. return. }", "commit_type": "fix"}
{"commit_tokens": ["allow", "path", "to", "a", "verbfile", "to", "be", "defined", "with", "-", "s"], "add_tokens": "src : argv . s || argv . src , if ( command . src ) { command . src = path . resolve ( command . src ) ; } if ( command . src ) { try { require ( command . src ) ( verb ) ; } catch ( err ) { require ( command . src ) ; } }", "del_tokens": "", "commit_type": "allow"}
{"commit_tokens": ["Add", "default", "weight", "in", "preLayout"], "add_tokens": "defaultStr ( attrs , \"label\" , u . id ( ) . toString ( ) ) ; defaultInt ( attrs , \"width\" , 0 ) ; defaultInt ( attrs , \"height\" , 0 ) ; defaultInt ( attrs , \"weight\" , 1 ) ; defaultVal ( attrs , \"color\" , \"#FFF\" ) ; defaultVal ( attrs , \"fontname\" , \"Times New Roman\" ) ; defaultInt ( attrs , \"fontsize\" , 14 ) ;", "del_tokens": "attrs . label = \"label\" in attrs ? attrs . label . toString ( ) : u . id ( ) . toString ( ) ; attrs . width = \"width\" in attrs ? parseInt ( attrs . width ) : 0 ; attrs . height = \"height\" in attrs ? parseInt ( attrs . height ) : 0 ; if ( ! ( \"color\" in attrs ) ) { attrs . color = \"#FFF\" ; } if ( ! ( \"fontname\" in attrs ) ) { attrs . fontname = \"Times New Roman\" ; } attrs . fontsize = \"fontsize\" in attrs ? parseInt ( attrs . fontsize ) : 14 ;", "commit_type": "add"}
{"commit_tokens": ["Update", "seed", "to", "use", "local", "config", "."], "add_tokens": "var config = require ( '../api/config.local' ) ; mongoose . connect ( config . mongo . URI ) ;", "del_tokens": "mongoose . connect ( 'mongodb://localhost/rest_hapi' ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "colleagues", ".", "js", "."], "add_tokens": "dispatcher . dispatch ( 'GET /conduit/health' , 'conduit' )", "del_tokens": "dispatcher . dispatch ( 'GET /health' , 'conduit' )", "commit_type": "fix"}
{"commit_tokens": ["ADD", "webpack", "for", "compile", "browser", "script"], "add_tokens": "const fontDetect = require ( './library/detector' ) const fontConvert = require ( './library/converter' ) const syllBreak = require ( './library/syllBreak' ) const spellingFix = require ( './library/spellingCheck' )", "del_tokens": "var fontDetect = require ( './library/detector' ) ; var fontConvert = require ( './library/converter' ) ; var syllBreak = require ( './library/syllBreak' ) ; var spellingFix = require ( './library/spellingCheck' )", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "detecting", "imported", "components"], "add_tokens": "function getName ( node ) { if ( node . type === 'Property' ) { const key = node . key || node . argument ; return key . type === 'Identifier' ? key . name : key . value ; } else if ( node . type === 'Identifier' ) { return node . name ; } const nodeName = getName ( node ) ; const propName = getName ( node ) ; ImportDeclaration : function ( node ) { if ( node . source . value === 'react-native' ) { node . specifiers . forEach ( ( importSpecifier ) => { if ( importSpecifier . type === 'ImportSpecifier' ) { reactComponents = reactComponents . concat ( importSpecifier . imported ) ; } } ) ; } } ,", "del_tokens": "function getKeyValue ( node ) { const key = node . key || node . argument ; return key . type === 'Identifier' ? key . name : key . value ; const nodeName = getKeyValue ( node ) ; const propName = getKeyValue ( node ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "a", "bug", "in", "the", "icon", "JSON"], "add_tokens": "const last = svgFiles . length ; svgFiles . sort ( ) ; const svgPromises = svgFiles . map ( async ( filepath , mapIndex ) => { //eslint-disable-line iconJSON += ` ${ path . basename ( filepath , '.svg' ) } ${ svgDData . exec ( dataOptimized . data ) [ 1 ] } ${ mapIndex + 1 === ( last ) ? '' : ',' } \\n ` ;", "del_tokens": "const svgPromises = svgFiles . map ( async filepath => { //eslint-disable-line iconJSON += ` ${ path . basename ( filepath , '.svg' ) } ${ svgDData . exec ( dataOptimized . data ) [ 1 ] } \\n ` ;", "commit_type": "fix"}
{"commit_tokens": ["adding", "Skype", "to", "the", "example", "."], "add_tokens": "'webchat' : process . env . DASHBOT_API_KEY_GENERIC , 'skype' : process . env . DASHBOT_API_KEY_GENERIC", "del_tokens": "'webchat' : process . env . DASHBOT_API_KEY_GENERIC", "commit_type": "add"}
{"commit_tokens": ["Added", "requirejs", "support", "doing", "crazy", "thing", "with", "it"], "add_tokens": "var Neon = { } ; Neon . Interface = function Interface ( nameOrNameSpace , name ) { Neon . Module = function Module ( nameOrNameSpace , name ) { Neon . Class = function Class ( classNameOrNameSpace , className ) { if ( typeof define === 'function' ) { define ( function ( ) { return Neon ; } ) ; } else { if ( typeof process !== 'undefined' ) { global . Neon = Neon ; } else { global . Class = Neon . Class ; global . Module = Neon . Module ; global . Interface = Neon . Interface ; } } } ( typeof window !== 'undefined' ? window : ( typeof exports !== 'undefined' ? exports : null ) ) ) ;", "del_tokens": "global . Interface = function Interface ( nameOrNameSpace , name ) { global . Module = function Module ( nameOrNameSpace , name ) { global . Class = function Class ( classNameOrNameSpace , className ) { } ( typeof window === 'undefined' ? exports : window ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "assetURL", "to", "minicartjs", ".", "com"], "add_tokens": "assetURL : 'http://www.minicartjs.com/build/' ,", "del_tokens": "assetURL : 'https://minicart.paypal-labs.com/build/' ,", "commit_type": "update"}
{"commit_tokens": ["added", "string", ".", "toArray", "()"], "add_tokens": "* @ return { String } The result string .", "del_tokens": "* @ return { String } The result array .", "commit_type": "add"}
{"commit_tokens": ["fixed", "error", "on", "Casper#captureSelector", "and", "Casper#fill"], "add_tokens": "return this . capture ( targetFile , this . evaluate ( function ( ) { this . evaluate ( function ( ) {", "del_tokens": "return this . capture ( targetFile , self . evaluate ( function ( ) { self . evaluate ( function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["Changed", "test", "back", "to", "mine", "vs", "substack", "s", "because", "results", "are", "not", "always", "exactly", "the", "same", "in", "every", "browser"], "add_tokens": "] / * , expected : require ( \"./expected.json\" ) * /", "del_tokens": "] , expected : require ( \"./expected.json\" )", "commit_type": "change"}
{"commit_tokens": ["removed", "tempUserlist", "from", "clone", "except", "--", "needed", "for", "correctness", "in", "a", "rare", "case"], "add_tokens": "'server'", "del_tokens": "'server' , 'tempUserlist'", "commit_type": "remove"}
{"commit_tokens": ["fix", "bugs", "in", "send", "and", "recv", "of", "messages", "in", "nodejs", "client"], "add_tokens": "if ( client ) { client . send ( ) ; client . close ( ) ; } messenger . send ( ) ; setImmediate ( untilSendComplete , message , callback ) ; var messages = messenger . receive ( 50 ) ; setImmediate ( check_for_messages ) ;", "del_tokens": "if ( client ) client . close ( ) ; process . setImmediate ( untilSendComplete , message , callback ) ; var messages = messenger . receive ( 1024 ) ; setTimeout ( check_for_messages , 1024 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "redundant", "pathfinding", "from", "navmesh", "."], "add_tokens": "/ ** * Computes path from source to target , using sides and centers of the edges * between adjacent polygons . source and target are Points and polys should * be the final partitioned map . * @ param { Point } source - The start location for the search . * @ param { Point } target - The target location for the search . * @ return { ? Array . < Point > } - A series of points representing the path from * the source to the target . If a path is not found , ` ` is returned . * / / ** * Holds the \"neighbor\" relationship of Poly objects in the partition * using the Poly 's themselves as keys, and an array of Poly' s as * values , where the Polys in the array are neighbors of the Poly * that was the key . * @ typedef AdjacencyGrid * @ type { Object . < Poly , Array < Poly >> } * / / ** * Given an array of Poly objects , find all neighboring polygons for * each polygon . * @ private * @ param { Array . < Poly > } polys - The array of polys to find neighbors * among . * @ return { AdjacencyGrid } - The \"neighbor\" relationships . * /", "del_tokens": "// Copied from NavMesh.prototype.aStar. // Copied from NavMes.prototype.generateAdjacencyGrid.", "commit_type": "remove"}
{"commit_tokens": ["Add", "notes", "about", "subscription", "weaknesses"], "add_tokens": "// Note that this will clobber any existing subscription on this channel. // For our purposes, this is okay (if another request comes in for the same // UUID and ganks the subscription, that's weird but fine), but in another // circumstance you would probably want a more robust solution. // Note that this will remove ANY existing subscription on this channel. // If another request has made a subsequent subscription to this channel, // this unsubscribe will remove it. Once again, for our purposes, this is // okay (if another request comes in for the same UUID and gets // unsubscribed by the first one timing out, that's the edge case coming // back to bite you), but in another circumstance you would probably want a // more robust solution. dbSubscriber . unsubscribe ( channel , function ( err ) { delete subscriptionCbs [ channel ] ; return cb ( err ) ; } ) ; if ( subscriptionCbs [ channel ] ) { //This should always be true, but be safe", "del_tokens": "dbSubscriber . unsubscribe ( channel , cb ) ; delete subscriptionCbs [ channel ] ; if ( subscriptionCbs [ channel ] ) { //if not, I don't know, some problem", "commit_type": "add"}
{"commit_tokens": ["Added", "error", "log", "function", "."], "add_tokens": "': ' + msg ) ; / ** * Log application error . * * @ param { string } msg Error message . * @ param { external : Error } [ err ] Optional error object . * / exports . error = function ( msg , err ) { console . error ( ( new Date ( ) ) . toISOString ( ) + ' ' + process . pid + ': ' + msg + ( err ? ': [' + err . name + ']: ' + err . message : '' ) ) ; } ;", "del_tokens": "': ' + msg ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "export", "for", "package", "managers"], "add_tokens": "// Generated by CoffeeScript 1.10.0 var _containersControllers , _windowEventsHandlerBinded , _windowInViewItems , addWindowInViewItem , angularInviewModule , bindWindowEvents , checkInView , debounce , getBoundingClientRect , getOffsetFromPercentage , getViewportHeight , offsetIsPercentage , removeWindowInViewItem , trackInViewContainer , triggerInViewCallback , unbindWindowEvents , untrackInViewContainer , windowCheckInView , windowEventsHandler , angularInviewModule = angular . module ( 'angular-inview' , [ ] ) . directive ( 'inView' , [ if ( typeof define === 'function' && define . amd ) { define ( [ 'angular' , 'inview' ] , angularInviewModule ) ; } else if ( typeof module !== 'undefined' && module && module . exports ) { module . exports = angularInviewModule ; }", "del_tokens": "// Generated by CoffeeScript 1.9.3 var _containersControllers , _windowEventsHandlerBinded , _windowInViewItems , addWindowInViewItem , bindWindowEvents , checkInView , debounce , getBoundingClientRect , getOffsetFromPercentage , getViewportHeight , offsetIsPercentage , removeWindowInViewItem , trackInViewContainer , triggerInViewCallback , unbindWindowEvents , untrackInViewContainer , windowCheckInView , windowEventsHandler , angular . module ( 'angular-inview' , [ ] ) . directive ( 'inView' , [", "commit_type": "add"}
{"commit_tokens": ["Upgraded", "to", "module", "-", "keys@2"], "add_tokens": "const instance = require . moduleKeys . unboxStrict ( const instance = require . moduleKeys . unboxStrict ( const mintCsvFragment = require . moduleKeys . unbox (", "del_tokens": "const instance = require . keys . unboxStrict ( const instance = require . keys . unboxStrict ( const mintCsvFragment = require . keys . unbox (", "commit_type": "upgrade"}
{"commit_tokens": ["Fix", "to", "support", "extra", "args", "as", "described", "in", "the", "docs"], "add_tokens": "exports . parse = function ( expr , globals , formatters ) { var extraArgs = slice . call ( arguments , 3 ) ; var extraArgs = slice . call ( arguments , 3 ) ; // Add _value_ as the first extra argument return exports . parse . apply ( exports , [ expr , globals , formatters , valueProperty ] . concat ( extraArgs ) ) ;", "del_tokens": "exports . parse = function ( expr , globals , formatters , extraArgs ) { if ( ! Array . isArray ( extraArgs ) ) extraArgs = [ ] ; if ( ! Array . isArray ( extraArgs ) ) extraArgs = [ ] ; // Add _value_ as the first extra argument extraArgs . unshift ( valueProperty ) ; return exports . parse ( expr , globals , formatters , extraArgs ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "stream", "as", "batch", "mode", "for", "kafka", "consumer", "stream"], "add_tokens": "this . streamAsBatch = options . streamAsBatch || false ; if ( self . streamAsBatch ) { self . push ( messages ) ; } else { for ( var i = 0 ; i < messages . length ; i ++ ) { self . messages . push ( messages [ i ] ) ; } // Now that we have added them all the inner messages buffer, // we can just push the most recent one self . push ( self . messages . shift ( ) ) ; if ( self . streamAsBatch ) { self . push ( messages ) ; } else { for ( var i = 0 ; i < messages . length ; i ++ ) { self . messages . push ( messages [ i ] . value ) ; } // Now that we have added them all the inner messages buffer, // we can just push the most recent one self . push ( self . messages . shift ( ) ) ;", "del_tokens": "for ( var i = 0 ; i < messages . length ; i ++ ) { self . messages . push ( messages [ i ] ) ; // Now that we have added them all the inner messages buffer, // we can just push the most recent one self . push ( self . messages . shift ( ) ) ; for ( var i = 0 ; i < messages . length ; i ++ ) { self . messages . push ( messages [ i ] . value ) ; // Now that we have added them all the inner messages buffer, // we can just push the most recent one self . push ( self . messages . shift ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "sub", "-", "schema", "to", "example"], "add_tokens": "var Schema = require ( './' ) ; function verb ( config , options ) { var schema = new Schema ( options ) ; schema . field ( 'toc' , [ 'boolean' , 'object' ] , { normalize : function ( val , key , config , schema ) { if ( typeof val === 'boolean' ) { val = { render : val } ; } return val ; } } ) ; return schema ; } . field ( 'verb' , [ 'object' ] , { normalize : function ( val , key , config , schema ) { if ( typeof val !== 'undefined' ) { var schema = verb ( schema . options ) ; val = config [ key ] = schema . normalize ( val ) ; console . log ( val ) return val ; } } } ) var res = schema . normalize ( pkg ) ; // console.log(res); // console.log(schema.warnings);", "del_tokens": "var Schema = require ( 'map-schema' ) ; console . log ( schema . normalize ( pkg ) ) ; console . log ( schema . errors ) ;", "commit_type": "add"}
{"commit_tokens": ["removed", "annoying", "time", "update", "messages"], "add_tokens": "self . websocket . close ( ) ; self . loggedIn = true ; if ( cached === toCache ) { this . sendData ( \"onopen\" ) ; this . websocket . sendData = function ( why ) {", "del_tokens": "var time = Date . now ( ) ; self . loggedIn = true ; console . log ( \"Took \" + ( Date . now ( ) - time ) + \" ms to login!\" ) ; var time = Date . now ( ) ; console . log ( \"Took \" + ( Date . now ( ) - time ) + \" ms to get READY!\" ) ; time = Date . now ( ) ; if ( cached >= toCache ) { console . log ( \"Took \" + ( Date . now ( ) - time ) + \" ms to prepare!\" ) ; this . sendData ( ) ; console . log ( \"Took \" + ( Date . now ( ) - time ) + \" ms to open WS connection!\" ) ; time = Date . now ( ) ; this . websocket . sendData = function ( ) { time = Date . now ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "new", "test", "for", "commit", "1c22f69b", "(", "bug", "fix", "in", "adoption", "agency", "algo", ")"], "add_tokens": "} ; exports . adoption = function ( ) { var html = \"<b>X<b>Y</b>Z</b>\" ; var doc = domino . createDocument ( html ) ; doc . body . innerHTML . should . equal ( html ) ; } ;", "del_tokens": "} ;", "commit_type": "add"}
{"commit_tokens": ["Use", "uglify", "-", "loader", "to", "reduce", "the", "size", "of", "main", ".", "js"], "add_tokens": "loader : 'uglify-loader!babel-loader'", "del_tokens": "loader : 'babel-loader' , query : { compact : false }", "commit_type": "use"}
{"commit_tokens": ["Added", "the", "ability", "to", "remove", "a", "receiver"], "add_tokens": "var result = [ ] ; result . push ( msngr . registry . routers . get ( i ) . receive ( msngr . utils . ensureMessage ( message ) , callback , context ) ) ; if ( result . length === 1 ) { return result [ 0 ] ; } return result ; } , remove : function ( id ) { if ( msngr . utils . isNullOrUndefined ( id ) ) { msngr . utils . ThrowRequiredParameterMissingOrUndefinedException ( \"id\" ) ; } var result = [ ] ; for ( var i = 0 ; i < msngr . registry . routers . count ( ) ; ++ i ) { result . push ( msngr . registry . routers . get ( i ) . remove ( id ) ) ; } if ( result . length === 1 ) { return result [ 0 ] ; } return result ;", "del_tokens": "msngr . registry . routers . get ( i ) . receive ( msngr . utils . ensureMessage ( message ) , callback , context ) ;", "commit_type": "add"}
{"commit_tokens": ["Implement", "polling", "for", "compat", "-", "v1", "devices"], "add_tokens": "let now = Date . now ( ) ; this . state . set ( 'last-poll' , now ) ; Promise . resolve ( this . _onTick ( now ) ) . catch ( ( e ) => this . emit ( 'error' , e ) ) ; _onTick ( now ) { for ( let item of results ) { item . __timestamp = now ; }", "del_tokens": "this . state . set ( 'last-poll' , Date . now ( ) ) ; Promise . resolve ( this . _onTick ( ) ) . catch ( ( e ) => this . emit ( 'error' , e ) ) ; _onTick ( ) { for ( let item of results )", "commit_type": "implement"}
{"commit_tokens": ["remove", "chinese", "characters", "in", "comment"], "add_tokens": "/ ** * Module Compiler for KISSY 1.2 + * @ author daxingplay < daxingplay @ gmail . com > debug : false , self . _analyzedFiles . push ( filePath ) ; ! self . _config . silent && console . info ( '[ok]' . bold . green + '锛�s ===> %s', in p tPath, ou t utPath); ! self . _config . silent && console . info ( '[err]' . bold . red + '锛歝annot find target: %s', ta r et);", "del_tokens": "* * 基于KISSY 1.2 的模块 打 包工具 * @ author 橘子（紫英）<daxingplay@ g mail.com> self . _analyzedFiles . push ( filePath ) ; ! self . _config . silent && console . info ( '[ok]' . bold . green + '：%s ===> %s', i putPath, o tputPath); ! self . _config . silent && console . info ( '[err]' . bold . red + '：cannot find target: %s', t rget);", "commit_type": "remove"}
{"commit_tokens": ["Changed", "a", "CORS", "test", "to", "pass", "on", "browsers", "that", "don", "t", "support", "CORS"], "add_tokens": "// The request failed, which is expected } ) . then ( function ( schema ) { // The request succeeded, which means this browser doesn't support CORS. expect ( schema ) . to . be . an ( 'object' ) ; expect ( schema ) . not . to . be . empty ; expect ( parser . schema ) . to . equal ( schema ) ; } ) . then ( function ( ) { } )", "del_tokens": ". then ( helper . shouldNotGetCalled ) } ) ;", "commit_type": "change"}
{"commit_tokens": ["added", "watchReplacer", "to", "avoid", "Windows", "7", "problems", "with", "fs", ".", "watch", "chef", "now", "works", "\\", "!"], "add_tokens": "return ( / ^(\\d+)$ / . test ( args [ 1 ] ) || / ^(\\d+)$ / . test ( args [ 0 ] ) ) &&", "del_tokens": "return ( / ^(\\d+)$ / . test ( args [ 0 ] ) || / ^(\\d+)$ / . test ( args [ 1 ] ) ) &&", "commit_type": "add"}
{"commit_tokens": ["Fixed", "bug", "required", "bug", ".", "Added", "ability", "to", "pass", "functions", ".", "Fixed", "bug", "that", "checks", "for", "init", "property", "on", "viewmodel", "."], "add_tokens": "function processValidateOpts ( viewModel , val , opts ) { console . log ( opts ) ; var processedObj = { } ; can . each ( opts , function ( item , key ) { var actualOpts = item ; if ( typeof item === 'function' ) { actualOpts = item . call ( viewModel , val ) ; } processedObj [ key ] = actualOpts ; } ) ; console . log ( processedObj ) ; return processedObj ; } ; // add method to prototype that validates entire map processedValidateOptions = can . extend ( { } , defaultValidationOpts , processValidateOpts ( this , value , validateOpts ) ) , propIniting = this . _initializing , console . log ( this . attr ( ) ) ;", "del_tokens": "// add method to prototype that valdiates entire map processedValidateOptions = can . extend ( { } , defaultValidationOpts , validateOpts ) , propIniting = typeof current === 'undefined' && ( defaultValue === value || typeof value === 'undefined' ) ,", "commit_type": "fix"}
{"commit_tokens": ["Remove", "promises", "from", "binding", ".", "js", "switch", "to", "new", "callback", "system", "(", "first", "argument", "is", "err", "argument", ")"], "add_tokens": "success : callback . success ? callback . success : function ( ) { var args = root . toArray ( arguments ) ; args . unshift ( null ) ; callback . apply ( null , args ) ; } , error : callback . error ? callback . error : function ( ) { var errorArgs = root . toArray ( arguments ) ; errorArgs = errorArgs . length === 1 ? errorArgs [ 0 ] : errorArgs ; var args = [ errorArgs , null ] ; callback . apply ( null , args ) ; }", "del_tokens": "success : callback . success ? callback . success : callback , error : callback . error ? callback . error : callback", "commit_type": "remove"}
{"commit_tokens": ["Make", "the", "button", "example", "a", "bit", "more", "dynamic"], "add_tokens": "getInitialState ( ) { return { } ; } , < button className = { cls } role = \"button\" onClick = { ( ) => this . setState ( s => ( { toggle : ! s . toggle } ) ) } style = { { fontSize : this . state . toggle ? '20px' : '10px' } } >", "del_tokens": "< button className = { cls } role = \"button\" >", "commit_type": "make"}
{"commit_tokens": ["Updating", "getAuthResponse", "to", "create", "an", "instance"], "add_tokens": "if ( ! ( this instanceof arguments . callee ) ) { // Invoke as an instance arguments . callee . prototype = this ; return new arguments . callee ( service ) ; } // Create an instance of Events this . utils . Event . call ( this ) ; // If the service doesn't exist service = service || this . settings . default_service ; if ( ! service || ! ( service in this . services ) ) { this . emit ( \"complete error\" , { error : { code : 'invalid_network' , message : 'The network was unrecognized' } } ) ; } return this . utils . store ( service ) ;", "del_tokens": "return this . utils . store ( service || this . service ( ) ) ;", "commit_type": "update"}
{"commit_tokens": ["moved", "the", "requires", "to", "the", "top", "to", "prevent", "from", "hitting", "the", "requires", "cache", "every", "time", "the", "client", "is", "initialized"], "add_tokens": "var dgram = require ( 'dgram' ) ; this . socket = dgram . createSocket ( 'udp4' ) ;", "del_tokens": "this . socket = require ( 'dgram' ) . createSocket ( 'udp4' ) ;", "commit_type": "move"}
{"commit_tokens": ["fix", "something", "(", "forgot", ")"], "add_tokens": "delay : 0 ,", "del_tokens": "delay : 300 ,", "commit_type": "fix"}
{"commit_tokens": ["use", "new", "stoppable", "fix", "package", ".", "json"], "add_tokens": "redNodes . registerType ( \"helper\" , helperNode ) ;", "del_tokens": "RED . nodes . registerType ( \"helper\" , helperNode ) ;", "commit_type": "use"}
{"commit_tokens": ["move", "to", "PSS", "padding", "requires", "custom", "version", "of", "ursa"], "add_tokens": "if ( ! hashname ) { warn ( \"seen called without a hashname\" , hashname ) ; return false ; } var aes = crypto . createCipheriv ( \"AES-256-CTR\" , crypto . createHash ( \"sha256\" ) . update ( to . eccOut . PublicKey ) . digest ( ) , iv ) ; open . js . sig = ursa . coercePrivateKey ( self . prikey ) . hashAndSign ( \"sha256\" , open . body , undefined , \"base64\" , ursa . RSA_PKCS1_PSS_PADDING ) ; var valid = ursa . coercePublicKey ( key ) . hashAndVerify ( \"sha256\" , packet . body , packet . js . sig , \"base64\" , ursa . RSA_PKCS1_PSS_PADDING )", "del_tokens": "var aes = crypto . createCipheriv ( \"AES-256-CTR\" , crypto . createHash ( 'sha256' ) . update ( to . eccOut . PublicKey ) . digest ( ) , iv ) ; open . js . sig = crypto . createSign ( \"RSA-SHA256\" ) . update ( open . body ) . sign ( self . prikey , \"base64\" ) ; var valid = crypto . createVerify ( \"RSA-SHA256\" ) . update ( packet . body ) . verify ( key , packet . js . sig , \"base64\" ) ;", "commit_type": "move"}
{"commit_tokens": ["Use", "a", "strict", "comparison", "and", "loop", "over", "all", "the", "lines", "."], "add_tokens": "var linesLen ; if ( file_stats . lines === null ) { linesLen = file . lines . length ; for ( var i = 0 ; i < linesLen ; i ++ ) { if ( file . lines [ i ] !== null ) { file_stats . lines [ i ] += file . lines [ i ] ; } }", "del_tokens": "if ( file_stats . lines == null ) { for ( var i = 0 ; i < file . lines ; i ++ ) { if ( file . lines [ i ] ) file_stats . lines [ i ] += file . lines [ i ] ; }", "commit_type": "use"}
{"commit_tokens": ["Use", "only", "one", "AudioContext", "for", "all", "test", "and", "improve", "tests", "checking"], "add_tokens": "var ac = null ac = ac || new AudioContext ( ) ; var audioStream = getOscillatorMedia ( ) audioStream : audioStream , assert . equal ( stream , audioStream , 'local stream' ) var audioStream = getOscillatorMedia ( ) audioStream : audioStream , assert . equal ( stream , audioStream , 'local stream' )", "del_tokens": "var ac = new AudioContext ( ) ; audioStream : getOscillatorMedia ( ) , assert . notEqual ( stream , undefined , 'local stream' ) audioStream : getOscillatorMedia ( ) , assert . notEqual ( stream , undefined , 'local stream' )", "commit_type": "use"}
{"commit_tokens": ["Fix", "local", "network", "udp", "transmit"], "add_tokens": "intf . sendIP4 ( viaIP || destIP , u8headers , u8data ) ;", "del_tokens": "intf . sendIP4 ( viaIP , u8headers , u8data ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "typeset", "format", "arg", "-", "again"], "add_tokens": "format : format ,", "del_tokens": "format : args . inputFormat ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "flickr", "plugin", ".", "On", "error", "for", "instagram", "fallback", "to", "iframe"], "add_tokens": "SDK : '//embed.redditmedia.com/widgets/platform.js' ,", "del_tokens": "SDK : 'https://embed.redditmedia.com/widgets/platform.js' ,", "commit_type": "add"}
{"commit_tokens": ["Remove", "schema", ".", "type", "file", "from", "responses"], "add_tokens": "if ( ! produces . length ) produces . push ( '*/*' ) ; // TODO verify default if ( response . content [ mimetype ] . schema . type == 'file' ) { delete response . content [ mimetype ] . schema ; }", "del_tokens": "if ( ! produces . length ) produces . push ( '*' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "autoclose", "functionality", "for", "lightbox"], "add_tokens": "_callback ( this ) ; afterglow . initPlayer ( lb_videoel , function ( player ) { // Adding autoclose functionality if ( lb_videoel . getAttribute ( \"data-autoclose\" ) == \"true\" ) { player . on ( 'ended' , function ( ) { afterglow . closeLightbox ( ) ; } ) ; }", "del_tokens": "_callback ( ) ; afterglow . initPlayer ( lb_videoel , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "diagonals", "via", "easystar", ".", "enableDiagonals", "()", "and", "easystar", ".", "disableDiagonals", "()", ".", "Add", "a", "test", "for", "diagonals", ".", "Update", "the", "demo", "."], "add_tokens": "this . _stage ; this . _diagonalsEnabled = false ; / ** * This method is called from the checkbox . * * It toggles the diagonals functionality of easystar . * / this . toggleDiagonals = function ( ) { if ( this . _diagonalsEnabled ) { this . _easystar . disableDiagonals ( ) ; } else { this . _easystar . enableDiagonals ( ) ; } this . _diagonalsEnabled = ! this . _diagonalsEnabled ; } var timeTakenToMoveMS ; if ( Math . abs ( player . x - path [ 0 ] . x ) + Math . abs ( player . y - path [ 0 ] . y ) == 2 ) { timeTakenToMoveMS = Demo . MOVE_TIME_MS * Demo . DIAGONAL_COST ; } else { timeTakenToMoveMS = Demo . MOVE_TIME_MS ; } } , timeTakenToMoveMS ) ; Demo . MAP_HEIGHT = 25 ; Demo . MOVE_TIME_MS = 50 ; Demo . DIAGONAL_COST = 1.4 ;", "del_tokens": "this . _stage ; } , 50 ) ; Demo . MAP_HEIGHT = 25 ;", "commit_type": "add"}
{"commit_tokens": ["use", "hashware", "-", "api", "for", "testing"], "add_tokens": "appPath : path . dirname ( require . resolve ( 'hashware-api' ) ) , this . timeout ( 30000 ) ;", "del_tokens": "appPath : path . dirname ( require . resolve ( 'xtuple-api' ) ) , this . timeout ( 10000 ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixing", "a", "hard", "to", "spot", "flaw", "with", "the", "new", "file", "naming", "scheme", ":", "if", "multiple", "types"], "add_tokens": "goog . addDependency ( '../../../../../src/js/nav.js' , [ 'dossier.nav' ] , [ 'goog.array' , 'goog.asserts' , 'goog.dom' , 'goog.events' , 'goog.events.KeyCodes' , 'goog.string' ] , true ) ; goog . addDependency ( '../../../../../src/js/dossier.js' , [ 'dossier' ] , [ 'dossier.keyhandler' , 'dossier.nav' , 'dossier.search' , 'goog.array' , 'goog.events' , 'goog.events.EventType' , 'goog.events.KeyCodes' , 'goog.dom' , 'goog.dom.TagName' , 'goog.dom.classlist' , 'goog.string' , 'goog.style' , 'goog.userAgent' ] ) ; goog . addDependency ( '../../../../../src/js/keyhandler.js' , [ 'dossier.keyhandler' ] , [ 'dossier.nav' , 'goog.events' , 'goog.events.EventType' , 'goog.events.KeyCodes' , 'goog.userAgent' ] , true ) ; goog . addDependency ( '../../../../../src/js/search.js' , [ 'dossier.search' ] , [ 'goog.events' , 'goog.events.EventType' , 'goog.events.KeyCodes' , 'goog.ui.ac.ArrayMatcher' , 'goog.ui.ac.AutoComplete' , 'goog.ui.ac.InputHandler' , 'goog.ui.ac.Renderer' , 'goog.userAgent' ] , true ) ;", "del_tokens": "goog . addDependency ( '../../../../../src/js/nav.js' , [ 'dossier.nav' ] , [ 'goog.array' , 'goog.asserts' , 'goog.string' ] , true ) ; goog . addDependency ( '../../../../../src/js/dossier.js' , [ 'dossier' ] , [ 'dossier.nav' , 'goog.array' , 'goog.events' , 'goog.events.EventType' , 'goog.events.KeyCodes' , 'goog.dom' , 'goog.dom.TagName' , 'goog.dom.classlist' , 'goog.string' , 'goog.ui.ac.ArrayMatcher' , 'goog.ui.ac.AutoComplete' , 'goog.ui.ac.InputHandler' , 'goog.ui.ac.Renderer' , 'goog.userAgent' ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "component", "set", "data", "-", "rcomponent", "fail", "bug"], "add_tokens": "_setAttribute ( c . $el , 'data-rcomponent' , cname ) function _setAttribute ( el , an , av ) { return el && el . setAttribute && el . setAttribute ( an , av ) }", "del_tokens": "tar . setAttribute ( 'data-rcomponent' , cname )", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "where", "children", "in", "branches", "were", "not", "filtered"], "add_tokens": ". filter ( filterSchemaNodes ( state ) )", "del_tokens": ". filter ( filterSchemaNodes ( state ) )", "commit_type": "fix"}
{"commit_tokens": ["adding", "ability", "to", "specify", "total", "as", "a", "function", "and", "adding", "example", "of", "giving", "complete", "control", "of", "the", "data", "to", "the", "caller"], "add_tokens": "var isFunction = function ( obj ) { return ! ! ( obj && obj . constructor && obj . call && obj . apply ) ; } ; var t = angular . isDefined ( total ) ? this . settings ( { 'total' : total } ) : settings . total ; return isFunction ( t ) ? t ( ) : t ;", "del_tokens": "return angular . isDefined ( total ) ? this . settings ( { 'total' : total } ) : settings . total ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "typo", "in", "website", "script", "."], "add_tokens": "fs . unlinkSync ( homeTemplatePath ) ;", "del_tokens": "fs . unlinkSync ( homepateTemplatePath ) ;", "commit_type": "fix"}
{"commit_tokens": ["made", "database", "schema", "migration", "more", "declarative"], "add_tokens": "resolve ( new ( this . constructor ) ( this [ FIELDS . request ] ) )", "del_tokens": "resolve ( new this . constructor ( this [ FIELDS . request ] ) )", "commit_type": "make"}
{"commit_tokens": ["Fix", "the", "hooks", "routes", "in", "HooksRouter", "."], "add_tokens": "const express = require ( 'express' ) ; var hooksApp = express ( ) ; hooksApp . use ( '/hooks' , middlewares . handleParseHeaders ) ; super . mountOnto ( hooksApp ) ; return app . use ( '/1' , hooksApp ) ;", "del_tokens": "app . use ( '/hooks/' , middlewares . handleParseHeaders ) ; return super . mountOnto ( app ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "when", "model", "is", "Capitalize"], "add_tokens": "var ChildModel = sails . models [ req . options . target . toLowerCase ( ) ] ;", "del_tokens": "var ChildModel = sails . models [ req . options . target ] ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "the", "un", "-", "cached", "blocks", "from", "the", "DOM", "to", "validate", ".", "This", "triggers", "the", "order", "to", "be", "correct", "."], "add_tokens": "var _block = _ . find ( this . blocks , function ( b ) { return ( b . blockID == $ ( block ) . attr ( 'id' ) ) ; } ) ; if ( _ . isUndefined ( _block ) ) { return false ; } this . performValidations ( _block , should_validate ) ; this . saveBlockStateToStore ( _block ) ; _ . each ( this . $wrapper . find ( '.st-block' ) , _ . bind ( blockIterator , this ) ) ;", "del_tokens": "this . blocks = this . $ ( '.st-block' ) ; this . performValidations ( block , should_validate ) ; this . saveBlockStateToStore ( block ) ; _ . each ( this . blocks , _ . bind ( blockIterator , this ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "supernode", ":", "lack", "arrOutputs"], "add_tokens": "createOptimalOutputs ( function ( arrOutputs ) { outputs : arrOutputs , var arrOutputs = [ { amount : 0 , address : my_address } ] ; return handleOutputs ( arrOutputs ) ; return handleOutputs ( arrOutputs ) ; handleOutputs ( arrOutputs ) ;", "del_tokens": "createOptimalOutputs ( function ( ) { outputs : [ { address : my_address , amount : 0 } ] , return handleOutputs ( ) ; return handleOutputs ( ) ; handleOutputs ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "correct", "path", "in", "examples", "when", "using", "handlers", "nested", "in", "subdirs"], "add_tokens": "filename : 'src/handler.js'", "del_tokens": "filename : 'handler.js'", "commit_type": "use"}
{"commit_tokens": ["allowing", "auth", "packages", "refactor", "in", "progress"], "add_tokens": "module . exports = function ( options , db ) { // Register app dependency; mean . register ( 'app' , function ( Auth , database ) { console . log ( Auth . passport ) ; require ( appPath + '/config/express' ) ( app , Auth . passport , database . connection ) ; require ( path ) ( app ) ; } ;", "del_tokens": "module . exports = function ( passport , db ) { // Bootstrap models // require('./util').walk(appPath + '/server', 'model', null, function(path) { // require(path); // }); require ( './util' ) . walk ( appPath + '/packages/mean-user/server' , 'model' , null , function ( path ) { require ( path ) ; } ) ; // Bootstrap passport config // require(appPath + '/config/passport')(passport); require ( appPath + '/packages/mean-user/server/config/passport' ) ( passport ) ; // Register passport dependency mean . register ( 'passport' , function ( ) { return passport ; } ) ; // Register auth dependency mean . register ( 'auth' , function ( ) { return require ( appPath + '/server/routes/middlewares/authorization' ) ; } ) ; // Register database dependency mean . register ( 'database' , { connection : db } ) ; // Register app dependency mean . register ( 'app' , function ( ) { // Load customizable express file require ( appPath + '/config/express' ) ( app , passport , db ) ; require ( path ) ( app , passport ) ; } ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "release", "note", "to", "README", ".", "md"], "add_tokens": "dev . query ( \"SELECT ROUND(RANDOM() * 100) AS number\" , function ( err , results ) {", "del_tokens": "dev . query ( \"SELECT 1\" , function ( err , results ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "transposed", "SVGO", "and", "svg", "-", "sprite", "-", "loader", "configs"], "add_tokens": "options : 'symbolId=ca-icon-[name]' , options : require ( './svgo.config.js' ) ,", "del_tokens": "options : require ( './svgo.config.js' ) , options : 'symbolId=ca-icon-[name]' ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "more", "data", "to", "message", "object"], "add_tokens": "actor : { '@type' : 'person' , '@id' : from } , '@type' : 'message' , } , published : new Date ( )", "del_tokens": "actor : { '@id' : from } , }", "commit_type": "add"}
{"commit_tokens": ["fix", "up", "bug", "with", "relabel", "subroutine"], "add_tokens": "var labels = new Array ( numPoints ) labels [ i ] = ptr labels [ i ] = - 1 //Fix up missing labels for ( var i = 0 ; i < numPoints ; ++ i ) { if ( labels [ i ] < 0 ) { labels [ i ] = labels [ uf . find ( i ) ] } } return labels", "del_tokens": "//If order is not consistent, then swap in tree if ( i < j ) { var rankI = uf . ranks [ i ] var rankJ = uf . ranks [ j ] uf . ranks [ i ] = rankJ uf . ranks [ j ] = rankI uf . roots [ j ] = uf . roots [ i ] = i floatPoints [ ptr ++ ] = floatPoints [ i ] } return uf . roots", "commit_type": "fix"}
{"commit_tokens": ["fixed", "test", "name", "for", "raw", "http"], "add_tokens": "test ( 'http' , function ( t ) {", "del_tokens": "test ( 'union' , function ( t ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "minimal", "modules", "and", "build", "files", "for", "CI"], "add_tokens": "function build ( paths , isCI ) { if ( isCI ) { return buildDebug ( sources , optionalRequireCode ) ; } else { return Q . all ( [ buildMain ( sources , optionalRequireCode ) . then ( function ( ) { return buildBrowser ( sources ) ; } ) , buildDebug ( sources , optionalRequireCode ) , buildZalgo ( sources , optionalRequireCode ) ] ) ; } var isCI = ! ! grunt . option ( \"ci\" ) ; build ( paths , isCI ) . then ( function ( ) {", "del_tokens": "function build ( paths ) { return Q . all ( [ buildMain ( sources , optionalRequireCode ) . then ( function ( ) { return buildBrowser ( sources ) ; } ) , buildDebug ( sources , optionalRequireCode ) , buildZalgo ( sources , optionalRequireCode ) ] ) ; build ( paths ) . then ( function ( ) {", "commit_type": "use"}
{"commit_tokens": ["fix", "merging", "mixins", "meta", "-", "data"], "add_tokens": "$create : function ( ) { this . _topics = { } ; } ,", "del_tokens": "this . _topics = this . _topics || { } ; this . _topics = this . _topics || { } ; this . _topics = this . _topics || { } ;", "commit_type": "fix"}
{"commit_tokens": ["adds", "support", "for", "overriding", "template", "name"], "add_tokens": "var templateName = page . metadata . template ? page . metadata . template : this . options . defaultTemplate ; var masterTemplate = grunt . file . read ( path . join ( this . options . templates , templateName + '.' + this . options . templateExt ) var tmpl = Handlebars . compile ( masterTemplate ) ;", "del_tokens": "var defaultTemplate = grunt . file . read ( path . join ( this . options . templates , this . options . defaultTemplate + '.' + this . options . templateExt ) var tmpl = Handlebars . compile ( defaultTemplate ) ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "dist", "files", "and", "promise", "-", "aplus", "-", "tests", "to", "use", "the", "new", "name"], "add_tokens": "define ( 'src/spromise' , [ return require ( \"src/spromise\" ) ;", "del_tokens": "define ( 'src/scpromise' , [ return require ( \"src/scpromise\" ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "ability", "to", "update", "a", "check"], "add_tokens": "app . use ( express . bodyParser ( ) ) ; app . use ( express . methodOverride ( ) ) ; res . render ( 'check' , { route : app . route , check : check , info : req . flash ( 'info' ) } ) ; } ) ; } ) ; app . put ( '/check/:id' , function ( req , res , next ) { Check . findOne ( { _id : req . params . id } , function ( err , check ) { if ( err ) return next ( err ) ; if ( ! check ) return next ( new Error ( 'failed to load check ' + req . params . id ) ) ; check . name = req . body . name ; check . url = req . body . url ; check . interval = req . body . interval ; check . maxTime = req . body . maxTime ; check . tags = req . body . tags . replace ( / \\s*,\\s* / g , ',' ) . split ( ',' ) ; check . save ( ) ; req . flash ( 'info' , 'Changes have been saved' ) ; res . redirect ( '/check/' + req . params . id ) ;", "del_tokens": "res . render ( 'check' , { route : app . route , check : check } ) ;", "commit_type": "add"}
{"commit_tokens": ["Improve", "how", "promises", "are", "handled", "in", "get", "chains"], "add_tokens": "if ( this . util . isPromise ( newContext ) ) { return newContext . then ( val => this . get ( val , path ) ) ; }", "del_tokens": "if ( this . util . isPromise ( newContext ) ) { return newContext . then ( val => this . get ( val , path ) ) ; } // If newContext is not a promise, it will pass through to the next if statement", "commit_type": "improve"}
{"commit_tokens": ["Fix", "segfaults", "and", "minor", "changes", "in", "m68k", "disasm", "+", "anal", "webversion", "is", "not"], "add_tokens": "{ tag : \"h3\" , style : \"color:#707070;margin-bottom:50px\" , content : \"the web frontend for radare2\" } , { tag : \"h2\" , style : \"color:#a0a0a0\" , content : \"author: pancake 2013-2014\" } , { tag : \"h2\" , style : \"color:#a0a0a0\" , content : \"version: ???\" , name : \"vertext\" } , { tag : \"h2\" , style : \"color:#a0a0a0\" , content : \"revision: ???\" , name : \"revtext\" } ( function ( me ) { setTimeout ( function ( ) { r2 . cmd ( \"?V\" , function ( v ) { var version = v . split ( \" \" ) [ 0 ] ; var revision = v . split ( \" \" ) [ 2 ] ; me . $ . vertext . setContent ( \"version: \" + version ) ; me . $ . revtext . setContent ( \"revision: \" + revision ) ; } ) ; } , 1000 ) ; } ) ( this ) ;", "del_tokens": "{ tag : \"h3\" , style : \"color:#707070;margin-bottom:50px\" , content : \"the web frontend for radare2\" } , { tag : \"h2\" , style : \"color:#a0a0a0\" , content : \"author: pancake 2013\" } , { tag : \"h2\" , style : \"color:#a0a0a0\" , content : \"version: 0.9.5git3\" , name : \"version\" } r2 . cmd ( \"?V\" , function ( version ) { this . $ . version . setContent ( \"version: \" + version ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["removes", "dev", "dep", "on", "can", "-", "connect"], "add_tokens": "QUnit . test ( 'basics' , function ( ) { var dataMethods = [ \"create\" , \"read\" , \"update\" , \"delete\" ] ; var daoValidator = makeInterfaceValidator ( [ dataMethods , \"id\" ] ) ; var dao = { create : function ( ) { } , read : function ( ) { } , update : function ( ) { } , delete : function ( ) { } var errors = daoValidator ( dao ) ; QUnit . deepEqual ( errors , { message : \"missing expected properties\" , related : [ \"id\" ] } ) ; dao . id = 10 ; errors = daoValidator ( dao ) ; QUnit . equal ( errors , undefined ) ;", "del_tokens": "var connect = require ( 'can-connect' ) ; var BaseInterface = [ 'id' , 'idProp' , 'listSet' , 'listSetProp' ] ; QUnit . test ( 'should return can-validate style error when can-connect connection is missing property' , function ( ) { var testBehavior = function ( baseBehavior ) { var validator = makeInterfaceValidator ( [ BaseInterface , 'testProp' ] ) , error = validator ( baseBehavior ) ; equal ( error . message , 'missing expected properties' , 'missing property validation error raised' ) ; deepEqual ( error . related , [ 'testProp' ] , 'error contains missing property name' ) ; return baseBehavior ; connect ( [ testBehavior ] , { } ) ;", "commit_type": "remove"}
{"commit_tokens": ["use", "correct", "create", "wallet", "api", "endpoint"], "add_tokens": "app . use ( '/api/v2' , v2API ) ;", "del_tokens": "app . use ( '/v2' , v2API ) ;", "commit_type": "use"}
{"commit_tokens": ["changed", "expected", "files", "names", "."], "add_tokens": ". pipe ( plugins . print ( function ( filename ) { return taskName + ': ' + filename ; } ) )", "del_tokens": ". pipe ( plugins . print ( ) )", "commit_type": "change"}
{"commit_tokens": ["Allow", "for", "a", "host", "to", "be", "specified"], "add_tokens": "Server . prototype . listen = function listen ( port , host , fn ) { if ( typeof host === 'function' ) { fn = host ; host = undefined ; } this . server . listen ( port , host , fn ) ;", "del_tokens": "Server . prototype . listen = function listen ( port , fn ) { this . server . listen ( port , fn ) ;", "commit_type": "allow"}
{"commit_tokens": ["add", "support", "for", "polyline", "borders", "on", "polygons", "in", "GL", "renderer"], "add_tokens": "if ( style . border . color && style . border . width ) { for ( var mpc = 0 ; mpc < polygons . length ; mpc ++ ) { GLBuilders . buildPolylines ( polygons [ mpc ] , feature , layer , style . border , tile , z + 0.01 , vertex_triangles , vertex_lines , { closed_polygon : true , remove_tile_edges : true } ) ; } }", "del_tokens": "// for (var mpc=0; mpc < polygons.length; mpc++) { // GLBuilders.buildPolylines(polygons[mpc], feature, layer, { color: [1, 0, 0], width: Style.width.pixels(1, tile) }, tile, z + 0.01, vertex_triangles, vertex_lines, { closed_polygon: true, remove_tile_edges: true }); // }", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "geo", "queries"], "add_tokens": "// according to the js sdk api documentation parse uses the following radius of the earth const RADIUS_OF_EARTH_KM = 6371.0 ; const RADIUS_OF_EARTH_MILES = 3958.8 ; // the parse rest guide says that the maximum distance is 100 miles if no explicit maximum // is provided; here we already convert this distance into radians const DEFAULT_MAX_DISTANCE = 100 / RADIUS_OF_EARTH_MILES ; $nearSphere : ( operand , value , additionalArgs ) => { let maxDistance = additionalArgs . maxDistanceInRadians ; if ( _ . isNil ( maxDistance ) ) { maxDistance = DEFAULT_MAX_DISTANCE ; } return new Parse . GeoPoint ( operand ) . radiansTo ( new Parse . GeoPoint ( value ) ) <= maxDistance ; } , // ignore these additional parameters for the $nearSphere op $maxDistance : ( ) => true , $maxDistanceInRadians : ( ) => true , $maxDistanceInKilometers : ( ) => true , $maxDistanceInMiles : ( ) => true , // $maxDistance... is not an operator for itself but just an additional parameter // for the $nearSphere operator, so we have to fetch this value in advance. const args = { } ; if ( whereParams ) { args . maxDistanceInRadians = whereParams . $maxDistance || whereParams . $maxDistanceInRadians ; if ( '$maxDistanceInKilometers' in whereParams ) { args . maxDistanceInRadians = whereParams . $maxDistanceInKilometers / RADIUS_OF_EARTH_KM ; } else if ( '$maxDistanceInMiles' in whereParams ) { args . maxDistanceInRadians = whereParams . $maxDistanceInMiles / RADIUS_OF_EARTH_MILES ; } } return matches && QUERY_OPERATORS [ constraint ] . apply ( null , [ keyValue , param , args ] ) ; } // { age: 30 }", "del_tokens": "return matches && QUERY_OPERATORS [ constraint ] . apply ( null , [ keyValue , param ] ) ; } // { age: 30 }", "commit_type": "add"}
{"commit_tokens": ["Fix", "syntax", "-", "rules", "bug", "if", "empty", "pair", "is", "provided"], "add_tokens": "if ( codeNode . car == null ) { let result = this . checkPattern ( patternCur . car , new PairValue ( ) , scope , patternEllipsis ) ; if ( ! result ) return false ; } else { if ( codeNode . car . type !== PAIR ) return false ; let result = this . checkPattern ( patternCur . car , codeNode . car , scope , patternEllipsis ) ; if ( ! result ) return false ; }", "del_tokens": "if ( codeNode . car . type !== PAIR ) return false ; let result = this . checkPattern ( patternCur . car , codeNode . car , scope , patternEllipsis ) ; if ( ! result ) return false ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "the", "third", "test", "for", "case", "3"], "add_tokens": "var async3 = async_test ( 'Case 3: hash changed to content[hash=\"case3-location2\"]' ) ; var content2 = document . querySelector ( ` ${ tagContent } ` ) ; var content2 = document . querySelector ( ` ${ tagContent } ` ) ; async3 . next ( ) ; } ) ; window . addEventListener ( 'hashchange' , check_hash ) ; window . location . hash = \"case3-location1\" ; } ) ; async3 . next = async3 . step_func ( _ => { var check_hash = async3 . step_func ( ( e ) => { window . removeEventListener ( 'hashchange' , check_hash ) ; //window.location.hash = '';// still having problems with this tear-down var content1 = document . querySelector ( ` ${ tagContent } ` ) ; var content2 = document . querySelector ( ` ${ tagContent } ` ) ; var content3 = document . querySelector ( ` ${ tagContent } ` ) ; assert_true ( content1 . hidden ) ; assert_true ( content2 . hidden ) ; assert_false ( content3 . hidden ) ; async3 . done ( ) ; window . location . hash = \"case3-location2\" ;", "del_tokens": "var content2 = document . querySelector ( ` ${ tagContent } ` ) ; var content2 = document . querySelector ( ` ${ tagContent } ` ) ; window . location . hash = \"case3-location1\" ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "org", "/", "user", "check"], "add_tokens": "var org = user === opt . auth . user ? undefined : user org : org ,", "del_tokens": "org : user ,", "commit_type": "fix"}
{"commit_tokens": ["changed", "prototypeString", "to", "use", "defineProperty", "instead", "of", "prototype"], "add_tokens": "if ( ! String . prototype . hasOwnProperty ( func ) ) { var proto = \"Object.defineProperty(String.prototype, \" + \"'\" + func + \"',\" + \"{value: function(params){ return mods['\" + mod + \"'].\" + func + \"(this.toString(), params);},\" + \"enumerable: false})\" ; eval ( proto ) ;", "del_tokens": "var exp = \"String.prototype.\" + func + \" = function(\" ; var params = [ ] ; for ( var n = 1 ; n < pcount ; n ++ ) { params . push ( \"p\" + n ) ; exp += params . join ( \",\" ) ; // TODO: // Need a rewrite of this for faster lookup exp += \") { return mods['\" + mod + \"'].\" + func + \"(this.toString()\" ; if ( pcount > 1 ) { exp += \", \" + params . join ( \",\" ) ; } exp += \") }\" ; eval ( exp ) ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "alt", "-", "require", "rule", "it", "used", "to", "process", "all", "elements", "not", "just", "imgs"], "add_tokens": "function filterElements ( opts , ele ) { if ( ele . type !== 'tag' || ele . name !== 'img' ) { // filter out if the element is not an img tag return false ; } // raise an issue if the alt attribute is not set return ! ele . attribs . alt ; } function createIssue ( opts , ele ) { return { index : ele . index , msg : 'the `alt` property must be set for image tags.' } ; } module . exports . process = function ( dom , opts ) { return domUtils . findAll ( filterElements . bind ( this , opts ) , dom ) . map ( createIssue . bind ( this , opts ) ) ;", "del_tokens": "module . exports . process = function ( dom , opts ) { return domUtils . findAll ( function testForLinkType ( ele ) { hasAltText = ele . attribs && ele . attribs . hasOwnProperty ( 'alt' ) && ( ele . attribs . alt !== \"\" ) ; //return true if angry return ! hasAltText ; } , dom ) . map ( function ( ele ) { return { index : ele . index , msg : 'the `alt` property must be set for image tags.' } ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "template", "variable", "and", "return", "the", "object", "directly"], "add_tokens": "return new TemplateBuilder ( str , props ) . getString ( ) ;", "del_tokens": "var template = new TemplateBuilder ( str , props ) ; return template . getString ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "comments", "and", "cleaned", "up", "some", "portions"], "add_tokens": "var value = arguments [ arguments . length - 1 ] ;", "del_tokens": "var value = last ( arguments ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "option", "to", "disable", "resolving", "files"], "add_tokens": "var resolveFiles = server !== undefined && server . _browserExtension . resolveFiles ; if ( resolveFiles && node . attributes . src != undefined ) { if ( resolveFiles && node . attributes . rel == 'import' && node . attributes . href != undefined ) { scriptTags : ( options && options . scriptTags ) ? options . scriptTags : [ \"script\" ] , resolveFiles : options . resolveFiles || true", "del_tokens": "if ( node . attributes . src != undefined ) { if ( node . attributes . rel == 'import' && node . attributes . href != undefined ) { scriptTags : ( options && options . scriptTags ) ? options . scriptTags : [ \"script\" ]", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "error", "everything", "worked", "."], "add_tokens": "afterglow . players . should . have . length ( 0 ) ;", "del_tokens": "afterglow . players . should . have . length ( 12 ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "order", "of", "reset", "and", "saving", "request", "options"], "add_tokens": "this . reset ( ) ; var req = https . request ( options ) ; reader ( this , 'options' , options ) ;", "del_tokens": "this . options = options ; var req = https . request ( options ) ; this . reset ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["allowing", "people", "to", "pass", "functions", "as", "processors"], "add_tokens": "var Process = processors . load ( options . processor ) ; var processor = new Process ( this ) ;", "del_tokens": "var specificProcess = processors . load ( options . processor ) ; var processor = new specificProcess ( this ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "support", "for", "axis", "/", "legend", "orient", "none", "."], "add_tokens": "case 'top' : case 'left' : case 'right' : case 'bottom' : default : x = item . x ; y = item . y ; default : x = item . x ; y = item . y ;", "del_tokens": "case 'top' : { } case 'left' : { } case 'right' : { } case 'bottom' : { }", "commit_type": "add"}
{"commit_tokens": ["fix", "multiple", "partitions", "of", "the", "same", "topic", "not", "consumed"], "add_tokens": "this . send ( payloads , encoder , decoder , cb ) ; this . send ( payloads , encoder , decoder , cb ) ; this . send ( payloads , encoder , decoder , cb ) ; this . send ( payloads , encoder , decoder , cb ) ; var count = Object . keys ( payloads ) . length ; var longpolling = encoder . name === 'encodeFetchRequest' ; if ( ! longpolling ) { cb = wrap ( payloads , cb ) ; }", "del_tokens": "this . send ( payloads , encoder , decoder , wrap ( payloads , cb ) ) ; this . send ( payloads , encoder , decoder , wrap ( payloads , cb ) ) ; this . send ( payloads , encoder , decoder , wrap ( payloads , cb ) ) ; this . send ( payloads , encoder , decoder , wrap ( payloads , cb ) ) ; var count = payloads . length ; var longpolling = encoder . name === 'encodeFetchRequest' ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "an", "option", "to", "include", "test", "output"], "add_tokens": "// We need to merge console.logs and attachments into one <system-out> - // see JUnit schema (only accepts 1 <system-out> per test). var systemOutLines = [ ] ; if ( this . _options . outputs && ( test . consoleOutputs && test . consoleOutputs . length > 0 ) ) { systemOutLines = systemOutLines . concat ( test . consoleOutputs ) ; } systemOutLines = systemOutLines . concat ( test . attachments . map ( ) ) ; } if ( systemOutLines . length > 0 ) { config . testcase . push ( { 'system-out' : systemOutLines . join ( '\\n' ) } ) ; } if ( this . _options . outputs && ( test . consoleErrors && test . consoleErrors . length > 0 ) ) { config . testcase . push ( { 'system-err' : test . consoleErrors . join ( '\\n' ) } ) ;", "del_tokens": "config . testcase . push ( { 'system-out' : test . attachments . map ( ) . join ( '\\n' ) } ) ;", "commit_type": "add"}
{"commit_tokens": ["Implemented", "support", "for", "field", "lists", "in", "$documents"], "add_tokens": "//debug.log('fields = ', JSON.stringify(fields, null, 2) );", "del_tokens": "debug . log ( 'fields = ' , JSON . stringify ( fields , null , 2 ) ) ;", "commit_type": "implement"}
{"commit_tokens": ["Allow", "finding", "elements", "by", "ng", "-", "bind", "not", "just", "{{", "}}", "interpolation", "."], "add_tokens": "if ( angular . element ( bindings [ i ] ) . data ( ) . $binding == binding ) { matches . push ( bindings [ i ] ) ; } else if ( angular . element ( bindings [ i ] ) . data ( ) . $binding [ 0 ] . exp == binding ) { if ( angular . element ( bindings [ i ] ) . data ( ) . $binding == binding ) { matches . push ( bindings [ i ] ) ; } else if ( angular . element ( bindings [ i ] ) . data ( ) . $binding [ 0 ] . exp == binding ) {", "del_tokens": "if ( angular . element ( bindings [ i ] ) . data ( ) . $binding [ 0 ] . exp == binding ) { if ( angular . element ( bindings [ i ] ) . data ( ) . $binding [ 0 ] . exp == binding ) {", "commit_type": "allow"}
{"commit_tokens": ["Moved", "extension", "to", "class", "-", "level", "to", "align", "with", "stringify", "/", "parse"], "add_tokens": "this . ext = options . ext || Store . ext ; Store . ext = '.json' ;", "del_tokens": "this . ext = options . ext || '.json' ;", "commit_type": "move"}
{"commit_tokens": ["add", "ES6", "export", "declarations", "support"], "add_tokens": "if ( types . VariableDeclaration . check ( node ) ) { return resolveToValue ( path . get ( 'declarations' , 0 ) ) } else if ( types . VariableDeclarator . check ( node ) ) { if ( node . init ) { return resolveToValue ( path . get ( 'init' ) ) ; } } else if ( types . AssignmentExpression . check ( node ) ) {", "del_tokens": "if ( types . AssignmentExpression . check ( node ) ) {", "commit_type": "add"}
{"commit_tokens": ["added", "ability", "to", "toggle", "header", "checkbox"], "add_tokens": "isCheckboxColumn : false , // Toggles the checkbox column in the header // for selecting all values given to the grid headerCheckbox : false", "del_tokens": "isCheckboxColumn : false", "commit_type": "add"}
{"commit_tokens": ["Added", "startOpen", "option", "to", "prevent", "immediate", "truncation"], "add_tokens": "startOpen : false , current . data ( 'sliderHeight' , maxHeight ) ; var useLink = $this . options . startOpen ? $this . options . lessLink : $this . options . moreLink ; current . after ( $ ( useLink ) . on ( 'click' , function ( event ) { $this . toggleSlider ( this , current , event ) } ) . addClass ( 'readmore-js-toggle' ) ) ; if ( ! useLink ) { current . css ( { height : maxHeight } ) ; } }", "del_tokens": "current . after ( $ ( $this . options . moreLink ) . on ( 'click' , function ( event ) { $this . toggleSlider ( this , current , event ) } ) . addClass ( 'readmore-js-toggle' ) ) ; } current . data ( 'sliderHeight' , maxHeight ) ; current . css ( { height : maxHeight } ) ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "the", "invalid", "valid_duration", "call"], "add_tokens": "return binary . length == 32 ; if ( ! valid_binary ( binary ) ) return ;", "del_tokens": "return binary . length != 32 ; if ( ! valid_binary ( durations ) ) return ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "the", "current", "testEnvironment", "available", "to", "utility", "functions"], "add_tokens": "// allow utility functions to access the current test environment QUnit . current_testEnvironment = testEnvironment ;", "del_tokens": "", "commit_type": "make"}
{"commit_tokens": ["fixed", "rangeIsSelectable", ";", "covered", "with", "a", "test"], "add_tokens": "var firstNode = iterator ( ) ; if ( ! firstNode ) { return false ; } var lastNode = range . getElementIterator ( true ) ( ) ; var cls1 = reg . exec ( firstSelection . className ) [ 1 ] ; var cls2 = reg . exec ( lastSelection . className ) [ 1 ] ; return cls1 !== cls2 ;", "del_tokens": "var node , firstNode , lastNode , first = true ; var hasNodes = false ; hasNodes = ! ! iterator ( ) if ( ! hasNodes ) { return false ; } return ( reg . exec ( firstSelection . className ) [ 1 ] != reg . exec ( lastSelection . className ) [ 1 ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["change", "ext", "class", "naming", "process"], "add_tokens": "ignore : 'test/tmp' // 'nodeunit', // 'clean'", "del_tokens": "ignore : 'test/tmp/app/' 'nodeunit' , 'clean'", "commit_type": "change"}
{"commit_tokens": ["Fixing", "an", "issue", "when", "using", "the", "AmCharts", ".", "React", "component", "on", "the", "server"], "add_tokens": "if ( typeof window !== \"undefined\" ) { window . React = require ( \"react\" ) ; window . ReactDOM = require ( \"react-dom\" ) ; require ( \"amcharts3/amcharts/amcharts.js\" ) ; require ( \"amcharts3/amcharts/serial.js\" ) ; require ( \"amcharts3/amcharts/themes/light.js\" ) ; require ( \"./amcharts3-react.js\" ) ; module . exports = window . AmCharts . React ; } else { module . exports = { } ; }", "del_tokens": "window . React = require ( \"react\" ) ; window . ReactDOM = require ( \"react-dom\" ) ; require ( \"amcharts3/amcharts/amcharts.js\" ) ; require ( \"amcharts3/amcharts/serial.js\" ) ; require ( \"amcharts3/amcharts/themes/light.js\" ) ; require ( \"./amcharts3-react.js\" ) ; module . exports = window . AmCharts . React ;", "commit_type": "fix"}
{"commit_tokens": ["Adds", "the", "ability", "to", "load", "plugins", "outside", "of", "this", "package", "."], "add_tokens": "var plugin = null if ( typeof pluginName === 'string' ) { var pluginConstructor = require ( __dirname + \"/plugins/\" + pluginName + \".js\" ) [ pluginName ] ; plugin = new pluginConstructor ( self , func , queue , job , args , pluginOptions ) ; } else if ( typeof pluginName === 'function' ) { plugin = new pluginName ( self , func , queue , job , args , pluginOptions ) ; } else { throw new Error ( 'Plugin must be the constructor name or an object' ) ; } exports . runPlugins = runPlugins ;", "del_tokens": "var pluginConstructor = require ( __dirname + \"/plugins/\" + pluginName + \".js\" ) [ pluginName ] ; var plugin = new pluginConstructor ( self , func , queue , job , args , pluginOptions ) ; exports . runPlugins = runPlugins ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "SSH", "tunnel", "local", "port"], "add_tokens": "const { address , port } = server . sshTunnel . address ( ) ; debug ( 'ssh forwarding through local connection %s:%d' , address , port ) ; server . config . localHost = address ; server . config . localPort = port ;", "del_tokens": "const localPort = server . sshTunnel . address ( ) . port ; debug ( 'ssh forwarding through local port connection %d' , localPort ) ; server . config . localHost = '127.0.0.1' ; server . config . localPort = localPort ;", "commit_type": "fix"}
{"commit_tokens": ["Moved", "all", "class", "files", "into", "classes", "/", "."], "add_tokens": "require ( 'classes/English' ) ; require ( 'classes/ANSI' ) ; require ( 'classes/Styles' ) ; require ( 'classes/Prompts' ) ; require ( 'classes/Messages' ) ; require ( 'classes/Base' ) ; require ( 'classes/Command' ) ; require ( 'classes/Container' ) ; require ( 'classes/Item' ) ; require ( 'classes/Living' ) ; require ( 'classes/Player' ) ; require ( 'classes/Room' ) ; require ( 'classes/World' ) ; require ( 'classes/Conversation' ) ;", "del_tokens": "require ( 'English' ) ; require ( 'ANSI' ) ; require ( 'Styles' ) ; require ( 'Prompts' ) ; require ( 'Messages' ) ; require ( 'models/Base' ) ; require ( 'models/Command' ) ; require ( 'models/Container' ) ; require ( 'models/Item' ) ; require ( 'models/Living' ) ; require ( 'models/Player' ) ; require ( 'models/Room' ) ; require ( 'models/World' ) ; require ( 'models/Conversation' ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "reversed", "translateVector", "coordinates", "(", "XYZ", "vs", "ZYX", ")"], "add_tokens": "position [ 0 ] * w , position [ 2 ] * w ]", "del_tokens": "position [ 2 ] * w , position [ 0 ] * w ]", "commit_type": "fix"}
{"commit_tokens": ["add", "registers", "back", "in", "separate", "file"], "add_tokens": "const { JOYPAD } = require ( './registers' ) ; if ( addr == JOYPAD ) { if ( addr == JOYPAD ) {", "del_tokens": "/ ** * FF00 - P1 / JOYP - Joypad ( R / W ) * * The eight gameboy buttons / direction keys are arranged in form of a 2 x4 * matrix . Select either button or direction keys by writing to this * register , then read - out bit 0 - 3. * * Bit 7 - Not used * Bit 6 - Not used * Bit 5 - P15 Select Button Keys ( 0 = Select ) * Bit 4 - P14 Select Direction Keys ( 0 = Select ) * Bit 3 - P13 Input Down or Start ( 0 = Pressed ) ( Read Only ) * Bit 2 - P12 Input Up or Select ( 0 = Pressed ) ( Read Only ) * Bit 1 - P11 Input Left or Button B ( 0 = Pressed ) ( Read Only ) * Bit 0 - P10 Input Right or Button A ( 0 = Pressed ) ( Read Only ) * / if ( addr == 0xff00 ) { if ( addr == 0xff00 ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "regression", "on", "Windows"], "add_tokens": "gulp . task ( 'test:browser' , ( ) => { if ( process . platform == 'win32' ) process . env . FIREFOX_BIN = 'firefox.exe' ; return _exec ( 'node_modules/.bin/karma' , [ 'start' , '--single-run' ] ) ; } ) ;", "del_tokens": "gulp . task ( 'test:browser' , ( ) => _exec ( 'node_modules/.bin/karma' , [ 'start' , '--single-run' ] ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "ember", "-", "socket", ".", "js", "with", "error", "function", "."], "add_tokens": "socket . on ( 'error' , this . error ) ; error : function ( ) { // Throw an exception if an error occurs. throw 'Unable to make a connection to the Socket.io server!' ; } ,", "del_tokens": "socket . on ( 'error' , function socketError ( ) { // Throw an exception if an error occurs. throw 'Unable to make a connection to the Socket.io server!' ; } ) ;", "commit_type": "update"}
{"commit_tokens": ["Updated", "service", "and", "servicerunner", "classes", ".", "Reduce", "dependencies"], "add_tokens": "var ScriptRunner = require ( './lib/scriptRunner' ) ; Service : Service , ScriptRunner : ScriptRunner", "del_tokens": "Service : Service", "commit_type": "update"}
{"commit_tokens": ["add", "a", "flow", "after", "upload", "file", "success"], "add_tokens": "owner . request ( 'after-send-file' , [ file , ret , headers ] , function ( ) { file . setStatus ( Status . COMPLETE ) ; owner . trigger ( 'uploadComplete' , file ) ; tr . destroy ( ) ; } ) . fail ( function ( reason ) { tr . trigger ( 'error' , reason ) ; } ) ;", "del_tokens": "file . setStatus ( Status . COMPLETE ) ; owner . trigger ( 'uploadComplete' , file ) ; tr . destroy ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "setRanges", "in", "WrappedSelection", "in", "IE", "to", "create", "and", "select", "a", "ControlRange", "when", "multiple", "ranges", "are", "supplied"], "add_tokens": "selProto . setRanges = function ( ranges ) { this . removeAllRanges ( ) ; for ( var i = 0 ; i < rangeCount ; ++ i ) { this . addRange ( ranges [ i ] ) ; } } ; selProto . setRanges = function ( ranges ) { this . removeAllRanges ( ) ; var rangeCount = ranges . length ; if ( rangeCount > 1 ) { // Ensure that the selection becomes of type \"Control\" var doc = dom . getDocument ( ranges [ 0 ] . startContainer ) ; var controlRange = doc . body . createControlRange ( ) ; for ( var i = 0 ; i < rangeCount ; ++ i ) { controlRange . add ( getSingleElementFromRange ( ranges [ i ] ) ) ; } controlRange . select ( ) ; // Update the wrapped selection based on what's now in the native selection updateFromControlRange ( this ) ; } else if ( rangeCount ) { this . addRange ( ranges [ 0 ] ) ; } } ;", "del_tokens": "selProto . setRanges = function ( ranges ) { this . removeAllRanges ( ) ; for ( var i = 0 , len = ranges . length ; i < len ; ++ i ) { this . addRange ( ranges [ i ] ) ; } } ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "it", ".", "each", ".", "only"], "add_tokens": "if ( this . _override ) { invoke = it [ this . _override ] ; } else { } it . each . skip = it . each . bind ( { _override : 'skip' } ) ; it . each . only = it . each . bind ( { _override : 'only' } ) ;", "del_tokens": "if ( this . _skipOverride ) { invoke = it . skip ; } else { } it . each . skip = it . each . bind ( { _skipOverride : true } ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "scripts", ".", "Move", "all", "to", "configuration", "."], "add_tokens": "var task = new Task ( { config : config , env : env } ) ;", "del_tokens": "var task = new Task ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["use", "empty", "string", "rather", "than", "undefined", "."], "add_tokens": "traverse ( environment ) . set ( node . key . replace ( key , '' ) . split ( '/' ) , node . value || '' ) ;", "del_tokens": "traverse ( environment ) . set ( node . key . replace ( key , '' ) . split ( '/' ) , node . value ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "reference", "to", "ruleName", "in", "message", "for", "missing", "semantic", "actions", "."], "add_tokens": "browser . error ( 'missing semantic action for' , this . ruleName ) ;", "del_tokens": "browser . error ( 'missing semantic action for' , ruleName ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "a", "package", "for", "API", "mapping", "templates"], "add_tokens": "const mappingTemplate = require ( 'api-gateway-mapping-template' ) ; body = mappingTemplate ( { template : template , payload : result , context : this . context } ) ;", "del_tokens": "const JSONPath = require ( 'jsonpath' ) ; const util = require ( '../helpers/api-gateway-util' ) ; let resultObject ; try { resultObject = JSON . parse ( result ) ; } catch ( e ) { // Ignore } const input = { params : function ( name ) { if ( ! name ) return resultObject ; if ( _ . has ( resultObject , name ) ) return resultObject [ name ] ; if ( _ . has ( resultObject , name . toLowerCase ( ) ) ) return resultObject [ name . toLowerCase ( ) ] ; } , json : function ( p ) { return JSON . stringify ( JSONPath . value ( resultObject , p ) ) ; } , path : function ( p ) { return JSONPath . value ( resultObject , p ) ; } } ; body = util . parseMappingTemplate ( template , input , this . context ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "error", "where", "if", "a", "string", "were", "passed", "to", "_computeTheme", "it", "would", "crash", "."], "add_tokens": "if ( typeof theme === 'string' ) { theme = this . _themes . getTheme ( theme ) } else if ( theme && ( Object . keys ( theme ) . length === 0 || theme . hasUnicode != null || theme . hasColor != null ) ) {", "del_tokens": "if ( theme && ( Object . keys ( theme ) . length === 0 || theme . hasUnicode != null || theme . hasColor != null ) ) { } else if ( typeof theme === 'string' ) { theme = this . _themes . getTheme ( theme )", "commit_type": "fix"}
{"commit_tokens": ["Added", "--", "cors", "option", "to", "enable", "replying", "to", "CORS", "requests"], "add_tokens": "if ( options . cors ) { if ( req . method === 'OPTIONS' ) { if ( req . headers [ 'access-control-request-headers' ] ) res . header ( 'Access-Control-Allow-Headers' , req . headers [ 'access-control-request-headers' ] ) ; if ( req . headers [ 'access-control-request-method' ] ) res . header ( 'Access-Control-Allow-Methods' , req . headers [ 'access-control-request-method' ] ) ; } if ( req . headers . origin ) res . header ( 'Access-Control-Allow-Origin' , '*' ) ;", "del_tokens": "if ( req . method === 'OPTIONS' ) { if ( req . headers [ 'access-control-request-headers' ] ) res . header ( 'Access-Control-Allow-Headers' , req . headers [ 'access-control-request-headers' ] ) ; if ( req . headers [ 'access-control-request-method' ] ) res . header ( 'Access-Control-Allow-Methods' , req . headers [ 'access-control-request-method' ] ) ; if ( req . headers . origin ) res . header ( 'Access-Control-Allow-Origin' , '*' ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "helper", ".", "exists", "()", "switch", "to", "fs", "-", "extra"], "add_tokens": "spawn = child_process . spawn ; ? fs . ensureDir ( path . dirname ( opts . path ) ) return fs . writeFile ( opts . path , json , 'utf8' ) ;", "del_tokens": "spawn = child_process . spawn , promiseWriteFile = Promise . promisify ( fs . writeFile ) , promiseEnsureDir = Promise . promisify ( fs . ensureDir ) ; ? promiseEnsureDir ( path . dirname ( opts . path ) ) return promiseWriteFile ( opts . path , json , 'utf8' ) ; // fs.exists does not conform with the Node callback signature e.g. // `function (err, result) {...}`. so we promisify this manually. helper . exists = function ( filePath ) { return new Promise ( function ( resolve , reject ) { fs . exists ( filePath , function ( exists ) { resolve ( exists ) ; } ) ; } ) ; } ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "a", "bug", "in", "my", "previous", "commit", ".", "Had", "forgotten", "to", "decode", "the", "basePath", "."], "add_tokens": "// Get the directory of the main Swagger file var baseDir = path . dirname ( decodeURI ( context . parser . _basePath ) ) ; // Get the normalized path of the requested file, relative to the baseDir var relativeFile = path . relative ( baseDir , file ) ;", "del_tokens": "// Get the normalized, relative path of the requested file var relativeFile = path . relative ( path . dirname ( context . parser . _basePath ) , file ) ;", "commit_type": "fix"}
{"commit_tokens": ["Using", "bunyan", "-", "logger", "for", "requests"], "add_tokens": "var Logger = require ( \"bunyan\" ) ; var restifyBunyanLogger = require ( 'restify-bunyan-logger' ) ; // Create bunyan logger var log = new Logger . createLogger ( { name : process . env . APP_NAME || 'hydrater' , } ) ; module . exports . log = log ; var server = restify . createServer ( { log : log } ) ; server . on ( 'after' , restifyBunyanLogger ( ) ) ; server . use ( restify . requestLogger ( ) ) ;", "del_tokens": "var server = restify . createServer ( ) ; server . use ( require ( './middlewares/logger.js' ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Removed", "return", "from", "default", "constructor"], "add_tokens": "parentConstructor . apply ( this , arguments )", "del_tokens": "return parentConstructor . apply ( this , arguments )", "commit_type": "remove"}
{"commit_tokens": ["Added", "functional", "tests", "for", "replicaset"], "add_tokens": "var passives = replsetOptions . passives || 1 ; var passiveServers = [ ] ; Object . defineProperty ( this , 'passives' , { enumerable : true , get : function ( ) { return passiveServers . slice ( 0 ) ; } } ) ; // For all servers add the members for ( var i = 0 ; i < passives ; i ++ , _id ++ ) { configSet . members [ _id ] = { _id : _id , host : serverManagers [ _id ] . name , priority : 0 } } var totalServers = secondaries + arbiters + passives + 1 ; this . getServerManagerByType = function ( type , callback ) { return getServerManagerByType ( type , callback ) ; } if ( typeof t == 'function' ) { callback = t ; t = 'secondary' ; } getServerManagerByType ( t , function ( err , m ) {", "del_tokens": "var totalServers = secondaries + arbiters + 1 ; getServerManagerByType ( 'secondary' , function ( err , m ) {", "commit_type": "add"}
{"commit_tokens": ["Remove", "Parser", "export", "Encoder", "and", "Decoder"], "add_tokens": "exports . Decoder = require ( './decoder' ) ; exports . Encoder = require ( './encoder' ) ;", "del_tokens": "exports . Parser = require ( './parser' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Changed", "core", "to", "use", "single", "shared", "bson", "parser", "instance"], "add_tokens": "// BSON parser var bsonInstance = null ; // BSON Parser, ensure we have a single instance if ( bsonInstance == null ) { bsonInstance = new BSON ( bsonTypes ) ; // Pick the right bson parser var bson = options . bson ? options . bson : bsonInstance ; // Add bson parser to options options . bson = bson ;", "del_tokens": "// Let's get the bson parser if none is passed in if ( options . bson == null ) { options . bson = new BSON ( bsonTypes ) ; // Save bson var bson = options . bson ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "infinite", "loop", "when", "no", "expects"], "add_tokens": "// if you have no expects, they can't fail if ( self . current . expects . length == 0 ) { self . current . retry = - 1 ; self . current . expectsFailed = false ; } self . current . retry = - 1 ;", "del_tokens": "self . current . retry = 0 ;", "commit_type": "fix"}
{"commit_tokens": ["added", "test", "for", "terminal", "colour", "output"], "add_tokens": "nocolor : ! process . stdout . isTTY , if ( this . nocolor ) {", "del_tokens": "if ( process . platform === 'win32' ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "silly", "$", "check", "since", "Node", "won", "t", "have", "one", "."], "add_tokens": "Augmented . $ = ( Backbone . $ ) ? Backbone . $ : { } ; // Does $ exist?", "del_tokens": "Augmented . $ = ( Backbone . $ ) ? Backbone . $ : $ ; // Does $ exist?", "commit_type": "fix"}
{"commit_tokens": ["Change", "to", "if", "stylestats", "throw", "error", "Kotori", "also", "throw", "error"], "add_tokens": "new Stats ( file , currentConfig . stats ) ;", "del_tokens": "new Stats ( file , currentConfig . stats , callback ) ;", "commit_type": "change"}
{"commit_tokens": ["Use", "more", "natural", "constructor", "call"], "add_tokens": "var HasteMapWebPackResolver = require ( 'haste-map-webpack-resolver' ) ; plugins : [ new HasteMapWebPackResolver ( {", "del_tokens": "var buildResolver = require ( 'haste-map-webpack-resolver' ) ; plugins : [ buildResolver ( {", "commit_type": "use"}
{"commit_tokens": ["fixing", "201", "error", "and", "datetime", "format", "for", "order", "creation"], "add_tokens": "\"Content-Type\" : \"application/x-www-form-urlencoded\" , \"X-Accept-Datetime-Format\" : \"UNIX\"", "del_tokens": "\"Content-Type\" : \"application/x-www-form-urlencoded\"", "commit_type": "fix"}
{"commit_tokens": ["Fix", "failing", "tests", "in", "sort", "-", "amd", "-", "paths"], "add_tokens": "errors : [ makeErrorMessage ( \"foo/bar/baz/Bat\" ) ] errors : [ makeErrorMessage ( \"foo/bar/baz/Bat\" ) ]", "del_tokens": "errors : [ ERROR ] errors : [ ERROR ]", "commit_type": "fix"}
{"commit_tokens": ["Add", "file", "argument", "to", "touchFile"], "add_tokens": "function touchFile ( file ) { return function ( ) { touch . sync ( file ? file : msgFile ) } setTimeout ( touchFile ( ) , 500 ) setTimeout ( touchFile ( ) , 500 ) setTimeout ( touchFile ( ) , 500 ) setTimeout ( touchFile ( ) , 500 ) setTimeout ( touchFile ( ) , 500 )", "del_tokens": "function touchFile ( ) { touch . sync ( msgFile ) ; setTimeout ( touchFile , 500 ) setTimeout ( touchFile , 500 ) setTimeout ( touchFile , 500 ) setTimeout ( touchFile , 500 ) setTimeout ( touchFile , 500 )", "commit_type": "add"}
{"commit_tokens": ["updated", "the", "input", "-", "testcases", ".", "js"], "add_tokens": "str = Expression . addSpaceBetweenTerms ( str ) ; Expression . encodeE = function ( str ) { str = ( str || \"\" ) . toString ( ) ; str = str . replace ( / (\\de)([+])(\\d) / gi , \"$1_plus_$3\" ) ; str = str . replace ( / (\\de)([-])(\\d) / gi , \"$1_sub_$3\" ) ; return str ; } ; Expression . decodeE = function ( str ) { str = ( str || \"\" ) . toString ( ) ; str = str . replace ( / _plus_ / g , \"+\" ) ; str = str . replace ( / _sub_ / g , \"-\" ) ; return str ; } ; Expression . addSpaceBetweenTerms = function ( str ) { str = Expression . encodeE ( str ) ; str = str . replace ( / ([\\+\\-]) / g , \" $1 \" ) ; str = str . replace ( / \\s{2,} / g , \" \" ) ; str = str . trim ( ) ; str = Expression . decodeE ( str ) ; return str ; } ; if ( obj && obj [ 1 ] ) { } ;", "del_tokens": "if ( obj [ 1 ] ) { } ;", "commit_type": "update"}
{"commit_tokens": ["Create", "isNestedPut", ".", "Use", "in", "sagaTestEngine", "assert"], "add_tokens": "const isNestedPut = arr => bool ( arr && arr . every && arr . length > 0 && arr . every ( element => isPut ( element ) ) ) const yieldedEffectIsPut = isPut ( val ) || isNestedPut ( val ) module . exports = { sagaTestEngine , isPut , isNestedPut , isNestedArray , getNextVal , assert }", "del_tokens": "const yieldedEffectIsPut = isPut ( val ) module . exports = { sagaTestEngine , isPut , isNestedArray , getNextVal , assert }", "commit_type": "create"}
{"commit_tokens": ["Implemented", "dynamic", "log", "level", "setting", "for", "express"], "add_tokens": "var token = req . header ( core . getDynLogLevelHeaderName ( ) ) ; if ( token != null ) { req . dynamicLogLevel = core . getLogLevelFromJWT ( token ) ; } else { req . dynamicLogLevel = null ; } core . sendLog ( 'info' , logObject , req . dynamicLogLevel ) ;", "del_tokens": "core . sendLog ( 'info' , logObject ) ;", "commit_type": "implement"}
{"commit_tokens": ["Use", "propper", "modules", "for", "better", "tree", "shaking"], "add_tokens": "import asyncParallel from 'async/parallel' import asyncSeries from 'async/series' import asyncParallelLimit from 'async/parallelLimit' ? asyncParallel : ( tasks , callback ) => asyncParallelLimit ( tasks , limit , callback ) return generatePromise ( promiseFunctions , asyncSeries , silenceErrors )", "del_tokens": "import async from 'async' ? async . parallel : ( tasks , callback ) => async . parallelLimit ( tasks , limit , callback ) return generatePromise ( promiseFunctions , async . series , silenceErrors )", "commit_type": "use"}
{"commit_tokens": ["adding", "_", "between", "global", "and", "instance", "counters"], "add_tokens": "var id = thisArg . prefix + thisArg . globalCounter + '_' + ( thisArg . counter ++ ) + '__' ;", "del_tokens": "var id = thisArg . prefix + thisArg . globalCounter + ( thisArg . counter ++ ) + '__' ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "console", ".", "log", "on", "normal", "case"], "add_tokens": "debug ( 'Constants file does not exist, setting constants to {}' ) ;", "del_tokens": "console . log ( 'Constants file does not exist, setting constants to {}' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Changed", "search", "to", "clear", "out", "search", "box", "and", "put", "search", "text", "in", "results", "."], "add_tokens": "var textToFind = this . get ( 'searchText' ) ; this . set ( 'searchText' , '' ) ; this . transitionToRoute ( this . searchRoute + \"/\" + textToFind ) ;", "del_tokens": "this . transitionToRoute ( this . searchRoute , { queryParams : { searchText : this . get ( 'searchText' ) } } ) ;", "commit_type": "change"}
{"commit_tokens": ["added", "connection", "/", "disconnection", "tests"], "add_tokens": "var chars = [ 'R' , 'S' , 'K' , 'Z' , 'Q' , 'C' , 'T' , 'D' , 'X' ] ; Client . prototype . disconnect = function ( ) { var terminationBuffer = new Buffer ( [ UTF8 . X , 0 , 0 , 0 , 4 ] ) ; this . con . write ( terminationBuffer ) ; } ;", "del_tokens": "var chars = [ 'R' , 'S' , 'K' , 'Z' , 'Q' , 'C' , 'T' , 'D' ] ;", "commit_type": "add"}
{"commit_tokens": ["Adds", "unfinished", "support", "for", "broadcast", "api"], "add_tokens": "Labels = require ( './message-labels' ) , Broadcast = require ( './broadcast-api' ) ; this . Broadcast = new Broadcast ( this . GraphRequest ) ;", "del_tokens": "Labels = require ( './message-labels' ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "ua", "-", "parser", "s", "dedicated", "method", "for", "benchmarking", "the", "UA", "parser", "."], "add_tokens": "uaparser . parseUA ( testcases [ i ] ) ;", "del_tokens": "uaparser . parse ( testcases [ i ] ) ;", "commit_type": "use"}
{"commit_tokens": ["moved", "minWidth", "/", "minHeight", "etc", ".", "to", "clampZoom", "()", "plugin"], "add_tokens": "const ClampZoom = require ( './clamp-zoom' ) const PLUGIN_ORDER = [ 'hit-area' , 'drag' , 'pinch' , 'wheel' , 'follow' , 'decelerate' , 'bounce' , 'snap' , 'clamp-zoom' , 'clamp' ] if ( this . plugins [ 'clamp-zoom' ] ) { this . plugins [ 'clamp-zoom' ] . clamp ( ) } clampZoom ( options ) { this . plugins [ 'clamp-zoom' ] = new ClampZoom ( this , options ) return this }", "del_tokens": "const PLUGIN_ORDER = [ 'hit-area' , 'drag' , 'pinch' , 'wheel' , 'follow' , 'decelerate' , 'bounce' , 'snap' , 'clamp' ]", "commit_type": "move"}
{"commit_tokens": ["make", "scope", "property", "from", "original", "scope", ";", "change", "scopes", "to", "be", "calculated", "from", "scope"], "add_tokens": "this . scope = other . scope ; Object . defineProperty ( this , \"scopes\" , { get : function ( ) { return ( this . scope || \"\" ) . split ( \" \" ) ; } } ) ;", "del_tokens": "this . scopes = ( other . scope || \"\" ) . split ( \" \" ) ;", "commit_type": "make"}
{"commit_tokens": ["Make", "test", "reset", "method", "recursive"], "add_tokens": "// Reset the state of the test and all child tests so that it is safe to // run it again. for ( let child of this . children ) { child . reset ( ) ; }", "del_tokens": "// Reset the state of the test so that it is safe to run it again.", "commit_type": "make"}
{"commit_tokens": ["moved", "providers", "to", "their", "own", "folder"], "add_tokens": "return self . _staticRequestHandler ( req , res ) // static stuff", "del_tokens": "return app ( req , res ) // static stuff", "commit_type": "move"}
{"commit_tokens": ["Allow", "null", "model", "value", "and", "ensure", "tinymce", "is", "instantiated"], "add_tokens": "var interval = setInterval ( function ( ) { tinyInstance = tinymce . get ( attrs . id ) ; if ( tinyInstance ) { clearInterval ( interval ) ; ngModel . $render = function ( ) { tinyInstance . setContent ( ngModel . $viewValue || '' ) ; } ; } , 0 ) ;", "del_tokens": "ngModel . $render = function ( ) { if ( ! tinyInstance ) { tinyInstance = tinymce . get ( attrs . id ) ; tinyInstance . setContent ( ngModel . $viewValue ) ; } ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "index", "feedback", "to", "reliable", "send"], "add_tokens": "return ReliableChannel . send ( $$ . fromCloud , constants_iot . FROM_CLOUD_CHANNEL_NAME , [ bStr ] ) ;", "del_tokens": "ReliableChannel . send ( $$ . fromCloud , constants_iot . FROM_CLOUD_CHANNEL_NAME , [ bStr ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "next", "-", "i18next", "-", "middleware", "test", "to", "reflect", "new", "ignoreRoutes", "setting"], "add_tokens": "expect ( i18nextMiddleware . handle ) . toBeCalledWith ( 'i18n' , expect . objectContaining ( { ignoreRoutes : expect . arrayContaining ( [ '/_next' , '/static' ] ) , } ) ) expect ( i18nextMiddleware . handle ) . toBeCalledWith ( 'i18n' , expect . objectContaining ( { ignoreRoutes : expect . arrayContaining ( [ '/_next' , '/static' ] ) , } ) )", "del_tokens": "expect ( i18nextMiddleware . handle ) . toBeCalledWith ( 'i18n' ) expect ( i18nextMiddleware . handle ) . toBeCalledWith ( 'i18n' )", "commit_type": "update"}
{"commit_tokens": ["Adds", "CSS", "Color", "Module", "4", "colors", "and", "hsl", "(", "a", ")"], "add_tokens": "test . expect ( 7 ) ; style . color = 'hsla(0, 1%, 2%, 0.5)' ; test . ok ( 'hsla(0, 1%, 2%, 0.5)' === style . color , 'color is not hsla(0, 1%, 2%, 0.5) ' + style . color ) ; style . color = 'hsl(0, 1%, 2%)' ; test . ok ( 'hsl(0, 1%, 2%)' === style . color , 'color is not hsl(0, 1%, 2%) ' + style . color ) ; style . color = 'rebeccapurple' ; test . ok ( 'rebeccapurple' === style . color , 'color is not rebeccapurple ' + style . color ) ;", "del_tokens": "test . expect ( 4 ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "some", "comments", "in", "the", "style", "of", "assocIn"], "add_tokens": "// simplest case is a 1-element array. Just a simple dissoc. // break the problem down. Assoc this object with the first key // and the result of dissocIn with the rest of the keys", "del_tokens": "// TODO: document // TODO: document", "commit_type": "add"}
{"commit_tokens": ["fixing", "a", "problem", "on", "2nd", "dimension", "controller", "management"], "add_tokens": "return app . drivers . logger . error ( 'Express' , 'Cannot init the driver, missing config' ) let path = route . dest . split ( '::' ) [ 0 ] , method = route . dest . split ( '::' ) [ 1 ] server [ route . method ] ( route . src , upload . single ( 'import' ) , require ( ` ${ app . root } ${ path . replace ( '.' , '/' ) } ` ) ( app ) [ method ] ) server [ route . method ] ( route . src , require ( ` ${ app . root } ${ path . replace ( '.' , '/' ) } ` ) ( app ) [ method ] )", "del_tokens": "return app . drivers . logger . error ( 'Drivers' , 'Cannot init express, no valid config' ) server [ route . method ] ( route . src , upload . single ( 'import' ) , require ( app . root + route . dest . split ( '::' ) [ 0 ] ) ( app ) [ route . dest . split ( '::' ) [ 1 ] ] ) server [ route . method ] ( route . src , require ( app . root + route . dest . split ( '::' ) [ 0 ] ) ( app ) [ route . dest . split ( '::' ) [ 1 ] ] )", "commit_type": "fix"}
{"commit_tokens": ["make", "sure", "test", "asserts", "span", "is", "now", "outer", "elem"], "add_tokens": "fragment . appendChild ( span ) ; expect ( morphedEl . nodeName ) . to . equal ( 'SPAN' ) ; expect ( morphedEl . textContent ) . to . equal ( 'World' ) ;", "del_tokens": "var div = document . createElement ( 'div' ) ; div . appendChild ( span ) ; fragment . appendChild ( div ) ; expect ( morphedEl . firstElementChild . nodeName ) . to . equal ( 'SPAN' ) ; expect ( morphedEl . firstElementChild . textContent ) . to . equal ( 'World' ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "doc", "generation", "as", "middleware"], "add_tokens": "} ; var versions = config . endpoints = endpoints . parse ( config . api ) ; } ;", "del_tokens": "} var versions = endpoints . parse ( config . api ) ; }", "commit_type": "add"}
{"commit_tokens": ["Update", "replace", "method", "with", "additional", "key", "parameter"], "add_tokens": "replacement = options . replace ( node , i ) ; // i = key // specify a \"key\" prop if element has siblings", "del_tokens": "replacement = options . replace ( node ) ; // specify a `key` prop if returning an array", "commit_type": "update"}
{"commit_tokens": ["Fixed", "JS", "bug", "in", "Chrome", "driver"], "add_tokens": "w . ping = { hostnames : { } } ;", "del_tokens": "w . ping = { } ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "readXingTag", "fix", "parsing", "of", "tag", ".", "identifier"], "add_tokens": "// There should be at least 36 (header) + 4 (\"Xing\"/\"Info\") = 40 octets ahead tag . identifier = ( lib . isSeq ( lib . seq . xing , buffer , offset + 36 ) && 'Xing' ) || ( lib . isSeq ( lib . seq . info , buffer , offset + 36 ) && 'Info' ) ;", "del_tokens": "// There should be at least 36 + 4 = 40 bytes ahead ( tag . identifier = lib . isSeq ( lib . seq . xing , buffer , offset + 36 ) ) || ( tag . identifier = lib . isSeq ( lib . seq . info , buffer , offset + 36 ) ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "uncatchable", "error", "on", "null", "map", "()", "result"], "add_tokens": "//bower.logger.debug('RHODECODE RESOLVER: Invoking finish callback...'); var tags = gitLsRemoteOutput . match ( / (^.+tags[\\/\\\\][^\\s\\^]+$) / gm ) ; if ( tags === null ) { tags = [ ] ; } else { tags = tags . map ( function ( tag ) { var _tag = tag . replace ( / ^.+tags[\\/\\\\]([^\\s\\^]+)$ / gm , '$1' ) ; return { target : _tag , version : _tag . replace ( / ^v / gm , '' ) } } ) ; } deferred . resolve ( tags ) ; } ;", "del_tokens": "var tags = gitLsRemoteOutput . match ( / (^.+tags[\\/\\\\][^\\s\\^]+$) / gm ) . map ( function ( tag ) { var _tag = tag . replace ( / ^.+tags[\\/\\\\]([^\\s\\^]+)$ / gm , '$1' ) ; return { target : _tag , version : _tag . replace ( / ^v / gm , '' ) } } ) ; deferred . resolve ( tags ) } ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "istanbul", "for", "test", "coverage"], "add_tokens": "var __get__Src = __get__ . toString ( ) , __set__Src = __set__ . toString ( ) ; /* istanbul ignore next because it will be removed soon */ appendix += \"module.exports.__set__ = \" + __set__Src + \"; \" ; appendix += \"module.exports.__get__ = \" + __get__Src + \"; \" ;", "del_tokens": "appendix += \"module.exports.__set__ = \" + __set__ . toString ( ) + \"; \" ; appendix += \"module.exports.__get__ = \" + __get__ . toString ( ) + \"; \" ;", "commit_type": "add"}
{"commit_tokens": ["improve", "logic", "on", "keyword", "exclusions"], "add_tokens": "var expected = [ 'bar' , 'baz' , 'fez' , 'foo' , 'one' , 'quux' ] ; normalize ( keywords , { omit : [ 'foo' , 'bar' ] } ) . should . eql ( [ 'baz' , 'fez' , 'one' , 'quux' ] ) ;", "del_tokens": "var expected = [ 'bar' , 'baz' , 'fez' , 'foo' , 'quux' ] ; normalize ( keywords , { omit : [ 'foo' , 'bar' ] } ) . should . eql ( [ 'baz' , 'fez' , 'quux' ] ) ;", "commit_type": "improve"}
{"commit_tokens": ["Add", "serialize", "and", "serializeKey", "options", "to", "updateParamsFromUrl", "."], "add_tokens": "serialize : false , serializeKey : 'referrer' , // Optionally serialize the keys and values into a single key and value, // and rewrite the element's attribute with the new serialized query // string. This was built specifically to do things like pass `utm_*` // parameters into a `referrer` query string, for Google Play links, e.g. // `&referrer=utm_source%3DSOURCE`. // // See https://developers.google.com/analytics/devguides/collection/android/v4/campaigns#google-play-url-builder if ( c . serialize ) { var serializedMap = { } ; serializedMap [ c . serializeKey ] = encodeQueryMap ( map ) ; url . search = encodeQueryMap ( serializedMap ) ; } else { url . search = encodeQueryMap ( map ) ; }", "del_tokens": "url . search = encodeQueryMap ( map ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "a", "conditional", "for", "armatureScale", "in", "skeletal", "animation"], "add_tokens": "if ( armatureScale ) { mat4Scale ( currentJointMatrix , currentJointMatrix , armatureScale ) }", "del_tokens": "mat4Scale ( currentJointMatrix , currentJointMatrix , armatureScale )", "commit_type": "add"}
{"commit_tokens": ["fixes", "https", ":", "//", "github", ".", "com", "/", "jonschlinkert", "/", "expand", "-", "files", "/", "issues", "/", "1"], "add_tokens": "var path = require ( 'path' ) ; var opts = config . options ; config . dest = mapDest . rename ( config . dest , config . src , opts ) ; if ( opts . cwd ) { config . src = config . src . map ( function ( fp ) { if ( hasPath ( opts . cwd , fp ) ) return fp ; return path . join ( opts . cwd , fp ) ; } ) ; } if ( typeof opts . transform === 'function' ) { config = opts . transform ( config ) ; function hasPath ( str , fp ) { var str = str . replace ( / ^\\/|\\/$ / g , '' ) ; return fp . indexOf ( str ) !== - 1 ; }", "del_tokens": "config . dest = mapDest . rename ( config . dest , config . src , config . options ) ; if ( typeof config . options . transform === 'function' ) { config = config . options . transform ( config ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "the", "_drop", "property", "(", "for", "now", ")", "and", "added", "more", "documentation"], "add_tokens": "var modelName = value . _model ; if ( _this . options . dropCollections === true ) {", "del_tokens": "var modelName = value . _model , drop = value . _drop ; delete value . _drop ; if ( _this . options . dropCollections === true && drop !== false ) {", "commit_type": "remove"}
{"commit_tokens": ["remove", "stremio", "-", "addons", "dep", "moved", "to", "using", "cinemeta", "URLs", "directly"], "add_tokens": "var fetch = require ( \"node-fetch\" ) var cinemetaUrls = { 'movie' : ' https : //cinemeta.strem.io/stremioget/stremio/v1/q.json?b=eyJwYXJhbXMiOltudWxsLHt9XSwibWV0aG9kIjoibmFtZXMubW92aWUiLCJpZCI6MSwianNvbnJwYyI6IjIuMCJ9', 'series' : ' https : //cinemeta.strem.io/stremioget/stremio/v1/q.json?b=eyJwYXJhbXMiOltudWxsLHt9XSwibWV0aG9kIjoibmFtZXMuc2VyaWVzIiwiaWQiOjEsImpzb25ycGMiOiIyLjAifQ==', } if ( query . type && ! pulled [ query . type ] && cinemetaUrls [ query . type ] ) { fetch ( cinemetaUrls [ query . type ] ) . then ( function ( resp ) { return resp . json ( ) } ) . then ( function ( resp ) { return resp . result } ) . then ( function ( res ) { } ) . catch ( function ( e ) { console . error ( e ) } ) . then ( function ( ) { match ( ) } ) } else process . nextTick ( match ) ;", "del_tokens": "var Stremio = require ( \"stremio-addons\" ) ; var stremio = new Stremio . Client ( ) ; stremio . add ( \"http://cinemeta.strem.io/stremioget/stremio/v1\" ) ; //stremio.add(\"http://localhost:3005/stremioget/stremio/v1\"); if ( query . type && ! pulled [ query . type ] ) stremio . call ( \"names.\" + query . type , { } , function ( err , res ) { if ( err ) console . error ( err ) ; if ( res ) { } match ( ) ; } ) ; else process . nextTick ( match ) ;", "commit_type": "remove"}
{"commit_tokens": ["fix", "syntax", "error", "introduced", "with", "report", ".", "errors", "fix"], "add_tokens": "errors : [ ]", "del_tokens": "errors : [ ] ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "in", "abstract", "classes", "and", "add", "more", "tests", "."], "add_tokens": "if ( initialize . caller !== this . $constructor ) {", "del_tokens": "if ( ! ( initialize . caller instanceof this . $constructor ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Change", "the", "EncryptedRpcChannel", "init", "procedure"], "add_tokens": "// - connection (required): the [Http|Tcp]Connection . // - context (required): // { authKey, serverSalt, sessionId, sequenceNumber, apiVersion } // - app (required), the application data required for execute the first API call to Telegram: // { id, version, langCode, deviceModel, systemVersion } function EncryptedRpcChannel ( connection , context , app ) { this . _app = { api_id : app . id , app_version : app . version , device_model : app . deviceModel || 'Unknown Device' , system_version : app . systemVersion || 'Unknown System' , lang_code : app . langCode || 'en' } ; this . _initialized = false ; if ( ! this . _initialized ) { var initData = require ( 'util' ) . _extend ( { query : method . serialize ( ) } , this . _app ) ; layer : this . _context . apiVersion || 23 , props : initData this . _initialized = true ;", "del_tokens": "// - [Http|Tcp]Connection, the connection must be already open (Required). // - context params (Required): // { authKey, serverSalt, sessionId, sequenceNumber } // - all the client data required for execute the first API call to Telegram (Optional): // { apiVersion, appId, appVersion, deviceModel, systemVersion, langCode } function EncryptedRpcChannel ( connection , context , clientData ) { this . _initClientData = clientData ; if ( this . _initClientData ) { layer : this . _initClientData . apiVersion || 23 , props : { api_id : this . _initClientData . appId , device_model : this . _initClientData . deviceModel || 'Unknown UserAgent' , system_version : this . _initClientData . systemVersion || 'Unknown Platform' , app_version : this . _initClientData . appVersion , lang_code : this . _initClientData . langCode || 'en' , query : method . serialize ( ) } this . _initClientData = null ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "issue", "191", "and", "192"], "add_tokens": "ctx . translate ( yAxisPosX + config . barValueSpacing + i * valueHop + ( barWidth / 2 ) - msr . highestXLabel / 2 , msr . xLabelPos ) ; ctx . fillTextMultiLine ( fmtChartJS ( config , data . labels [ i ] , config . fmtXLabel ) , yAxisPosX + config . barValueSpacing + i * valueHop + ( barWidth / 2 ) , msr . xLabelPos , ctx . textBaseline , config . scaleFontSize ) ; if ( config . legendPosY == 0 || config . legendPosY == 4 || config . legendPosX == 0 || config . legendPosX == 4 ) {", "del_tokens": "ctx . translate ( yAxisPosX + i * valueHop + ( barWidth / 2 ) - msr . highestXLabel / 2 , msr . xLabelPos ) ; ctx . fillTextMultiLine ( fmtChartJS ( config , data . labels [ i ] , config . fmtXLabel ) , yAxisPosX + i * valueHop + ( barWidth / 2 ) , msr . xLabelPos , ctx . textBaseline , config . scaleFontSize ) ; if ( config . legendPosY == 0 || config . legendPosY == 4 ) {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "the", "readMultiple", "and", "writeMultiple", "functions", "that", "were", "using", "the"], "add_tokens": "// Raw test of some labjack-nodejs stuff var t7_raw_test = require ( './t7_raw_test' ) ; // Thermocouple Tests var t7_thermocouple_speed_test = require ( './t7_thermocouple_speed_test' ) ; // exports.t7_single_channel_speed_test = t7_single_channel_speed_test.tests; // Passing // Raw tests // exports.t7_raw_test = t7_raw_test.tests; // Thermocouple Tests exports . t7_thermocouple_speed_test = t7_thermocouple_speed_test . tests ;", "del_tokens": "exports . t7_single_channel_speed_test = t7_single_channel_speed_test . tests ; // Passing", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "text", "output"], "add_tokens": "json : fragment if ( ! queryMetadata . output || ueryMetadata. o utput. i ndexOf( ' html') 1 ) fragmentObject . html = fragment . asHtml ( ctx . linkResolver , ctx . htmlSerializer ) ; } if ( queryMetadata . output && queryMetadata . output . indexOf ( 'text' ) > - 1 ) { // https://github.com/prismicio/javascript-kit/issues/104 if ( ! ( fragment instanceof Prismic . Fragments . SliceZone ) && ! ( fragment instanceof Prismic . Fragments . SliceZone ) ) { fragmentObject . text = fragment . asText ( ctx . linkResolver ) ; } }", "del_tokens": "json : fragment , html : fragment . asHtml ( ctx . linkResolver , ctx . htmlSerializer )", "commit_type": "add"}
{"commit_tokens": ["Fixing", "all", "bMoor", "JSHint", "errors"], "add_tokens": "define ( dis , settings , obj ) ; function define ( dis , settings , obj ) { dis . extend ( obj , parent ) ; dis . alias ( obj , settings . aliases ) ; dis . statics ( obj , settings . statics ) ; dis . properties ( obj , settings . properties ) ;", "del_tokens": "define . call ( dis , settings , obj ) ; function define ( settings , obj ) { this . extend ( obj , parent ) ; this . alias ( obj , settings . aliases ) ; this . statics ( obj , settings . statics ) ; this . properties ( obj , settings . properties ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "the", "component", "name", "if", "no", "reference", "is", "provided"], "add_tokens": "// Root components do not contain a $vnode, so use the name as a fallback this . $_componentId = this . $vnode ? this . $vnode . data . ref : this . $options . name ;", "del_tokens": "// We need a component id this . $_componentId = this . $vnode . data . ref || this . $vnode . componentOptions . Ctor . options . name ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "old", "call", "to", "toLowerCase", "()", "function", "."], "add_tokens": "if ( encoding ) encoding = encoding . toLowerCase ( ) ;", "del_tokens": "if ( encoding ) encoding = toLowerCase ( encoding ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "big", "in", "binding", "compilation", "."], "add_tokens": "if ( ! node . hasAttribute ( attr . name ) ) { // If this was removed already by another binding, don't process. continue ; } node . removeAttribute ( attr . name ) ;", "del_tokens": "node . removeAttributeNode ( attr ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "bootstrap", "license", "comments", "to", "pull", "directly", "from", "bootstrap", "source", "files", ";", "added", "missing", "license", "comment", "for", "bootstrap", "css"], "add_tokens": "// =require _bootstrap-license.js", "del_tokens": "/ *! * Bootstrap v4 .0 .0 - alpha .6 ( https : //getbootstrap.com) * Copyright 2011 - 2017 The Bootstrap Authors ( https : //github.com/twbs/bootstrap/graphs/contributors) * Licensed under MIT ( https : //github.com/twbs/bootstrap/blob/master/LICENSE) * /", "commit_type": "update"}
{"commit_tokens": ["Allowing", "for", "custom", "Content", "types", "to", "be", "registerd", "&", "better", "jsonp"], "add_tokens": "mime . define ( { 'text/javascript' : [ 'jsonp' ] } ) console . log ( mime . types . jsonp ) callback ( null , util . format ( \"%s(%j)\" . replace ( '\\u2028' , '\\\\u2028' ) . replace ( '\\u2029' , '\\\\u2029' ) , ( options && options . callback || this . meta . callbackKey ) , data ) ) ;", "del_tokens": "callback ( null , util . format ( \"%s(%j)\" , ( options && options . callback || this . meta . callbackKey ) , data ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "chrome", "extension", "to", "new", "architecture"], "add_tokens": "// Enable session app . use ( express . cookieParser ( ) ) ; app . use ( express . session ( { 'store' : new MongoStore ( { 'mongoose_connection' : database . connection } ) , 'secret' : config . web . sessionSecret } ) ) ;", "del_tokens": "// Enable session app . use ( express . cookieParser ( ) ) ; app . use ( express . session ( { 'store' : new MongoStore ( { 'mongoose_connection' : database . connection } ) , 'secret' : config . web . sessionSecret } ) ) ;", "commit_type": "add"}
{"commit_tokens": ["updated", "message", "for", "partial", "support"], "add_tokens": "let messages = [ ] ; if ( features [ feature ] . missing ) { messages . push ( ' not supported by: ' + features [ feature ] . missing ) ; } if ( features [ feature ] . partial ) { messages . push ( ' only partially supported by: ' + features [ feature ] . partial ) ; } let message = features [ feature ] . title + messages [ 0 ] + ( messages [ 1 ] ? ( ' and ' + messages [ 1 ] ) : '' ) + ' (' + feature + ')' ;", "del_tokens": "let message = features [ feature ] . title + ' not supported by: ' + features [ feature ] . missing + ' (' + feature + ')'", "commit_type": "update"}
{"commit_tokens": ["Allow", "query", "execution", "when", "sort", "options", "are", "present"], "add_tokens": "// console.log('Executing for', component, finalQuery); if ( ( queryObj && Object . keys ( queryObj ) . length ) || ( options && ( 'aggs' in options || 'sort' in options ) ) ) {", "del_tokens": "// console.log(\"Executing for\", component, finalQuery); if ( ( queryObj && Object . keys ( queryObj ) . length ) || ( options && 'aggs' in options ) ) {", "commit_type": "allow"}
{"commit_tokens": ["Fix", "tests", "so", "that", "they", "work", "on", "things", "that", "inherit", "from", "ampersand", "-", "view"], "add_tokens": "if ( ! Function . prototype . bind ) { Function . prototype . bind = require ( 'function-bind' ) ; } window . tests = [ ] ; function hasPropertyDefinition ( object , fieldName ) { //truthy if ( object [ fieldName ] ) { return true ; } //defined on the object, but not truthy if ( object . hasOwnProperty ( fieldName ) ) { return true ; } //Defined as a getter/setter on the prototype chain var current = object . constructor . prototype ; var fieldDefinition ; while ( current !== Object . getPrototypeOf ( { } ) ) { fieldDefinition = Object . getOwnPropertyDescriptor ( current , 'value' ) ; if ( fieldDefinition && fieldDefinition . get ) { return true ; } current = Object . getPrototypeOf ( current ) ; } return false ; } t . ok ( hasPropertyDefinition ( view , 'value' ) , 'has `value` property' + str ) ;", "del_tokens": "t . ok ( view . hasOwnProperty ( 'value' ) , 'has `value` property' + str ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "test", "around", "a", "successful", "request"], "add_tokens": "import nock from 'nock' ; import request from 'supertest' ; import slackin from '../lib/index' ; describe ( 'slackin' , ( ) => { describe ( 'POST /invite' , ( ) => { it ( \"returns success for a successful invite\" , ( done ) => { let opts = { token : 'mytoken' , org : 'myorg' } ; // TODO simplify mocking nock ( ` ${ opts . org } ` ) . get ( '/api/rtm.start?token=mytoken' ) . reply ( 200 , { team : { name : 'myteam' , icon : { } } , users : [ { } ] } ) ; nock ( ` ${ opts . org } ` ) . post ( '/api/users.admin.invite' ) . reply ( 200 , { ok : true } ) ; let app = slackin ( opts ) ; request ( app ) . post ( '/invite' ) . send ( { email : 'foo@example.com' } ) // .expect('Content-Type', /json/) . expect ( 200 , { } ) . end ( done ) ; } ) ; } ) ;", "del_tokens": "describe ( '' , ( ) => {", "commit_type": "add"}
{"commit_tokens": ["move", "method", "support", "logic", "to", "middleware"], "add_tokens": "const router = Router ( configuration ) ; Router . methods . forEach ( function ( method ) { if ( methods . indexOf ( method ) === - 1 ) { sansServer [ method ] = function ( ) { const err = Error ( 'Method not supported by sans-server instance:' + method ) ; err . code = 'ESSRMET' ; throw err ; } ; } else { sansServer [ method ] = router [ method ] ; }", "del_tokens": "const router = Router ( configuration , methods ) ; methods . forEach ( function ( method ) { if ( Router . prototype [ method ] ) sansServer [ method ] = router [ method ] ;", "commit_type": "move"}
{"commit_tokens": ["Remove", "deleted", "media", "from", "the", "generated", "HTML", "pages"], "add_tokens": "function removeDeletedFiles ( allFiles ) { var existingPaths = _ . keys ( existing ) ; var actualPaths = _ . pluck ( allFiles , 'relative' ) ; var deleted = _ . difference ( existingPaths , actualPaths ) ; deleted . forEach ( function ( key ) { delete existing [ key ] ; } ) ; return deleted . length > 0 ; } process . stdout . write ( pad ( 'List all files' , 20 ) ) ; console . log ( '[===================] done' ) ; var deleted = removeDeletedFiles ( allFiles ) ; } if ( deleted || ( count > 0 ) ) {", "del_tokens": "", "commit_type": "remove"}
{"commit_tokens": ["Added", "intervalEvent", "attribute", "and", "an", "example"], "add_tokens": ". directive ( 'timer' , function ( $rootScope , $timeout , $compile ) { countdownattr : '=countdown' , intervalevent : '=intervalevent' controller : function ( $rootScope , $scope , $element ) { $scope . intervalEvents = 0 ; //example only: should consume this event in your controller $scope . $on ( 'event:timer-interval' , function ( ) { $scope . intervalEvents ++ } ) ; if ( $scope . intervalevent != undefined && $scope . intervalevent ) { $rootScope . $broadcast ( 'event:timer-interval' ) ; }", "del_tokens": ". directive ( 'timer' , function ( $timeout , $compile ) { countdownattr : '=countdown' controller : function ( $scope , $element ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "gulp", "task", "to", "copy", "files", "from", "app", "to", "dist"], "add_tokens": "// Copy All Files At The Root Level (app) gulp . task ( 'copy' , function ( ) { return gulp . src ( [ 'app/*' , '!app/*.html' ] ) . pipe ( gulp . dest ( 'dist' ) ) . pipe ( $ . size ( { title : 'copy' } ) ) ; } ) ; runSequence ( 'styles' , [ 'jshint' , 'html' , 'images' , 'copy' ] , cb ) ;", "del_tokens": "runSequence ( 'styles' , [ 'jshint' , 'html' , 'images' ] , cb ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "docs", "and", "libs", "for", "NEXT"], "add_tokens": "s . version = /*version*/ \"NEXT\" ; // injected by build process s . buildDate = /*date*/ \"Thu, 31 Oct 2013 17:53:08 GMT\" ; // injected by build process", "del_tokens": "s . version = /*version*/ \"0.4.0\" ; // injected by build process s . buildDate = /*date*/ \"Wed, 25 Sep 2013 17:09:35 GMT\" ; // injected by build process", "commit_type": "update"}
{"commit_tokens": ["updates", "test", "to", "handle", "custom", "events", "better", "test", "structure", "adds", "helper", "file"], "add_tokens": "it ( 'should return a new event from that promise callback' , ( done ) => { load ( 'MouseEvent' , 'click' , document , center ( ) ) ( { } ) . then ( ( { event } ) => { expect ( event . clientX ) . to . not . eql ( 0 ) ; done ( ) ; } ) ; } ) ; fire ( 'mouseenter' , document , center ( ) ) ; const clip = load ( 'mousemove' , document , center ( ) ) ;", "del_tokens": "fire ( 'MouseEvent' , 'moveenter' , document , center ( ) ) ; const clip = load ( 'MouseEvent' , 'mousemove' , document , center ( ) ) ;", "commit_type": "update"}
{"commit_tokens": ["fix", "table", "error", "on", "sort"], "add_tokens": "controller : computedAlias ( 'tableComponent.parentController' ) ,", "del_tokens": "controller : computedAlias ( 'tableComponent.templateData.view.controller' ) ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "inDegree", "and", "outDegree", "to", "nodes"], "add_tokens": "function inDegree ( ) { return inEdges ( ) . length ; } function outDegree ( ) { return outEdges ( ) . length ; } function edges ( ) { return inEdges ( ) . concat ( outEdges ( ) ) ; } inDegree : inDegree , outDegree : outDegree ,", "del_tokens": "function edges ( ) { return inEdges ( ) . concat ( outEdges ( ) ) ; }", "commit_type": "add"}
{"commit_tokens": ["Add", "transactionFullHash", "on", "signTx", "with", "vault"], "add_tokens": "} ) . then ( ( { data : { error , transactionJSON , transactionBytes , transactionFullHash } } ) => { return { transactionJSON , transactionBytes , transactionFullHash } // Output: { transactionBytes, transactionJSON, transactionFullHash } . then ( ( { transactionBytes , transactionJSON , transactionFullHash } ) => ( callback ( null , { transactionBytes , transactionJSON , transactionFullHash } )", "del_tokens": "} ) . then ( ( { data : { error , transactionJSON , transactionBytes } } ) => { return { transactionJSON , transactionBytes } // Output: { transactionBytes, transactionJSON } . then ( ( { transactionBytes , transactionJSON } ) => ( callback ( null , { transactionBytes , transactionJSON } )", "commit_type": "add"}
{"commit_tokens": ["Removed", "reference", "to", "inexistent", "Node", "module"], "add_tokens": "var data = fs . readFileSync ( file , 'utf8' ) ; fs . writeFileSync ( file , data ) ;", "del_tokens": "var data = Node . fs . readFileSync ( file , 'utf8' ) ; Node . fs . writeFileSync ( file , data ) ;", "commit_type": "remove"}
{"commit_tokens": ["add", "requestID", "param", "to", "broker", ".", "call"], "add_tokens": "* @ param { any } requestID requestID ( optional ) call ( actionName , params , parentCtx , requestID ) { ctx = new Context ( { broker : this , action , params , requestID } ) ;", "del_tokens": "call ( actionName , params , parentCtx ) { ctx = new Context ( { broker : this , action , params } ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "the", "next", "(", "obj", ")", "passing", "code", ".", "All", "tests", "now", "pass", "."], "add_tokens": "proto . _iterate_stack = function ( index , req , passed_args ) { if ( passed_args === undefined ) passed_args = [ ] // DESCRIBE CODE PATH // match alls) // If this function was not given any arguments, we have nothing to do // here. if ( arguments . length > 0 ) { // Convert `arguments` to an array var args = Array . prototype . slice . call ( arguments , 0 ) Array . prototype . push . apply ( passed_args , args ) } self . _iterate_stack ( ++ index , req , passed_args ) if ( passed_args . length > 0 ) { // If we have any passed_args, put them in the middle of req & next(), // then call the handler. // Build our argument array var handler_args = [ req ] Array . prototype . push . apply ( handler_args , passed_args ) handler_args . push ( handler_callback ) // Now that we're all done, call the handler! stack_item . handler . apply ( stack_item . handler , handler_args ) } else { // We have no passed args, so just call the handler with req & next() stack_item . handler ( req , handler_callback ) }", "del_tokens": "proto . _iterate_stack = function ( index , req ) { // match alls) // Here we would process additional arguments and add them to future // stack matches, allowing middleware to inject objects in the stack. // For now this feature is being left out. self . _iterate_stack ( ++ index , req ) // Now that we're all done, call the handler! stack_item . handler ( req , handler_callback )", "commit_type": "add"}
{"commit_tokens": ["remove", "stack", "collecting", "in", "css", "extract"], "add_tokens": "'shash' : function ( token , parent ) { 'clazz' : function ( token , parent ) {", "del_tokens": "var stackRequired = flow . options . cssCutUnused ; // parse 'shash' : function ( token , parent , stack ) { if ( stackRequired ) entry . stack = stack . slice ( stack . length - 4 ) . reverse ( ) ; 'clazz' : function ( token , parent , stack ) { if ( stackRequired ) entry . stack = stack . slice ( stack . length - 4 ) . reverse ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "npmPublish", "tool", "and", "some", "documentation"], "add_tokens": "manifests : [ 'package.json' , 'testbower.json' ] , noWrite : true , clean : undefined , branch : [ 'master' ] , syncVersion : true , updateConfig : 'pkg' , add : 'package.json' , tasks : [ 'jshint' , 'jshint' ] target : '' , tags : true , } , npmPublish : { message : 'Released {%= version %}' , } , make_patch : { common : { // defaults for all tools manifests : [ 'package.json' , 'testbower.json' ] , noWrite : true , } , check : { clean : true , branch : [ 'master' ] } , bump : { } , commit : { } , tag : { } , run : { tasks : [ 'jshint' ] } , push : { } , bump_develop : { inc : 'prepatch' }", "del_tokens": "manifests : [ 'package.json' , 'testbower.json' ] // 'check': Assert preconditons and fail otherwise clean : undefined , // Repo must/must not contain modifications? branch : [ 'master' ] , // Current branch must be in this list // 'bump': increment manifest.version and synchronize with other JSON files. // bump also requires a mode // inc: null, // Used instead of 'yabs:target:INC' syncVersion : true , // Only increment master manifest, then copy to secondaries // space: 2, // Used by JSON.stringify updateConfig : 'pkg' , // Make sure pkg.version contains new value // Synchronize entries from master to secondaries // (if exist in target) // 'commit': Commit all manifest files (and optionally others) add : 'package.json' , // Also add these files (\".\" for all) // 'tag': Create a tag // 'run': Run arbitrary grunt tasks (must also be defined in this Gruntfile) tasks : [ 'jshint' ] // 'push': push changes and tags target : '' , // e.g. 'upstream', tags : true , // Also 'push --tags'", "commit_type": "add"}
{"commit_tokens": ["Fixing", "bug", "where", "last", "param", "becomes", "empty", "if", "contains", "0"], "add_tokens": "\"provider\" : provider \"value\" : value \"appliesTo\" : appliesTo \"appliesTo\" : appliesTo \"userProperties\" : userProperties \"dataName\" : dataName \"dataValue\" : dataValue \"dataName\" : dataName \"dataValue\" : dataValue \"dataFlags\" : dataFlags \"challengeFlags\" : challengeFlags \"notifierName\" : notifierName", "del_tokens": "\"provider\" : provider || { } \"value\" : value || { } \"appliesTo\" : appliesTo || { } \"appliesTo\" : appliesTo || { } \"userProperties\" : userProperties || { } \"dataName\" : dataName || { } \"dataValue\" : dataValue || { } \"dataName\" : dataName || { } \"dataValue\" : dataValue || { } \"dataFlags\" : dataFlags || { } \"challengeFlags\" : challengeFlags || { } \"notifierName\" : notifierName || { }", "commit_type": "fix"}
{"commit_tokens": ["fix", "dev", "code", "for", "webpack", "compatibility"], "add_tokens": "if ( process . env . NODE_ENV !== 'production' ) { Object . defineProperty ( this . onList , \"name\" , { value : \"live.list new list::\" + canReflect . getName ( observableOrList ) , } ) ; Object . defineProperty ( this . onPatchesNotify , \"name\" , { value : \"live.list notify::\" + canReflect . getName ( observableOrList ) , } ) ; Object . defineProperty ( this . onPatchesDerive , \"name\" , { value : \"live.list derive::\" + canReflect . getName ( observableOrList ) , } ) ; }", "del_tokens": "Object . defineProperty ( this . onList , \"name\" , { value : \"live.list new list::\" + canReflect . getName ( observableOrList ) , } ) ; Object . defineProperty ( this . onPatchesNotify , \"name\" , { value : \"live.list notify::\" + canReflect . getName ( observableOrList ) , } ) ; Object . defineProperty ( this . onPatchesDerive , \"name\" , { value : \"live.list derive::\" + canReflect . getName ( observableOrList ) , } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "typo", "that", "broke", "error", "handling", "."], "add_tokens": "return \"this.data\" + this . bindster_error_prefix + bind ;", "del_tokens": "return \"this.data.\" + this . bindster_error_prefix + bind ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "suspicious", "dispose", "implementations", "in", "goog", ".", "ui", "."], "add_tokens": "goog . ui . PlainTextSpellChecker . superClass_ . disposeInternal . call ( this ) ;", "del_tokens": "goog . ui . PlainTextSpellChecker . superClass_ . disposeInternal . call ( this ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "=", "and", ";", "to", "satisfy", "jshint"], "add_tokens": "if ( node === undefined ) { node . sortImportance = 0 ; }", "del_tokens": "if ( node == undefined ) { node . sortImportance = 0 }", "commit_type": "add"}
{"commit_tokens": ["remove", "setter", "support", "add", "listener", "support"], "add_tokens": "delegate ( attribute ( 'disabled' ) . listen ( ( el , odlValue , newValue ) => { el . querySelector ( 'button[type=button]' ) . disabled = newValue ; delegate ( attribute ( 'readonly' ) . setter ( ( el , odlValue , newValue ) => { el . querySelector ( 'button[type=button]' ) . disabled = newValue ;", "del_tokens": "delegate ( attribute ( 'disabled' ) . setter ( ( el , value ) => { el . querySelector ( 'button[type=button]' ) . disabled = value ; return value ; delegate ( attribute ( 'readonly' ) . setter ( ( el , value ) => { el . querySelector ( 'button[type=button]' ) . disabled = value ; return value ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "addEventListener", "removeEventListener", "to", "the", "window", "stub"], "add_tokens": "\" window = {Date: Date,addEventListener : function() {},removeEventListener : function() {}};\\n\" +", "del_tokens": "\" window = {Date: Date};\\n\" +", "commit_type": "add"}
{"commit_tokens": ["change", "dep", "lodash", ".", "flatten", "-", ">", "flatten"], "add_tokens": "var flatten = require ( 'flatten' )", "del_tokens": "var flatten = require ( 'lodash.flatten' )", "commit_type": "change"}
{"commit_tokens": ["change", "transpile", "command", "line", "option", "to", "build"], "add_tokens": ". option ( '-b, --build' , 'Transpile all files specified in the files property in zwitterion.json to the corresponding location in the specified output directory (--output-dir)' ) if ( build ) {", "del_tokens": ". option ( '-y, --transpile' , 'Transpile all files specified in the files property in zwitterion.json to the corresponding location in the specified output directory (--output-dir)' ) if ( transpile ) {", "commit_type": "change"}
{"commit_tokens": ["add", "label", "array", "to", "onChange", "second", "param", "make", "forward", "compatibility"], "add_tokens": "treeDefaultExpandAll = { false } treeDefaultExpandAll = { false }", "del_tokens": "treeDefaultExpandAll treeDefaultExpandAll", "commit_type": "add"}
{"commit_tokens": ["Add", "function", "to", "retrieve", "underlying", "express", "app", "in", "http", "module"], "add_tokens": "enableSwagger : enableSwagger , getApp : getApp } function getApp ( ) { return app ;", "del_tokens": "enableSwagger : enableSwagger", "commit_type": "add"}
{"commit_tokens": ["fixed", "Branch", "Universal", "Object", "methods"], "add_tokens": "", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "changeHeight", "and", "changeAspect", "method"], "add_tokens": "base . changeAspect = function ( aspect ) { opts . aspect = aspect ; base . height = base . width * opts . aspect ; svg . setAttributeNS ( null , \"height\" , base . height ) ; } base . changeHeight = function ( height ) { base . height = height ; opts . aspect = base . height / base . width ; svg . setAttributeNS ( null , \"height\" , base . height ) ; }", "del_tokens": "console . log ( parent )", "commit_type": "add"}
{"commit_tokens": ["updated", "internal", "var", "for", "semantics"], "add_tokens": "var decorators = [ ] ; var group = decorators [ id ] ; group = decorators [ id ] = { } ;", "del_tokens": "var middles = [ ] ; var group = middles [ id ] ; group = middles [ id ] = { } ;", "commit_type": "update"}
{"commit_tokens": ["Add", "the", "right", "comment", "token", "to", "maintain", "minimized", "version", "with", "license", "comments"], "add_tokens": "/ *!", "del_tokens": "/ **!", "commit_type": "add"}
{"commit_tokens": ["Add", "description", "field", "to", "all", "input", "type", "components", "."], "add_tokens": "} , \"description\" : \"Some arbitrary text explaining how this all works. \" + \"It's cool if this wraps across multiple lines\" \"defaultValue\" : false , \"description\" : \"Some arbitrary text explaining how this all works. \" + \"It's cool if this wraps across multiple lines\" \"sunlight\" : true , \"description\" : \"Some arbitrary text explaining how this all works. \" + \"It's cool if this wraps across multiple lines\" ] , \"description\" : \"Some arbitrary text explaining how this all works. \" + \"It's cool if this wraps across multiple lines\" ] , \"description\" : \"Some arbitrary text explaining how this all works. \" + \"It's cool if this wraps across multiple lines\" } , \"description\" : \"Some arbitrary text explaining how this all works. \" + \"It's cool if this wraps across multiple lines\"", "del_tokens": "} \"defaultValue\" : false \"sunlight\" : true ] ] }", "commit_type": "add"}
{"commit_tokens": ["Added", "copying", "html", "for", "server"], "add_tokens": "grunt . task . run ( [ 'clean:html' , 'copy:html' , 'assemble:production' ] ) : grunt . task . run ( [ 'clean:html' , 'copy:html' , 'assemble:development' ] ) ;", "del_tokens": "grunt . task . run ( [ 'clean:html' , 'assemble:production' ] ) : grunt . task . run ( [ 'clean:html' , 'assemble:development' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "grunt", "publishdocs", "task", "to", "publish", "the", "docs", "to", "the", "gh", "-", "pages", "branch"], "add_tokens": "docs : [ 'docs' ] } , jshint : { files : [ 'familysearch-javascript-sdk.js' ] , options : { jshintrc : '.jshintrc' } 'gh-pages' : { base : 'docs' , message : 'Update docs' } , local : { src : [ '**/*' ] } , travis : { options : { repo : 'https://' + process . env . GH_TOKEN + '@github.com/rootsdev/familysearch-javascript-sdk.git' , silent : true } , src : [ '**/*' ] grunt . loadNpmTasks ( 'grunt-ngdocs' ) ; grunt . loadNpmTasks ( 'grunt-gh-pages' ) ; grunt . registerTask ( 'publishdocs' , [ 'docs' , 'gh-pages:local' ] ) ;", "del_tokens": "docs : [ 'docs/*' ] jshint : { files : [ 'familysearch-javascript-sdk.js' ] , jshintrc : '.jshintrc' // Load the plugin that provides the documentation task grunt . loadNpmTasks ( 'grunt-ngdocs' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "with", "previous", "button", "locking", "up"], "add_tokens": "* teeble - v0 .3 .6 - 2013 - 12 - 23 * Licensed MIT var html , info , page , pages ; _results . push ( { } ) ; prev_disabled : info . previous === false , next_disabled : info . next === false , this . $el . empty ( ) . append ( \"<table><tbody></tbody></table>\" ) ; } ) . call ( this ) ;", "del_tokens": "* teeble - v0 .3 .4 - 2013 - 10 - 25 * Licensed MIT var html , info , p , page , pages ; p = { } ; _results . push ( p ) ; prev_disabled : info . previous === false || info . hasPrevious === false , next_disabled : info . next === false || info . hasNext === false , this . $el . empty ( ) . append ( \"<table><tbody></tbody></table\" ) ; } ) . call ( this ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "multimap", "client", "update", "bug"], "add_tokens": "//console.log('put-added: ' + key + ' -> ' + edit.id) //console.log('now: ' + JSON.stringify(Object.keys(this.obj))) //if(key === '645_90') console.log('now-values: ' + JSON.stringify(this.obj)) } //else{ // console.log('already got: ' + key) //} //console.log('deleted key: ' + key) if ( this . valueCache && this . valueCache [ key ] ) { delete this . valueCache [ key ] } //console.log('now: ' + JSON.stringify(Object.keys(this.obj)))", "del_tokens": "} else { } //console.log('key: ' + key)", "commit_type": "fix"}
{"commit_tokens": ["fixed", "a", "bug", "with", "DOMEvents", "transitions", "on", "StatefulView"], "add_tokens": "} else events = this . events = { } ;", "del_tokens": "} else events = { } ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "examples", ":", "no", "parallels", "anymore"], "add_tokens": "* Exceptions inside of a Sync . Future * see examples / future . js for more details about Sync . Future var result1 = someAsyncFunction . future ( null , 2 , 2 ) , result2 = someAsyncFunction . future ( null , 3 , 3 ) ; result1 . yield ( ) ; result2 . yield ( ) ;", "del_tokens": "* Exceptions inside of a Sync . Parallel * see examples / parallel . js for more details about Sync . Parallel var results = Sync . Parallel ( function ( callback ) { someAsyncFunction ( 2 , 2 , callback ( ) ) ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "some", "support", "for", "2d", "&", "3d", "transformations", ".", "Fixed", "startDelay", "to", "work", ".", "Some", "things", "are", "not", "working", ".", "Many", "efficiency", "problems", "will", "be", "fixed", "soon", ".", "Added", "documentation"], "add_tokens": "var resp = JSON . parse ( event . data ) ;", "del_tokens": "try { var resp = JSON . parse ( event . data ) ; } catch ( e ) { console . log ( e ) ; return ; }", "commit_type": "add"}
{"commit_tokens": ["added", "missing", "tests", "for", "match", "element", "by", "ID", "/", "testID"], "add_tokens": "import * as Screens from './src/Screens' { this . renderScreenButton ( 'Matchers' , Screens . MatchersScreen ) }", "del_tokens": "import * as Screens from './src/screens'", "commit_type": "add"}
{"commit_tokens": ["added", "test", "for", "async", "setter"], "add_tokens": "\"ecmaVersion\" : 2017 , \"quotes\" : [ 2 , \"single\" , { \"avoidEscape\" : true , \"allowTemplateLiterals\" : true } ] ,", "del_tokens": "\"quotes\" : [ 2 , \"single\" , { \"avoidEscape\" : true , \"allowTemplateLiterals\" : true } ] ,", "commit_type": "add"}
{"commit_tokens": ["Removed", "reliance", "on", "bluebird", "cancel", "()", "."], "add_tokens": "this . _update ( ) ; this . _update ( ) ; if ( this . _task ) { this . _task . cancelled = true ; } this . _task = { cancelled : false } this . _plugin . create . call ( this , this . _datavis , this . _view , hidden , false , this . _task ) . then ( ( ) => { this . _task . cancelled = true ; this . _task = { cancelled : false } this . _plugin . create . call ( this , this . _datavis , this . _view , hidden , true , this . _task ) . then ( ( ) => {", "del_tokens": "update . call ( this ) ; update . call ( this ) ; this . _plugin . create . call ( this , this . _datavis , this . _view , hidden , false ) . then ( ( ) => { this . _task . cancel ( ) ; this . _task = this . _plugin . create . call ( this , this . _datavis , this . _view , hidden , true ) . then ( ( ) => {", "commit_type": "remove"}
{"commit_tokens": ["Use", "the", "checkIfTypeIsBare", "method", "also", "on", "the", "serialization"], "add_tokens": "var isBareCheck = checkIfTypeIsBare ( typeName ) ; var isBare = isBareCheck . isBare ; typeName = isBareCheck . typeName ;", "del_tokens": "var isBare = typeName . charAt ( 0 ) === '%' ; typeName = isBare ? typeName . slice ( 1 ) : typeName ;", "commit_type": "use"}
{"commit_tokens": ["remove", "calling", "argument", ".", "slice", "in", "step", "-", "function", "s", "iterator"], "add_tokens": "var xArgs = args", "del_tokens": "var xArgs = utils . slice ( args )", "commit_type": "remove"}
{"commit_tokens": ["Remove", "url", "formatting", "in", "publicPath", "."], "add_tokens": "publicPath += '/' ;", "del_tokens": "var urlModule = require ( 'url' ) ; publicPath = path . join ( urlModule . resolve ( publicPath + '/' , '.' ) , '/' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "new", "data", "blobs", "for", "testing", ";", "Added", "callback", "function", "that", "return", "value", "at", "mouse", "position", ";", "Small", "style", "changes", ";"], "add_tokens": "var max_range = 13600 ; var min_label = document . getElementById ( \"min_label\" ) ; min_label . innerHTML = min_range ; var max_label = document . getElementById ( \"max_label\" ) ; max_label . innerHTML = max_range ; var measurevalue = document . getElementById ( \"measurevalue\" ) ; function showvalue ( val ) { measurevalue . innerHTML = \"Value: \" + val ; } plot = new plotty . plot ( [ min_range , max_range ] , el , data , width , height , showvalue ) ; min_label . innerHTML = min_range ; max_label . innerHTML = max_range ;", "del_tokens": "var max_range = 13000 ; document . getElementById ( \"min_label\" ) . innerHTML = min_range ; document . getElementById ( \"max_label\" ) . innerHTML = max_range ; plot = new plotty . plot ( [ min_range , max_range ] , el , data , width , height ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "shortcuts", "for", "all", "the", "inputs", "and", "stats"], "add_tokens": "var algo = require ( './algorithms.js' ) , input = require ( './input.js' ) . input ( ) , stat = require ( './stat.js' ) . stat ( ) , config = require ( './config.js' ) . config ( ) ; if ( config . sampleContent ) { var models = require ( './sampleContent/starter.js' ) . starter ( urlOfDB ) ; } stat : stat , liked : input . liked , disliked : input . disliked , recommendFor : stat . recommendFor , bestRated : stat . bestRated , worstRated : stat . worstRated , mostLiked : stat . mostLiked , mostDisliked : stat . mostDisliked , usersWhoLikedAlsoLiked : stat . usersWhoLikedAlsoLiked , mostSimilarUsers : stat . mostSimilarUsers , leastSimilarUsers : stat . leastSimilarUsers , likedBy : stat . likedBy , likedCount : stat . likedCount , dislikedBy : stat . dislikedBy , dislikedCount : stat . dislikedCount , allLikedFor : stat . allLikedFor , allDislikedFor : stat . allDislikedFor , allWatchedFor : stat . allWatchedFor", "del_tokens": "var models = require ( './sampleContent/starter.js' ) . starter ( urlOfDB ) , algo = require ( './algorithms.js' ) ; input = require ( './input.js' ) . input ( ) ; stat = require ( './stat.js' ) . stat ( ) ; stat : stat", "commit_type": "add"}
{"commit_tokens": ["Improve", "the", "responseMatches", "assertion", "with", "debug", "output"], "add_tokens": "this . actualContent = actual . send . getCall ( 0 ) . args [ 0 ] ; r = r && ( this . actualContent === expectedResponse . content ) ; assertMessage : \"Expected ${0} to produce response '${1}' (was '${actualContent}')!\" ,", "del_tokens": "r = r && ( actual . send . getCall ( 0 ) . args [ 0 ] === expectedResponse . content ) ; assertMessage : \"Expected ${0} to produce response '${1}'!\" ,", "commit_type": "improve"}
{"commit_tokens": ["Fixing", "active", "user", "for", "ringr"], "add_tokens": "routeInfo = webRouteHandler . getRouteInfo ( appName , url , request . query , request . app . lang , request . user ) ;", "del_tokens": "routeInfo = webRouteHandler . getRouteInfo ( appName , url , request . query , request . app . lang ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "addDecls", "to", "work", "with", "@", "rules"], "add_tokens": "ruleSelector = rule . selector ; if ( rule . type === 'atrule' ) { console . log ( rule . parent . type ) ; ruleSelector = ( rule . parent && rule . parent . type === 'rule' ) ? rule . parent . selector : '' ; } postcss . list . comma ( ruleSelector ) . forEach ( ( sel ) => { newSelector = ` ${ newSelector } ${ toAdd } ` ; if ( rule . type === 'atrule' ) { newSelector = ` ${ rule . name } ${ rule . params } ${ newSelector } ` ; } console . log ( newSelector ) ; css . insertBefore ( rule , ` ${ selector } ` ) ; css . insertAfter ( rule , ` ${ selector } ` ) ;", "del_tokens": "postcss . list . comma ( rule . selector ) . forEach ( ( sel ) => { css . insertBefore ( rule , ` ${ selector } ${ toAdd } ` ) ; css . insertAfter ( rule , ` ${ selector } ${ toAdd } ` ) ;", "commit_type": "update"}
{"commit_tokens": ["change", "routeParamKey", "-", ">", "routeIdAttribute", "to", "be", "in", "line", "with", "model", "idAttribute", "field", "(", "req", "by", "@funkytek", ")"], "add_tokens": "var routeIdAttribute = this . getParams ( ) [ this . routeIdAttribute ] ; routeIdAttribute && routeIdAttribute !== this . model . getId ( ) ) { var routeIdAttribute = this . getParams ( ) [ this . routeIdAttribute ] ; if ( routeIdAttribute ) { this . props . id = routeIdAttribute ;", "del_tokens": "var routeParamId = this . getParams ( ) [ this . routeParamKey ] ; routeParamId && routeParamId !== this . model . getId ( ) ) { var routeParamId = this . getParams ( ) [ this . routeParamKey ] ; if ( routeParamId ) { this . props . id = routeParamId ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "error", "on", "embark", "deploy", "when", "deploying", "contracts", "from", "new", "boilerplate"], "add_tokens": "contractObject [ \"new\" ] . apply ( contractObject , contractParams ) ; contractAddress = undefined ; // TODO;", "del_tokens": "contractAddress = contractObject [ \"new\" ] . apply ( contractObject , contractParams ) . address ;", "commit_type": "fix"}
{"commit_tokens": ["added", "a", "if", "for", "the", "case", "when", "defaults", "don", "t", "exist"], "add_tokens": "if ( ops . defaults ) { for ( var op in ops . optional ) { k = op ; if ( ops . defaults [ op ] ) { k = k + \"=\" + ops . defaults [ k ] ; } childHelp . add ( 'Optional Flags' , \"--\" + k , ops . optional [ op ] ) ; }", "del_tokens": "for ( var op in ops . optional ) { k = op ; if ( ops . defaults [ op ] ) { k = k + \"=\" + ops . defaults [ k ] ; } childHelp . add ( 'Optional Flags' , \"--\" + k , ops . optional [ op ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Implemented", "octant", "-", "based", "countPoints", "method", "."], "add_tokens": "* Counts how many points are in this octant . * @ method countPoints * @ return { Number } The amount of points . countPoints ( ) { const heap = [ this ] ; let result = 0 ; let octant , children ; while ( heap . length > 0 ) { octant = heap . pop ( ) ; children = octant . children ; if ( children !== null ) { heap . push ( ... children ) ; } else if ( octant . points !== null ) { result += octant . points . length ; } } return result ; }", "del_tokens": "bias = Math . max ( 0.0 , x ) ; biasSquared = bias * bias ;", "commit_type": "implement"}
{"commit_tokens": ["Moved", "CSS", "positioning", "code", "into", "separate", "function", "."], "add_tokens": "setTipPosition ( session . currentX + options . offset , session . currentY + options . offset ) ; // position the tooltip setTipPosition ( x , y ) ; // position the tooltip setTipPosition ( Math . round ( x ) , Math . round ( y ) ) ; } / ** * Sets the tooltip CSS position on the document . * @ private * @ param { Number } x Left position in pixels . * @ param { Number } y Top position in pixels . * / function setTipPosition ( x , y ) { tipElement . css ( 'left' , x + 'px' ) ; tipElement . css ( 'top' , y + 'px' ) ;", "del_tokens": "tipElement . css ( 'left' , session . currentX + options . offset + 'px' ) ; tipElement . css ( 'top' , session . currentY + options . offset + 'px' ) ; // set the css tipElement . css ( 'left' , x + 'px' ) ; tipElement . css ( 'top' , y + 'px' ) ; // set the css position tipElement . css ( 'left' , Math . round ( x ) + 'px' ) ; tipElement . css ( 'top' , Math . round ( y ) + 'px' ) ;", "commit_type": "move"}
{"commit_tokens": ["Use", "statuses", "instead", "of", "http", "module", "for", "status", "messages"], "add_tokens": "* @ private var statuses = require ( 'statuses' ) * @ param { number } status * @ param { Error } [ error ] * @ private SendStream . prototype . error = function error ( status , error ) { var msg = statuses [ status ] ; var err = error || new Error ( msg ) ;", "del_tokens": ", http = require ( 'http' ) * @ param { Number } status * @ api private SendStream . prototype . error = function ( status , err ) { var msg = http . STATUS_CODES [ status ] ; err = err || new Error ( msg ) ;", "commit_type": "use"}
{"commit_tokens": ["removed", "trailing", "slash", "from", "count", "uri"], "add_tokens": "var uri_count = util . format ( apiUri + '/count' , options . prefix , options . version , model . modelName ) ;", "del_tokens": "var uri_count = util . format ( apiUri + '/count/' , options . prefix , options . version , model . modelName ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "error", "message", "thrown", "if", "there", "is", "a", "loop", "/", "missing", "dep", "in", "particles"], "add_tokens": "self . log ( 'warn' , \"There is a loop or missing requirement in the particles dependencies\" , dependencies ) ;", "del_tokens": "self . log ( 'warn' , \"There is a cicle or missing requirement in the particles dependencies \" , dependencies ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "always", "-", "multi", "-", "line", "to", "block", "-", "closing", "-", "brace", "-", "space", "-", "before"], "add_tokens": "expectedBeforeSingleLine : ( ) => \"Expected single space before \\\"}\\\" of a single-line block\" , rejectedBeforeSingleLine : ( ) => \"Unexpected space before \\\"}\\\" of a single-line block\" , expectedBeforeMultiLine : ( ) => \"Expected single space before \\\"}\\\" of a multi-line block\" , rejectedBeforeMultiLine : ( ) => \"Unexpected space before \\\"}\\\" of a multi-line block\" , * @ param { \"always\" | \"never\" | \"always-single-line\" | \"never-single-line\" | \"always-multi-line\" | \"never-multi-line\" } expectation const blockStringNoSelector = blockString . slice ( blockString . indexOf ( \"{\" ) ) } , blockStringNoSelector )", "del_tokens": "* @ param { \"always\" | \"never\" } expectation } )", "commit_type": "add"}
{"commit_tokens": ["add", "yarn", "lock", "+", "autocomplete"], "add_tokens": "jsOptions = { } , autocomplete = false", "del_tokens": "jsOptions , autocomplete", "commit_type": "add"}
{"commit_tokens": ["adds", "rte", "dest", "handling", "updates", "plugin", "loading"], "add_tokens": "var rte = require ( './plugins/rte' ) ; var destObj = require ( './plugins/dest-obj' ) ; var readme = require ( './plugins/readme' ) ; // 'dest:path': destObj.call(verb, dest, locals), // 'dest:readme': readme.call(verb, locals), 'dest:render' : render . call ( verb , locals ) , 'dest:readme' : readme . call ( verb , locals ) , // 'dest:rte': rte.call(verb, dest, locals)", "del_tokens": "var destPath = require ( './plugins/dest' ) ; // if (verb.enabled('minimal') || plugins.length === 0) { // return es.pipe.apply(es, []); // } // 'dest:path': destPath.call(verb, dest, locals), 'dest:render' : render . call ( verb , locals )", "commit_type": "add"}
{"commit_tokens": ["Fixed", ":", "message", "for", "nodeamon", "mode"], "add_tokens": "if ( process . argv [ 2 ] != 'nodeamon' ) { console . log ( 'Daemon started successfully' ) ; }", "del_tokens": "console . log ( 'Daemon started successfully' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "for", "pre", "-", "render", "scenario"], "add_tokens": "this . attrs [ 'name' ] = this . name + \"_file\" ; this . attrs [ 'id' ] = 'id_' + this . attrs [ 'name' ] ; this . value = null ;", "del_tokens": "this . name += \"_file\" ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "key", "returning", "in", "Emoji", ".", "random"], "add_tokens": "var key = emojiKeys [ randomIndex ] ; var emoji = Emoji . _get ( key ) ;", "del_tokens": "var emoji = Emoji . _get ( emojiKeys [ randomIndex ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "contraints", "assigning", "a", "type", "(", "atom", ")"], "add_tokens": "// Process a single constraint consisting of two feature paths // Process a single constraint consisting of two feature paths ProductionRule . prototype . process_constraint_type = function ( constraint , type_lattice ) { logger . debug ( 'ProductionRule.process_constraint_type: enter: ' + JSON . stringify ( constraint ) ) ; var current_fs = this . fs ; constraint . left . forEach ( function ( feature ) { var new_fs = featureStructureFactory . createFeatureStructure ( { } ) ; current_fs . add_feature ( feature , new_fs , type_lattice ) ; current_fs = current_fs . features [ feature ] ; } ) ; var type = type_lattice . get_type_by_name ( constraint . right ) ; current_fs . type = type ; logger . debug ( 'ProductionRule.process_constraint_type: exit: ' + JSON . stringify ( this . fs ) ) ; } ; if ( typeof ( c . right ) === \"string\" ) { that . process_constraint_type ( c , type_lattice ) ; } else { that . process_constraint ( c , type_lattice ) ; }", "del_tokens": "// Process a single constraint that . process_constraint ( c , type_lattice ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "override", "native", "console", "proxy"], "add_tokens": "* @ param { Function | Object } thing * @ returns { Object | null } return null ;", "del_tokens": "* @ param { * } thing * @ returns { * }", "commit_type": "add"}
{"commit_tokens": ["changed", "dodgey", "naming", "convention", "for", "begin", "and", "end", "files"], "add_tokens": "util . defs ( ( __lib__ = util . expose ( __lib__ , Name , util . ENV == 'commonjs' ? module : util . global ) ) , { get : get , is : is , type : type , register : register } , 'w' , true ) ; util . expose ( util , __lib__ ) ; // store a reference to m8 on id8 anon_list . Class_constructor = true ; // add these two method names to the anonymous function names list anon_list . Class_instance_method = true ; // this will give us more clarity when debugging // extend Function and Object natives with id8's extensions if not sandboxed // or sandboxed environment's natives with all m8 AND id8 extensions util . x ( Object , Array , Boolean , Function ) ;", "del_tokens": "util . defs ( ( __lib__ = util . expose ( __lib__ , Name , util . ENV == 'commonjs' ? module : util . global ) ) , { get : get , is : is , type : type , register : register } , 'w' , true ) ; util . expose ( util , __lib__ ) ; // store a reference to m8 on id8 anon_list . Class_constructor = true ; // add these two method names to the anonymous function names list anon_list . Class_instance_method = true ; // this will give us more clarity when debugging // extend Function and Object natives with id8's extensions if not sandboxed // or sandboxed environment's natives with all m8 AND id8 extensions util . x ( Object , Array , Boolean , Function ) ; // make_processable( class_name );", "commit_type": "change"}
{"commit_tokens": ["Added", "tests", "for", "TagSoup", "parsing"], "add_tokens": "cm . load ( BilibiliParser ( f , xmlhttp . responseText ) ) ; cm . load ( BilibiliParser ( xmlhttp . responseXML , xmlHTTP . responseText ) ) ;", "del_tokens": "cm . load ( BilibiliParser ( f ) ) ; cm . load ( BilibiliParser ( xmlhttp . responseXML ) ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "MW", "from", "exact", "molecule"], "add_tokens": "const cHelperRings = OCL . Molecule . cHelperRings ; molecule . ensureHelperArrays ( cHelperRings ) ; const queryMW = getMW ( query ) ; const queryMW = getMW ( query ) ; function getMW ( query ) { let copy = query . getCompactCopy ( ) ; copy . setFragment ( false ) ; return copy . getMolecularFormula ( ) . relativeWeight ; }", "del_tokens": "molecule . ensureHelperArrays ( 3 ) ; const queryMW = query . getMolecularFormula ( ) . relativeWeight ; const queryMW = query . getMolecularFormula ( ) . relativeWeight ;", "commit_type": "use"}
{"commit_tokens": ["use", "_", ".", "each", "to", "limit", "variable", "scope"], "add_tokens": "_ . each ( [ 'core' , 'utils' , 'parse' , 'render' , 'attributes' , 'traversing' , 'manipulation' ] , function ( name ) { require ( './api/' + name + '.js' ) ; } ) ;", "del_tokens": "var api = [ 'core' , 'utils' , 'parse' , 'render' , 'attributes' , 'traversing' , 'manipulation' ] ; for ( var t = 0 ; t < api . length ; t ++ ) { require ( './api/' + api [ t ] + '.js' ) ; }", "commit_type": "use"}
{"commit_tokens": ["Allow", "relative", "condition", "module", "names"], "add_tokens": "var conditionExportIndex = conditionModule . replace ( / ^(?:\\.+\\/)+. / g , \"\" ) // removes './' or '../' in relative names . indexOf ( \".\" ) ; return pluginLoader [ \"import\" ] ( conditionModule , { name : parentName , address : parentAddress } )", "del_tokens": "if ( conditionModule [ 0 ] === \".\" || conditionModule . indexOf ( \"/\" ) !== - 1 ) { throw new TypeError ( \"Invalid condition \" + conditionalMatch [ 0 ] + \"\\n\\tCondition modules cannot contain . or / in the name.\" ) ; } var conditionExportIndex = conditionModule . indexOf ( \".\" ) ; return pluginLoader [ \"import\" ] ( conditionModule , parentName , parentAddress )", "commit_type": "allow"}
{"commit_tokens": ["Add", "rail", ">", "range", "change", "CSS", "a", "bit"], "add_tokens": "this . body . range = document . createElement ( 'div' ) this . body . range . classList . add ( 'jsr_range' ) this . body . rail . appendChild ( this . body . range ) ; this . body . rail . appendChild ( this . body . sliders . from ) this . body . rail . appendChild ( this . body . sliders . to ) _toUpdate : [ 'range' , 'sliders' , 'info' , 'values' ] , range : function ( ) { // Calc range position _this . body . range . style . left = ` ${ start * 100 } ` _this . body . range . style . width = ` ${ ( end - start ) * 100 } `", "del_tokens": "this . body . sliders . from , this . body . sliders . to , _toUpdate : [ 'rail' , 'sliders' , 'info' , 'values' ] , rail : function ( ) { // Calc rail color position // Calc real start (because of weird percentage work) let realStart = start / ( 1 - ( end - start ) ) // Sets colored part of rail // Expects percentages without % sign _this . body . rail . style . backgroundPosition = ` ${ realStart * 100 } ` _this . body . rail . style . backgroundSize = ` ${ ( end - start ) * 100 } `", "commit_type": "add"}
{"commit_tokens": ["Changed", "help", "output", "in", "init"], "add_tokens": "console . log ( pad ( 'captain run' ) ) ;", "del_tokens": "console . log ( pad ( 'npm start' ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "a", "jshint", "warning", "about", "global", ".", "ELEMENT_REGISTRY"], "add_tokens": "result . contextInfo . issuer . indexOf ( \"element-registry\" ) !== - 1 && global . ELEMENT_REGISTRY && ! global . ELEMENT_REGISTRY [ result . request ] ) { if ( result . contextInfo . issuer . indexOf ( \"bundle-entry-points\" ) !== - 1 && global . ELEMENT_REGISTRY && ! global . ELEMENT_REGISTRY [ result . request ] ) {", "del_tokens": "result . contextInfo . issuer . indexOf ( \"element-registry\" ) !== - 1 && global [ \"ELEMENT_REGISTRY\" ] && ! global [ \"ELEMENT_REGISTRY\" ] [ result . request ] ) { if ( result . contextInfo . issuer . indexOf ( \"bundle-entry-points\" ) !== - 1 && global [ \"ELEMENT_REGISTRY\" ] && ! global [ \"ELEMENT_REGISTRY\" ] [ result . request ] ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "a", "bug", "with", "_first", ";", ".", "first", "()", "now", "returns", "this", "(", "example", "code", "should", "work", "now", ")"], "add_tokens": "var mid = stack . splice ( i , 1 ) [ 0 ] ; stack . unshift ( mid ) ; return this ; } ;", "del_tokens": "stack . splice ( i , 1 ) ; stack . unshift ( handle ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Allow", "tasks", "to", "be", "enqueued", "out", "of", "order"], "add_tokens": "// Store the last event time var gLast = Date . now ( ) ; if ( this . later > gLast ) { gLast = this . later ; } if ( gLast <= now ) { // With sub-millisecond wait times, it's conceivable that the clock // may have passed our next task time so make sure it runs if ( entry . later > gLast ) { gLast = entry . later ; }", "del_tokens": "var scheduled = Object . keys ( queue ) ; var last = scheduled . length && + scheduled [ scheduled . length - 1 ] ; if ( last <= now ) {", "commit_type": "allow"}
{"commit_tokens": ["Implement", "and", "assert", "on", "flatten", "()", "."], "add_tokens": "* @ param opts Processing opts . * @ param opts . re The string or regexp delimiter function expand ( source , opts ) { opts = opts || { } ; var re = opts . re = opts . re || '.'", "del_tokens": "* @ param options Processing options . * @ param options . re The string or regexp delimiter function expand ( source , options ) { options = options || { } ; var re = options . re = options . re || '.'", "commit_type": "implement"}
{"commit_tokens": ["move", "jasmine", "adapter", "to", "/", "adapter", "directory", "+", "add", "config", "constant"], "add_tokens": "LOG_DEBUG : 3 , JASMINE_ADAPTER : __dirname + '/../adapter/jasmine.js'", "del_tokens": "LOG_DEBUG : 3", "commit_type": "move"}
{"commit_tokens": ["add", "rule", ":", "title", "-", "require", "<title", ">", "must", "be", "present", "in", "<head", ">", "tag", "."], "add_tokens": "'attr-no-duplication' : true , 'title-require' : true", "del_tokens": "'attr-no-duplication' : true", "commit_type": "add"}
{"commit_tokens": ["Create", "cldr", ".", "supplemental", "()", "helper"], "add_tokens": "define ( [ \"./util/always-array\" ] , function ( alwaysArray ) { path = alwaysArray ( path ) ;", "del_tokens": "define ( function ( ) { if ( typeof path === \"string\" ) { path = [ path ] ; }", "commit_type": "create"}
{"commit_tokens": ["add", "extra", "blocks", "for", "oauth", "forbiddens"], "add_tokens": "acl . can ( permissionName , req . user , record , function ( err , can ) { if ( err ) return callback ( err ) ; if ( ! can ) { if ( ! req . user ) { req . _sails . log . info ( 'ACL:canPolicy: forbidden for unAuthenticated user:' , permissionName ) ; } else { req . _sails . log . info ( 'ACL:canPolicy: forbidden for user id: ' , req . user . id , req . user . username , permissionName ) ; } } return callback ( null , can ) ; } ) ;", "del_tokens": "acl . can ( permissionName , req . user , record , callback ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "remove", "method", "fox", "mongoose"], "add_tokens": "return require ( './lib/sql' ) ;", "del_tokens": "var baseSQL = './lib/sql' ; return require ( baseSQL ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "library", "tmp", "instead", "of", "temp"], "add_tokens": "tmp = require ( \"tmp\" ) , path = resolve ( _assetGenerationDir , fileName ) ; tmp . tmpName ( function ( err , tmpPath ) { if ( err ) { return ; } // Save the image in a temporary file savePixmap ( pixmap , tmpPath ) . fail ( function ( err ) { layerUpdatedDeferred . reject ( err ) ; } ) // When ImageMagick is done . done ( function ( ) { // ...move the temporary file to the desired location fs . rename ( tmpPath , path , function ( err ) { if ( err ) { layerUpdatedDeferred . reject ( err ) ; } else { layerUpdatedDeferred . resolve ( ) ; } } ) ; } ) ;", "del_tokens": "temp = require ( \"temp\" ) , path = resolve ( _assetGenerationDir , fileName ) , tmpPath = temp . path ( { suffix : \".png\" } ) ; // Save the image in a temporary file savePixmap ( pixmap , tmpPath ) . fail ( function ( err ) { } ) // When ImageMagick is done . done ( function ( ) { // ...move the temporary file to the desired location fs . rename ( tmpPath , path , function ( err ) { if ( err ) { layerUpdatedDeferred . reject ( err ) ; } else { layerUpdatedDeferred . resolve ( ) ; } } ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "slash", "from", "/", "to", "\\", "."], "add_tokens": "return path . relative ( this . loader . baseURL , this . bundlesPath ) . replace ( / \\\\ / g , '/' ) ;", "del_tokens": "return path . relative ( this . loader . baseURL , this . bundlesPath ) . replace ( / \\/ / g , '/' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "spec", "for", "creating", "actions"], "add_tokens": "Reflux = require ( '../src' ) , Q = require ( 'q' ) ; describe ( 'when listening to action' , function ( ) { var promise ; beforeEach ( function ( ) { promise = Q . promise ( function ( resolve , reject ) { action . listen ( function ( ) { resolve ( Array . prototype . slice . call ( arguments , 0 ) ) ; } ) ; } ) ; } ) ; describe ( 'and when calling the action with arbitrary params' , function ( ) { var testArgs = [ 1337 , 'test' ] ; beforeEach ( function ( ) { action ( testArgs [ 0 ] , testArgs [ 1 ] ) ; } ) ; it ( 'should receive the correct arguments' , function ( done ) { promise . then ( function ( args ) { assert . equal ( args [ 0 ] , testArgs [ 0 ] ) ; assert . equal ( args [ 1 ] , testArgs [ 1 ] ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ;", "del_tokens": "Reflux = require ( '../src' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "problem", "with", "not", "having", "lightning", "-", "icon", "on", "listings"], "add_tokens": "token : this . token , automatic : 'all'", "del_tokens": "token : this . token", "commit_type": "fix"}
{"commit_tokens": ["Add", "test", "for", "moving", "child", "nodes"], "add_tokens": "parent . insertBefore ( a , prevChildNodes [ newPosition ] )", "del_tokens": "prevChildNodes [ newPosition ] = a", "commit_type": "add"}
{"commit_tokens": ["Change", "default", "port", "to", "5776", "technically", "breaking", "but", "YOLO"], "add_tokens": "host : '//' + document . location . hostname + ':5776'", "del_tokens": "host : '//' + document . location . hostname + ':7777'", "commit_type": "change"}
{"commit_tokens": ["Make", "codemirror", "with", "different", "height"], "add_tokens": "< div class = \"connection\" data-connection tabindex = \"1\" >", "del_tokens": "< div class = \"connection\" data-connection >", "commit_type": "make"}
{"commit_tokens": ["Add", "dynamic", "css", "className", "support"], "add_tokens": "if ( value [ 0 ] === '{' ) { this . forEachObjectLiteral ( value . slice ( 1 , - 1 ) , function ( className , expr ) { val = saferEval ( expr , context , data , node ) ; if ( val ) { $ ( node ) . addClass ( className ) ; } else { $ ( node ) . removeClass ( className ) ; } } ) ; } else { var className = saferEval ( value , context , data , node ) ; if ( className ) { $ ( node ) . addClass ( className ) ; } }", "del_tokens": "this . forEachObjectLiteral ( value . slice ( 1 , - 1 ) , function ( className , expr ) { val = saferEval ( expr , context , data , node ) ; if ( val ) { $ ( node ) . addClass ( className ) ; } else { $ ( node ) . removeClass ( className ) ; } } ) ;", "commit_type": "add"}
{"commit_tokens": ["added", ":", "support", "for", "the", "parseDynamicRoutes", "argument"], "add_tokens": "attributes = [ 'img:src' ] , parseDynamicRoutes = false ; // Check if dynamic routes must be parsed if ( query . parseDynamicRoutes !== undefined ) { parseDynamicRoutes = ! ! query . parseDynamicRoutes ; } } , 'ATTRIBUTE' , root , parseDynamicRoutes ) ;", "del_tokens": "attributes = [ 'img:src' ] ; } , 'ATTRIBUTE' , root ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "default", "behavior", "for", "responseContext", ".", "next"], "add_tokens": "handler ( err , response ) ;", "del_tokens": "handler ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "init", "to", "initialize", "a", "file", "loader"], "add_tokens": "const THREE = AFRAME . THREE ; init : function ( ) { this . loader = new THREE . FileLoader ( ) ; } , update : function ( oldData ) { } ,", "del_tokens": "init : function ( ) { } , update : function ( oldData ) { } ,", "commit_type": "change"}
{"commit_tokens": ["Add", "missing", "dependencies", "for", "the", "sample", "app"], "add_tokens": "// If you don't provide a todo, one will be provided for you. EMPTY : \"empty todo...\" , this . set ( { \"content\" : this . EMPTY } ) ;", "del_tokens": "// Default attributes for the todo. defaults : { content : \"empty todo...\" , done : false } , this . set ( { \"content\" : this . defaults . content } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "for", "acyclic", "graphs"], "add_tokens": "var dig_alg_tarjan = function ( graph ) { dig . alg . tarjan = dig_alg_tarjan ;", "del_tokens": "dig . alg . tarjan = function ( graph ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "jsdoc", "and", "eslint", "support", "postinstall", "script"], "add_tokens": "/ ** * Exception class * @ class Exception * @ author Grall Arnaud ( folkvir ) * / / ** * @ constructs * @ param { string } name - Exception name * @ param { string } message - Exception message * / constructor ( name , message ) { constructor ( ) { constructor ( ) { constructor ( ) { constructor ( ) {", "del_tokens": "constructor ( name , message ) { constructor ( ) { constructor ( ) { constructor ( ) { constructor ( ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "error", "on", "model", "method"], "add_tokens": "if ( ! name ) { return new model ( name , this . config ) ; return new this . constructor ( name , this . config ) ;", "del_tokens": "if ( ! name || ! helper . isObject ( this . config . models ) ) { return model ; } let handle = this . config . handle ; if ( ! helper . isFunction ( handle ) ) { handle = this . constructor ; return new handle ( name , this . config ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "reporting", "of", "errors", "that", "are", "in", "the", "response", "body"], "add_tokens": "error : methodErr . response && methodErr . response . body && ( methodErr . response . body . error && methodErr . response . body . error . message || methodErr . response . body . message ) || methodErr . error || methodErr . message , status : methodErr . response && methodErr . response . body && ( methodErr . response . body . error && methodErr . response . body . error . status || methodErr . response . body . status ) || methodErr . response . statusCode || methodErr . status ,", "del_tokens": "error : ( methodErr . response && methodErr . response . body && methodErr . response . body . error && methodErr . response . body . error . message ) || methodErr . error || methodErr . message , status : methodErr . response && methodErr . response . statusCode || methodErr . status ,", "commit_type": "fix"}
{"commit_tokens": ["Updated", "documentation", "and", "included", "new", "NEXT", "lib", "and", "docs"], "add_tokens": "o . buildDate = /*date*/ \"Fri, 19 Jul 2013 18:05:19 GMT\" ; // injected by build process", "del_tokens": "o . buildDate = /*date*/ \"Fri, 28 Jun 2013 15:39:58 GMT\" ; // injected by build process", "commit_type": "update"}
{"commit_tokens": ["add", "some", "environment", "variables", "so", "we", "can", "override", "things", "in", "test", "apps", "with", "changing", "the", "code", "."], "add_tokens": "apiKey = process . env . DASHBOT_API_KEY_OVERRIDE || apiKey ; var serverRoot = process . env . DASHBOT_SERVER_ROOT || 'https://tracker.dashbot.io' ; var debug = process . env . DASHBOT_DEBUG === 'true' || false ; debug = config . debug || debug ;", "del_tokens": "var serverRoot = 'https://tracker.dashbot.io' ; var debug = false ; debug = config . debug ;", "commit_type": "add"}
{"commit_tokens": ["Use", "zIndex", ":", "auto", "for", "true", "modal", "behavior", ".", "Fix", "related", "bugs", "in", "master"], "add_tokens": "zIndex : 'auto' , zIndex : 'auto' ,", "del_tokens": "jBox . useTrueModal = true ; dragOver : true , dragOver : true ,", "commit_type": "use"}
{"commit_tokens": ["added", "support", "for", "new", "dialogflow", "fulfillment", "sdk", "google"], "add_tokens": "if ( typeof assistant . doResponse_ !== 'undefined' ) { } else if ( typeof assistant . handleRequest !== 'undefined' ) { // dialogflow-fulfillment npm that . assistantHandle . client . orginalSend = assistant . client . sendJson_ ; that . assistantHandle . client . sendJson_ = dashbotSend ; that . requestBody = assistant . request_ . body ; that . logIncoming ( assistant . request_ . body , incomingMetadata ) ; } else { function dashbotSend ( responseJson ) { that . logOutgoing ( that . requestBody , responseJson , that . outgoingMetadata , that . outgoingIntent ) that . outgoingMetadata = null that . outgoingIntent = null that . assistantHandle . client . orginalSend ( responseJson ) }", "del_tokens": "if ( typeof assistant . doResponse_ !== 'undefined' ) { } else {", "commit_type": "add"}
{"commit_tokens": ["update", "demos", "and", "demo", "site"], "add_tokens": "return angular . isDefined ( total ) ? this . settings ( { 'total' : total } ) : settings . total ; $templateCache . put ( 'ng-table/pager.html' , '<div class=\"ng-cloak\"> <div ng-if=\"params.settings().counts.length\" class=\"btn-group pull-right\"> <button ng-repeat=\"count in params.settings().counts\" type=\"button\" ng-class=\"{\\'active\\':params.count()==count}\" ng-click=\"params.count(count)\" class=\"btn btn-default btn-xs\"> {{count}} </button> </div> <ul class=\"pagination\"> <li ng-class=\"{\\'disabled\\': !page.active}\" ng-repeat=\"page in pages\" ng-switch=\"page.type\"> <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\">&laquo;</a> <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\">{{page.number}}</a> <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\">{{page.number}}</a> <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">&#8230;</a> <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\">{{page.number}}</a> <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\">&raquo;</a> </li> </ul> </div>' ) ;", "del_tokens": "var isFunction = function ( obj ) { return ! ! ( obj && obj . constructor && obj . call && obj . apply ) ; } ; var t = angular . isDefined ( total ) ? this . settings ( { 'total' : total } ) : settings . total ; return isFunction ( t ) ? t ( ) : t ; $templateCache . put ( 'ng-table/pager.html' , '<div class=\"ng-cloak\"> <div ng-if=\"params.settings().counts.length\" class=\"btn-group pull-right\"> <button ng-repeat=\"count in params.settings().counts\" type=\"button\" ng-class=\"{\\'active\\':params.count()==count}\" ng-click=\"params.count(count)\" class=\"btn btn-default btn-xs\"> {{count}} </button> </div> <ul class=\"pagination\"> <li ng-class=\"{\\'disabled\\': !page.active}\" ng-repeat=\"page in pages\" ng-switch=\"page.type\"> <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\">«</a> <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\">{{page.number}}</a> <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\">{{page.number}}</a> <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">…</a> <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\">{{page.number}}</a> <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\">»</a> </li> </ul> </div>');", "commit_type": "update"}
{"commit_tokens": ["fixing", "tests", "to", "not", "depend", "on", "timezone"], "add_tokens": "expect ( string ) . to . contain ( ':000' ) ; expect ( string ) . to . contain ( ':001' ) ; expect ( string ) . to . contain ( ':999' ) ;", "del_tokens": "expect ( string ) . to . equal ( '17:34:26:000' ) ; expect ( string ) . to . equal ( '17:34:26:001' ) ; expect ( string ) . to . equal ( '17:34:26:999' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "String", "(", "out", ")", "instead", "of", "out", ".", "toString", "()"], "add_tokens": "String ( out ) . split ( '\\n' ) . forEach ( ( f ) => {", "del_tokens": "out . toString ( ) . split ( '\\n' ) . forEach ( ( f ) => {", "commit_type": "use"}
{"commit_tokens": ["Adding", "event", "for", "mouseover", "/", "mouseout", "of", "annotations"], "add_tokens": "( function ( ) { document . addEventListener ( 'click' , function handleDocumentClick ( e ) { let target = findAnnotationAtPoint ( e . clientX , e . clientY ) ; // Emit annotation:click if target was clicked if ( target ) { emitter . emit ( 'annotation:click' , target ) ; } } ) ; let mouseOverNode ; document . addEventListener ( 'mousemove' , function handleDocumentMousemove ( e ) { let target = findAnnotationAtPoint ( e . clientX , e . clientY ) ; // Emit annotation:mouseout if target was mouseout'd if ( mouseOverNode && ! target ) { emitter . emit ( 'annotation:mouseout' , mouseOverNode ) ; } // Emit annotation:mouseover if target was mouseover'd if ( target && mouseOverNode !== target ) { emitter . emit ( 'annotation:mouseover' , target ) ; } mouseOverNode = target ; } ) ; } ) ( ) ;", "del_tokens": "document . addEventListener ( 'click' , function handleDocumentClick ( e ) { let target = findAnnotationAtPoint ( e . clientX , e . clientY ) ; // Emit annotation:click if target was clicked if ( target ) { emitter . emit ( 'annotation:click' , target ) ; } } ) ; // document.addEventListener('mousemove', function handleDocumentMousemove(e) { // let target = findAnnotationAtPoint(e.clientX, e.clientY); // // // Emit annotation:mouseover if target was clicked // if (target) { // emitter.emit('annotation:mouseover', target); // } // });", "commit_type": "add"}
{"commit_tokens": ["Changing", "line", "style", "adding", "width", "field"], "add_tokens": "strokeOpacity : 0.7", "del_tokens": "strokeOpacity : 0.5", "commit_type": "change"}
{"commit_tokens": ["add", "outgoing", "intent", "to", "google", "and", "clear", "intents", "on", "alexa", "."], "add_tokens": "that . logOutgoing ( that . requestBody , response , that . outgoingMetadata , that . outgoingIntent ) that . outgoingIntent = null that . setOutgoingIntent = function ( outgoingIntent ) { that . outgoingIntent = outgoingIntent } that . logIncoming = function ( requestBody , metadata , intent ) { if ( intent ) { data . intent = intent }", "del_tokens": "that . logOutgoing ( that . requestBody , response , that . outgoingMetadata ) that . logIncoming = function ( requestBody , metadata ) {", "commit_type": "add"}
{"commit_tokens": ["fixed", "@@", "compatibility", "mode", "for", "mt940", "multi", "messages"], "add_tokens": "// SWIFT Protokoll // Nachrichten // enthalten Felder :Zahl: Trennzeichen // Der Kontoauszug kann über mehrere Nachrichten verteilt werden // // Trennzeichen = \\r\\n Kompatibilität @@ // Syntax: // Nachrichten Begin: \\r\\n-\\r\\n oder @@ (optional) // Feld :Zahl: (\\r\\n oder @@) // Feld Mehrfach :Zahl: (\\r\\n oder @@)(mehrfach) // Nachrichten Ende: -\\r\\n oder (@@ und dann muss direkt wieder @@ als Anfang folgen) // Für Feld Mehrfach while ( parser . hasNext ( ) && ! ( parser . getCurrentChar ( ) == \":\" || parser . getCurrentChar ( ) == \"-\" || parser . getCurrentChar ( ) == \"@\" ) ) { if ( ( parser . cur_pos + 1 >= parser . data . length || ( parser . getCurrentChar ( ) == \"@\" && parser . data [ parser . cur_pos + 1 ] == \"@\" ) ) || ( parser . cur_pos + 2 >= parser . data . length || ( parser . getCurrentChar ( ) == \"-\" && parser . data [ parser . cur_pos + 1 ] == \"\\r\" && parser . data [ parser . cur_pos + 2 ] == \"\\n\" ) ) ) {", "del_tokens": "while ( parser . hasNext ( ) && ! ( parser . getCurrentChar ( ) == \":\" || parser . getCurrentChar ( ) == \"-\" ) ) { if ( parser . getCurrentChar ( ) == \"-\" && ( parser . cur_pos + 1 >= parser . data . length || ( parser . data [ parser . cur_pos + 1 ] == \"\\r\" || parser . data [ parser . cur_pos + 1 ] == \"@\" ) ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "javascript", "not", "js", "for", "syntax", "."], "add_tokens": "return 'javascript' ;", "del_tokens": "return 'js' ;", "commit_type": "use"}
{"commit_tokens": ["Update", "determinant", "function", "to", "support", "1x1", "matrix"], "add_tokens": "if ( numRow !== numCol ) { throw new Error ( \"Not a square matrix.\" ) } if ( numRow === 1 ) { return m [ 0 ] [ 0 ] ; } else if ( numRow === 2 ) {", "del_tokens": "if ( ( numRow === 2 ) && ( numCol === 2 ) ) {", "commit_type": "update"}
{"commit_tokens": ["Added", "support", "for", "stylesheet", "href", "with", "an", "absolute", "url", ".", "Added", "new", "tests"], "add_tokens": "// if the href to the stylesheet is an absolute path, we use it directly, // if it starts with a / we use the host as the base url if ( el . substr ( 0 , 4 ) == 'http' ) p = el ; else if ( el [ 0 ] == '/' ) p += el ; if ( err ) console . error ( err ) ;", "del_tokens": "// if the href to the stylesheet starts with a / we use the host as the base url if ( el [ 0 ] == '/' ) p += el ;", "commit_type": "add"}
{"commit_tokens": ["Added", "deps", "to", "grunt", "docs"], "add_tokens": "\"install-deps\" : { command : \"npm install\" } , grunt . registerTask ( 'docs' , [ 'install-deps' , 'shell:github-pages-checkout' , 'clean:docs' , 'docker:main' , 'shell:github-pages-push' ] ) ;", "del_tokens": "grunt . registerTask ( 'docs' , [ 'shell:github-pages-checkout' , 'clean:docs' , 'docker:main' , 'shell:github-pages-push' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "utility", "functions", "replaceLiteralValue", "equals", "&", "isDate"], "add_tokens": "return terms . replaceLiteralValue ( a , a . value . split ( \"\" ) . reverse ( ) . join ( \"\" ) )", "del_tokens": "function cloneLiteral ( base , newValue ) { switch ( base . type ) { case 'literal+type' : return terms . TypedLiteralDescriptor ( newValue , base . datatype ) case 'literal+lang' : return terms . createLangLiteral ( newValue , base . lang ) default : return terms . RawLiteralDescriptor ( newValue ) } } return cloneLiteral ( a , a . value . split ( \"\" ) . reverse ( ) . join ( \"\" ) )", "commit_type": "add"}
{"commit_tokens": ["Move", "transformation", "-", "related", "code", "under", "a", "different", "directory"], "add_tokens": "import { Node } from \"../model\"", "del_tokens": "import { block , Node } from \"../model\"", "commit_type": "move"}
{"commit_tokens": ["add", "jsDoc", "for", "convertPatternProperties", "()"], "add_tokens": "/ ** * Change RAML pattern properties to JSON patternProperties . * * @ param { Object } data - the library fragment to convert * @ returns { Object } * / function convertPatternProperties ( data ) { Object . keys ( data . properties ) . map ( function ( key ) { if ( / ^\\/.*\\/$ / . test ( key ) ) { data . patternProperties = data . patternProperties || { } var stringRegex = key . slice ( 1 , - 1 ) data . patternProperties [ stringRegex ] = data . properties [ key ] delete data . properties [ key ] } } ) return data }", "del_tokens": "function convertPatternProperties ( data ) { Object . keys ( data . properties ) . map ( function ( key ) { if ( / ^\\/.*\\/$ / . test ( key ) ) { data . patternProperties = data . patternProperties || { } var stringRegex = key . slice ( 1 , - 1 ) data . patternProperties [ stringRegex ] = data . properties [ key ] delete data . properties [ key ] } } ) return data }", "commit_type": "add"}
{"commit_tokens": ["Add", "leading", "zeroes", "to", "MGRS", "easting", "and", "northing"], "add_tokens": "* 100 m , 2 for 1000 m or 1 for 10000 m ) . Optional , default is 5. // prepend with leading zeroes var seasting = \"00000\" + utm . easting , snorthing = \"00000\" + utm . northing ;", "del_tokens": "* 100 m , 4 for 1000 m or 5 for 10000 m ) . Optional , default is 5. // add 100,000 to numerical locations to create leading zeroes in string // the additional leading 1 will be truncated in the subsequent 'substr' commands var seasting = \"\" + ( utm . easting + 100000 ) , snorthing = \"\" + ( utm . northing + 100000 ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "error", "when", "report", "dir", "does", "not", "exist"], "add_tokens": "tests : [ '.tmp' ] missingFiles : { options : { dir : '.tmp/does/not/exist' , file : 'non-existing-file.json' } , results : { junit : { results : { file : 'non/existing/results.xml' } , coverage : { file : 'non/existing/results.json' } } , e2e : { results : { dir : 'non/existing/directory/*.xml' } , coverage : { dir : 'non/existing/directory/*.json' } } , jshint : 'non/existing/results.xml' } } ,", "del_tokens": "tests : [ 'tmp' ]", "commit_type": "fix"}
{"commit_tokens": ["Fix", "null", "reference", "bug", "in", "Project", "."], "add_tokens": "as = output ( _ . fields , _ . as || [ ] ) ,", "del_tokens": "as = output ( _ . fields , _ . as ) ,", "commit_type": "fix"}
{"commit_tokens": ["Remove", "SVG", "check", "for", "attribute", "animations"], "add_tokens": "dom : a => a . nodeType || a instanceof SVGElement , if ( is . dom ( el ) && ( el . getAttribute ( prop ) ) ) return 'attribute' ; // console.log('0');", "del_tokens": "svg : a => a instanceof SVGElement , dom : a => a . nodeType || is . svg ( a ) , if ( is . dom ( el ) && ( el . getAttribute ( prop ) || ( is . svg ( el ) && el [ prop ] ) ) ) return 'attribute' ;", "commit_type": "remove"}
{"commit_tokens": ["allows", ".", "get", "with", "0", "parameters", "to", "return", "a", "clone", "of", "the", "entire", "_values", "map"], "add_tokens": "return key ? this . _values [ key ] : _ . clone ( this . _values ) ;", "del_tokens": "return this . _values [ key ] ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "can", "-", "namespace", "domEvents"], "add_tokens": "var namespace = require ( 'can-namespace' ) ; module . exports = namespace . domEvents = {", "del_tokens": "module . exports = {", "commit_type": "add"}
{"commit_tokens": ["add", "eslint", "disable", "in", "demo", "file"], "add_tokens": "console . log ( 'foo' ) ; // eslint-disable-line no-console", "del_tokens": "console . log ( 'foo' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "thumb", "up"], "add_tokens": "return ( this . message !== null && ! ! this . message . text ) || this . _stickerToSmile ( ) !== '' ; } _stickerToSmile ( ) { if ( this . attachments . length !== 1 || this . attachments [ 0 ] . type !== 'image' || ! this . attachments [ 0 ] . payload || ! this . attachments [ 0 ] . payload . sticker_id ) { return '' ; } switch ( this . attachments [ 0 ] . payload . sticker_id ) { case 369239263222822 : return '👍'; default : return '' ; } return this . message . text || this . _stickerToSmile ( ) || '' ;", "del_tokens": "return this . message !== null && ! ! this . message . text ; return this . message . text || '' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "Vue", "components", "without", "script", "and", "/", "or", "template"], "add_tokens": "// Compile template const compiled = compiler . compile ( template ) const moduleFuncs = '\\nrender: ' + toFunction ( compiled . render ) + ',' + '\\nstaticRenderFns: [' + compiled . staticRenderFns . map ( toFunction ) . join ( ',' ) + ']' // There is no script tag if ( ! script || script . length < 20 ) { return 'export default {' + moduleFuncs + '\\n}' } // Inject in actual script return script . split ( matches [ 1 ] ) . join ( matches [ 1 ] + moduleFuncs + ',' ) var js = nodes . script && parse5 . serialize ( nodes . script ) || 'export default {\\n}'", "del_tokens": "const compiled = compiler . compile ( template ) return script . split ( matches [ 1 ] ) . join ( matches [ 1 ] + '\\nrender: ' + toFunction ( compiled . render ) + ',' + '\\nstaticRenderFns: [' + compiled . staticRenderFns . map ( toFunction ) . join ( ',' ) + '],' ) // Don't touch files that don't look like Vue components if ( ! nodes . template && ! nodes . script ) { throw new Error ( 'There must be at least one script tag or one template tag per *.vue file.' ) } var js = parse5 . serialize ( nodes . script )", "commit_type": "add"}
{"commit_tokens": ["adds", "additional", "tests", "and", "readme", "notes"], "add_tokens": "* @ version 0.2 .5", "del_tokens": "* @ version 0.2 .4 // TODO ensure we've actually got a wordlist!", "commit_type": "add"}
{"commit_tokens": ["fixed", "compiler", "path", "being", "incorrect", "for", "newer", "versions", "of", "typescript"], "add_tokens": "var tsc = path . join ( path . dirname ( require . resolve ( \"typescript\" ) ) , \"tsc.js\" ) ;", "del_tokens": "var tsc = require . resolve ( \"typescript\" ) . replace ( / typescript\\.js$ / , \"tsc.js\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "action", "navigation", "on", "pagination"], "add_tokens": ". directive ( 'pagination' , function ( ) { value : '<' , value : '>' , page : '@' , pageSize : '@' , total : '@' , paginationAction : '&' 'ng-click=\"Item.action()\" ' + '<a href> ' + '<span ng-bind=\"Item.value\"></span> ' + '</a>' + } ) ; } ( angular ) ) ;", "del_tokens": ". directive ( 'pagination' , [ \"$sce\" , function ( $sce ) { value : '<i class=\"mdi-navigation-chevron-left\"></i>' , prev . value = $sce . trustAsHtml ( prev . value ) ; value : '<i class=\"mdi-navigation-chevron-right\"></i>' , next . value = $sce . trustAsHtml ( next . value ) ; item . value = $sce . trustAsHtml ( item . value ) ; scope . dots = $sce . trustAsHtml ( scope . dots ) ; page : '=' , pageSize : '=' , total : '=' , pagingAction : '@' '<a href=\"#!\" ng-click=\"Item.action()\"> ' + '<span ng-bind-html=\"Item.value\"></span> ' + '</a> ' + } ] ) ; } ( angular ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "small", "bugs", "in", "the", "reconnection", "logic"], "add_tokens": "if ( this . _state !== ConnectionState . Connecting || ! this . _connection || ! this . _connection . equals ( connection ) || connection . isClosed ) if ( ! this . _connection || ! this . _connection . equals ( connection ) ) return ; if ( this . _state === ConnectionState . Closed || ! this . _connection || ! this . _connection . equals ( connection ) ) var msg = util . format ( \"EventStoreConnection '%s': closing TCP connection [%j, L%j, %s] due to HEARTBEAT TIMEOUT at pkgNum %d.\" , this . _settings . log . info ( msg ) ;", "del_tokens": "if ( this . _state !== ConnectionState . Connecting || ! this . _connection . equals ( connection ) || connection . isClosed ) if ( ! this . _connection . equals ( connection ) ) return ; if ( this . _state === ConnectionState . Closed || ! this . _connection . equals ( connection ) ) this . _logInfo ( \"EventStoreConnection '%s': closing TCP connection [%j, L%j, %s] due to HEARTBEAT TIMEOUT at pkgNum %d.\" ,", "commit_type": "fix"}
{"commit_tokens": ["Changed", "getElements", "()", "return", "type", "to", "object"], "add_tokens": "while ( multiplearray [ 0 ] . traditional == nextChar ( i + 1 ) ) { dictionarysimplified [ multiplearray [ 0 ] . simplified ] = multiplearray ; dictionarytraditional [ multiplearray [ 0 ] . traditional ] = multiplearray ; return { traditional : traditional , simplified : simplified , pinyin : pinyin , definition : definition } ; if ( dictionarysimplified [ character ] . pinyin != null ) { return dictionarysimplified [ character ] . pinyin ;", "del_tokens": "while ( multiplearray [ 0 ] [ 0 ] == nextChar ( i + 1 ) ) { dictionarysimplified [ multiplearray [ 0 ] [ 1 ] ] = multiplearray ; dictionarytraditional [ multiplearray [ 0 ] [ 0 ] ] = multiplearray ; return [ traditional , simplified , pinyin , definition ] ; if ( dictionarysimplified [ character ] [ 2 ] != null ) { return dictionarysimplified [ character ] [ 2 ] ;", "commit_type": "change"}
{"commit_tokens": ["updated", "dev", "dependencies", "to", "run", "the", "example"], "add_tokens": "] , loaders : [ { test : / \\.js$ / , loader : 'babel' } ]", "del_tokens": "]", "commit_type": "update"}
{"commit_tokens": ["Added", "the", "click", "functionality", "to", "the", "geojson", "property"], "add_tokens": "setupGeojson ( ) ; function setupGeojson ( ) { if ( ! geojson . mouseover ) return ; geojson . mouseover ( e ) ; } , click : function ( e ) { if ( geojson . click ) { geojson . click ( geojson . selected ) ; }", "del_tokens": "setupChoroPleth ( ) ; function setupChoroPleth ( ) { geojson . mouseover ( e ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "difficult", "to", "debug", "variadic"], "add_tokens": "first , rest , push , apply , unshift , eventListener , compose , when , function merge ( /*args*/ ) { } , arguments ) ; }", "del_tokens": "variadic , push , apply , unshift , eventListener , compose , when , var merge = variadic ( function merge ( args ) { } , args ) ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["removed", "unused", "var", "in", "utils"], "add_tokens": "exports . isFunction = function ( value ) {", "del_tokens": "var isFunction = exports . isFunction = function ( value ) {", "commit_type": "remove"}
{"commit_tokens": ["add", "custom", "errors", ";", "improve", "typing"], "add_tokens": "/** @param {Nimiq.Transaction} transaction */ // todo choose better type throw new AmountTooSmallError ( ) ; throw new NetworkMissmatchError ( transaction . network , Nimiq . GenesisConfig . NETWORK_NAME ) ;", "del_tokens": "throw new Error ( 'Amount is too small' ) ; throw Error ( ` ${ transaction . network } ${ Nimiq . GenesisConfig . NETWORK_NAME } ` ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "unextracted", "@param", "when", "last", "tag", "in", "block", "."], "add_tokens": "re = / @param\\s+\\{\\(?([^})]+)\\)?\\}\\s+(\\[.+\\]|[\\w]+(?:\\[.+\\])?)\\s+([\\s\\S]*?)(?=\\@|\\*\\/) / gim ,", "del_tokens": "re = / @param\\s+\\{\\(?([^})]+)\\)?\\}\\s+(\\[.+\\]|[\\w]+(?:\\[.+\\])?)\\s+([\\s\\S]*?)(?=\\@) / gim ,", "commit_type": "fix"}
{"commit_tokens": ["use", "mini", "-", "css", "-", "extract", "-", "plugin", "instead", "of", "extract", "-", "text", "-", "webpack", "-", "plugin"], "add_tokens": "use : [ extract_loader , require . resolve ( \"css-loader\" ) , ] , const MiniCssExtractPlugin = require ( \"mini-css-extract-plugin\" ) ; const extract_plugin = new MiniCssExtractPlugin ( { filename } ) ; const extract_loader = MiniCssExtractPlugin . loader ; // filename = filename.replace(/\\[chunkhash\\]/g, '[contenthash]');", "del_tokens": "use : extract_loader , const ExtractTextPlugin = require ( 'extract-text-webpack-plugin' ) ; const extract_plugin = new ExtractTextPlugin ( { filename } ) ; const extract_loader = ( extract_plugin . extract ( { fallback : require . resolve ( \"style-loader\" ) , use : loaders , } ) ) ; filename = filename . replace ( / \\[chunkhash\\] / g , '[contenthash]' ) ;", "commit_type": "use"}
{"commit_tokens": ["Remove", "adapter", "lib", ";", "update", "the", "settings", "file", "to", "import", "the", "utils", "libs", "directly"], "add_tokens": "const Guid = require ( 'guid' ) ; const visualGuid = Guid . raw ( ) . replace ( \"-\" , \"\" ) ; const rendered = _ . template ( templateContent ) ( { name : visualName , guid : visualGuid , } ) ; . then ( ( ) => renderTemplates ( ) ) ;", "del_tokens": "const rendered = _ . template ( templateContent ) ( { name : visualName } ) ; . then ( ( ) => renderTemplates ( ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", "visitors", "to", "better", "handle", "nested", "pathnames"], "add_tokens": "var existsSync = require ( 'exists-sync' ) ; if ( ! options . force && verifyResult . destExists ) { throw new SilentError ( 'The destination: ' + destPath + ' already exists. Cannot execute git mv.' ) ; } var exists = existsSync ( destPath ) ; // if (exists) { // this.ui.writeLine('The destination path: ' + destPath + ' already exists. Cannot overrwrite.', 'WARNING'); // } var exists = existsSync ( sourcePath ) ;", "del_tokens": "var exists = fs . existsSync ( destPath ) ; if ( exists ) { this . ui . writeLine ( 'The destination path: ' + destPath + ' already exists. Cannot overrwrite.' , 'WARNING' ) ; } var exists = fs . existsSync ( sourcePath ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "a", "page", "to", "list", "movies"], "add_tokens": "import movies from '../movies' ; res . render ( req . url , { movies : movies", "del_tokens": "import { join } from 'path' ; import { loadPhotos } from '../lib/photos' ; loadPhotos ( function ( err , data ) { if ( err ) { return next ( err ) ; } console . dir ( data ) ; res . render ( req . url , { title : 'React Engine Express Sample App' , name : 'Jordan' } ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "dictionary", "input", "as", "field", "type"], "add_tokens": "new Assertion ( item , 'script output should be an object' ) . an ( 'object' ) ; new Assertion ( obj . type ) . to . match ( / ^text|password|email|select|textarea|datetime|boolean|dictionary$ / ) ;", "del_tokens": "new Assertion ( item ) . an ( 'object' ) ; new Assertion ( obj . type ) . to . match ( / ^text|password|email|select|textarea|datetime|boolean$ / ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "final", "callback", "and", "array", ".", "splice", "affecting", "config"], "add_tokens": "operationMiddlewares = operationHandler . slice ( 0 , - 1 ) ; operationHandler = operationHandler [ operationHandler . length - 1 ] ; invokeHandler ( operationHandler , req , res , done ) ; function runMiddlewareStack ( stack , req , res , callback ) { setImmediate ( callback , err ) ; let error = err ; return ; return ; // if new error thrown, replace the error error = e ; // otherwise skip layer next ( error ) ; function invokeHandler ( handler , req , res , done ) {", "del_tokens": "operationMiddlewares = operationHandler . splice ( 0 , operationHandler . length - 1 ) ; [ operationHandler ] = operationHandler ; invokeHandler ( operationHandler , req , res ) ; function runMiddlewareStack ( stack , req , res , done ) { setImmediate ( done , err ) ; } else { // otherwise skip layer next ( err ) ; // if new error raised, replace the error next ( e ) ; function invokeHandler ( handler , req , res ) {", "commit_type": "fix"}
{"commit_tokens": ["change", "the", "test", "code", "detects", "undefined"], "add_tokens": "should . not . exist ( error ) ; should . not . exist ( error ) ; should . not . exist ( error ) ; should . exist ( error ) ; should . not . exist ( error ) ; should . not . exist ( error ) ; should . not . exist ( error ) ; should . not . exist ( error ) ;", "del_tokens": "should ( error ) . eql ( undefined ) ; should ( error ) . eql ( undefined ) ; should ( error ) . eql ( undefined ) ; should ( error ) . not . eql ( undefined ) ; should ( error ) . eql ( undefined ) ; should ( error ) . eql ( undefined ) ; should ( error ) . eql ( undefined ) ; should ( error ) . eql ( undefined ) ;", "commit_type": "change"}
{"commit_tokens": ["Use", "more", "performant", "number", "-", ">", "string", "conversion"], "add_tokens": "return observeReader . get ( result , \"\" + key ) ;", "del_tokens": "return observeReader . get ( result , key . toString ( ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "custom", "macPlist", "options", "support"], "add_tokens": "var plistOptions = Utils . getPlistOptions ( { name : self . options . appName , version : self . options . appVersion , copyright : self . _appPkg . copyright || false } , self . options . macPlist ) ;", "del_tokens": "var defaultPlist = { appName : self . options . appName , appVersion : self . options . appVersion , copyright : self . _appPkg . copyright || false } ; var plistOptions = ( self . options . macPlist ? _ . defaults ( self . options . macPlist , defaultPlist ) : defaultPlist ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "beige", "theme", "move", "theme", "class", "from", ".", "reveal", "to", "document", "element", "use", "log", "instead", "of", "alert", "to", "demonstrate", "custom", "events"], "add_tokens": "document . documentElement . classList . add ( 'theme-' + config . theme ) ;", "del_tokens": "dom . wrapper . classList . add ( config . theme ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "assembler", "out", "of", "CPU"], "add_tokens": "writeTrytes ( address , data ) { let i = address ; for ( let tryte of data ) { console . log ( 'DISASM:' , di , '=' , disasm ( di ) ) ;", "del_tokens": "const assembler = require ( './as' ) ; assemble ( source ) { let lines = source ; let machine_code = assembler ( lines ) ; let i = 0 ; // TODO .org, offset to assemble into for ( let tryte of machine_code ) { console . log ( 'DISASM:' , disasm ( di ) ) ;", "commit_type": "move"}
{"commit_tokens": ["Removing", "need", "for", "formTransformer", "to", "write", "file", "."], "add_tokens": "function transformFeature ( input , callback ) { handleSpec ( spec , output , callback ) ; writeOutput ( output , callback ) ; function writeOutput ( output , callback ) {", "del_tokens": "function transformFeature ( input , outputFile , callback ) { handleSpec ( spec , output , callback , outputFile ) ; writeOutput ( output , callback , outputFile ) ; function writeOutput ( output , callback , outputFile ) { console . log ( \"writeOutput\" ) fs . writeFileSync ( outputFile , jsonOutput ) ; console . log ( callback ) ;", "commit_type": "remove"}
{"commit_tokens": ["Allow", "interfaces", "in", "GraphQLObjectType", "to", "be", "a", "thunk"], "add_tokens": "_interfaces : Array < GraphQLInterfaceType > ; return this . _interfaces || ( this . _interfaces = defineInterfaces ( this . _typeConfig . interfaces || [ ] ) ) ; function resolveMaybeThunk < T > (thingOrThunk: T | () = > T ) : T { return typeof thingOrThunk === 'function' ? thingOrThunk ( ) : thingOrThunk ; } function defineInterfaces ( interfacesOrThunk ) : Array < GraphQLInterfaceType > { return resolveMaybeThunk ( interfacesOrThunk ) ; } var fieldMap : any = resolveMaybeThunk ( fields ) ;", "del_tokens": "return this . _typeConfig . interfaces || [ ] ; var fieldMap : any = typeof fields === 'function' ? fields ( ) : fields ;", "commit_type": "allow"}
{"commit_tokens": ["added", "setPlaying", "and", "now", "working", "on", "docs"], "add_tokens": "var gameMap = require ( \"../ref/gameMap.json\" ) ; this . __idleTime = null ; this . __gameId = null ; this . __idleTime = idleTime ; this . websocket . send ( JSON . stringify ( { op : 3 , d : { idle_since : this . __idleTime , game_id : this . __gameId } } ) ) ; } setPlayingGame ( id ) { if ( id instanceof String || typeof id === ` ` ) { // working on names var gid = id . trim ( ) . toUpperCase ( ) ; id = null ; for ( var game of gameMap ) { if ( game . name . trim ( ) . toUpperCase ( ) === gid ) { id = game . id ; break ; } } } this . __gameId = id ; idle_since : this . __idleTime , game_id : this . __gameId } playingGame ( id ) { this . setPlayingGame ( id ) ;", "del_tokens": "idle_since : idleTime , game_id : null", "commit_type": "add"}
{"commit_tokens": ["Upgraded", "to", "module", "-", "keys@2"], "add_tokens": "// Allow require.moduleKeys and require.resolve but not require(moduleId). 'val' : ` ${ unpredictableSuffix } ` , 'val' : ( 'require(\\'module-keys/cjs\\').polyfill(module, require);\\n' + ` ${ unpredictableSuffix } ` ) ,", "del_tokens": "// Allow require.keys and require.resolve but not require(moduleId). 'val' : ` ${ unpredictableSuffix } ` , 'val' : ` ${ unpredictableSuffix } ` ,", "commit_type": "upgrade"}
{"commit_tokens": ["Added", "possibility", "to", "set", "browserSync", "server", "option"], "add_tokens": "options . webserver . server = _ . assign ( options . webserver . server , { } ) ; startWebserver ( options . webserver , 'Serving develop!' ) ; options . webserver . server = _ . assign ( options . webserver . server , { baseDir : options . paths . root } ) ; startWebserver ( options . webserver , 'Serving compiled!' ) ; function startWebserver ( config , message ) { console . warn ( config ) ; setTimeout ( function ( ) { } , 2000 )", "del_tokens": "options . webserver . server = { } ; startWebserver ( options . webserver , 'Serving develop!' ) ; options . webserver . server = { baseDir : options . paths . build } ; startWebserver ( options . webserver , 'Serving compiled!' ) ; //gulp.src(options.files.jsNoVendor), function startWebserver ( config , message ) { setTimeout ( function ( ) { } , 2000 )", "commit_type": "add"}
{"commit_tokens": ["Allow", "overriding", "of", "approveDomains", "in", "web", ".", "getLetsEncryptLex", "()"], "add_tokens": "getLetsEncryptLex : function ( approveDomainsFunc ) { testing : true , approveDomainsFunc : function ( opts , certs , cb ) { if ( certs ) { // change domain list here opts . domains = certs . altnames ; } else { // change default email to accept agreement opts . email = self . conf . https . letsEncrypt . email ; opts . agreeTos = true ; } cb ( null , { options : opts , certs : certs } ) ; } approveDomainsFunc = approveDomainsFunc || self . conf . https . letsEncrypt . approveDomainsFunc ; approveDomains : approveDomainsFunc", "del_tokens": "getLetsEncryptLex : function ( ) { testing : false approveDomains : function ( opts , certs , cb ) { if ( certs ) { // change domain list here opts . domains = certs . altnames ; } else { // change default email to accept agreement opts . email = self . conf . https . letsEncrypt . email ; opts . agreeTos = true ; } cb ( null , { options : opts , certs : certs } ) ; }", "commit_type": "allow"}
{"commit_tokens": ["fix", "config", ".", "load", "can", "not", "load", "config", "when", "isMultiModule", "is", "true", ";", "add", "more", "unitest", ";", "add", "eslint", "script", "on", "package", ".", "json"], "add_tokens": "test ( 'common.load when isMultiModule is false' , t => { // mock fs const dir = path . join ( 'apppath' , 'type' ) ; mockModule ( dir ) ; mockHelper ( t , dir ) ; const common = require ( '../loader/common' ) ; var cache = common . load ( 'apppath' , false , 'type' ) ; t . is ( cache . a . __name , 'ajs' ) ; t . is ( cache . b . __name , 'bjs' ) ; } ) ;", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["fixed", "issue", "that", "would", "cause", "default", "style", "to", "inherit", "font", "declaration", "if", "alignment", "was", "set", "prior", "to", "any", "other", "front", "setting", "."], "add_tokens": "// Generate default style this . Style ( ) ;", "del_tokens": "var defaultStyle = this . Style ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "regression", "test", "for", "file", "descriptor", "leak"], "add_tokens": "const agent = new http . Agent ( { maxSockets : 20 , callOptions . pool = agent agent ,", "del_tokens": "const reqPool = new http . Agent ( { maxSockets : 40 , callOptions . pool = reqPool", "commit_type": "add"}
{"commit_tokens": ["fixed", "json", "error", "messages", "also", "override", "accept", "if", "specified", "earlier"], "add_tokens": "let contentType = this . res . get ( 'Content-Type' ) ; if ( 'string' === typeof contentType ) { this . req . headers . accept = contentType ; } self . render ( config [ err . status ] , err ) ; self . render ( config [ err . status ] . file , config [ err . status ] . data ) ; self . json ( _ . merge ( { error : message } , err ) ) ; . access ( 'type' )", "del_tokens": "self . render ( config [ err . status ] , data ) ; self . render ( config [ status ] . file , config [ err . status ] . data ) ; self . json ( { error : message } ) ; . method ( 'type' )", "commit_type": "fix"}
{"commit_tokens": ["Made", "chord", "-", "to", "-", "symbol", "more", "robust", "and", "removed", "error", "catching"], "add_tokens": "try { int = key . getInterval ( n . clean ( ) ) ; } catch ( err ) { int = key . getInterval ( n . toggleAccidental ( ) ) ; } key = note . create ( key || 'C' ) ;", "del_tokens": "int = key . getInterval ( n . clean ( ) ) ; key = note . create ( key ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "try", "/", "catch", "to", "runs"], "add_tokens": "sys . print ( msg + \"\\n\" ) ;", "del_tokens": "sys . print ( msg ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "default", "handler", "when", "available", "."], "add_tokens": "this . PASS = function ( ) { // console.log('Keyboard: passing event to parent.'); this . BLOCK = function ( e ) { // console.log('Keyboard: blocking event.'); this . defaultHandler ( e ) ; } else this . BLOCK ( e ) ; } else if ( this . defaultHandler ) { this . defaultHandler ( e ) ; } else this . BLOCK ( e ) ; this . bindAll ( combinations , \"keyup\" , this . PASS ) ; this . bindAll ( combinations , \"keydown\" , this . PASS ) ; this . bindAll ( combinations , \"keypress\" , this . PASS ) ;", "del_tokens": "var PASS = function ( ) { console . log ( 'Keyboard: passing event to parent.' ) ; var BLOCK = function ( e ) { console . log ( 'Keyboard: blocking event.' ) ; return this . defaultHandler ( e ) ; } return BLOCK ( e ) ; } return BLOCK ( e ) ; this . bindAll ( combinations , \"keyup\" , PASS ) ; this . bindAll ( combinations , \"keydown\" , PASS ) ; this . bindAll ( combinations , \"keypress\" , PASS ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "support", "for", "expressions", "within", "template", "literals"], "add_tokens": "import { Suite } from 'benchmark' const makeTransform = fixturePath => { const fixture = readFileSync ( resolve ( __dirname , fixturePath ) , 'utf8' ) return ( ) => babel ( fixture , { babelrc : false , plugins : [ plugin ] } ) } const benchs = { basic : makeTransform ( './fixtures/basic.js' ) , withExpressions : makeTransform ( './fixtures/with-expressions.js' ) } const suite = new Suite ( 'styled-jsx Babel transform' ) module . exports = suite . add ( 'basic' , benchs . basic ) . add ( 'with expressions' , benchs . withExpressions )", "del_tokens": "import Benchmark from 'benchmark' const read = path => readFileSync ( resolve ( __dirname , path ) , 'utf8' ) const fixture = read ( './fixtures/babel.js' ) module . exports = new Benchmark ( { name : 'Babel transform' , minSamples : 500 , fn : ( ) => { babel ( fixture , { babelrc : false , plugins : [ plugin ] } ) } } )", "commit_type": "add"}
{"commit_tokens": ["Fix", "routing", "options", "passed", "in", "to", "not", "set", "any", "routes", "when", "passed", "in"], "add_tokens": "return _ . extend ( { } , createDefaults ( ) , options || { } ) ; * the corresponding route regex as a string . If no route found , returns ` ` . * @ returns { String | Null } if ( ! routes ) return null ;", "del_tokens": "var defaults = createDefaults ( ) ; options = options || { } ; // Merge options with defaults var union = Object . keys ( defaults ) . reduce ( function ( coll , prop ) { // If property is an object, make a clone of it if ( typeof defaults [ prop ] === 'object' ) { coll [ prop ] = _ . extend ( { } , options [ prop ] || defaults [ prop ] ) ; } else { coll [ prop ] = options [ prop ] != null ? options [ prop ] : defaults [ prop ] ; } return coll ; } , { } ) ; for ( key in options ) { if ( ! union . hasOwnProperty ( key ) ) { union [ key ] = options [ key ] ; } } return union ; * the corresponding route regex as a string * @ returns { String }", "commit_type": "fix"}
{"commit_tokens": ["USe", "fancy", "-", "log", "to", "log", "instead", "gutil", ".", "log"], "add_tokens": "const log = require ( 'fancy-log' ) ; log ( PLUGIN_NAME + ' - We have the config file to the following path: ' + configFilePath ) ; log ( PLUGIN_NAME + ' - We will run the Protractor engine' ) ; log ( PLUGIN_NAME + ' - We will stop the Protractor engine' ) ;", "del_tokens": "gutil . log ( PLUGIN_NAME + ' - We have the config file to the following path: ' + configFilePath ) ; gutil . log ( PLUGIN_NAME + ' - We will run the Protractor engine' ) ; gutil . log ( PLUGIN_NAME + ' - We will stop the Protractor engine' ) ;", "commit_type": "use"}
{"commit_tokens": ["Move", "callback", "contents", "into", "try", "/", "catch"], "add_tokens": "try { // cleanup temp dir fs . chmodSync ( dirname , 0x1B6 ) ; // 666 in octal fs . rmdirSync ( dirname ) ; // error should have been set assert . ok ( err != null ) ; assert . equal ( err . code , 'EACCES' ) ; done ( ) ; } catch ( err ) { done ( err ) ; }", "del_tokens": "// error should have been set assert . ok ( err != null ) ; assert . equal ( err . code , 'EACCES' ) ; // cleanup temp dir fs . chmodSync ( dirname , 0x1B6 ) ; // 666 in octal fs . rmdirSync ( dirname ) ; done ( ) ;", "commit_type": "move"}
{"commit_tokens": ["added", "new", "feature", "to", "replace", "endpoint"], "add_tokens": "var _endpoint = options . endpoint || \"localhost:8080/v1\" ; endpoint : null ,", "del_tokens": "* @ const var _endpoint = \"localhost:8080/v1\" ;", "commit_type": "add"}
{"commit_tokens": ["Added", "listControls", "API", "to", "retrieve", "the", "available", "camera", "controls", ".", "This"], "add_tokens": "* @ param { Function } callback returns a list of cameras / ** * List available camera controls * * @ method listControls * * @ param { Function ( Array < CameraControl > ) } callback Function that receives * camera controls * * @ param { String } stdoutOverride fswebcam command output override ( for * testing purposes ) * * / listControls : function ( callback , stdoutOverride ) { var scope = this ; var sh ; try { sh = scope . getListControlsSh ( ) ; } catch ( _ ) { callback && callback ( [ ] ) ; } //Shell execute var shArgs = { maxBuffer : 1024 * 10000 } ; EXEC ( sh , shArgs , function ( err , out , derr ) { if ( err ) { return callback && callback ( err ) ; } if ( scope . opts . verbose && derr ) { console . log ( derr ) ; } scope . parseListControls ( stdoutOverride || out + derr , callback ) ; } ) } ,", "del_tokens": "* @ param { Function } callback returns a list of camers", "commit_type": "add"}
{"commit_tokens": ["add", ":", "gzip", "funciton", "and", "add", "reactjs", "example"], "add_tokens": "var defaultCtrl = require ( '../../model/default' ) ; var ctrl = { index : function * ( next ) { yield defaultCtrl . bind ( this ) ( ) ; this . body = 'test' ; console . log ( next , '~~~~~~~~' ) ; yield next ; return ; this . body = 'deal/,deal/index,deal/index/index' ; } , order : function * ( ) { this . body = 'deal/index/order' ; } module . exports = ctrl ;", "del_tokens": "exports . index = function * ( ) { this . body = 'deal/,deal/index,deal/index/index' ; exports . order = function * ( ) { this . body = 'deal/index/order' ; }", "commit_type": "add"}
{"commit_tokens": ["Fix", "the", "reference", "to", "the", "HTML", "reporter", "."], "add_tokens": "Mocha . reporters . HTML . call ( this , runner ) ;", "del_tokens": "mocha . reporters . HTML . call ( this , runner ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "family", "property", "to", "families", "to", "be", "consistent", "with", "the", "custom", "module", "."], "add_tokens": "{ families : [ 'Font1' , 'Font2' ] } ) ; { api : 'http://moo' , families : [ 'Font1' , 'Font2' ] } ) ;", "del_tokens": "{ family : [ 'Font1' , 'Font2' ] } ) ; { api : 'http://moo' , family : [ 'Font1' , 'Font2' ] } ) ;", "commit_type": "change"}
{"commit_tokens": ["Added", "basic", "option", "to", "accept", "base64", "encoded", "options", "to", "obfuscate", "the", "config"], "add_tokens": "Raven . config ( \"eyJwdWJsaWNLZXkiOiAiZTg5NjUyZWMzMGI5NGQ5ZGI2ZWE2ZjI4NTgwYWI0OTkiLCAic2VjcmV0S2V5IjogIjc3ZWM4Yzk5YTg4NTQyNTZhYTY4Y2NiOTFkZDkxMTlkIiwgInNlcnZlcnMiOiBbIi9hcGkvc3RvcmUvIl0sICJ0ZXN0TW9kZSI6IHRydWV9\" ) ;", "del_tokens": "Raven . config ( { publicKey : 'e89652ec30b94d9db6ea6f28580ab499' , secretKey : '77ec8c99a8854256aa68ccb91dd9119d' , servers : [ '/api/store/' ] , // These are different for each browser, making the signature unpredictable testMode : true } ) ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "base", "config", "for", "app", "to", "work", "when", "installed", "as", "a", "dep", ":", "sparkles", ":"], "add_tokens": "// This appears to get called when the addon is installed, which is causing // some weird behavior right now... // includedCommands: function() { // return { // 'fountainhead-gendocs': require('./lib/index') // }; // }", "del_tokens": "} , includedCommands : function ( ) { return { 'fountainhead-gendocs' : require ( './lib/index' ) } ;", "commit_type": "update"}
{"commit_tokens": ["Updated", "info", "and", "list", "-", "all", "-", "token", "examples"], "add_tokens": "// Set NETWORK to either testnet or mainnet const NETWORK = ` ` // Instantiate Wormhole based on the network. if ( NETWORK === ` ` ) var Wormhole = new WH ( { restURL : ` ` } ) //else var Wormhole = new WH({ restURL: `https://trest.bitcoin.com/v1/` }) else var Wormhole = new WH ( { restURL : ` ` } )", "del_tokens": "const Wormhole = new WH ( { restURL : ` ` } )", "commit_type": "update"}
{"commit_tokens": ["Fix", "path", "of", "depending", "modules"], "add_tokens": "var BatchProcessor = require ( '../batch/processor' ) . Processor ;", "del_tokens": "var BatchProcessor = require ( './batch/processor' ) . Processor ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "cartTotalItems", "in", "routes", "/", "index", ".", "js", "instead", "of", "adding", "handlebar", "helper", ".", "fixes", "quantity", "discrepency", "in", "the", "view", "when", "you", "first", "add", "items", "to", "the", "cart"], "add_tokens": "req . session . cartTotalItems = req . session . cart . reduce ( ( a , b ) => + a + + b . quantity , 0 ) ; return res . status ( 200 ) . json ( { message : 'Cart successfully updated' , totalCartItems : req . session . cartTotalItems } ) ;", "del_tokens": "req . session . cartTotalItems = Object . keys ( req . session . cart ) . length ; return res . status ( 200 ) . json ( { message : 'Cart successfully updated' , totalCartItems : Object . keys ( req . session . cart ) . length } ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "config", "plugin", "added", "test"], "add_tokens": "module . exports = function config ( seneca , opts , cb ) { else seneca . fail ( cb , 'no-file' ) seneca . add ( { role : 'config' , cmd : 'get' } , function ( args , cb ) { val = seneca . util . copydata ( val )", "del_tokens": "module . exports = function config ( si , opts , cb ) { else si . fail ( cb , 'no-file' ) si . add ( { role : 'config' , cmd : 'get' } , function ( args , cb ) { val = common . copydata ( val )", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "typo", "in", "debugging", "message", "."], "add_tokens": "console . warn ( 'Starting to watch ' + dirName + ' using fs.watch' ) ;", "del_tokens": "console . warn ( 'Starting to ' + dirName + ' using fs.watch' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "template", "literal", "strings", "from", "theme", "-", "product"], "add_tokens": "throw new TypeError ( value + ' is not a Number.' ) ; throw new TypeError ( product + 'is not an object.' ) ; throw new Error ( product + 'is empty.' ) ; throw new TypeError ( collection + 'is not an array.' ) ; throw new Error ( collection + 'is empty.' ) ; 'Invalid value type passed for name of option ' + collection [ 0 ] . name + '. Value should be string.' throw new Error ( collection [ 0 ] + 'does not contain name key.' ) ; throw new Error ( options + 'is not a valid array of options.' ) ;", "del_tokens": "throw new TypeError ( ` ${ value } ` ) ; throw new TypeError ( ` ${ product } ` ) ; throw new Error ( ` ${ product } ` ) ; throw new TypeError ( ` ${ collection } ` ) ; throw new Error ( ` ${ collection } ` ) ; ` ${ collection [ 0 ] . name } . Value should be string . ` throw new Error ( ` ${ collection [ 0 ] } ` ) ; throw new Error ( ` ${ options } ` ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "tests", "for", "read", "options"], "add_tokens": "var db1 , db2", "del_tokens": "var db1 , db2 , bs1 , bs2", "commit_type": "add"}
{"commit_tokens": ["adding", "context", "to", "headers", "is", "now", "part", "of", "the", "agent", "s", "private", "api"], "add_tokens": "agent . addContextToHeaders ( span , options . headers ) ;", "del_tokens": "span . spanData_ . span . addContextToHeaders ( options . headers ) ;", "commit_type": "add"}
{"commit_tokens": ["Removes", "AMD", "support", "as", "was", "breaking", "other", "code", "and", "preventing", "it", "from", "functioning", "on", "some", "devices", "."], "add_tokens": "( function ( $ ) { } ) ( jQuery ) ;", "del_tokens": "( function ( factory ) { if ( typeof define === 'function' && define . amd ) { // AMD. Register as an anonymous module. define ( [ 'jquery' ] , factory ) ; } else { // Browser globals factory ( jQuery ) ; } } ( function ( $ ) { } ) ) ( jQuery ) ;", "commit_type": "remove"}
{"commit_tokens": ["Update", "build", "dist", "/", "assets"], "add_tokens": "* The YNAB API client class YnabApi { / ** * / budgets endpoints interface * / / ** * / budgets / { budget_id } / accounts endpoints interface * / get accounts ( ) { if ( ! this . _accounts ) { this . _accounts = new api_1 . AccountsApi ( this . _configuration ) ; } return this . _accounts ; } / ** * / budgets / { budget_id } / categories endpoints interface * / / ** * / budgets / { budget_id } / months endpoints interface * / / ** * / budgets / { budget_id } / payees endpoints interface * / / ** * / budgets / { budget_id } / payee_locations endpoints interface * / / ** * / budgets / { budget_id } / transactions endpoints interface * / / ** * / budgets / { budget_id } / scheduled_transactions endpoints interface * / / ** * Utilities * / module . exports = YnabApi ;", "del_tokens": "* ynabApi is the entrypoint to the YNAB API client . class ynabApi { get accounts ( ) { if ( ! this . _accounts ) { this . _accounts = new api_1 . AccountsApi ( this . _configuration ) ; } return this . _accounts ; } module . exports = ynabApi ;", "commit_type": "update"}
{"commit_tokens": ["adding", "/", "removing", "task", "sources", "and", "emitting", "task", "change", "events", "in", "plugin", "api"], "add_tokens": "task_manager = require ( './task_manager' ) , account_manager : async . apply ( account_manager . start , manager ) , task_manager : async . apply ( task_manager . start , manager ) var tm = results . task_manager ; opt . addSource = tm . addSource ; opt . removeSource = tm . removeSource ; tm . on ( 'change' , function ( db , change ) { api . task . emit ( 'change' , db , change ) ; if ( change && change . doc && change . doc . type ) { api . task . emit ( 'change:' + change . doc . type , db , change ) ; } } ) ; am . stop , tm . stop", "del_tokens": "account_manager : async . apply ( account_manager . start , manager ) am . stop", "commit_type": "add"}
{"commit_tokens": ["Add", "version", "to", "npm", "builds"], "add_tokens": "const version = require ( '../package.json' ) . version", "del_tokens": "const version = global . VERSION", "commit_type": "add"}
{"commit_tokens": ["remove", "constrains", "option", "implemented", "by", "placement", "(", "add", "horizontal", "vertical", "option", "to", "placement", ")"], "add_tokens": "var isH = placement === 'horizontal' ; var isV = placement === 'vertical' ; var detect = placement === 'auto' || isH || isV ; if ( detect ) { placement = isH ? 'right-bottom' : 'bottom-right' ; if ( isV ) { placement = isH ? 'right-top' : 'top-right' ; if ( isH ) { if ( isH ) { if ( isH ) { placement = isH ? 'left-bottom' : 'bottom-left' ; if ( isV ) { placement = isH ? 'left-top' : 'top-left' ;", "del_tokens": "constrains : null , getConstrains : function ( ) { var dataAttr = this . $element . attr ( 'data-contrains' ) ; if ( typeof ( dataAttr ) !== 'undefined' ) { return dataAttr ; } return this . options . constrains ; } , if ( placement === 'auto' ) { var constrainsH = this . getConstrains ( ) === 'horizontal' , constrainsV = this . getConstrains ( ) === 'vertical' ; placement = constrainsH ? 'right-bottom' : 'bottom-right' ; if ( constrainsV ) { placement = constrainsH ? 'right-top' : 'top-right' ; if ( constrainsH ) { if ( constrainsH ) { if ( constrainsH ) { placement = constrainsH ? 'left-bottom' : 'bottom-left' ; if ( constrainsV ) { placement = constrainsH ? 'left-top' : 'top-left' ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "unit", "tests", "for", "boundary", "comparators", "."], "add_tokens": "initialLowerBound ( ) { initialUpperBound ( ) { describe ( 'and no time has passed' , ( ) => {", "del_tokens": "getInitialLowerBound ( ) { getInitialUpperBound ( ) { describe ( 'and no time has passing' , ( ) => {", "commit_type": "add"}
{"commit_tokens": ["Add", "reject", "message", "(", "mandatory", ")"], "add_tokens": "deferred . reject ( 'fail' ) ;", "del_tokens": "deferred . reject ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "several", "comments", "and", "improved", "example", "getter", "/", "setter", "on", "last", "example"], "add_tokens": "/** Getter */ /** Setter */ else if ( typeof arg == 'string' ) this . _test = arg ; /** Handle type errors */ else throw new TypeError ( ` ${ this . constructor . name } ${ typeof arg } ` ) ; /** Return this object for set call chaining */ return this ;", "del_tokens": "this . _test = arg ;", "commit_type": "add"}
{"commit_tokens": ["Use", "the", "(", "new", "and", "improved", ")", "crc", "for", "crc32"], "add_tokens": "var crc = require ( 'crc' ) . crc32", "del_tokens": "var crc = require ( 'buffer-crc32' ) . unsigned", "commit_type": "use"}
{"commit_tokens": ["Added", "test", "function", "to", "test", "reduced", "components"], "add_tokens": "console . log ( hanzi . decompose ( '氵')) ;", "del_tokens": "console . log ( hanzi . decompose ( '水')) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "style", "tag", "to", "processings", "."], "add_tokens": "return href ? path . join ( path . isAbsolute ( href ) ? _root : path . dirname ( _from ) , href ) : _from ; tree . match ( match ( 'link[module][href], style[module]' ) , function ( node ) {", "del_tokens": "return path . join ( path . isAbsolute ( href ) ? _root : path . dirname ( _from ) , href ) ; tree . match ( match ( 'link[module][href]' ) , function ( node ) {", "commit_type": "add"}
{"commit_tokens": ["use", "browser", "hash", "instead", "of", "search", "and", "separate", "logic", "from", "retrieving", "source"], "add_tokens": "window . open ( \"/ruleset.html#\" + $ ( this ) . html ( ) , \"ruleset\" ) ;", "del_tokens": "window . open ( \"/ruleset.html?\" + $ ( this ) . html ( ) , \"ruleset\" ) ;", "commit_type": "use"}
{"commit_tokens": ["adding", "timeout", "to", "directive", "and", "unit", "tests", "used", "while", "integrating", "with", "other", "directives", "to", "queue", "processing", "of", "validations", "properly"], "add_tokens": "var element , scope , errorMessages , hiddenErrorMessages , visibleErrorMessages , passwordInput , confirmPasswordInput , templateRetriever ; inject ( function ( $injector , $rootScope , $compile , $q , $timeout ) { $timeout . flush ( ) ; inject ( function ( $rootScope , $compile , $timeout ) { $timeout . flush ( ) ; inject ( function ( $rootScope , $compile , $timeout ) { $timeout . flush ( ) ; inject ( function ( $rootScope , $compile , $timeout ) { $timeout . flush ( ) ;", "del_tokens": "var element , scope , errorMessages , hiddenErrorMessages , visibleErrorMessages , passwordInput , confirmPasswordInput , templateRetriever ; inject ( function ( $injector , $rootScope , $compile , _$q_ ) { $q = _$q_ ; inject ( function ( $rootScope , $compile ) { inject ( function ( $rootScope , $compile ) { inject ( function ( $rootScope , $compile ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "the", "signIn", "function", "the", "var", "credentials", "should", "be", "a", "map", ".", "and", "we", "should", "remember", "the", "accessKey", "in", "constructor", "so", "that", "we", "can", "access", "it", "in", "signIn", "function", "."], "add_tokens": "this . accessKey = accessKey ; var credentials = { } ;", "del_tokens": "var credentials = [ ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "new", "line", "to", "end", "of", "file"], "add_tokens": "} ) ;", "del_tokens": "} ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "option", "to", "control", "saving", "uninitialized", "sessions", "to", "storage"], "add_tokens": "var saveUninitializedSession = options . saveUninitialized === undefined ? true : options . saveUninitialized ; if ( ! shouldSetCookie ( req ) ) { return ; if ( shouldSave ( req ) ) { originalId = req . sessionID ; originalHash = hash ( req . session ) ; // determine if session should be saved to store function shouldSave ( req ) { return unsignedCookie != req . sessionID ? saveUninitializedSession || isModified ( req . session ) : resaveSession || isModified ( req . session ) ; } // determine if cookie should be set on response function shouldSetCookie ( req ) { // in case of rolling session, always reset the cookie if ( rollingSessions ) { return true ; } return unsignedCookie != req . sessionID ? saveUninitializedSession || isModified ( req . session ) : req . session . cookie . expires != null && isModified ( req . session ) ; }", "del_tokens": "var isNew = unsignedCookie != req . sessionID ; // in case of rolling session, always reset the cookie if ( ! rollingSessions ) { // browser-session length cookie if ( null == cookie . expires ) { if ( ! isNew ) { debug ( 'already set browser-session cookie' ) ; return } // compare hashes and ids } else if ( ! isModified ( req . session ) ) { debug ( 'unmodified session' ) ; return } if ( resaveSession || isModified ( req . session ) ) {", "commit_type": "add"}
{"commit_tokens": ["allow", "names", "to", "be", "found", "up", "along", "the", "proto", "chain"], "add_tokens": "// using `in` instead of `hasOwnProperty` to // allow property to be somewhere on the prototype chain // todo: are we sure this is what we want? need a way to specify // a prop *must* be on the object? return ! ( el in obj ) ;", "del_tokens": "return ! obj . hasOwnProperty ( el ) ;", "commit_type": "allow"}
{"commit_tokens": ["Remove", "use", "of", "q", "-", "specific", "function", "Promise~done", "()"], "add_tokens": ". then ( ( filenames ) => { /* eslint-disable no-console */ console . log ( 'The following files were updated: ' + filenames . join ( ', ' ) ) /* eslint-enable no-console */ } , ( err ) => console . error ( err ) // eslint-disable-line no-console ) . then ( ( ) => console . log ( 'OK' ) , // eslint-disable-line no-console ( err ) => console . error ( err ) // eslint-disable-line no-console ) . then ( ( ) => console . log ( 'OK' ) , // eslint-disable-line no-console ( err ) => console . error ( err ) // eslint-disable-line no-console ) require ( '../lib/up-to-date.js' ) ( ) . then ( ( ) => console . log ( 'OK' ) , // eslint-disable-line no-console ( err ) => console . error ( err ) // eslint-disable-line no-console )", "del_tokens": ". done ( function ( filenames ) { debug ( 'done' ) /* eslint-disable no-console */ console . log ( 'The following files were updated: ' + filenames . join ( ', ' ) ) /* eslint-enable no-console */ } ) . done ( function ( ) { console . log ( 'OK' ) // eslint-disable-line no-console } ) . done ( function ( ) { console . log ( 'OK' ) // eslint-disable-line no-console } ) require ( '../lib/up-to-date.js' ) ( ) . done ( function ( ) { console . log ( 'OK' ) // eslint-disable-line no-console } )", "commit_type": "remove"}
{"commit_tokens": ["Fix", "Range", "for", "empty", "ranges", "(", "e", ".", "g", ".", "2", "..", "2", ")"], "add_tokens": "let start ; let end ; start = 2 ; end = 4 ; describe ( '.size()' , ( ) => { it ( 'is inclusive of `end`' , ( ) => { expect ( subject ( ) . size ( ) ) . toEqual ( 3 ) ; } ) ; describe ( 'when start and end are equal' , ( ) => { beforeEach ( ( ) => { start = 2 ; end = 2 ; } ) ; it ( 'has a size of zero' , ( ) => { expect ( subject ( ) . size ( ) ) . toEqual ( 0 ) ; } ) ; } ) ; describe ( 'when start and end are equal' , ( ) => { beforeEach ( ( ) => { start = 2 ; end = 2 ; } ) ; it ( 'does not iterate' , ( ) => { const numbers = [ ] ; subject ( ) . forEach ( ( i ) => numbers . push ( i ) ) ; expect ( numbers ) . toEqual ( [ ] ) ; } ) ; } ) ;", "del_tokens": "const start = 2 ; const end = 4 ; it ( 'has a size' , ( ) => { expect ( subject ( ) . size ( ) ) . toEqual ( 3 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "placeholders", "support", "for", "a", "messages", ".", "json"], "add_tokens": "if ( lineValue === '' && messageProp !== 'description' ) { getByPath ( locales , propPath , true ) [ messageProp ] = messageProp !== 'placeholders' ? lineValue || '' : parsePlaceholders ( lineValue ) ; / ** * Generates a placeholders object from a source string * @ param { string } source * @ returns { object } * / function parsePlaceholders ( source ) { return source . match ( / \\([^\\)]+\\) / g ) . reduce ( function ( result , placeholder ) { placeholder = placeholder . replace ( / ^\\(([^\\)]+)\\)$ / , '$1' ) ; var keyValue = placeholder . split ( ':' ) ; result [ keyValue [ 0 ] ] = { content : keyValue [ 1 ] } ; return result ; } , { } ) ; }", "del_tokens": "if ( lineValue === '' && messageProp === 'message' ) { getByPath ( locales , propPath , true ) [ messageProp ] = lineValue || '' ;", "commit_type": "add"}
{"commit_tokens": ["added", "identiy", "defaults", "and", "isObject", "to", "VisSenseUtils"], "add_tokens": "var DEFAULT_CONFIG = { visibleUpdateInterval : 250 , hiddenUpdateInterval : 250 , updatePercentageOnPageHidden : false } ; var parseConfig = function ( config ) { if ( config . visibleUpdateInterval < 1 || config . hiddenUpdateInterval < 1 ) { throw new Error ( 'InvalidArgument: update interval needs to be positive.' ) ; return VisSenseUtils . defaults ( config , DEFAULT_CONFIG ) ; if ( ! config . updatePercentageOnPageHidden && ! VisSenseUtils . isPageVisible ( ) ) {", "del_tokens": "var parseConfig = function ( config ) { var c = { visibleUpdateInterval : 250 , hiddenUpdateInterval : 250 } ; if ( config . visibleUpdateInterval > 0 ) { c . visibleUpdateInterval = config . visibleUpdateInterval ; } if ( config . hiddenUpdateInterval > 0 ) { c . hiddenUpdateInterval = config . hiddenUpdateInterval ; return c ; if ( ! VisSenseUtils . isPageVisible ( ) ) {", "commit_type": "add"}
{"commit_tokens": ["fixes", "styles", "in", "sub", "-", "components"], "add_tokens": "if ( itemObject . srcContents ) { finalString = itemObject . srcContents ; } else { if ( itemObject . charset ) { finalString += ` ${ itemObject . charset } ` ; if ( itemObject . type ) { finalString += ` ${ itemObject . type } ` ; } if ( itemObject . src ) { finalString += ` ${ itemObject . src } ` ; } if ( itemObject . async || itemObject . defer ) { if ( itemObject . async ) { extras += \" async\" ; } if ( itemObject . defer ) { extras += \" defer\" ; } finalString += extras ; finalString += \" ></script>\" ;", "del_tokens": "if ( itemObject . charset ) { finalString += ` ${ itemObject . charset } ` ; } if ( itemObject . type ) { finalString += ` ${ itemObject . type } ` ; } if ( itemObject . src ) { finalString += ` ${ itemObject . src } ` ; } if ( itemObject . async || itemObject . defer ) { if ( itemObject . async ) { extras += \" async\" ; if ( itemObject . defer ) { extras += \" defer\" ; finalString += extras ; finalString += \" ></script>\" ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "timeout", "to", "init", "setUp", "and", "tearDown", "functions", "."], "add_tokens": "catch ( err2 ) { err = ( failed [ key ] . stack ) ? failed [ key ] . stack : failed [ key ] . message ; split = failedValue . split ( constants . ERROR_MESSAGE_DELIMITER ) ;", "del_tokens": "catch ( err ) { err = failed [ key ] . stack ; var split = failedValue . split ( constants . ERROR_MESSAGE_DELIMITER ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "precheck", "from", "public", "API", "add", "folder", "argument", "where", "necessary"], "add_tokens": "var error = new Error ( response . humanReadable || 'Error' ) ;", "del_tokens": "const error = new Error ( response . humanReadable || 'Error' ) ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", "regexp", "for", "e", "-", "mail", "validator"], "add_tokens": "if ( value != '' && ! value . match ( / ^[a-z0-9\\.\\-\\_]+\\@(([a-z0-9][a-z0-9\\-]*\\.)+[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})$ / i ) )", "del_tokens": "if ( value != '' && ! value . match ( / ^[a-z0-9\\.\\-\\_]+\\@(([a-z][a-z0-9\\-]*\\.)+[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})$ / i ) )", "commit_type": "fix"}
{"commit_tokens": ["Fix", "typeof", "/", "instanceof", "mixup"], "add_tokens": "* @ version 2013.04 .15 if ( filepath instanceof Array ) {", "del_tokens": "* @ version 2013.02 .19 if ( typeof filepath == 'array' ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "method", "of", "testing", "function", "equality"], "add_tokens": "function noopReactDOMRender ( ) { } ReactDOM . render = noopReactDOMRender ; noopReactDOMRender ,", "del_tokens": "ReactDOM . render = function noopReactDOMRender ( ) { } ;", "commit_type": "fix"}
{"commit_tokens": ["add", "support", "for", "routing", "with", "windows", "environment"], "add_tokens": "path : path . relative ( this . options . pageRoot , route . path ) . replace ( / \\\\ / g , '/' )", "del_tokens": "path : path . relative ( this . options . pageRoot , route . path )", "commit_type": "add"}
{"commit_tokens": ["added", "handling", "when", "credentials", "not", "found"], "add_tokens": "var username , password , language_translation ; username = service . username ; password = service . password ; res . json ( service ? { bound_service : true } : null ) ; } ) ; username = username || this . credentials . username ; password = password || this . credentials . password ; RED . nodes . createNode ( this , config ) ; var node = this ;", "del_tokens": "var username , password , sUsername , sPassword , language_translation ; sUsername = service . username ; sPassword = service . password ; res . json ( service ? { bound_service : true } : null ) ; } ) ; RED . nodes . createNode ( this , config ) ; var node = this ; username = sUsername || this . credentials . username ; password = sPassword || this . credentials . password ; username = sUsername || this . credentials . username ; password = sPassword || this . credentials . password ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "bugs", "with", "Property", "Array", "s", "since", "PropertyArray", "instanceof", "Property", "is", "false", ".", "They", "inherit", "the", "methods", "but", "don", "t", "extend", "the", "prototype", "."], "add_tokens": "aArray : [ 1 , 2 , 3 , 8 , 5 ] key3 : \"new key\" , aArray : [ 1 , 4 ] //fix setValue", "del_tokens": "aArray : [ 1 , 2 ] key3 : \"new key\"", "commit_type": "fix"}
{"commit_tokens": ["Fix", "duplicate", "associations", "created", "for", "tags", "passed", "in", "reverse"], "add_tokens": "/ ** * Check if two arrays are either equal or palindromes , i . e . their elements * match even if one is reversed . * * @ param { Array } arr1 * @ param { Array } arr2 * @ returns { Boolean } - Whether the arrays are equal or not . * / TiqDB . prototype . equalArrays = function ( arr1 , arr2 ) { return _ . isEqual ( arr1 , arr2 ) || _ . isEqual ( arr1 , arr2 . reverse ( ) ) ; } var notExists = true , assocValues = _ . values ( assoc ) ; if ( tiq . equalArrays ( assocValues , _ . values ( existingAssocs [ i ] ) ) ) {", "del_tokens": "var notExists = true ; if ( _ . isEqual ( assoc , existingAssocs [ i ] ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "module", ".", "exports", "and", "game", ".", "run", "()", "TODO", "."], "add_tokens": "// Export the game object module . exports = game ; game . run ( ) ; // TODO: Delete this", "del_tokens": "game . run ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "animation", "start", "property", "sometimes", "not", "being", "correctly", "initialized", "especially", "in", "IE"], "add_tokens": "s : parseFloat ( s [ 1 ] ) || 0 , e : parseFloat ( e [ 1 ] ) || 0 ,", "del_tokens": "s : parseFloat ( s [ 1 ] ) , e : parseFloat ( e [ 1 ] ) ,", "commit_type": "fix"}
{"commit_tokens": ["adds", "common", "-", "questions", "as", "a", "dep"], "add_tokens": ". use ( utils . commonQuestions ( ) ) // app.task('questions', {silent: true}, function(cb) { // debug('loading questions'); // app.data(base.cache.data); // app.question('project.name', 'Project name?', { // default: app.data('name') || app.pkg.get('name') // }); // app.question('project.alias', 'Project alias?', { // default: app.data('alias') // }); // debug('loaded questions'); // cb(); // }); app . task ( 'mocha' , [ 'questions' , 'templates' ] , function ( cb ) {", "del_tokens": "app . helper ( 'relative' , function ( dest ) { return ( dest !== this . app . cwd ) ? path . relative ( dest , this . app . cwd ) : './' ; } ) ; app . task ( 'questions' , { silent : true } , function ( cb ) { debug ( 'loading questions' ) ; app . data ( base . cache . data ) ; app . question ( 'project.name' , 'Project name?' , { default : app . data ( 'name' ) || app . pkg . get ( 'name' ) } ) ; app . question ( 'project.alias' , 'Project alias?' , { default : app . data ( 'alias' ) } ) ; debug ( 'loaded questions' ) ; cb ( ) ; } ) ; app . task ( 'mocha' , [ 'questions' , 'templates' , 'dest' ] , function ( cb ) {", "commit_type": "add"}
{"commit_tokens": ["Remove", "undocumented", "req", ".", "sessionCookies", "and", "req", ".", "sessionKey"], "add_tokens": "// for overriding if ( ( sess = tryGetSession ( cookies , name , req . sessionOptions ) ) ) { * Try getting a session from a cookie . function tryGetSession ( cookies , name , opts ) {", "del_tokens": "// to pass to Session() req . sessionCookies = cookies req . sessionKey = name if ( ( sess = tryGetSession ( req ) ) ) { * Try getting a session from a request . function tryGetSession ( req ) { var cookies = req . sessionCookies var name = req . sessionKey var opts = req . sessionOptions", "commit_type": "remove"}
{"commit_tokens": ["Changed", "test", "GitHub", "user", "to", "not", "go", "over", "API", "rate", "limit"], "add_tokens": "var lintProcess = spawn ( 'node' , [ './bin/mdlint' , 'user' , 'mishalshah' ] ) ;", "del_tokens": "var lintProcess = spawn ( 'node' , [ './bin/mdlint' , 'user' , 'ChrisWren' ] ) ;", "commit_type": "change"}
{"commit_tokens": ["Use", "Analyzer", "type", "in", "plugin", "example"], "add_tokens": "var Analyzer = require ( 'code-copter' ) . Analyzer ; module . exports = new Analyzer ( { } ) ;", "del_tokens": "module . exports = { } ;", "commit_type": "use"}
{"commit_tokens": ["Changing", "mqtt", "send", "to", "mqtt", "publish"], "add_tokens": "/ ** publish MQTT publish ( topic , message , bucket ) {", "del_tokens": "/ ** Send MQTT send ( topic , message , bucket ) {", "commit_type": "change"}
{"commit_tokens": ["add", "a", "way", "to", "disable", "event", "logging"], "add_tokens": "eventLog : { enabled : true } , if ( loggers . console && this . get ( 'eventLog' ) . enabled ) {", "del_tokens": "eventLog : { } , if ( loggers . console && this . get ( 'eventLog' ) ) {", "commit_type": "add"}
{"commit_tokens": ["Updating", "browncorpus", "and", "corpuscoverage", "utility", "updating", "wikparser", "to", "fix", "high", "memory", "issues"], "add_tokens": "brown . output = path . join ( outputDir , 'en-brown.tag.vocab' ) ; brown . outputDist = path . join ( outputDir , 'en-brown.tag.dist' ) ;", "del_tokens": "brown . output = path . join ( outputDir , 'en-brown.tag.dist' ) ;", "commit_type": "update"}
{"commit_tokens": ["add", "test", "to", "page", "::", "create"], "add_tokens": "* @ param { string } uri return components . get ( layoutReference ) . then ( function ( layoutReferenceData ) {", "del_tokens": "* @ param { string } uri Currently unused ; saving for later for consistency with other functions return components . get ( layoutReference ) . then ( function ( ) {", "commit_type": "add"}
{"commit_tokens": ["make", "this", "newfangled", "browsersync", "shit", "work", "locally"], "add_tokens": "var staticUri = process . env . SINGULARITY_STATIC_URI || ( serverBase + '/static' ) ; var appUri = process . env . SINGULARITY_APP_URI || ( serverBase + '/ui' ) ; staticRoot : staticUri , appRoot : appUri , var port = process . env . PORT || 3334 ; publicPath : staticUri , port : port , startPath : appUri , socket : { domain : 'localhost:' + port , clientPath : '/singularity/browser-sync' } ,", "del_tokens": "staticRoot : process . env . SINGULARITY_STATIC_URI || ( serverBase + '/static' ) , appRoot : process . env . SINGULARITY_APP_URI || ( serverBase + '/ui' ) , publicPath : webpackConfig . output . publicPath ,", "commit_type": "make"}
{"commit_tokens": ["Fix", "for", "new", "version", "of", "Sweet", "Alert"], "add_tokens": "var buttonContainerTag = sweetAlertModal . querySelector ( '.sa-button-container' ) || sweetAlertModal . querySelector ( '.cancel' ) // insert form before swal bottom buttons sweetAlertModal . insertBefore ( formTag , buttonContainerTag ) \" value='{value}' title='{placeholder}' placeholder='{placeholder}'>\" + input . clazz = ! input . isRadioOrCheckbox ( ) ? 'nice-input' : 'patch-swal-styles-for-inputs'", "del_tokens": "var cancelButtonTag = sweetAlertModal . querySelector ( '.cancel' ) sweetAlertModal . insertBefore ( formTag , cancelButtonTag ) \" value='{value}' title='{placeholder}' placeholder='{placeholder}'>\" + input . clazz = ! input . isRadioOrCheckbox ( ) ? 'nice-input' : ''", "commit_type": "fix"}
{"commit_tokens": ["Changed", "method", "name", "for", "get", "cart", "by", "id", ".", "Added", "get", "products"], "add_tokens": "this . getCart = function ( cartId ) {", "del_tokens": "this . get = function ( cartId ) {", "commit_type": "change"}
{"commit_tokens": ["make", "Set", "use", "correct", "values"], "add_tokens": "else set [ e . key ] = e . value db . put ( key , - 1 , cb ) db . del ( key , cb )", "del_tokens": "else set [ e . key ] = true db . put ( key , 0 , cb ) db . del ( key , 0 , cb )", "commit_type": "make"}
{"commit_tokens": ["move", "example", "goto", "logic", "into", "component"], "add_tokens": "gotoPrevious ( ) { gotoNext ( ) {", "del_tokens": "gotoPrevious ( event ) { if ( event ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; } gotoNext ( event ) { if ( event ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; }", "commit_type": "move"}
{"commit_tokens": ["removed", "outstanding", "references", "to", "client"], "add_tokens": "var client = new Connection ( { var client = new Connection ( {", "del_tokens": "var client = new Client ( { var client = new Client ( {", "commit_type": "remove"}
{"commit_tokens": ["Added", "test", "and", "code", "to", "prevent", "cookie", "sniffing"], "add_tokens": "if ( token ) { token . getUser ( ) . success ( function ( user ) { req . session = { user : user } ; next ( ) ; } ) . error ( onError ( res ) ) ; } else { res . clearCookie ( 'token' ) ; }", "del_tokens": "token . getUser ( ) . success ( function ( user ) { req . session = { user : user } ; } ) . error ( onError ( res ) ) ;", "commit_type": "add"}
{"commit_tokens": ["adding", "ui", "date", "picker", "template", "since", "boostrap", "3", "date", "input", "not", "OK", "on", "navigators", "<", ">", "chrome"], "add_tokens": "var version = { build : '1.0.2' } ' Version ' + version . build + ' \\n' + ' Link: https://github.com/MacKentoch/easyFormGenerator \\n' + ' License : MIT (2015) \\n' + ' * Version ' + version . build + ' \\n' + ' * Author : Erwan Datin (MacKentoch) \\n' + ' Link: https://github.com/MacKentoch/easyFormGenerator \\n' +", "del_tokens": "' Version 1.0.1 \\n' + ' License : 2015 MIT \\n' + ' * Version 1.0.1 \\n' + ' * Author : Erwan Datin (MacKentoch) \\n' +", "commit_type": "add"}
{"commit_tokens": ["added", "Bezier", ".", "js", "to", "render", "worker"], "add_tokens": "importScripts ( '../../target/js/browser.maker.js' , '../../external/bezier-js/bezier.js' ) ;", "del_tokens": "importScripts ( '../../target/js/browser.maker.js' ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "renameProperties", "to", "match", "bracketing", "structure", "with", "the", "rest", "of", "the", "code", "and", "to", "remove", "the", "assumption", "that", "newObject", ".", "forEach", "is", "present", "in", "Object", ".", "prototype"], "add_tokens": "newObject . forEach . call ( mappingObject , function ( newPropertyName , oldPropertyName ) { if ( self . hasOwnProperty ( oldPropertyName ) ) {", "del_tokens": "mappingObject . forEach ( function ( newPropertyName , oldPropertyName ) { if ( self . hasOwnProperty ( oldPropertyName ) ) {", "commit_type": "update"}
{"commit_tokens": ["Fix", "integration", "test", "by", "updating", "asset", "-", "rev", "fingerprint"], "add_tokens": "assert . ok ( content . indexOf ( 'href=\"https://www.example.com/manifest-f105f80557272f93397e34ea016e172d.webmanifest\"' ) > - 1 , 'checksum fingerprint is added to manifest.webmanifest file' ) ; . then ( contentOf ( app , 'dist/manifest-f105f80557272f93397e34ea016e172d.webmanifest' ) )", "del_tokens": "assert . ok ( content . indexOf ( 'href=\"https://www.example.com/manifest-ce65942fa306b3b532ff17cf85454f3d.webmanifest\"' ) > - 1 , 'checksum fingerprint is added to manifest.webmanifest file' ) ; . then ( contentOf ( app , 'dist/manifest-ce65942fa306b3b532ff17cf85454f3d.webmanifest' ) )", "commit_type": "fix"}
{"commit_tokens": ["allow", "default", "options", "to", "be", "modified", "in", "constructor"], "add_tokens": "function DiscogsClient ( userAgent , oauth , options ) { // Merge any passed configuration options into the configuration object which already has the defaults config = merge ( config , options ) ;", "del_tokens": "function DiscogsClient ( userAgent , oauth ) {", "commit_type": "allow"}
{"commit_tokens": ["Add", ":", "find", "findIdx", "findLastIdx"], "add_tokens": "/ * Return the first key where the predicate truth test passes. * | [ ctx ] | * | Predicate context | * | return | string | Key of matched element |", "del_tokens": "/ * Return the key where the predicate truth test passes or undefined. * | return | string | The key of matched element |", "commit_type": "add"}
{"commit_tokens": ["Allow", "the", "tree", "to", "scroll", "overflow", "in", "case", "we", "re", "not", "running", "on", "firefox", "."], "add_tokens": "_moveMember : function ( member , toIndex ) { moveMember : function ( member , toIndex ) { this . _moveMember ( member , toIndex ) ; this . getQueryDesigner ( ) . axisChanged ( this ) ; } , if ( hierarchyName !== \"Measures\" ) { setDef = \"Hierarchize(\" + setDef + \")\" ; } if ( mdx . length ) mdx = mdx + \" ON Axis(\" + this . conf . id + \")\" ; //bug in gecko: mouseup event does not report correct target //in case overflow in anything but hidden. if ( ! ( navigator . userAgent . indexOf ( \"Gecko\" ) && navigator . userAgent . indexOf ( \"WebKit\" ) === - 1 ) ) { gEl ( \"cube-body\" ) . style . overflow = \"auto\" ; }", "del_tokens": "moveMember : function ( member , toIndex ) { if ( mdx . length ) mdx = \"Hierarchize(\" + mdx + \") ON Axis(\" + this . conf . id + \")\" ; //gEl(\"cube-body\").style.overflow = \"auto\";", "commit_type": "allow"}
{"commit_tokens": ["add", "tests", "for", "promise", "api"], "add_tokens": "var timeout = 1000 ; describe ( 'Promise' , function ( ) { it ( 'should reject with error if timeout is hit' , function ( done ) { modbusRTU . setID ( 6 ) ; modbusRTU . setTimeout ( timeout ) ; modbusRTU . readCoils ( 1 , 1 ) . then ( function ( ) { done ( new Error ( 'Failed should timeout' ) ) ; } ) . catch ( function ( err ) { expect ( err ) . to . have . string ( 'Timed out' ) ; done ( ) ; } ) ; clock . tick ( timeout ) ; } ) ; } ) ;", "del_tokens": "var timeout = 1000 ;", "commit_type": "add"}
{"commit_tokens": ["Making", "sure", "sourceMappingURL", "is", "at", "the", "end", "of", "the", "file", "and", "that", "it"], "add_tokens": "autonomous : autonomous , moriSrc : moriSrc ,", "del_tokens": "if ( autonomous ) { result . code += 'var mori = ' + moriSrc ; }", "commit_type": "make"}
{"commit_tokens": ["added", "unsubscribe", "api", "and", "fixed", "callbacks", "without", "rpc", "function"], "add_tokens": "// Have device join its uuid room name so that others can subscribe to it console . log ( 'joining room ' , room ) ; socket . on ( 'unsubscribe' , function ( room ) { console . log ( 'leaving room ' , room ) ; socket . leave ( room ) ; } ) try { fn ( results ) ; } catch ( e ) { console . log ( e ) ; } try { fn ( results ) ; } catch ( e ) { console . log ( e ) ; } try { fn ( results ) ; } catch ( e ) { console . log ( e ) ; } try { fn ( results ) ; } catch ( e ) { console . log ( e ) ; } } ; try { fn ( results ) ; } catch ( e ) { console . log ( e ) ; } try { fn ( results ) ; } catch ( e ) { console . log ( e ) ; }", "del_tokens": "console . log ( 'joining room' , room ) ; fn ( results ) ; fn ( results ) ; fn ( results ) ; fn ( results ) ; } fn ( results ) ; fn ( results ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "close", "button", "to", "widget"], "add_tokens": "var histogramView = require ( '../views/histogram' ) ; var histogramModel = require ( '../models/histogram' ) ; contentView : [ 'any' , false , ] , contentModel : [ 'any' , false ] , this . add ( { type : 'histogram' , contentView : histogramView , contentModel : histogramModel } ) ;", "del_tokens": "var Histogram = require ( '../views/histogram' ) ; contentConstructor : [ 'any' , false , ] , this . add ( { type : 'histogram' , contentConstructor : Histogram } ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "internal", "server", "module", "to", "run", "the", "iosServer", "in", "test"], "add_tokens": "import { startServer } from '../../lib/server' ; context . server = await startServer ( env . APPIUM_PORT , 'localhost' ) ;", "del_tokens": "import server from 'appium-express' ; context . server = await server ( setupRoutes , env . APPIUM_PORT , 'localhost' ) ;", "commit_type": "use"}
{"commit_tokens": ["updated", ":", "cafeteria", "string", "resources"], "add_tokens": "* Resource converter ( from ods to messages / messages . * . res ) // [CDP customize] // [CDP customize] // [CDP customize] // [CDP customize] // [CDP customize] // [CDP customize]", "del_tokens": "* PMO Web Resource converter ( from ods to messages / messages . * . res ) // [SA customize] // [SA customize] // [SA customize] // [SA customize] // [SA customize] // [SA customize]", "commit_type": "update"}
{"commit_tokens": ["Added", "default", "reference", "and", "schema", "buckets", "and", "reference", "validation"], "add_tokens": "// Provide default options _ . defaults ( options , { schemaBucket : 'schemas.taskcluster.net' } ) ; // Create validator assert ( options . schemaPrefix , \"Can't publish without schemaPrefix\" ) ;", "del_tokens": "assert ( options . schemaPrefix , \"Can't publish without schemaPrefix\" ) ; assert ( options . schemaBucket , \"Can't publish without schemaBucket\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Moved", "to", "proper", "Kinetic", "."], "add_tokens": "var ReactUpdates = require ( 'react/lib/ReactUpdates' ) ; var transaction = ReactUpdates . ReactReconcileTransaction . getPooled ( ) ; ReactUpdates . ReactReconcileTransaction . release ( transaction ) ;", "del_tokens": "var transaction = ReactComponent . ReactReconcileTransaction . getPooled ( ) ; ReactComponent . ReactReconcileTransaction . release ( transaction ) ;", "commit_type": "move"}
{"commit_tokens": ["Implement", "--", "debug", "=", "false", "."], "add_tokens": "if ( ! parsed . bundler && parsed . debug !== 'false' ) {", "del_tokens": "if ( ! parsed . bundler && ( parsed . debug === undefined || parsed . debug ) ) {", "commit_type": "implement"}
{"commit_tokens": ["Make", "it", "possible", "to", "disable", "Socket", ".", "io", "and", "pass", "options"], "add_tokens": "if ( this . socketio !== false ) { this . io = io ( this . url , this . socketio || { } ) ; }", "del_tokens": "this . io = io ( this . url ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "reading", "tokenKey", "from", "options", "."], "add_tokens": "var options = feathersClient . authentication . options ; var tokenLocation = options . tokenKey || options . cookie ;", "del_tokens": "var tokenLocation = feathersClient . authentication . tokenKey || feathersClient . authentication . cookie ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "accept", "header", "in", "test", "cases", "."], "add_tokens": "req . headers [ 'accept' ] = 'application/json' req . headers [ 'accept' ] = 'application/xrd+xml'", "del_tokens": "req . headers [ 'content-type' ] = 'application/json' req . headers [ 'content-type' ] = 'application/xrd+xml'", "commit_type": "use"}
{"commit_tokens": ["Added", "quotes", "to", "url", "line", "."], "add_tokens": "var url = 'url(\"' + encodedImage + '\")' ;", "del_tokens": "var url = \"url(\" + encodedImage + \")\" ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "issue", "when", "detecting", "file", "changes"], "add_tokens": ", file = path . resolve ( dir , filename ) ;", "del_tokens": ", file = dir + '/' + filename ;", "commit_type": "fix"}
{"commit_tokens": ["added", "few", "missing", "fields", "to", "GetEntityMetadataList"], "add_tokens": "{ Select : [ 'MetadataId' , 'DisplayName' , 'DisplayCollectionName' , 'LogicalName' , 'LogicalCollectionName' , 'PrimaryIdAttribute' ] } ) . then ( edm . MetadataId = entity . MetadataId ; edm . PrimaryIdAttribute = entity . PrimaryIdAttribute ;", "del_tokens": "{ Select : [ 'DisplayName' , 'DisplayCollectionName' , 'LogicalName' , 'LogicalCollectionName' ] } ) . then (", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "paging", "through", ">", "1000", "results"], "add_tokens": "this . fetchSize = options . fetchSize ; return AdapterRead . commonOptions ( ) . concat ( [ 'viewId' , 'webProperty' , 'fetchSize' ] ) ; fetchSize : this . fetchSize , this . fetches = results . fetches ; points : results . points ,", "del_tokens": "return AdapterRead . commonOptions ( ) . concat ( [ 'viewId' , 'webProperty' ] ) ; points : results ,", "commit_type": "add"}
{"commit_tokens": ["Moved", "key", "protection", "into", "view", ".", "extend", "so", "that", "views", "and", "be", "created", "outside", "of", "FruitMachine", ".", "define"], "add_tokens": "View . extend = extend ( util . keys ( View . prototype ) ) ;", "del_tokens": "View . extend = extend ;", "commit_type": "move"}
{"commit_tokens": ["Added", "retry", "in", "file", "uploads"], "add_tokens": "console . log ( \"Error \" + err ) ; function doUpload ( src , dest , headers , retry , callback ) { client . putFile ( src , dest , headers , function ( err ) { if ( err ) { if ( retry > 2 ) { callback ( err ) ; } else { console . log ( err , \"Retrying...\" ) ; doUpload ( src , dest , headers , retry + 1 , callback ) ; } } else { callback ( ) ; } } ) ; } doUpload ( src , dest , headers , 0 , syncPoint ( src , dest , bucket ) ) ;", "del_tokens": "var extensions = { 'json' : 'application/json' , 'js' : 'application/javascript' , 'css' : 'text/stylesheet' , 'jpg' : 'image/jpg' , 'png' : 'image/png' , 'gif' : 'image/gif' } ; console . log ( \"Error\" , err ) ; client . putFile ( src , dest , headers , syncPoint ( src , dest , bucket ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "ie", "-", "specific", "code", "add", "direct", "color", "buffer", "mode"], "add_tokens": "// positions: [0,0, 1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7], size : 8 , // color: 'red', // color: ['red', 'green', 'blue', 'black', 'red', 'red', 'red', 'gray'], color : Array ( pos . length ) . fill ( 0 ) . map ( ( ) => colors [ Math . floor ( Math . random ( ) * colors . length ) ] ) , // color: 'rgba(0, 0, 255, .5)', // color: Array(pos.length * 4).fill(0).map(Math.random), // borderColor: 'rgba(0, 255, 0, .5)',", "del_tokens": "size : 5 , // color: Array(pos.length).fill(0).map(() => colors[Math.floor(Math.random() * colors.length)]), color : 'rgba(0, 0, 255, .5)' , // borderColor: 'rgba(255, 0, 0, .5)',", "commit_type": "remove"}
{"commit_tokens": ["Remove", "internal", "stack", "trace", "for", "error", "trace"], "add_tokens": "stack = ( obj instanceof Error ) ? obj . stack : new Error ( ) . stack . split ( \"\\n\" ) . splice ( 1 , 4 ) . join ( \"\\n\" ) ;", "del_tokens": "stack = ( obj instanceof Error ) ? obj . stack : new Error ( ) . stack ;", "commit_type": "remove"}
{"commit_tokens": ["fixing", "test", "for", "property", "attr"], "add_tokens": "try { foo . bar = NaN ; var fail = true ; } catch ( e ) { console . assert ( ! fail , 'this should never be seen' ) } try { foo . bar = 'aString' ; var fail = true ; } catch ( e ) { console . assert ( ! fail , 'this should never be seen' ) }", "del_tokens": "foo . bar = NaN ; foo . bar = 'aString' ;", "commit_type": "fix"}
{"commit_tokens": ["using", "ES", "-", "9", "-", "isms", "broke", "Travis", "testing", "on", "Node", "7"], "add_tokens": "trustedTypes : Object . assign ( { report ( msg ) { consoleOutput += ` ${ msg } \\n ` ; } , optionsFromSource ) ,", "del_tokens": "trustedTypes : { report ( msg ) { consoleOutput += ` ${ msg } \\n ` ; ... optionsFromSource , } ,", "commit_type": "use"}
{"commit_tokens": ["Add", "messages", "to", "handleResult", "for", "93196strict", "case"], "add_tokens": "sourceCode . push ( \"\\tthis.handleResult(errors, path || 'rootObject', this.makeError('objectStrict', undefined, [...givenProps.keys()].join(', ')), this.messages);\" ) ;", "del_tokens": "sourceCode . push ( \"\\tthis.handleResult(errors, path || 'rootObject', this.makeError('objectStrict', undefined, [...givenProps.keys()].join(', ')));\" ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "data", "not", "set", "properly"], "add_tokens": "} else if ( startBlock === endBlock ) { data", "del_tokens": "} else if ( startBlock === endBlock && startOffset === 0 ) { const startAt = data . get ( startAtField ) ; const checked = data . get ( checkField ) ; data : Data . create ( { [ startAtField ] : startAt , [ checkField ] : checked } )", "commit_type": "fix"}
{"commit_tokens": ["Make", "channel", "argument", "check", "more", "strict"], "add_tokens": "channel = parseInt ( channel ) if ( typeof channel !== 'number' ) {", "del_tokens": "if ( ! channel ) {", "commit_type": "make"}
{"commit_tokens": ["Fix", "hard", "erroring", "tests", "with", ".", "then", "(", "done", "done", ")"], "add_tokens": "} ) . then ( ( results ) => { . then ( done , done ) } ) . then ( ( results ) => { . then ( done , done ) it ( 'It should make a post request and then call the callback' , ( done ) => { } ) . then ( ( results ) => { . then ( done , done )", "del_tokens": "} ) . then ( ( results ) => { done ( ) } ) . then ( ( results ) => { done ( ) it . only ( 'It should make a post request and then call the callback' , ( done ) => { } ) . then ( ( results ) => { done ( )", "commit_type": "fix"}
{"commit_tokens": ["Changed", "config", ".", "percentThreshold", "to", "also", "accept", "a", "list", "of", "percentiles", "."], "add_tokens": "percentThreshold : for time information , calculate the Nth percentile ( s ) ( can be a single value or list of floating - point values )", "del_tokens": "percentThreshold : for time information , calculate the Nth percentile", "commit_type": "change"}
{"commit_tokens": ["Fix", "on", "connectController", "just", "res", ".", "render", "()", "if", "NOT", "resp", ".", "finished", "yet"], "add_tokens": "function index_id ( id , res ) { res . json ( { 'title' : 'Details' , 'id' : id } )", "del_tokens": "function index_id ( id ) { return { title : 'Details' , forum : forum }", "commit_type": "fix"}
{"commit_tokens": ["Fix", "missing", "var", "declarations", "extraneous", "arg"], "add_tokens": "checkMultiFileModeOptions ( ) ; var files = [ ] ;", "del_tokens": "checkMultiFileModeOptions ( options ) ; files = [ ] ;", "commit_type": "fix"}
{"commit_tokens": ["added", "more", "demos", "of", "dom", "type"], "add_tokens": "html = item . content ; self . onslide && self . onslide ( offset ) ; self . onslideend && self . onslideend ( self . slideIndex ) ;", "del_tokens": "html = '<div style=\"height: 100%; width: 100%;\">' + item . content + '</div>' ; self . onslide && self . onslide . call ( self , offset ) ; self . onslideend && self . onslideend ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "tests", "-", "extend", "editor", "functions", "only", "if", "editor", "is", "set"], "add_tokens": "if ( options && options . editor ) { options . editor . _serialize = options . editor . serialize ; options . editor . _deactivate = options . editor . deactivate ; options . editor . _activate = options . editor . activate ; options . editor . serialize = this . editorSerialize ; options . editor . deactivate = this . editorDeactivate ; options . editor . activate = this . editorActivate ; }", "del_tokens": "options . editor . _serialize = options . editor . serialize ; options . editor . _deactivate = options . editor . deactivate ; options . editor . _activate = options . editor . activate ; options . editor . serialize = this . editorSerialize ; options . editor . deactivate = this . editorDeactivate ; options . editor . activate = this . editorActivate ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "attributes", "to", "props", "helper", "in", "DOM", "to", "React", "parser"], "add_tokens": "var attributesToProps = require ( './attributes-to-props' ) ; var props ; // update values props = attributesToProps ( node . attribs ) ; props . dangerouslySetInnerHTML = { props . defaultValue = node . children [ 0 ] . data ; children = domToReact ( node . children , options ) ; props . key = i ; React . createElement ( node . name , props , children )", "del_tokens": "node . attribs . dangerouslySetInnerHTML = { node . attribs . defaultValue = node . children [ 0 ] . data ; children = domToReact ( node . children ) ; node . attribs . key = i ; React . createElement ( node . name , node . attribs , children )", "commit_type": "use"}
{"commit_tokens": ["Use", "emptyFunction", "for", "empty", "functions"], "add_tokens": "var emptyFunction = require ( 'react/lib/emptyFunction' ) ; * Dummy routing method which does nothing . * * Should be used on server or in WebWorker . getPath : emptyFunction . thatReturnsNull , setPath : function ( path , cb ) { this . path = path ; cb ( ) ; } , start : emptyFunction , stop : emptyFunction", "del_tokens": "* Dummy routing environment which does nothing . Should be used on server and / or * in WebWorker . getPath : function ( path ) { return null ; } , setPath : function ( path , cb ) { cb ( ) ; } , start : function ( ) { } , stop : function ( ) { }", "commit_type": "use"}
{"commit_tokens": ["make", "sure", "jasmine", "-", "node", "is", "execd"], "add_tokens": "command : './node_modules/.bin/jasmine-node' ,", "del_tokens": "command : 'jasmine-node' ,", "commit_type": "make"}
{"commit_tokens": ["Adds", "mapped", "property", "updateInterval", "and", "lastComm", "conversion"], "add_tokens": "const rwTagProps = [ \"name\" , [ \"updateInterval\" , \"postBackInterval\" ] ] ; WirelessTag . prototype . lastUpdated = function ( ) { return new Date ( u . FILETIMEtoDate ( this . data . lastComm ) ) ; }", "del_tokens": "const rwTagProps = [ \"name\" ] ;", "commit_type": "add"}
{"commit_tokens": ["fix", "static", "join", "&", "slice", "with", "strings", "in", "ES3", "environment", "and", "library", "version"], "add_tokens": ", core = $ . core if ( length == undefined && key in core . Array ) statics [ key ] = core . Array [ key ] ; else if ( key in [ ] ) statics [ key ] = require ( './$.ctx' ) ( Function . call , [ ] [ key ] , length ) ;", "del_tokens": "if ( key in [ ] ) statics [ key ] = require ( './$.ctx' ) ( Function . call , [ ] [ key ] , length ) ;", "commit_type": "fix"}
{"commit_tokens": ["update", "the", "config", "based", "on", "deprecation", "message"], "add_tokens": "cssFontsUrl : options . fontsPath ,", "del_tokens": "cssFontsPath : options . fontsPath ,", "commit_type": "update"}
{"commit_tokens": ["Fix", "file", "path", "bug", "."], "add_tokens": "file = path || ( process . cwd ( ) + '/config/config.json' ) ,", "del_tokens": "file = __dirname + ( path || '/config/config.json' ) ,", "commit_type": "fix"}
{"commit_tokens": ["Update", "all", "lib", "units", "to", "use", "Base"], "add_tokens": "indeed . mixin = function ( obj ) { _ . chain ( obj ) . keys ( ) . each ( function ( key ) { var fn = function ( condition ) { return this . _compare ( key , obj [ key ] ( condition ) ) ; } ; Base . prototype [ key ] = fn ; } ) ; } Base . apply ( this , arguments ) ;", "del_tokens": "indeed . mixin = new Base ( ) . mixin ; Base . call ( this ) ; this . current = [ { val : condition , negate : negate , actual : condition } ] ;", "commit_type": "update"}
{"commit_tokens": ["Added", "Schema#isValid", "and", "tests", "."], "add_tokens": "/ ** * Calls ` ` , translating the error to a boolean . * * @ method isValid * @ return { Boolean } * / isValid ( ) { try { return this . validate ( ... arguments ) ; } catch ( ex ) { return false ; } }", "del_tokens": "* @ since v1 .5 .0", "commit_type": "add"}
{"commit_tokens": ["Added", "colour", "cycling", "demo", "to", "the", "CLI", "options"], "add_tokens": "console . log ( \"Press 6 to cycle forwards through colours\" ) ; console . log ( \"Press 7 to cycle backwards through colours\" ) ; console . log ( \"Test 1 (colour cycle forwards)\" ) ; console . log ( \"Test 2 (colour cycle backwards)\" ) ;", "del_tokens": "console . log ( \"Test 1\" ) ; console . log ( \"Test 2\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "a", "node", "script", "to", "download", "the", "selenium", "standalone", "server", "and"], "add_tokens": "seleniumServerJar : './selenium/selenium-server-standalone-2.33.0.jar' ,", "del_tokens": "seleniumServerJar : '../selenium/selenium-server-standalone-2.28.0.jar' ,", "commit_type": "add"}
{"commit_tokens": ["Adds", "tab", "and", "audio", "sharing", "when", "using", "Chrome", "50", "+"], "add_tokens": "var REQUEST_OPTS = { targets : [ 'screen' , 'window' ] } ; var CHROME_VERSION = getChromeVersion ( ) ; // Chrome >= 50 allows for greater sharing options if ( CHROME_VERSION >= 50 ) { REQUEST_OPTS . targets . push ( 'tab' ) ; REQUEST_OPTS . targets . push ( 'audio' ) ; } extension . sendCommand ( 'share' , REQUEST_OPTS , function ( err , sourceId ) { var audioConstraints = false ; // Support audio on Chrome 50+ if ( CHROME_VERSION >= 50 ) { audioConstraints = { mandatory : { chromeMediaSource : 'desktop' , chromeMediaSourceId : sourceId } } ; } audio : audioConstraints , } ; function getChromeVersion ( ) { var raw = navigator . userAgent . match ( / Chrom(e|ium)\\/([0-9]+)\\. / ) ; return raw ? parseInt ( raw [ 2 ] , 10 ) : - 1 ; }", "del_tokens": "extension . sendCommand ( 'share' , function ( err , sourceId ) { audio : false , } ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "bug", "with", "new", "placements"], "add_tokens": "placement = 'top-left' ; placement = 'bottom-left' ;", "del_tokens": "placement = 'top' ; placement = 'bottom' ;", "commit_type": "fix"}
{"commit_tokens": ["add", "the", "files", "I", "m", "using", "for", "testing"], "add_tokens": "var Compiler = ( function ( ) {", "del_tokens": "var Compiler = exports . Compiler = ( function ( ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "browser", "-", "xhr", "bundling", "for", "es5", "lib"], "add_tokens": "/* eslint-disable */ /* eslint-disable */ /***/ function ( module , exports ) { \"use strict\" ; var XMLHttpRequest = window . XMLHttpRequest ; // eslint-disable-line //# sourceMappingURL=ipfs-mini.js.map", "del_tokens": "/* eslint-disable */ /* eslint-disable */ /***/ function ( module , exports , __webpack_require__ ) { 'use strict' ; var XMLHttpRequest = __webpack_require__ ( 2 ) . XMLHttpRequest ; /***/ } , /* 2 */ /***/ function ( module , exports ) { /* (ignored) */ //# sourceMappingURL=ipfs-mini.js.map", "commit_type": "fix"}
{"commit_tokens": ["fix", "boolean", "properties", "for", "minification"], "add_tokens": "var BOOL_PROPS = [ 'autofocus' , 'checked' , 'defaultchecked' , 'disabled' , 'formnovalidate' , 'indeterminate' , 'readonly' , 'required' , 'selected' , 'willvalidate' ] if ( BOOL_PROPS . indexOf ( key ) !== - 1 ) {", "del_tokens": "var BOOL_PROPS = { autofocus : 1 , checked : 1 , defaultchecked : 1 , disabled : 1 , formnovalidate : 1 , indeterminate : 1 , readonly : 1 , required : 1 , selected : 1 , willvalidate : 1 } if ( BOOL_PROPS [ key ] ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "ternary", "(", "ConditionalExpression", ")"], "add_tokens": "type : 'ConditionalExpression' ,", "del_tokens": "type : 'LogicalExpression' ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "todate", "(", "str", ")", "function", "tlid", ".", "js"], "add_tokens": ") ; console . log ( tool . xtro ( pattern ) ) ; console . log ( \"-----todate-----\" + pattern ) ; console . log ( tool . todate ( pattern ) ) ; pattern = \"@tlid 181208 I will be done\" ; console . log ( \"-----todate-----\" + pattern ) ; console . log ( tool . todate ( pattern ) ) ; pattern = \"@tlid 181208182233 I will be done\" ; console . log ( \"-----todate-----\" + pattern ) ; console . log ( tool . todate ( pattern ) ) ; pattern = \"@tlid 18120818223344 I will be done\" ; console . log ( \"-----todate-----\" + pattern ) ; console . log ( tool . todate ( pattern ) ) ; pattern = \"@tlid 181208182233199 I will be done\" ; console . log ( \"-----todate-----\" + pattern ) ; console . log ( tool . todate ( pattern ) ) ;", "del_tokens": ") ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "debug", "output", "for", "setting", "GPT", "targeting"], "add_tokens": "utils . logMessage ( 'Attempting to set key value for slot: ' + slot . getSlotElementId ( ) + ' key: ' + key + ' value: ' + encodeURIComponent ( keyStrings [ key ] ) ) ; utils . logMessage ( 'Attempting to set key value for slot: ' + slot . getSlotElementId ( ) + ' key: ' + key + ' value: ' + encodeURIComponent ( keyValues [ key ] ) ) ;", "del_tokens": "utils . logMessage ( 'Attempting to set key value for placement code: ' + code + ' slot: ' + slot + ' key: ' + key + ' value: ' + encodeURIComponent ( keyStrings [ key ] ) ) ; utils . logMessage ( 'Attempting to set key value for placement code: ' + code + ' slot: ' + slot + ' key: ' + key + ' value: ' + encodeURIComponent ( keyValues [ key ] ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "the", "item", "path", "bug", "for", "hopefully", "the", "last", "time", "."], "add_tokens": "if ( lines . length == 0 ) lines . push ( \"%You have nothing.\" ) ;", "del_tokens": "if ( lines . length == 0 ) return \"%You have nothing.\" ;", "commit_type": "fix"}
{"commit_tokens": ["added", "support", "for", "nested", "folders", "and", "pods"], "add_tokens": "var chalk = require ( 'chalk' ) ; ui . writeLine ( chalk . green ( 'Move was successful!' ) ) ; ui . writeLine ( chalk . green ( 'Updated all paths!' ) ) ; ui . writeLine ( chalk . red ( 'The mv command failed: ' ) + e . message ) ;", "del_tokens": "ui . writeLine ( 'Move was successful!' ) ; ui . writeLine ( 'Updated all paths!' ) ; ui . writeLine ( 'The mv command failed: ' + e . message ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", ".", "pre", "(", "validate", ")", "funciton", "and", "change", "from", "arrow", "fns", "to", "regular", "fns"], "add_tokens": "const PROMO_CODES = constants . PROMO_CODES ; default : PROMO_CODES . DEFAULT default : PAYMENT_PROCESSORS . DEFAULT , Credit . pre ( 'validate' , function ( next ) { try { } catch ( err ) { var error = new Error ( 'Cannot save credit: ' , err ) ; return next ( error ) ; return next ( ) ; } ) ; // Do not use arrow functions Credit . pre ( 'save' , function ( next ) {", "del_tokens": "default : null default : PAYMENT_PROCESSORS . NULL , Credit . pre ( 'save' , ( next ) => { if ( this . paid_amount ) { var convertToInt = parseInt ( this . paid_amount ) ; var converted_paid_amount = parseInt ( this . paid_amount ) ; console . log ( 'paid amount' , this . paid_amount ) ; console . log ( 'converted' , converted_paid_amount ) ; if ( this . paid_amount && isNaN ( converted_paid_amount ) ) { console . assert ( typeof ( this . paid_amount ) === 'number' ) }", "commit_type": "add"}
{"commit_tokens": ["add", "an", "app", "module", "singleton"], "add_tokens": "var cache = { } ; var configLoader = function ( configname , reload ) { if ( ! reload && cache [ configname ] ) //do this for consistency as much as for efficiency return cache [ configname ] ; var config = _ . defaults . apply ( _ , defaultss ) ; cache [ configname ] = config ; return config ;", "del_tokens": "var configLoader = function ( configname ) { return _ . defaults . apply ( _ , defaultss ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "query", "sorting", "schema", "issue"], "add_tokens": "var Sort = BasicQuery . makeSort ( schema , hydrateAndValue ) ;", "del_tokens": "var Sort = BasicQuery . makeSort ( keys , hydrateAndValue ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "tests", "for", "saveSVG", "()"], "add_tokens": "filename = filename || 'untitled' ; ext = ext || this . _checkFileExtension ( filename , ext ) [ 1 ] ; var regexp = new RegExp ( '\\\\.' + ext + '$' ) ; filename = filename . replace ( regexp , '' ) ;", "del_tokens": "ext = ext || p5 . prototype . _checkFileExtension ( filename , ext ) [ 1 ] ;", "commit_type": "add"}
{"commit_tokens": ["Move", "the", "intern", "testing", "package", "to", "the", "development", "dependencies"], "add_tokens": "excludeInstrumentation : / ^(?:bower_components|node_modules)\\/ / ,", "del_tokens": "excludeInstrumentation : / ^(?:bower_components|node_modules|tests)\\/ / ,", "commit_type": "move"}
{"commit_tokens": ["Remove", "mock", "fs", "due", "to", "latest", "validator", "module", "also", "uses", "fs", "."], "add_tokens": "// this.mockFs.expects('readFileSync').once().returns(JSON.stringify(config));", "del_tokens": "this . mockFs . expects ( 'readFileSync' ) . once ( ) . returns ( JSON . stringify ( config ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Make", "print_element", "helper", "force", "a", "template", "rerender", "if", "it", "has", "already", "been", "rendered", "once"], "add_tokens": "if ( payload . request . elements [ templatename ] && ! options . forcerender ) {", "del_tokens": "if ( payload . request . elements [ templatename ] ) {", "commit_type": "make"}
{"commit_tokens": ["use", "collectContentPost", "hook", "to", "reset", "lineAttributes", "to", "prevent", "hx", "leak"], "add_tokens": "} ; var collectContentPost = function ( hook , context ) { var tname = context . tname ; var state = context . state ; var lineAttributes = state . lineAttributes var tagIndex = _ . indexOf ( tags , tname ) ; if ( tagIndex >= 0 ) { exports . collectContentPost = collectContentPost ;", "del_tokens": "else {", "commit_type": "use"}
{"commit_tokens": ["Add", "a", "dead", "letter", "exchange", "and", "failed", "messages", "queue", "to", "worker", "route", "pattern", "."], "add_tokens": "beforeEach ( function ( ) { afterEach ( function ( ) { broker . publish ( 'publish' , 'succeed' , new Buffer ( theMessage ) ) ; } ) ; } ) ; it ( 'should be able to nack messages and have them end up in a failed queue' , function ( done ) { var theMessage = 'Can I buy your magic bus?' ; var handler = function ( msg ) { broker . nack ( 'subscribe' , msg , false , false ) . then ( function ( ) { done ( ) ; } ) ; } ; broker . registerRoute ( 'publish' , 'topic-publisher' ) ; broker . registerRoute ( 'subscribe' , 'worker' ) ; broker . consume ( 'subscribe' , handler ) . then ( function ( ) { broker . publish ( 'publish' , 'fail' , new Buffer ( theMessage ) ) ;", "del_tokens": "before ( function ( ) { after ( function ( ) { broker . publish ( 'publish' , 'anything' , new Buffer ( theMessage ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "total", "to", "Song", "search", "filter"], "add_tokens": "this . template = _ . template ( template ) ( { total : 0 } ) ; $ ( \"#total\" ) . text ( \"0\" ) ; $ ( \"#total\" ) . text ( collection . length ) ;", "del_tokens": "this . template = _ . template ( template ) ( { } ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "effects", "can", "not", "accpet", "arguments"], "add_tokens": "function * sagaWithErrorCatch ( ... arg ) { yield _saga ( ... arg ) ;", "del_tokens": "function * sagaWithErrorCatch ( ) { yield _saga ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "installing", "all", "NGN", "modules", "at", "once"], "add_tokens": "console . log ( ( 'Adding ' + available . groups [ mod ] . length + ' packages...' ) . cyan . bold ) ; } else if ( mod . toString ( ) . trim ( ) . toLowerCase ( ) === 'all' ) { console . log ( 'Installing everything...' . cyan . bold ) ; available . modules . forEach ( function ( ngnpkg ) { exec ( 'npm install -g ' + ngnpkg , function ( ) { console . log ( ngnpkg + ' support added.' . green . bold ) ; } ) ; } ) ;", "del_tokens": "console . log ( 'Install ' + mod + ' group.' ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "option", "files", "to", "include", "only", "some", "file", "patterns"], "add_tokens": "var allowedFiles = conf . files ; if ( ! _ . isArray ( allowedFiles ) ) { allowedFiles = _ . invoke ( allowedFiles . split ( \",\" ) , \"trim\" ) ; } analyzeDiff ( _ . filter ( parseDiff ( diff ) , function ( file ) { return _ . any ( allowedFiles , _ . partial ( minimatch , file ) ) ; } ) , targetSha , conf ) ;", "del_tokens": "analyzeDiff ( parseDiff ( diff ) , targetSha , conf ) ;", "commit_type": "add"}
{"commit_tokens": ["Creating", "the", "getFlash", "and", "simplifying", "the", "set", "method"], "add_tokens": "/ ** * Flash message * / return { routes : { before : { 'all /*' : require ( './lib/flash' ) } }", "del_tokens": "return { routes : { before : { 'all /*' : require ( './lib/flash' ) } }", "commit_type": "create"}
{"commit_tokens": ["added", "tests", "for", "customized", "steps", "for", "numeric", "dimension"], "add_tokens": "let pivot = Math . floor ( min / step ) * step ; let stepNum = Math . ceil ( ( max - pivot ) / step ) ; for ( let i = 1 ; i <= stepNum ; i ++ ) { tokens . push ( ` ${ Math . floor ( pivot / step ) * step } ${ step } ` ) ; pivot += step ; } return this . _getRangeTokens ( min , max , curStepIndex + 1 , tokens ) ;", "del_tokens": "tokens . push ( ` ${ Math . floor ( min / step ) * step } ${ step } ` ) ; return this . _getRangeTokens ( min , max , curStepIndex + 1 ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "to", "es6", "+", "."], "add_tokens": "const gulp = require ( 'gulp' ) ; const eslint = require ( 'gulp-eslint' ) ; const mocha = require ( 'gulp-mocha' ) ; const paths = { scripts : [ './*.js' , '!./gulpfile.js' ] } ; gulp . task ( 'lint' , ( ) => gulp . src ( paths . scripts ) . pipe ( eslint ( ) ) . pipe ( eslint . format ( ) ) ) ; gulp . task ( 'test' , ( ) => gulp . src ( './test.js' ) . pipe ( mocha ( ) ) ) ; gulp . task ( 'watch' , ( ) => {", "del_tokens": "'use strict' ; var gulp = require ( 'gulp' ) , eslint = require ( 'gulp-eslint' ) , mocha = require ( 'gulp-mocha' ) , paths = { scripts : [ './*.js' , '!./gulpfile.js' ] } ; gulp . task ( 'lint' , function ( ) { return gulp . src ( paths . scripts ) . pipe ( eslint ( ) ) . pipe ( eslint . format ( ) ) ; } ) ; gulp . task ( 'test' , function ( ) { return gulp . src ( './test.js' ) . pipe ( mocha ( ) ) ; } ) ; gulp . task ( 'watch' , function ( ) {", "commit_type": "update"}
{"commit_tokens": ["Added", "method", "for", "appending", "a", "thumbnail", "size", "and", "an", "auth", "token", "to", "a", "file", "URL", "so", "images", "can", "be", "accessed", "outside", "of", "podio", ".", "com", "."], "add_tokens": "var GeneralLib = require ( './general' ) ; PlatformJS . prototype = _ . extend ( { } , AuthLib , TransportLib , GeneralLib ) ;", "del_tokens": "PlatformJS . prototype = _ . extend ( { } , AuthLib , TransportLib ) ;", "commit_type": "add"}
{"commit_tokens": ["allow", "--", "dir", "path", "to", "be", "relative"], "add_tokens": "dir = path . resolve ( process . cwd ( ) , dir ) ;", "del_tokens": "dir = path . resolve ( __dirname , dir ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "a", "cache", "for", "type", "lookup", "by", "string", "name", "."], "add_tokens": "// Internal cache of data types. // Data constructors are cached here so we can perform lookups based on name. var typeCache = { } ; ctr . prototype . constructor = ctr ; // Export constructor as a static property on the parent class. // Keep it in the cache. if ( name in typeCache ) typeCache [ name ] . push ( ctr ) ; else typeCache [ name ] = [ ctr ] ; ctr . prototype = ctr ; ctr . prototype . constructor = ctr ; ctr . prototype . slot = function ( num ) { if ( num < 0 || num > names . length - 1 ) throw new Error ( \"Slot index out of range\" ) ; return this [ names [ i ] ] ( ) ; } ; // Returns a list of constructors given a string type name adt . lookup = function ( type ) { var ctrs = typeCache [ type ] ; return ctrs ? ctrs . slice ( ) : undefined ; } ;", "del_tokens": "// Export constructor as a static property on the parent class", "commit_type": "add"}
{"commit_tokens": ["use", "assign", "polyfill", "for", "the", "sake", "of", "coverage"], "add_tokens": "export function assign ( obj ) {", "del_tokens": "export function assignPolyfill ( obj ) { export var assign = Object . assign ; if ( ! assign ) { assign = assignPolyfill ; }", "commit_type": "use"}
{"commit_tokens": ["use", "the", "initialized", "top", "value", "as", "the", "value", "of", "the", "root", "node", "."], "add_tokens": "let tree = pure ( Tree , new Node ( { Type , path : [ ] , root : topValue } ) ) ;", "del_tokens": "let tree = pure ( Tree , new Node ( { Type , path : [ ] , root : value } ) ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "ascending", "option", "to", "sorting"], "add_tokens": "it ( 'get - must create proper get route return sorted records if sort query provided (sorting ascending)' , function ( done ) { //invoke path with supertest request ( app ) . get ( config . path ) . set ( 'accept' , 'application/json' ) . query ( { sort : 'name' , order : 'asc' } ) . expect ( 200 ) . end ( function ( err , res ) { res . body . length . should . equal ( 3 ) ; res . body [ 0 ] . name . should . equal ( 'abc' ) ; res . body [ 1 ] . name . should . equal ( 'def' ) ; res . body [ 2 ] . name . should . equal ( 'xyz' ) ; done ( err ) ; //pass err so that fail expect errors will get caught } ) ; } ) ; it ( 'get - must create proper get route return sorted records if sort query provided (sorting descending)' , function ( done ) {", "del_tokens": "it ( 'get - must create proper get route return sorted records if sort query provided' , function ( done ) {", "commit_type": "add"}
{"commit_tokens": ["make", "models", "compatible", "with", "NodeJS", "environment"], "add_tokens": "if ( typeof exports === 'object' ) { var joint = { dia : { Cell : require ( './joint.dia.cell' ) . Cell , CellView : require ( './joint.dia.cell' ) . CellView } } ; var Backbone = require ( 'backbone' ) ; var _ = require ( 'lodash' ) ; } var newValue = _ . merge ( { } , labels [ idx ] , value ) ; if ( typeof exports === 'object' ) { module . exports . Link = joint . dia . Link ; module . exports . LinkView = joint . dia . LinkView ; }", "del_tokens": "var newValue = _ . deepExtend ( { } , labels [ idx ] , value ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "projected", "bounds", "on", "tile", "layers"], "add_tokens": "var map , marker ; var extent = 11000000 + 9036842.762 ; origin : [ - extent , extent ] , maxResolution : ( ( extent - - extent ) / 256 ) , projectedBounds : L . bounds ( L . point ( - extent , extent ) , L . point ( extent , - extent ) ) , baseLayer : projectedTiles [ \"arctic_connect@EPSG:3571\" ] marker = L . marker ( [ 51.080126 , - 114.13380900 ] ) . bindPopup ( \"University of Calgary\" ) ; marker , map . setView ( [ 51.080126 , - 114.13380900 ] , 18 ) ;", "del_tokens": "var map ; origin : [ - 20036842.762 , 20036842.762 ] , maxResolution : ( ( 20036842.762 - - 20036842.762 ) / 256 ) , baseLayer : projectedTiles [ \"arctic_connect@EPSG:3573\" ] L . marker ( [ 51.080126 , - 114.13380900 ] ) . bindPopup ( \"University of Calgary\" ) ,", "commit_type": "add"}
{"commit_tokens": ["Move", "Bracket", "-", "specific", "compute", "data", "case", "to", "Bracket", ".", "prototype", ".", "value"], "add_tokens": "if ( prop . computeData != null && prop . hasOwnProperty ( \"value\" ) ) { prop = prop . value ; }", "del_tokens": "if ( computeOrFunction . computeData != null && computeOrFunction . hasOwnProperty ( \"value\" ) ) { return computeOrFunction . value ; }", "commit_type": "move"}
{"commit_tokens": ["Move", "tape", "name", "into", "own", "method"], "add_tokens": "var file = path . join ( opts . dirname , tapename ( req , body ) ) ; / ** * Returns the tape name for ` ` . * @ param { http . IncomingMessage } req * @ param { Array . < Buffer > } body * @ returns { String } * / function tapename ( req , body ) { return hash . sync ( req , Buffer . concat ( body ) ) + '.js' ; }", "del_tokens": "var tape = hash . sync ( req , Buffer . concat ( body ) ) ; var file = path . join ( opts . dirname , tape + '.js' ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "for", "Mac", "build", "and", "internal", "link", "handling"], "add_tokens": "/** @type {string} */ this . packageURL = \"\" ; /** @const {adapt.base.EventListener} */ this . hyperlinkListener = null ; self . packageURL = epubURL ; self . packageURL = xmlURL ; * @ param { adapt . base . JSON | string } cmd var scheduler = adapt . task . currentTask ( ) . getScheduler ( ) ; viewer . hyperlinkListener = function ( evt ) { var hrefEvent = /** @type {adapt.vtree.PageHyperlinkEvent} */ ( evt ) ; var internal = hrefEvent . href . substr ( 0 , viewer . packageURL . length ) == viewer . packageURL ; var msg = { \"t\" : \"hyperlink\" , \"href\" : hrefEvent . href , \"internal\" : internal } ; scheduler . run ( function ( ) { viewer . callback ( msg ) ; return adapt . task . newResult ( true ) ; } ) ; } ;", "del_tokens": "/** @const {adapt.base.EventListener} */ this . hyperlinkListener = function ( evt ) { var hrefEvent = /** @type {adapt.vtree.PageHyperlinkEvent} */ ( evt ) ; callbackFn ( { \"t\" : \"hyperlink\" , \"href\" : hrefEvent . href , \"i\" : instanceId } ) ; } ; * @ param { adapt . base . JSON } command", "commit_type": "fix"}
{"commit_tokens": ["improve", "initial", "subview", "hydration", "perf", "by", "28%"], "add_tokens": "var vm = createView ( vnode2 . view , vnode2 . model , vnode2 . key , vnode2 . opts ) . _redraw ( vnode , i , false ) ; // todo: handle new model updates insertBefore ( vnode . el , hydrate ( vm . node ) ) ; vm . _redraw ( vnode , i ) ; // , false insertBefore ( vnode . el , vm . node . el ) ; // , hydrate(vm.node)", "del_tokens": "var vm = createView ( vnode2 . view , vnode2 . model , vnode2 . key , vnode2 . opts ) . _redraw ( vnode , i ) ; // todo: handle new model updates insertBefore ( vnode . el , vm . node . el ) ; vm . _redraw ( vnode , i ) ; insertBefore ( vnode . el , vm . node . el ) ;", "commit_type": "improve"}
{"commit_tokens": ["Fix", "ipv6", "-", "interface", "format"], "add_tokens": "import { networkMaskValid } from './utils' return ( ipv6Address ( ipAddress ) && networkMaskValid ( networkMask , true ) && networkMask !== '128' )", "del_tokens": "import { ipv6AddressBits , networkMaskValid } from './utils' if ( ! networkMaskValid ( networkMask , true ) ) { return false } if ( ! ipv6Address ( ipAddress ) ) { return false } const bits = ipv6AddressBits ( ipAddress ) const postPrefixBits = bits . slice ( parseInt ( networkMask , 10 ) ) if ( networkMask === '128' ) { return false } return ! / ^(0+|1+)$ / . test ( postPrefixBits )", "commit_type": "fix"}
{"commit_tokens": ["Adding", "support", "for", "local", "-", "properties"], "add_tokens": "var coreSettings = require ( './options.json' ) , path = require ( 'path' ) , pathToApp = path . dirname ( require . main . filename ) , var userSettingsFile = pathToApp + '/user/options/options.json' , localSettingsFile = pathToApp + '/user/options/local-options.json' ; // If user settings file is present, override core settings if ( fs . existsSync ( userSettingsFile ) ) { deepExtend ( coreSettings , require ( userSettingsFile ) ) ; // If local settings file is present, override core settings if ( fs . existsSync ( localSettingsFile ) ) { deepExtend ( coreSettings , require ( localSettingsFile ) ) ; }", "del_tokens": "var coreSettings = require ( \"./options.json\" ) , var userSettings = { } , userSettingsFile = \"/../../user/options/options.json\" ; // if user settings file is present, override core settings if ( fs . existsSync ( __dirname + userSettingsFile ) ) { userSettings = require ( __dirname + userSettingsFile ) ; deepExtend ( coreSettings , userSettings ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "git", "-", "repo", "-", "version", "instead", "of", "git", "-", "repo", "-", "info", "directly", "."], "add_tokens": "var gitVersion = require ( 'git-repo-version' ) ; // remove leading `v` (since by default our tags use a `v` prefix) return gitVersion ( ) . replace ( / ^v / , '' ) ;", "del_tokens": "var gitInfo = require ( 'git-repo-info' ) ; return gitInfo ( ) . abbreviatedSha ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "for", "malformed", "output", "."], "add_tokens": "const magicString = this . magicString . snip ( node . start , node . end ) . append ( '\\n' ) ;", "del_tokens": "const magicString = this . magicString . snip ( node . start , node . end ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "browser", "version", "of", "vueFilePond"], "add_tokens": "* vue - filepond v3 .0 .3", "del_tokens": "* vue - filepond v3 .0 .2", "commit_type": "fix"}
{"commit_tokens": ["add", "the", "load", "testing", "feature", "into", "module"], "add_tokens": "path : '' , isLoadTest : false , loadName : '' , requests : 0 , concurrent : 0 // cope with loadTest info if ( info . loadTest != null ) { _ . forEach ( info . loadTest , function ( loadTestParam ) { if ( loadTestParam . pathName === path && loadTestParam . operation === operation ) { data . loadName = path . replace ( / \\/ / g , '_' ) + '_' + operation + '_load_test' ; info . importArete = true ; data . isLoadTest = true ; data . requests = loadTestParam . load . requests !== undefined ? loadTestParam . load . requests : 1000 ; data . concurrent = loadTestParam . load . concurrent !== undefined ? loadTestParam . load . concurrent : 100 ; } } ) ; } importArete : false , security : [ ] , loadTest : null if ( config . loadTest ) { info . loadTest = config . loadTest ; } importEnv : info . importEnv , importArete : info . importArete", "del_tokens": "path : '' security : [ ] importEnv : info . importEnv", "commit_type": "add"}
{"commit_tokens": ["Fixed", "id", "command", "to", "work", "with", "arguments"], "add_tokens": "id : function ( id , cb ) { if ( typeof id === 'function' ) { cb = id ; id = null ; } send ( 'id' , id , null , null , cb ) ; } ,", "del_tokens": "id : command ( 'id' ) ,", "commit_type": "fix"}
{"commit_tokens": ["added", "login", "/", "sessions", "/", "logout", "[", "all", "]", "and", "auto", "-", "focusing", "chatbox", "and", "username"], "add_tokens": "function processChatboxLine ( user , line , parseCommands , sessionId ) { clientcommands . handleClientCommand ( activeWindow , command , rest , sessionId ) ;", "del_tokens": "function processChatboxLine ( line , user , parseCommands ) { clientcommands . handleClientCommand ( activeWindow , command , rest ) ;", "commit_type": "add"}
{"commit_tokens": ["improve", "click", "handling", "for", "svg", "elements"], "add_tokens": "// svg elements on some platforms don't have nodeNames while ( el && ( el . nodeName == null || 'A' != el . nodeName . toUpperCase ( ) ) ) { if ( ! el || 'A' != el . nodeName . toUpperCase ( ) ) return ;", "del_tokens": "while ( el && 'A' != el . nodeName ) { if ( ! el || 'A' != el . nodeName ) return ;", "commit_type": "improve"}
{"commit_tokens": ["Added", "tests", "for", "proxyReq", "-", "host", "header"], "add_tokens": "proxy . on ( 'proxyReq' , utils . proxyReqHost ) ;", "del_tokens": "proxy . on ( 'proxyReq' , proxyReqHost ) ; function proxyReqHost ( proxyReq , req , res , options ) { var host = options . target . host ; if ( host ) { proxyReq . setHeader ( 'host' , host ) ; } }", "commit_type": "add"}
{"commit_tokens": ["Add", "spec", "for", "Dancer", ".", "Beat", "format", "Dancer", "specs"], "add_tokens": "songReady = function ( ) { return dancer . isLoaded ( ) && dancer . getTime ( ) > 1 ; } ; // Relying on adapter implementation, possibly better way to spec", "del_tokens": "songReady = function ( ) { return dancer . isLoaded ( ) && dancer . getTime ( ) > 1 ; } // Relying on adapter implementation, possibly better way to spec", "commit_type": "add"}
{"commit_tokens": ["Allow", "secrets", "to", "be", "forgotten", "."], "add_tokens": "function accessor ( object ) { return hasOwn . call ( secrets , key ) ? secrets [ key ] : secrets [ key ] = create ( null ) ; } accessor . forget = function ( object ) { delete secrets [ object [ brand ] ] ; return accessor ;", "del_tokens": "secrets [ key ] = create ( null ) ; return function ( object ) { if ( hasOwn . call ( secrets , key ) ) return secrets [ key ] ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "angular", "-", "translate", "to", "raw"], "add_tokens": "'copy:raw_angular_ui_router_to_deploy' , 'copy:raw_angular_translate_to_deploy'", "del_tokens": "'copy:raw_angular_ui_router_to_deploy'", "commit_type": "add"}
{"commit_tokens": ["moved", "the", "API", "info", "from", "README", ".", "md", "into", "api", ".", "md", "and", "added", "a", "check", "for", "methods", "that", "have", "no", "params", "."], "add_tokens": "if ( process . env . FORCE_GEN ) { download ( ) ; } else { try { var stat = fs . statSync ( outputPath ) ; if ( ! stat . isFile ( ) || stat . ctime < Date . now ( ) - 86400000 ) { download ( ) ; } } catch ( e ) {", "del_tokens": "try { var stat = fs . statSync ( outputPath ) ; if ( ! stat . isFile ( ) || stat . ctime < Date . now ( ) - 86400000 ) { } catch ( e ) { download ( ) ;", "commit_type": "move"}
{"commit_tokens": ["Added", "fix", "for", "GEMV", "function", "."], "add_tokens": "for ( var i = A . shape [ 0 ] - 1 ; i >= 0 ; i -- ) {", "del_tokens": "for ( var i = A . shape [ 1 ] - 1 ; i >= 0 ; i -- ) {", "commit_type": "add"}
{"commit_tokens": ["Adding", "Sound", "to", "Android", "PhoneGap"], "add_tokens": "if ( Device . isAndroid ) { window . DroidGap . playSound ( clip ) ; } else { return Device . exec ( 'sound:' + clip ) ; }", "del_tokens": "return Device . exec ( 'sound:' + clip ) ;", "commit_type": "add"}
{"commit_tokens": ["improved", "perf", "of", "parsebindings", "a", "little"], "add_tokens": "nodes = $ . parseHTML ( core . trim ( nodes ) ) ; return $ . parseHTML ( core . trim ( nodes ) ) ; all = { } , k = 0 , all [ k ++ ] = allChildren [ j ] ; all [ k ++ ] = nodes [ i ] ; for ( i = 0 ; i < k ; i ++ ) {", "del_tokens": "nodes = $ . parseHTML ( nodes . replace ( / ^\\s+|\\s+$ / g , '' ) ) ; return $ . parseHTML ( nodes . replace ( / ^\\s+|\\s+$ / g , '' ) ) ; all = [ ] , all . push ( allChildren [ j ] ) ; all . push ( nodes [ i ] ) ; for ( i = 0 ; i < all . length ; i ++ ) {", "commit_type": "improve"}
{"commit_tokens": ["improve", "deletion", "speed", "and", "implement", "a", "re", "-", "index", "function", "on", "graphs"], "add_tokens": "/ ** * Cleanup gaps * / graph . prototype . reindex = function ( criteria ) { var index = { } ; this . points = this . points . filter ( function ( item ) { if ( item != undefined ) { for ( var i = 0 ; i < item . indexes . length ; i ++ ) { var key = item . indexes [ i ] ; if ( ! ( key [ 0 ] in index ) ) { index [ key [ 0 ] ] = { } ; } if ( ! ( key [ 1 ] in index [ key [ 0 ] ] ) ) { index [ key [ 0 ] ] [ key [ 1 ] ] = [ ] ; } index [ key [ 0 ] ] [ key [ 1 ] ] . push ( item ) ; } ; return true ; } return false ; } ) ; this . index = index ; return this ; } ;", "del_tokens": "", "commit_type": "improve"}
{"commit_tokens": ["Add", "Project", "-", "Id", "-", "Version", "header"], "add_tokens": "'Content-Transfer-Encoding' : '8bit' , 'Project-Id-Version' : ''", "del_tokens": "'Content-Transfer-Encoding' : '8bit'", "commit_type": "add"}
{"commit_tokens": ["Make", "flags", "argument", "in", "init", "method", "optional", "."], "add_tokens": "var flagsSanitised = flags || ldClient . allFlags ( ) ; setFlags ( flagsSanitised , dispatch ) ; subscribeToChanges ( flagsSanitised , dispatch ) ;", "del_tokens": "setFlags ( flags , dispatch ) ; subscribeToChanges ( flags , dispatch ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "--", "chdir", "argument", "."], "add_tokens": "* @ param { String } chdir A directory to which the test runner chdirs before * running the tests . var executeTest = function ( cwd , chdir , filePath , failfast , verbosity , callback ) { var args = [ 'run_test_file.js' , filePath , cwd , chdir ] ; var runTests = function ( cwd , initFile , chdir , tests , failFast , verbosity ) { executeTest ( cwd , chdir , test , failFast , verbosity , callback ) ; var chdir = null ; p . on ( 'chdir' , function ( opt , value ) { if ( value ) { chdir = value ; } } ) ; runTests ( cwd , initFile , chdir , tests , failFast , verbosity ) ;", "del_tokens": "var executeTest = function ( cwd , filePath , failfast , verbosity , callback ) { var args = [ 'run_test_file.js' , filePath , cwd ] ; var runTests = function ( cwd , initFile , tests , failFast , verbosity ) { executeTest ( cwd , test , failFast , verbosity , callback ) ; runTests ( cwd , initFile , tests , failFast , verbosity ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "typos", "in", "usage", "example"], "add_tokens": "tree . createStream ( ) . pipe ( process . stdout ) ; // {op: 'create', pnode: {...} } assert ( tree . pnode . isPrototypeOf ( tasks [ 0 ] ) ) ;", "del_tokens": "tree . createStream ( ) . pipe ( process . stdout ) ; // {op: 'create', node: {...} } assert ( tree . node . isPrototypeOf ( tasks [ 0 ] ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "lambda", "expression", "processing", "in", "included", "partial", "templates"], "add_tokens": "// Make sure we consider parent template now if ( this . activeSub === undefined ) { // Store parent template text in partials.stackText to perform substitutions in child templates correctly partials . stackText = this . text ; } template = createSpecializedPartial ( template , partial . subs , partial . partials , partials . stackText || this . text ) ; } // tries to find a partial in the current scope and render it", "del_tokens": "template = createSpecializedPartial ( template , partial . subs , partial . partials , this . text ) ; } // tries to find a partial in the curent scope and render it", "commit_type": "fix"}
{"commit_tokens": ["Fix", "flaky", "test", "that", "s", "trying", "to", "compare", "Object", "ids", "."], "add_tokens": "var mongo = require ( 'mongojs' ) ; _id : mongo . ObjectID ( '58164d86f69ab45942c6ff38' ) ,", "del_tokens": "var BSON = require ( 'bson' ) ; _id : BSON . ObjectID ( '58164d86f69ab45942c6ff38' ) , expect ( decoded ) . toEqual ( obj ) ; expect ( decoded . _id ) . toEqual ( jasmine . any ( BSON . ObjectID ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "sub", "subDoc", "get", "query", "tests"], "add_tokens": "path : '/localhost/articles/:articleName/comments' , idParam : 'articleName' , path : 'comments' , idAttribute : 'name' . get ( '/localhost/articles/article-one/comments/comment-one' ) res . body . name . should . equal ( 'comment-one' ) ; path : 'replies' , idAttribute : 'name' . get ( '/localhost/articles/article-one/comments/comment-one/replies/reply-one' ) res . body . name . should . equal ( 'reply-one' ) ;", "del_tokens": "path : '/localhost/articles/:name/comments' , idParam : 'name' , path : 'comments' . get ( '/localhost/articles/article-one/comments' ) res . body . length . should . equal ( 2 ) ; path : 'replies' . get ( '/localhost/articles/article-one/comments/comment-one/replies' ) res . body . length . should . equal ( 1 ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "typo", "in", "if", "statement", "logic"], "add_tokens": "if ( href . toString ( ) . indexOf ( \"http\" ) !== 0 ) {", "del_tokens": "if ( href . toString ( ) . indexOf ( \"http\" ) === 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["move", "timeline", ".", "data", "to", "timeline", ".", "config"], "add_tokens": "VALID_PROPERTIES : [ 'slides' ] , // we'll only pull things in from this self . _importProperties ( d . timeline ) ; throw ( \"Configuration could not be loaded: \" + type ) ; this . _importProperties ( data . timeline ) ; this . _makeUniqueIdentifiers ( this . slides ) ; this . _processDates ( this . slides ) ; VCO . DateUtil . sortByDate ( this . slides ) ; } , _importProperties : function ( d ) { for ( var i = 0 ; i < this . VALID_PROPERTIES . length ; i ++ ) { k = this . VALID_PROPERTIES [ i ] ; this [ k ] = d [ k ] ; }", "del_tokens": "VCO . Util . mergeData ( self . data , d . timeline ) ; VCO . DateUtil . sortByDate ( self . data . slides ) ; trace ( \"ERROR LOADING\" ) ; this . data = data . timeline ; this . _makeUniqueIdentifiers ( this . data . slides ) ; this . _processDates ( this . data . slides ) ;", "commit_type": "move"}
{"commit_tokens": ["fix", "bug", "+", "write", "additional", "test"], "add_tokens": "test ( 'layer names as numbers' , function ( t ) { t . deepEqual ( filter_obj . layers ( ) , [ '1' ] ) ;", "del_tokens": "test . only ( 'layer names as numbers' , function ( t ) {", "commit_type": "fix"}
{"commit_tokens": ["changed", "minimal", "to", "robust", "added", "the", "real", "minimal", "swagger"], "add_tokens": "describe ( 'robust swagger' , function ( ) { assert . lengthOf ( output1 , 1 ) ; assert . lengthOf ( output5 , 1 ) ; assert . lengthOf ( output6 , 1 ) ; assert . lengthOf ( output3 , 1 ) ; assert . lengthOf ( output7 , 1 ) ; assert . lengthOf ( output8 , 1 ) ;", "del_tokens": "describe ( 'minimal swagger' , function ( ) { assert . lengthOf ( output1 , 2 ) ; assert . lengthOf ( output5 , 2 ) ; assert . lengthOf ( output6 , 2 ) ; assert . lengthOf ( output3 , 2 ) ; assert . lengthOf ( output7 , 2 ) ; assert . lengthOf ( output8 , 2 ) ;", "commit_type": "change"}
{"commit_tokens": ["make", "test", "suite", "work", "on", "windows"], "add_tokens": "var dir = __dirname + '/fixture' , msgFile = dir + '/message.js' , msg = 'module.exports = \"Please touch message.js now\"\\n' function touch ( ) { fs . writeFileSync ( msgFile , msg ) } var ps = child . spawn ( 'node' , [ bin ] . concat ( cmd . split ( ' ' ) ) , { cwd : dir } ) setTimeout ( touch , 500 ) var tmp = dir + '/message.tmp' fs . renameSync ( tmp , msgFile ) setTimeout ( touch , 500 ) expect ( argv [ 0 ] ) . to . match ( / .*?node(\\.exe)?$ / )", "del_tokens": ", touch = require ( 'touch' ) var dir = __dirname + '/fixture' var ps = child . spawn ( bin , cmd . split ( ' ' ) , { cwd : dir } ) touch ( dir + '/message.js' ) var f = dir + '/message.js' , tmp = dir + '/message.tmp' , msg = fs . readFileSync ( f ) fs . rename ( tmp , f ) setTimeout ( function ( ) { touch ( dir + '/message.js' ) } , 1000 ) expect ( argv [ 0 ] ) . to . match ( / .*?node$ / )", "commit_type": "make"}
{"commit_tokens": ["fix", "missing", "http", "icons", "(", "bad", "spelling", ")"], "add_tokens": "labelOffset = [ sz / 2 - 4 , - 4 ] ;", "del_tokens": "labelOffset = [ iz / 2 - 4 , - 4 ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "style", "text", "-", "link", "for", "Button"], "add_tokens": "'link' , 'text-link'", "del_tokens": "'link'", "commit_type": "add"}
{"commit_tokens": ["Added", "custom", "meta", "objects", "example"], "add_tokens": "this . setPosition ( ) this . setPhysics ( )", "del_tokens": "console . log ( this . position )", "commit_type": "add"}
{"commit_tokens": ["Add", "prop", "closable", "to", "alerts"], "add_tokens": "onClose : React . PropTypes . func , closable : React . PropTypes . bool , style : React . PropTypes . oneOf ( STYLES ) if ( onClose ) onClose ( ) ; var onClose = this . props . onClose ; var closable = this . props . closable ; if ( onClose || closable ) {", "del_tokens": "onClose : React . PropTypes . func , style : React . PropTypes . oneOf ( STYLES ) onClose ( ) ; var onClose = this . props . onClose ; if ( onClose ) {", "commit_type": "add"}
{"commit_tokens": ["Update", "p5", ".", "serialserver", ".", "js"], "add_tokens": "logit ( \"serialPort == null || !serialPort.isOpen\" ) ; logit ( \"serialPort != null && serialPort.isOpen is true so serialPort = null\" ) ; if ( serialPort != null && typeof serialPort === \"object\" && serialPort . isOpen ) { logit ( \"serialPort != null && serialPort.isOpen is true\" ) ; if ( serialPort != null && typeof serialPort === \"object\" && serialPort . isOpen ) { logit ( \"serialPort != null && serialPort.isOpen is true so serialPort = null\" ) ;", "del_tokens": "logit ( \"serialPort == null || !serialPort.isOpen()\" ) ; logit ( \"serialPort != null && serialPort.isOpen() is true so serialPort = null\" ) ; if ( serialPort != null && serialPort . isOpen ( ) ) { logit ( \"serialPort != null && serialPort.isOpen() is true\" ) ; if ( serialPort != null && serialPort . isOpen ( ) ) { logit ( \"serialPort != null && serialPort.isOpen() is true so serialPort = null\" ) ;", "commit_type": "update"}
{"commit_tokens": ["Use", "safe", "-", "buffer", "in", "place", "of", "new", "Buffer", "."], "add_tokens": "var Buffer = require ( 'safe-buffer' ) . Buffer if ( data instanceof ArrayBuffer ) data = Buffer . from ( new Uint8Array ( data ) ) else data = Buffer . from ( data , 'utf8' ) buffers [ i ] = Buffer . from ( chunks [ i ] , 'utf8' )", "del_tokens": "if ( data instanceof ArrayBuffer ) data = new Buffer ( new Uint8Array ( data ) ) else data = new Buffer ( data ) buffers [ i ] = new Buffer ( chunks [ i ] , 'utf8' ) // TODO use safe-buffer", "commit_type": "use"}
{"commit_tokens": ["remove", "some", "console", ".", "logging"], "add_tokens": "", "del_tokens": "console . log ( \"POSSIBLE COMMANDS\" , possible_commands ) ;", "commit_type": "remove"}
{"commit_tokens": ["Adding", "support", "for", "fulfillmentMessages", "structure", "from", "Dialogflow"], "add_tokens": "( message . text . length > 0 || message . attachments != null || message . attachment != null || message . fulfillmentMessages != null ) ) {", "del_tokens": "( message . text . length > 0 || message . attachments != null || message . attachment != null ) ) {", "commit_type": "add"}
{"commit_tokens": ["Changing", "default", "session", "duration", "to", "30", "minutes", "."], "add_tokens": "app . set ( 'stormpathSessionDuration' , opts . sessionDuration || parseInt ( process . env . STORMPATH_SESSION_DURATION ) || 1000 * 60 * 30 ) ;", "del_tokens": "app . set ( 'stormpathSessionDuration' , opts . sessionDuration || parseInt ( process . env . STORMPATH_SESSION_DURATION ) || 1000 * 60 * 60 * 24 * 30 ) ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "regression", "in", "interpolated", "strings"], "add_tokens": "var EXPRESSION_START = [ '(' , '[' , '{' , 'INDENT' , 'CALL_START' , 'PARAM_START' , 'INDEX_START' , 'TAG_PARAM_START' , 'BLOCK_PARAM_START' , 'STRING_START' , '{{' ] ; var EXPRESSION_END = [ ')' , ']' , '}' , 'OUTDENT' , 'CALL_END' , 'PARAM_END' , 'INDEX_END' , 'TAG_PARAM_END' , 'BLOCK_PARAM_END' , 'STRING_END' , '}}' ] ;", "del_tokens": "var EXPRESSION_START = [ '(' , '[' , '{' , 'INDENT' , 'CALL_START' , 'PARAM_START' , 'INDEX_START' , 'TAG_PARAM_START' , 'BLOCK_PARAM_START' , 'STRING_START' ] ; var EXPRESSION_END = [ ')' , ']' , '}' , 'OUTDENT' , 'CALL_END' , 'PARAM_END' , 'INDEX_END' , 'TAG_PARAM_END' , 'BLOCK_PARAM_END' , 'STRING_END' ] ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "Copyrights", "as", "per", "David", "s", "email"], "add_tokens": "/ * * Copyright 2015 IBM Corp . * * Licensed under the Apache License , Version 2.0 ( the \"License\" ) ; * you may not use this file except in compliance with the License . * You may obtain a copy of the License at * * http : //www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing , software * distributed under the License is distributed on an \"AS IS\" BASIS , * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . * See the License for the specific language governing permissions and * limitations under the License . * / } ) ;", "del_tokens": "} ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "support", "for", "colon", "-", "based", "inline", "nesting"], "add_tokens": "describe ( 'Inline' , function ( ) { it ( 'should work with spaces and tabs' , function ( ) { var result ; result = ltl . compile ( 'p:b test' ) ( ) ; assert . equal ( result , '<p><b>test</b></p>' ) ; result = ltl . compile ( 'p: b test' ) ( ) ; assert . equal ( result , '<p><b>test</b></p>' ) ; result = ltl . compile ( 'p: b test' ) ( ) ; assert . equal ( result , '<p><b>test</b></p>' ) ; result = ltl . compile ( 'p:\\tb test' ) ( ) ; assert . equal ( result , '<p><b>test</b></p>' ) ; } ) ; it ( 'should nest to multiple levels' , function ( ) { var result ; result = ltl . compile ( 'p:b:i' ) ( ) ; assert . equal ( result , '<p><b><i></i></b></p>' ) ; } ) ; it ( 'should not interfere with other nesting' , function ( ) { var result ; result = ltl . compile ( '.\\n p:b\\n br\\n p:b' ) ( ) ; assert . equal ( result , '<div><p><b></b></p><br><p><b></b></p></div>' ) ; } ) ; } ) ; } ) ;", "del_tokens": "} ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "an", "option", "for", "responsive", "designs"], "add_tokens": "txtResponsive : 'Make Responsive (ignore width and height, fit to width)' , invalidTime : 'Inform a valid start time' , chkSourceLink : 'Include a link to YouTube'", "del_tokens": "invalidTime : 'Inform a valid start time'", "commit_type": "add"}
{"commit_tokens": ["Improve", "exit", "code", "handling", "."], "add_tokens": "\" console.log(data.message);\" + \" process.exit(data.exitCode);\\n\" +", "del_tokens": "\" process.exit(data);\\n\" +", "commit_type": "improve"}
{"commit_tokens": ["add", "support", "for", "redirects", "inside", "iframe", "for", "performing", "the", "handshake", "again"], "add_tokens": "this . handshakeAttemptsOrig = PostMessageUtilities . parseNumber ( options . handshakeAttempts , DEFAULT_HANDSHAKE_RETRY_ATTEMPTS ) ; this . handshakeAttempts = this . handshakeAttemptsOrig ; // Handshake was successful, Channel is ready for messages // Set the counter back to original value for dealing with iframe reloads this . handshakeAttempts = this . handshakeAttemptsOrig ; var frame = document . createElement ( \"IFRAME\" ) ; var delay = options . delayLoad ; } ; var defaultStyle = { for ( var key in options . attributes ) { if ( this . handshakeAttempts === this . handshakeAttemptsOrig ) { // Probably a first try for handshake or a reload of the iframe, // Either way, we'll need to perform handshake, so ready flag should be set to false (if not already) this . ready = false ; }", "del_tokens": "this . handshakeAttempts = PostMessageUtilities . parseNumber ( options . handshakeAttempts , DEFAULT_HANDSHAKE_RETRY_ATTEMPTS ) ; } , defaultStyle = { var frame = document . createElement ( \"IFRAME\" ) ; var delay = options . delayLoad ; for ( var key in options . attributes ) {", "commit_type": "add"}
{"commit_tokens": ["Update", "scroll", "-", "tracker", "-", "stream", ".", "js"], "add_tokens": "var evObj = document . createEvent ( 'HTMLEvents' ) ; evObj . initEvent ( 'scroll' , true , true ) ; window . dispatchEvent ( evObj ) ;", "del_tokens": "window . dispatchEvent ( new Event ( 'scroll' ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Fixing", "karma", "-", "gzip", "breaking", "karma"], "add_tokens": "urlRegex : new RegExp ( relativePaths . join ( '|' ) ) ,", "del_tokens": "urlRegex : new RegExp ( gzippedFilePaths . map ( relativePaths ) . join ( '|' ) ) ,", "commit_type": "fix"}
{"commit_tokens": ["Remove", "quotes", "from", "strings", "that", "have", "them"], "add_tokens": "var quoted = / ([\"'])(.*?)\\1 / g ; if ( ! part . match ( quoted ) ) { current . push ( part ) ; return ; } var quoteMatch ; while ( ( quoteMatch = quoted . exec ( part ) ) !== null ) { current . push ( quoteMatch [ 2 ] ) ; }", "del_tokens": "current . push ( part ) ;", "commit_type": "remove"}
{"commit_tokens": ["Adding", "default", "props", "to", "Box", "shape", "."], "add_tokens": "console . log ( this . props ) ; var _props = this . props ; var _props$height = _props . height ; var height = _props$height === undefined ? 1 : _props$height ; var _props$width = _props . width ; var width = _props$width === undefined ? 1 : _props$width ; height : height , width : width } ] , [ { key : \"propTypes\" , value : { height : _react . PropTypes . number , width : _react . PropTypes . number } , enumerable : true", "del_tokens": "height : 1 , width : 1 , faceColors : [ 100 , 255 , 23 , 0.5 ]", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "when", "there", "are", "no", "URIs", "in", "stylesheet"], "add_tokens": "var URIs = _ . uniq ( s . data . match ( / url\\((.*)\\) / g ) || [ ] ) ;", "del_tokens": "var URIs = _ . uniq ( s . data . match ( / url\\((.*)\\) / g ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["move", "events", "to", "closure", "variable"], "add_tokens": "var listeners = events [ type ] || ( events [ type ] = [ ] ) ; var index = events [ type ] . indexOf ( handler ) ; ~ index && events [ type ] . splice ( index , 1 ) ; if ( msg && msg . type && events [ msg . type ] ) { var listeners = events [ msg . type ] ;", "del_tokens": "events : { } , var listeners = appjs . events [ type ] || ( appjs . events [ type ] = [ ] ) ; var index = appjs . events [ type ] . indexOf ( handler ) ; ~ index && appjs . events [ type ] . splice ( index , 1 ) ; if ( msg && msg . type && appjs . events [ msg . type ] ) { var listeners = appjs . events [ msg . type ] ;", "commit_type": "move"}
{"commit_tokens": ["fix", "the", "test", "by", "changing", "arraybuffer", "conversion", "to", "use", "uint8", "which", "limits", "to", "ascii", "only", "support", "."], "add_tokens": "// The function has limitation, it won't convert non-ascii utf8 or // utf16 binary representation to readable string. return String . fromCharCode . apply ( null , new Uint8Array ( buf ) ) ; // This function can only deal with ascii character. var bufView = new Uint8Array ( buf . buffer ) ; for ( var i = 0 ; i < str . length ; i ++ ) {", "del_tokens": "return String . fromCharCode . apply ( null , new Uint16Array ( buf ) ) ; var bufView = new Uint16Array ( buf . buffer ) ; for ( var i = 0 , strLen = str . length ; i < strLen ; i ++ ) {", "commit_type": "fix"}
{"commit_tokens": ["fixes", "async", "re", "-", "render", "incorrect", "order"], "add_tokens": "// Appease jshint which is unable to understand function hoisting and claims // these functions are undefined; var LayoutManager , renderViews , wrappedRender ; if ( view . _hasRendered ) { // If the view contains a views object, iterate over it as well if ( _ . isObject ( view . options . views ) ) { return renderViews ( view , view . options . views ) ; } // This will be useful to allow wrapped renders to know when they are // done as well return viewDeferred . resolve ( view . el ) ; } // Always remove the view when re-rendering view . remove ( ) ; // Let us know the view has been rendered view . _hasRendered = true ; viewDeferred . resolve ( view . el ) ; // Ensure events are rebound view . delegateEvents ( ) ; LayoutManager = Backbone . LayoutManager = Backbone . View . extend ( {", "del_tokens": "// Always remove the view when re-rendering view . remove ( ) ; viewDeferred . resolve ( view . el ) . then ( function ( el ) { // Ensure events are rebound view . delegateEvents ( ) ; } ) ; var LayoutManager = Backbone . LayoutManager = Backbone . View . extend ( {", "commit_type": "fix"}
{"commit_tokens": ["improved", "code", "-", "size", "performance", "and", "accuracy"], "add_tokens": "var Complex = require ( \"../complex.min\" ) ; expect : \"6.59210468080686 + 2.730539163373364i\" expect : \"6.59210468080686 - 2.730539163373364i\" expect : \"2.730539163373364 + 6.59210468080686i\" expect : \"2.730539163373364 - 6.59210468080686i\"", "del_tokens": "var Complex = require ( \"../complex\" ) ; expect : \"6.592104680806861 + 2.7305391633733636i\" expect : \"6.592104680806861 - 2.7305391633733636i\" expect : \"2.7305391633733636 + 6.592104680806861i\" expect : \"2.7305391633733636 - 6.592104680806861i\"", "commit_type": "improve"}
{"commit_tokens": ["Fix", "spelling", "mistake", "in", "Path"], "add_tokens": "* @ return { Any } Returns Maybe Data if found , undefined if not", "del_tokens": "* @ return { Any } Returns Data if found , undfined if not", "commit_type": "fix"}
{"commit_tokens": ["add", "validators", "for", "type", "numbers", "and", "update", "Readme"], "add_tokens": "'inRange' , 'isInteger' , 'gt' , 'gte' , 'lt' , 'lte'", "del_tokens": "'inRange'", "commit_type": "add"}
{"commit_tokens": ["Make", "functions", "sync", "add", "randomBytes"], "add_tokens": "getRand : function ( ) { return reqQueue . getBuffer ( ) ; getRandLength : function ( length ) { fillRequestQueue ( length || 1 ) ; dev . hasPendingIRQ ( ) ; return reqQueue . getBuffer ( ) ; } , randomBytes : function ( length ) { var retbuf = null ; length = length || 1 ; var u8 = reqQueue . getBuffer ( ) ; retbuf = new Buffer ( u8 . length ) ; for ( let k in u8 ) { retbuf . writeUInt8 ( u8 [ k ] , k ) ; } return retbuf ;", "del_tokens": "getRand : function ( cb ) { reqQueue . fetchBuffers ( cb ) ; getRandLength : function ( length , cb ) { if ( typeof length === 'function' ) { cb = length ; length = 1 ; } if ( ! cb ) { cb = function ( ) { } ; } reqQueue . fetchBuffers ( cb ) ;", "commit_type": "make"}
{"commit_tokens": ["Implement", "mute", "for", "Audio", "Tag"], "add_tokens": "this . volume = new Audio ( ) . volume ; audio . volume = this . volume ; function setAudioTagVolume ( sounds , gain ) { for ( var name in sounds ) { if ( sounds . hasOwnProperty ( name ) ) { sounds [ name ] . volume = gain ; } } } AudioTagSoundLoader . prototype . mute = function ( ) { setAudioTagVolume ( this . sounds , 0 ) ; this . muted = true ; } ; AudioTagSoundLoader . prototype . unmute = function ( ) { setAudioTagVolume ( this . sounds , this . volume ) ; this . muted = false ; } ; AudioTagSoundLoader . prototype . setVolume = function ( gain ) { this . volume = gain ; setAudioTagVolume ( this . sounds , gain ) ; this . muted = false ; } ; AudioTagSoundLoader . prototype . isMuted = function ( ) { return this . muted ; } ;", "del_tokens": "if ( this . muted ) { return ; }", "commit_type": "implement"}
{"commit_tokens": ["use", "double", "brackts", "on", "name"], "add_tokens": "return canReflect . getName ( this . constructor ) + \"{{\" + this . key + \"}}\" ;", "del_tokens": "return canReflect . getName ( this . constructor ) + \"{\" + this . key + \"}\" ;", "commit_type": "use"}
{"commit_tokens": ["fix", "redundant", "header", "for", "static", "rendering"], "add_tokens": "var floating_cols_header = React . createElement ( \"div\" , { id : \"floating-cols-header-\" + this . props . eventKey , className : \"floating-cols-header\" } )", "del_tokens": "var floating_cols_header = React . createElement ( \"div\" , { id : \"floating-cols-header-\" + this . props . eventKey , className : \"floating-cols-header\" } , \"header\" )", "commit_type": "fix"}
{"commit_tokens": ["Use", "sass", "to", "create", "css", "test", "file", "."], "add_tokens": "// Sass sass : { main : { options : { 'sourcemap' : 'none' } , files : { 'test/style.css' : 'test/sass/main.scss' } } , sourcemap : { files : { 'test/style_sourcemap.css' : 'test/sass/main.scss' } } } , grunt . loadNpmTasks ( 'grunt-contrib-sass' ) ; grunt . registerTask ( 'walbo' , [ 'clean' , 'sass' , 'px_to_rem' ] ) ;", "del_tokens": "grunt . registerTask ( 'walbo' , [ 'clean' , 'px_to_rem' ] ) ;", "commit_type": "use"}
{"commit_tokens": ["Updated", "default", "sample", "metadata", "."], "add_tokens": "sequence : 1 ,", "del_tokens": "sequence : 2 ,", "commit_type": "update"}
{"commit_tokens": ["Use", "provided", "alias", "when", "creating", "an", "application"], "add_tokens": "return Application . linkRepo ( api , app . id , alias ) ;", "del_tokens": "return Application . linkRepo ( api , app . id ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "multistream", "and", "muxer", "tests"], "add_tokens": "// var Identify = require('./../src/identify') // var peerA = new Peer(Id.create(), [multiaddr('/ip4/127.0.0.1/tcp/' + a.port)]) // var i = new Identify(a, peerA) // i.on('thenews', function (news) { // console.log('such news') // }) return console . log ( err )", "del_tokens": "var Identify = require ( './../src/identify' ) var peerA = new Peer ( Id . create ( ) , [ multiaddr ( '/ip4/127.0.0.1/tcp/' + a . port ) ] ) var i = new Identify ( a , peerA ) i . on ( 'thenews' , function ( news ) { console . log ( 'such news' ) } ) return console . log ( 'ERR - ' , err )", "commit_type": "add"}
{"commit_tokens": ["use", "MonetaryAmount", "for", "the", "function", "startChallengeFromPayment"], "add_tokens": "const currency = '0x0000000000000000000000000000000000000000' ; currency : { ct : currency , id : 0 } , const stageAmount = new MonetaryAmount ( ethers . utils . parseUnits ( amount , 18 ) , currency , 0 ) ; . withArgs ( receipt . toJSON ( ) , wallet . address , stageAmount . toJSON ( ) . amount , { } ) let tx = await wallet . startChallengeFromPayment ( receipt , stageAmount ) ; const stageAmount = new MonetaryAmount ( ethers . utils . parseUnits ( amount , 18 ) , t . currency , 0 ) ; . withArgs ( receipt . toJSON ( ) , wallet . address , stageAmount . toJSON ( ) . amount ) let tx = await wallet . startChallengeFromPayment ( receipt , stageAmount ) ; const expectedSettlement = null ;", "del_tokens": "currency : { ct : '0x0000000000000000000000000000000000000000' , id : 0 } , . withArgs ( receipt . toJSON ( ) , wallet . address , ethers . utils . parseUnits ( amount , 18 ) , { } ) let tx = await wallet . startChallengeFromPayment ( receipt , amount ) ; . withArgs ( receipt . toJSON ( ) , wallet . address , ethers . utils . parseUnits ( amount , testTokens [ 1 ] . decimals ) , { } ) let tx = await wallet . startChallengeFromPayment ( receipt , amount ) ; const expectedSettlement = undefined ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "fhignore", "and", "fhinclude", "that", "are", "broken", "in", "v1", "+"], "add_tokens": "if ( fhignore && _ . isArray ( fhignore ) ) { extras = fhignore . map ( function ( elem ) { if ( fhinclude && _ . isArray ( fhinclude ) ) { extras = fhinclude ;", "del_tokens": "if ( typeof fhignore === 'string' && fhignore . length > 0 ) { extras = fhignore . split ( ',' ) . map ( function ( elem ) { if ( typeof fhinclude === 'string' && fhinclude . length > 0 ) { extras = fhinclude . split ( ',' ) ;", "commit_type": "fix"}
{"commit_tokens": ["allowing", "you", "to", "pass", "Bracket", "expression", "as", "an", "argument", "to", "a", "Call", "expression"], "add_tokens": "compute = expr . value ( // foo([bar]) expr = new expression . Call ( new expression . Lookup ( '@foo' ) , [ new expression . Bracket ( new expression . Lookup ( 'bar' ) ) ] , { } ) ; compute = expr . value ( new Scope ( new CanMap ( { foo : function ( val ) { return val + '!' ; } , bar : 'name' , name : 'Kevin' } ) ) ) ; equal ( compute ( ) , \"Kevin!\" ) ;", "del_tokens": "var compute = expr . value (", "commit_type": "allow"}
{"commit_tokens": ["updated", "package", ".", "json", "with", "dev", "deps", "and", "tests"], "add_tokens": "'node_modules/angular/angular.min.js' , 'node_modules/angular-mocks/angular-mocks.js' , 'node_modules/d3/d3.min.js' , 'node_modules/nvd3/build/nv.d3.min.js' ,", "del_tokens": "'lib/angular.min.js' , 'lib/angular-mocks.js' , 'lib/d3.min.js' , 'lib/nv.d3.min.js' ,", "commit_type": "update"}
{"commit_tokens": ["allow", "file", ":", "null", "for", "templates"], "add_tokens": "if ( typeof o === 'undefined' || typeof o . file === 'undefined' ) throw new Error ( \"Failed to provide the current file as 'file' to the template\" ) ;", "del_tokens": "if ( ! o . file ) throw new Error ( \"Failed to provide the current file as 'file' to the template\" ) ;", "commit_type": "allow"}
{"commit_tokens": ["adding", "first", "batch", "of", "tests"], "add_tokens": "grunt . loadNpmTasks ( 'grunt-contrib-clean' ) ; grunt . loadNpmTasks ( 'grunt-mocha-test' ) ; 'tasks/**/*.js' , 'test/**/*.js' } , clean : { tmp : [ './tmp/**/*' , './test/tmp/**/*' ] } , mochaTest : { options : { reporter : 'mocha-unfunk-reporter' } , all : { src : [ './test/spec/*.test.js' ] } grunt . registerTask ( 'prep' , [ 'clean' , 'jshint' ] ) ; grunt . registerTask ( 'test' , [ 'prep' , 'mochaTest' ] ) ;", "del_tokens": "/ * * grunt - tv4 * https : //github.com/Bartvds/grunt-tv4 * * Copyright ( c ) 2013 Bart van der Schoor * Licensed under the MIT license . * / /*jshint unused:false*/ var util = require ( 'util' ) ; //used by format checker var dateRegex = / ^\\d{4}-\\d{1,2}-\\d{1,2}$ / ; var dateValidateCallback = function ( data , schema ) { if ( typeof data !== 'string' || ! dateRegex . test ( data ) ) { // return error message return 'value must be string of the form: YYYY-MM-DD' ; } return null ; } ; 'tasks/**/*.js' grunt . registerTask ( 'test' , [ 'jshint' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "assigner", "to", "be", "specified"], "add_tokens": "store : undefined , buttonText : React . PropTypes . string , assigner : React . PropTypes . string } , componentWillMount ( ) { this . store = createStore ( app ( this . props . assigner ) ) ; < Provider store = { this . store } >", "del_tokens": "let store = createStore ( app ) ; buttonText : React . PropTypes . string < Provider store = { store } >", "commit_type": "allow"}
{"commit_tokens": ["Use", "seconds", "and", "millis", "in", "filenames"], "add_tokens": "name_format : '%Y-%m-%d-%H-%M-%S-%L-' + ( process . env . NODE_ENV || 'development' ) + '-' + os . hostname ( ) + '.log'", "del_tokens": "name_format : '%Y-%m-%d-%H-%M-' + ( process . env . NODE_ENV || 'development' ) + '-' + os . hostname ( ) + '.log'", "commit_type": "use"}
{"commit_tokens": ["Added", "first", "draft", "of", "_", ".", "mapcat"], "add_tokens": "} , // Maps a function over an array and concatenates all of the results. mapcat : function ( coll , fun ) { return _ . cat . apply ( null , _ . map ( coll , fun ) ) ; }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Made", "a", "more", "sensible", "runtime", "but", "it", "is", "still", "incomplete"], "add_tokens": "var def , make_module_def , make_module_set , restore_normal_def , restore_normal_set , set ; set = null ; var _name ; _name = is_symbol ( name ) ? [ to_symbol ( \".\" ) , self_name , [ to_symbol ( 'quote' ) , name ] ] : name ; return def ( _name , value ) ; } ; } ; make_module_set = function ( self_name ) { set = compiler [ to_js_symbol ( \"set!\" ) ] ; return compiler [ to_js_symbol ( \"set!\" ) ] = function ( name , value ) { if ( _ . isEqual ( name , self_name ) ) { throw \"Can't redefine 'self' in a module.\" ; } else { return set ( name , value ) ; } restore_normal_set = function ( ) { var ret ; ret = compiler [ to_js_symbol ( \"set!\" ) ] = set ; set = null ; return ret ; } ; make_module_set ( self_name ) ; restore_normal_set ( ) ;", "del_tokens": "var def , make_module_def , restore_normal_def ; name = [ to_symbol ( \".\" ) , self_name , [ to_symbol ( 'quote' ) , name ] ] ; return def ( name , value ) ;", "commit_type": "make"}
{"commit_tokens": ["removed", "broken", "colltion", "calculation", "for", "now"], "add_tokens": "console . log ( 'top top' , top ) ; console . log ( 'top left' , top ) ; // if (this.default.collision === 'fit' && (top + popDim.height) > bodyDim.height) { // top = bodyDim.height - popDim.height; // } console . log ( 'top right' , top ) ; console . log ( 'top bottom' , top ) ; console . log ( 'top final' , top ) ;", "del_tokens": "if ( this . default . collision === 'fit' && top + popDim . height > bodyDim . height ) { top = bodyDim . height - popDim . height ; }", "commit_type": "remove"}
{"commit_tokens": ["Added", "remoteAddress", "to", "repl", "socket", "logging"], "add_tokens": "var from = sock . remoteAddress ? 'from ' + sock . remoteAddress : '' ; master . log . info ( 'repl connection ' + from ) ; master . log . info ( 'repl disconnect ' + from ) ;", "del_tokens": "master . log . info ( 'repl connection' ) ; master . log . info ( 'repl disconnect' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "report", "class", "and", "reports", "tests", "(", "create", "and", "get", ")"], "add_tokens": "\"disputes_repudiation_get_settlement\" : [ \"/${apiVersion}/${clientId}/settlements/${id}\" , \"GET\" ] , \"reports_create\" : [ \"/${apiVersion}/${clientId}/reports/transactions/\" , \"POST\" ] , \"reports_get\" : [ \"/${apiVersion}/${clientId}/reports/${id}\" , \"GET\" ] , \"reports_all\" : [ \"/${apiVersion}/${clientId}/reports\" , \"GET\" ]", "del_tokens": "\"disputes_repudiation_get_settlement\" : [ \"/${apiVersion}/${clientId}/settlements/${id}\" , \"GET\" ]", "commit_type": "add"}
{"commit_tokens": ["Using", "grunt", "-", "wiredep", "instead", "of", "grunt", "-", "bower", "-", "install"], "add_tokens": "'wiredep:dev' ,", "del_tokens": "'bowerInstall:dev' ,", "commit_type": "use"}
{"commit_tokens": ["Add", "callback", "check", "to", "connect", "method"], "add_tokens": "var promise ; if ( typeof credentials === 'function' ) callback = credentials ; promise = API . signIn ( defaultRequestCliOptions , credentials ) . then ( function ( data ) {", "del_tokens": "var promise = API . signIn ( defaultRequestCliOptions , credentials ) . then ( function ( data ) {", "commit_type": "add"}
{"commit_tokens": ["Allow", "querying", "for", "null", "fields"], "add_tokens": "} , hobby : String hobby : ( item === 'Tim' ) ? null : item + 'sledding'", "del_tokens": "}", "commit_type": "allow"}
{"commit_tokens": ["Add", "tests", "for", "2nd", "order", "curve", "."], "add_tokens": "mask >>>= 1", "del_tokens": "//console.log(\"P: \"+point[point.length-(k+1)]+' mask '+mask.toString(2)) if ( point [ point . length - ( k + 1 ) ] & ( 1 << i ) ) { //console.log(\"BIT CHANGE.\") bits |= mask } //console.log(\"bits: \"+bits.toString(2)+\" mask \"+ mask.toString(2)) //console.log(\"EXIT HILBERT\")", "commit_type": "add"}
{"commit_tokens": ["added", "if", "match", "header", "to", "remove"], "add_tokens": "var msg = new message . DeleteObject ( state . bucket , state . id , state . getDatabaseObjectInfo ( ) ) ; if ( ! force && state . version ) { msg . setIfMatch ( state . version ) ; } return this . _connector . send ( msg ) . then ( function ( ) {", "del_tokens": "return this . _connector . send ( new message . DeleteObject ( state . bucket , state . id , state . getDatabaseObjectInfo ( ) ) ) . then ( function ( ) {", "commit_type": "add"}
{"commit_tokens": ["add", "the", "listen", "method", "review", "doc", "refactor", "internal", "built", "in", "features"], "add_tokens": "//[Add listeners](doc.7.listeners.html) builder . listen ( /* a mix of html selector and event's name */ , /* the callback */ ) ; //[Add features](doc.8.features.html)", "del_tokens": "//[Add features](doc.7.features.html)", "commit_type": "add"}
{"commit_tokens": ["use", "empty", ".", "js", "target", "for", "false", "shims", ";", "false", "test", "passes"], "add_tokens": "resolve ( './fake.js' , { filename : parent_file } , function ( err , p ) {", "del_tokens": "resolve ( './fake' , { filename : parent_file } , function ( err , p ) {", "commit_type": "use"}
{"commit_tokens": ["Added", "new", "example", ":", "minimal"], "add_tokens": "/ * console . log ( TaskList . prototype ) ; //retryMethodOnceWithoutCb: true taskList . f_ . onFinish = function ( ) { console . log ( ' ! onFinish !' ) ; //console.log(this); // console.log(this); taskList . start ( ) ; * / TaskList = f_ . augment ( TaskList , { functionFlow : [ 'getSource' , 'writeSource' , 'notify' ] , toLog : [ 'all' ] , desc : 'logAll task list' } ) ; var taskList = new TaskList ( ) ; taskList = f_ . setup ( taskList ) ; for ( var key in this ) { if ( key . indexOf ( 'f_' ) === - 1 ) console . log ( key ) ; } } ; taskList . start ( ) ; / * taskList . onRetry = function ( info ) { //console.log(info); taskList . start ( ) ; * /", "del_tokens": "retryMethodOnceWithoutCb : true taskList . onRetry = function ( info ) { //console.log(info); console . log ( 'onFinish' ) ; //console.log(this); taskList . start ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "scroll", "unit", "tests", "."], "add_tokens": "function ( scrollValues ) { currentScroll . scrollTop = scrollValues . scrollTop ; currentScroll . scrollBottom = scrollValues . scrollBottom ; callback ( new UT . ScrollEvent ( scrollValues . scrollTop , scrollValues . scrollBottom ) ) ;", "del_tokens": "function ( ) { callback ( new UT . ScrollEvent ( currentScroll . scrollTop , currentScroll . scrollBottom ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "walker", "s", "scope", "module", "use", "objects", "for", "variables"], "add_tokens": "inner . vars [ node . params [ i ] . name ] = { type : \"argument\" , node : node . params [ i ] } ; if ( node . id ) { var decl = node . type == \"FunctionDeclaration\" ; ( decl ? scope : inner ) . vars [ node . id . name ] = { type : decl ? \"function\" : \"function name\" , node : node . id } ; } inner . vars [ handler . param . name ] = { type : \"catch clause\" , node : handler . param } ; scope . vars [ decl . id . name ] = { type : \"var\" , node : decl . id } ;", "del_tokens": "inner . vars [ node . params [ i ] . name ] = \"argument\" ; if ( node . type == \"FunctionDeclaration\" ) scope . vars [ node . id . name ] = \"function\" ; else if ( node . id ) inner . vars [ node . id . name ] = \"function'\" ; inner . vars [ handler . param . name ] = \"catch\" ; scope . vars [ decl . id . name ] = \"var\" ;", "commit_type": "make"}
{"commit_tokens": ["Make", "sure", "currentSlide", "is", "a", "number"], "add_tokens": "// Get current slide and make sure it is a number slider . currentSlide = parseInt ( ( slider . vars . startAt ? slider . vars . startAt : 0 ) ) ; if ( isNaN ( slider . currentSlide ) ) slider . currentSlide = 0 ;", "del_tokens": "slider . currentSlide = slider . vars . startAt ;", "commit_type": "make"}
{"commit_tokens": ["Move", "to", "bootprint", "-", "organization", "and", "enable", "ghook", "for", "StandardJS"], "add_tokens": "var path = require ( 'path' ) module . exports = function ( builder ) { return builder . load ( require ( 'bootprint-base' ) ) . merge ( { 'handlebars' : { 'partials' : path . join ( __dirname , 'handlebars/partials' ) , 'helpers' : require . resolve ( './handlebars/helpers.js' ) } , 'less' : { 'main' : [ require . resolve ( './less/theme.less' ) , require . resolve ( './less/variables.less' ) ] } } ) } module . exports . package = require ( './package' )", "del_tokens": "var path = require ( \"path\" ) ; module . exports = function ( builder ) { return builder . load ( require ( \"bootprint-base\" ) ) . merge ( { \"handlebars\" : { \"partials\" : path . join ( __dirname , \"handlebars/partials\" ) , \"helpers\" : require . resolve ( \"./handlebars/helpers.js\" ) } , \"less\" : { \"main\" : [ require . resolve ( \"./less/theme.less\" ) , require . resolve ( \"./less/variables.less\" ) ] } } ) ; } ; module . exports . package = require ( \"./package\" ) ;", "commit_type": "move"}
{"commit_tokens": ["added", "first", "half", "of", "replicator"], "add_tokens": "replicator = require ( './indexing/replicator.js' ) , } ; exports . createReadStream = function ( callback ) { replicator . createReadStream ( indexes , function ( msg ) { callback ( msg ) ; } ) ; } ;", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["updated", "init", "views", "and", "start", "up"], "add_tokens": "initViews = require ( './lib/init' ) , if ( process . env . NODE_ENV === 'production' ) { initViews ( cloudq , function ( ) { console . log ( 'reloaded views' ) ; app . start ( 3000 ) ; } ) ; } else { app . start ( 3000 ) ; }", "del_tokens": "initViews = require ( './lib/init' ) initViews ( cloudq , function ( ) { app . start ( 3000 ) } ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "relative", "paths", "handling", "with", "fsevents"], "add_tokens": "var dir = sysPath . resolve ( directory ) ; FSWatcher . prototype . _watchWithFsEvents = function ( watchPath ) { if ( this . _isIgnored ( watchPath ) ) return ; var watcher = createFSEventsInstance ( watchPath , function ( fullPath , flags ) { var info = fsevents . getInfo ( fullPath , flags ) ; var path = sysPath . join ( watchPath , sysPath . relative ( watchPath , fullPath ) ) ; if ( this . _isIgnored ( entry . path ) ) return ; emitAdd ( sysPath . join ( file , entry . path ) , entry . stat ) ;", "del_tokens": "var dir = directory . replace ( / [\\\\\\/]$ / , '' ) ; FSWatcher . prototype . _watchWithFsEvents = function ( path ) { if ( this . _isIgnored ( path ) ) return ; var watcher = createFSEventsInstance ( path , function ( path , flags ) { var info = fsevents . getInfo ( path , flags ) ; if ( ! this . _isIgnored ( entry . path ) ) emitAdd ( entry . path , entry . stat ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "for", "new", "strict", "mode", "behavior"], "add_tokens": "const strictOption = { strict : true } test ( 'strict mode objects throw when invalid attrs are accessed' , ( ) => { const env = cleanEnv ( { FOO : 'bar' , BAZ : 'baz' } , { FOO : str ( ) } , strictOption ) assert . strictEqual ( env . FOO , 'bar' ) assert . throws ( ( ) => env . ASDF ) } ) test ( 'strict mode objects throw when attempting to mutate' , ( ) => { const env = cleanEnv ( { FOO : 'bar' , BAZ : 'baz' } , { FOO : str ( ) } , strictOption ) assert . throws ( ( ) => env . FOO = 'foooooo' ) } )", "del_tokens": "const strictOption = { strict : true , reporter : null }", "commit_type": "add"}
{"commit_tokens": ["Moved", "mock", "fetcher", "to", "true", "async", "using", "setTimeout"], "add_tokens": "if ( options === undefined ) { if ( ! options . fetcher ) { this . del ( key , function ( err , success ) { if ( err ) { throw new Error ( \"Couldn't remove an expired key: \" + key ) ; } this . _fetch ( key , { staleTtl : cacheEntry . staleTtl , expiresTtl : cacheEntry . expiresTtl } , callback ) ; } . bind ( this ) ) ; if ( err ) { debug ( \"Issue with fetcher, resolving in error\" ) ; debug ( \"Got value: \" + value + \" from fetcher for key: \" + key ) ; if ( err ) {", "del_tokens": "if ( options === undefined ) { if ( ! options . fetcher ) { this . _fetch ( key , { staleTtl : cacheEntry . staleTtl , expiresTtl : cacheEntry . expiresTtl } , callback ) ; this . del ( key ) ; if ( err ) { if ( err ) {", "commit_type": "move"}
{"commit_tokens": ["added", "accountInfo", "binding", "to", "getIcon"], "add_tokens": "describe : function ( accountInfo ) { 'icon' : this . getIcon ( accountInfo ) ,", "del_tokens": "describe : function ( ) { 'icon' : this . getIcon ( ) ,", "commit_type": "add"}
{"commit_tokens": ["Add", "feature", "to", "support", "setting", "node", "and", "npm", "version", "through", "flags"], "add_tokens": "packageContents . engines = { node : FindNodeVersion ( options ) , npm : typeof options . npmVersion !== 'undefined' ? options . npmVersion : 'latest' } ;", "del_tokens": "packageContents . engines = { node : FindNodeVersion ( options ) } ;", "commit_type": "add"}
{"commit_tokens": ["Added", "hReview", "hAtom", "and", "support", "for", "html5", "time", "element", ".", "Fix", "a", "outstanding", "bugs"], "add_tokens": "function ufadr ( node ) { function ufhCard ( node ) { if ( ufShiv . getTextContent ( givenName ) != undefined ) if ( ufShiv . getTextContent ( additionalName ) != undefined ) if ( ufShiv . getTextContent ( familyName ) != undefined ) function ufhCalendar ( node ) { function ufgeo ( node ) { function uftag ( node ) {", "del_tokens": "function ufadr ( node , validate ) { function ufhCard ( node , validate ) { if ( ufShiv . getTextContent ( givenName ) != '' ) if ( ufShiv . getTextContent ( additionalName ) != '' ) if ( ufShiv . getTextContent ( familyName ) != '' ) function ufhCalendar ( node , validate ) { function ufgeo ( node , validate ) { function uftag ( node , validate ) {", "commit_type": "add"}
{"commit_tokens": ["add", "test", "framework", "and", "some", "tests"], "add_tokens": "if ( ! user || ! user . constructor || ! user . constructor . name || user . constructor . name !== \"User\" || ! user . serialize || typeof user . serialize !== \"function\" ) {", "del_tokens": "if ( ! user || ! user . constructor || ! user . constructor . name || user . constructor . name !== \"User\" || ! user . serialize || typeof ( user . serialize !== \"function\" ) ) {", "commit_type": "add"}
{"commit_tokens": ["Allow", "a", "forced", "session", "id", "that", "is", "not", "available", "in", "the", "cookie"], "add_tokens": "if ( ! this . sessionId ) { this . sessionId = this . cookies . get ( key , { signed : cookie . signed } ) ; }", "del_tokens": "this . sessionId = this . cookies . get ( key , { signed : cookie . signed } ) ;", "commit_type": "allow"}
{"commit_tokens": ["Make", "pretty", "printing", "SSML", "strings", "optional", "and", "false", "by", "default"], "add_tokens": "export default function renderToString ( data , pretty = false ) { return xml . end ( { pretty } ) ;", "del_tokens": "export default function renderToString ( data ) { return xml . end ( { pretty : true } ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "static", "file", "directory", "on", "export", "."], "add_tokens": "yield cpy ( globs , dest , { cwd : src , parents : true , nodir : true , ignore : opts . excludes } )", "del_tokens": "yield cpy ( globs , dest , { cwd : src , nodir : true , ignore : opts . excludes } )", "commit_type": "fix"}
{"commit_tokens": ["add", "null", "check", "in", "validate", "function", ".", "add", "documentation", "badge", ".", "use", "html", "reporter", "for", "nyc"], "add_tokens": "else if ( rows && rows . rows ) return rows . rows", "del_tokens": "else if ( rows . rows ) return rows . rows", "commit_type": "add"}
{"commit_tokens": ["Fix", "without", "and", "refactor", "slightly", "."], "add_tokens": "keysToRemove = Array . prototype . slice . call ( arguments ) ; for ( var key in this ) { if ( keysToRemove . indexOf ( key ) === - 1 ) {", "del_tokens": "keysToRemove = Array . slice . call ( arguments ) ; for ( key in this ) { if ( ! ( key in keysToRemove ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "statuscode", "error", "handling", "for", "rest", "service"], "add_tokens": "const res = { statusCode : 200 , setEncoding : sinon . spy ( ) , on : sinon . spy ( ) } ;", "del_tokens": "const res = { setEncoding : sinon . spy ( ) , on : sinon . spy ( ) } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "proper", "handling", "of", "native", "node", "lists"], "add_tokens": "var elementType = Object . prototype . toString . call ( element ) ; if ( '[object Array]' === elementType || ( '[object NodeList]' === elementTyle ) || ( '[object HTMLCollection]' === elementTyle ) } ) ( ) ;", "del_tokens": "if ( \"[object Array]\" === Object . prototype . toString . call ( element ) } ) ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "a", "more", "descriptive", "error", "message"], "add_tokens": "grunt . log . error ( 'PhantomJS timed out, possibly due to:\\n' + '- QUnit is not loaded correctly.\\n- A missing QUnit start() call.\\n' + '- Or, a misconfiguration of this task.' ) ;", "del_tokens": "grunt . log . error ( 'PhantomJS timed out, possibly due to a missing QUnit start() call.' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "React", "Router", "after", "upgrade"], "add_tokens": "var Router = require ( 'react-router' ) ; var Route = Router . Route ; var content = document . getElementById ( 'content' ) ; var Routes = ( < Route handler = { < %= scriptAppName % > } > < Route name = \"/\" handler = { < %= scriptAppName % > } / > < / Route > ) ; Router . run ( Routes , function ( Handler ) { React . render ( < Handler / > , content ) ; } ) ;", "del_tokens": "var { DefaultRoute , Route , Routes } = require ( 'react-router' ) ; React . renderComponent ( ( < Routes location = \"history\" > < Route path = \"/\" handler = { < %= scriptAppName % > } > < / Route > < / Routes > ) , document . getElementById ( 'content' ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["updates", "to", "allow", "other", "plugins", "to", "initialize", "with", "acl", "groups", "info", "."], "add_tokens": "const localUserClient = require ( './lib/localUserClient' ) ; //initializeAcl.createGroups(server); each plugin should call transomLocalUserClient.setGroups(server, groups) initializeAcl . createDefaultUser ( server ) ; server . registry . set ( 'transomLocalUserClient' , localUserClient ) ;", "del_tokens": "if ( process . env . NODE_ENV !== 'production' ) { initializeAcl . createGroups ( server ) ; initializeAcl . createDefaultUser ( server ) ; }", "commit_type": "update"}
{"commit_tokens": ["Adding", "table", "-", "level", "descriptions"], "add_tokens": "pFable . Stricture . Tables [ pScopeHash ] = { TableName : pScopeHash , Domain : pFable . DDLParserState . CurrentDomain , Columns : [ ] , Description : '' } ; // ### Column Description case ' > ' // ### Table Description tmpLineType = 'TableDescription' ; var tmpDescription = tmpLine . substring ( 1 ) ; if ( pFable . Stricture . Tables [ pFable . DDLParserState . CurrentScope ] . Description . length > 0 ) pFable . Stricture . Tables [ pFable . DDLParserState . CurrentScope ] . Description += \"\\n\\n\" ; pFable . Stricture . Tables [ pFable . DDLParserState . CurrentScope ] . Description += tmpDescription ; break ;", "del_tokens": "pFable . Stricture . Tables [ pScopeHash ] = { TableName : pScopeHash , Domain : pFable . DDLParserState . CurrentDomain , Columns : [ ] } ; // ### Integer Number", "commit_type": "add"}
{"commit_tokens": ["fixing", "a", "help", "array", "vs", ".", "non", "issue"], "add_tokens": "var descr = command . does ; if ( ! descr ) { descr = command . description ; } if ( ! util . isArray ( descr ) ) { descr = [ descr ] ; } utilities . indentLines ( descr , \" \" , 4 )", "del_tokens": "utilities . indentLines ( command . does || command . description . split ( '\\n' ) , \" \" , 4 )", "commit_type": "fix"}
{"commit_tokens": ["Added", "capability", "for", "Domain", "clustering", "of", "models"], "add_tokens": "StanzaType : 'None' , CurrentDomain : 'Default' pFable . Stricture . Tables [ pScopeHash ] = { TableName : pScopeHash , Domain : pFable . DDLParserState . CurrentDomain , Columns : [ ] } ; else if ( ( tmpLineSplit [ 0 ] === '[Domain' ) && ( tmpLine . charAt ( tmpLine . length - 1 ) === ']' ) ) { // Change of domain, not stanza. pFable . DDLParserState . CurrentDomain = tmpLineSplit [ 1 ] . substring ( 0 , tmpLineSplit [ 1 ] . length - 1 ) ; // Add the table to the model if it doesn't exist. InitializeScope ( pFable . DDLParserState . CurrentScope , pFable ) ; console . log ( ' > Line #' + pFable . DDLParserState . LineCount + ' changes the domain: ' + pFable . DDLParserState . CurrentDomain ) ; }", "del_tokens": "StanzaType : 'None' pFable . Stricture . Tables [ pScopeHash ] = { TableName : pScopeHash , Columns : [ ] } ;", "commit_type": "add"}
{"commit_tokens": ["Use", "json", "-", "schema", "-", "ref", "-", "parser", "in", "place", "of", "json", "-", "schema", "-", "deref"], "add_tokens": "", "del_tokens": "", "commit_type": "use"}
{"commit_tokens": ["Fix", "a", "timing", "issue", "that", "causes", "automation", "to", "break"], "add_tokens": "_currentDocumentLoaded = false , _currentDocumentLoaded = false ; if ( ! _currentDocumentLoaded ) { if ( ! _currentDocumentLoaded ) { _currentDocumentLoaded = true ;", "del_tokens": "_setupDone = false , if ( ! _setupDone ) { if ( ! _setupDone ) { _setupDone = true ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "options", ".", "star", "and", "options", ".", "slash", "to", "be", "a", "function"], "add_tokens": "if ( options && typeof options . slash === 'string' ) { return options . slash ; } if ( options && typeof options . slash === 'function' ) { return options . slash . call ( nanomatch ) ; } return '\\\\\\\\/' ; if ( options && typeof options . star === 'string' ) { return options . star ; } if ( options && typeof options . star === 'function' ) { return options . star . call ( nanomatch ) ; } return '[^' + slash ( ) + ']*?' ;", "del_tokens": "return ( options && options . slash ) || '\\\\\\\\/' ; return ( options && options . star ) || '[^' + slash ( ) + ']*?' ;", "commit_type": "allow"}
{"commit_tokens": ["Use", "2", "-", "letter", "country", "code", "+", "currency", "symbol", "instead", "of", "3", "-", "letter", "."], "add_tokens": "internationalCurrencySymbol : 'CA$' currencySymbol : '€' internationalCurrencySymbol : 'GB£' internationalCurrencySymbol : 'JP¥', internationalCurrencySymbol : 'US$'", "del_tokens": "internationalCurrencySymbol : 'CAD$' currencySymbol : '€', internationalCurrencySymbol : 'EUR€' internationalCurrencySymbol : 'GBP£' internationalCurrencySymbol : 'JPY¥', internationalCurrencySymbol : 'USD$'", "commit_type": "use"}
{"commit_tokens": ["make", "trace", "timeout", "actual", "working"], "add_tokens": "traceStats ( items ) ; window . _webdriverrtcTimeout = setTimeout ( getStats . bind ( window , items ) , interval ) ; cb ( ) ;", "del_tokens": "/ ** * trace stats for the first time to check if everything works * / if ( Object . keys ( window . _webdriverrtc ) . length === 0 ) { traceStats ( items ) ; cb ( ) ; } window . _webdriverrtcTimeout = setTimeout ( traceStats . bind ( window , items ) , interval ) ;", "commit_type": "make"}
{"commit_tokens": ["Remove", "dom", "reference", "at", "require", "time", "in", "themeUtils"], "add_tokens": "const customPropsSupported = function ( ) { return window . CSS && window . CSS . supports && window . CSS . supports ( 'color' , 'var(--primary)' ) } if ( typeof injectStylesFunc === 'function' && customPropsSupported ( ) ) { } else if ( customPropsSupported ( ) ) { if ( customPropsSupported ( ) ) {", "del_tokens": "const CUSTOM_PROPS_SUPPORTED = window . CSS && window . CSS . supports && window . CSS . supports ( 'color' , 'var(--primary)' ) if ( typeof injectStylesFunc === 'function' && CUSTOM_PROPS_SUPPORTED ) { } else if ( CUSTOM_PROPS_SUPPORTED ) { if ( CUSTOM_PROPS_SUPPORTED ) {", "commit_type": "remove"}
{"commit_tokens": ["removed", "lodash", "and", "combined", "getTransitionDuration", ".", "js", "and", "createTransitions", ".", "js"], "add_tokens": "var animationDefinition = createTransitions ( animation , states [ from ] , states [ to ] ) ; animationDefinition . transitions driver . fromTo ( from , to , animationDefinition . duration , animation ) ;", "del_tokens": "var getTransitionDuration = require ( './getTransitionDuration' ) ; var duration ; // get the duration between from state and to state duration = getTransitionDuration ( animation , states [ from ] , states [ to ] ) ; createTransitions ( duration , animation , states [ from ] , states [ to ] ) driver . fromTo ( from , to , duration , animation ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "support", "for", "typeOf", "-", "call", "for", "no", "-", "is", "-", "array", "rule"], "add_tokens": ". createCombos ( [ \"code\" ] , [ { IS_ARRAY : \"typeOf\" } , { IS_ARRAY : \"Ember.typeOf\" } , { IS_ARRAY : \"Ember['typeOf']\" } , { IS_ARRAY : \"Array.isArray\" } , { IS_ARRAY : \"Array['isArray']\" } ] )", "del_tokens": ". createCombos ( [ \"code\" ] , [ { IS_ARRAY : \"Ember.typeOf\" } , { IS_ARRAY : \"Ember['typeOf']\" } , { IS_ARRAY : \"Array.isArray\" } , { IS_ARRAY : \"Array['isArray']\" } ] )", "commit_type": "add"}
{"commit_tokens": ["Added", "the", "required", "x", "-", "arrow", "attribute", "to", "enable", "the", "arrow", "to", "stay", "bound", "to", "the", "target"], "add_tokens": "this . el = createFromHTML ( '<div class=\\'shepherd-step ' + ( this . options . classes || '' ) + '\\' data-id=\\'' + this . id + '\\' ' + ( this . options . idAttribute ? 'id=\"' + this . options . idAttribute + '\"' : '' ) + '><div class=\"popper__arrow\" x-arrow></div>' ) ;", "del_tokens": "this . el = createFromHTML ( '<div class=\\'shepherd-step ' + ( this . options . classes || '' ) + '\\' data-id=\\'' + this . id + '\\' ' + ( this . options . idAttribute ? 'id=\"' + this . options . idAttribute + '\"' : '' ) + '><div class=\"popper__arrow\"></div>' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "tests", "for", "default", "loader", "modification"], "add_tokens": "modifiedDefaultLoader = defaultLoader !== loadTemplate , if ( ( customLoader || modifiedDefaultLoader ) && $template !== \"\" && ! ( $template instanceof Backbone . $ ) ) { throw new CustomizationError ( \"Invalid return value. The \" + ( customLoader ? \"custom\" : \"default\" ) + \" loadTemplate function must return a jQuery instance, but it hasn't\" ) ; }", "del_tokens": "if ( customLoader && $template !== \"\" && ! ( $template instanceof Backbone . $ ) ) throw new CustomizationError ( \"Invalid return value. The custom loadTemplate function must return a jQuery instance, but it hasn't\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "--", "src", "command", "line", "option"], "add_tokens": "if ( ! argv . s && ! argv . src ) {", "del_tokens": "if ( ! argv . s ) {", "commit_type": "fix"}
{"commit_tokens": ["changing", "build", "so", "it", "should", "use", "steal", "as", "the", "global"], "add_tokens": "global : \"steal\"", "del_tokens": "nojquery : \"steal\"", "commit_type": "change"}
{"commit_tokens": ["Making", "possible", "to", "start", "the", "server", "on", "another", "port", "than", "3000", "by", "using", "the", "-", "p", "argument", "."], "add_tokens": "server . start ( getPort ( ) ) ; // Get port from command line argument \"-p\" or fallback to 3000. function getPort ( ) { var port = 3000 ; var args = process . argv . slice ( 2 ) ; if ( args . length && args . shift ( ) === '-p' ) { port = args . shift ( ) || port ; } return port ; }", "del_tokens": "server . start ( 3000 ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "problem", "with", "severals", "instances"], "add_tokens": "wallID : null , //differentiates several walls; var blockId = ( setting . wallID ? setting . wallID + '-' : '' ) + runtime . lastId ++ + '-' + this . totalGrid ;", "del_tokens": "var blockId = runtime . lastId ++ + '-' + this . totalGrid ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "some", "more", "context", "info", "to", "VBOLE", "errors"], "add_tokens": "* @ version 0.2 .2 result . type = req . type ; result . vbmsg = entry . error ; result . req = req ;", "del_tokens": "* @ version 0.2 .1", "commit_type": "add"}
{"commit_tokens": ["Fix", "build", "-", "css", "crashing", "on", "error"], "add_tokens": "if ( error . showSourceCode ) { process . stderr . write ( ` ${ error . message } \\n ${ error . showSourceCode ( ) } ` ) ; } throw error ;", "del_tokens": "process . stderr . write ( ` ${ error . message } \\n ${ error . showSourceCode ( ) } ` ) ; throw new Error ( error ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "interfaces", "for", "the", "options", "of", "..", "StorageProvenanceGraphManagers"], "add_tokens": "application : 'unknown' , defaultPermission : Permission . ALL_READ_NONE permissions : this . options . defaultPermission , permissions : this . options . defaultPermission ,", "del_tokens": "application : 'unknown' permissions : Permission . ALL_READ_NONE , permissions : Permission . ALL_READ_NONE ,", "commit_type": "add"}
{"commit_tokens": ["Make", "Struct", ".", "extend", "accept", "array", "of", "extensions"], "add_tokens": "return struct ( [ props ] . concat ( newProps ) . reduce ( mixin , { } ) , name ) ;", "del_tokens": "return struct ( mixin ( mixin ( { } , props ) , newProps ) , name ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "task", "init", "and", "test"], "add_tokens": "'default' : 'autofile' if ( ! utils . string . endsWith ( opt . name , '.js' ) ) { opt . filename = opt . name + '.js' ; } else { opt . filename = opt . name ; opt . name = opt . name . slice ( 0 , - 3 ) ; file : '{{dst}}/{{filename}}.js' ,", "del_tokens": "filename : { description : 'The task filename' , 'default' : 'autofile.js' } , 'default' : 'your-task' console . log ( opt ) ; if ( ! utils . string . endsWith ( opt . filename , '.js' ) ) { opt . filename += '.js' ; file : '{{dst}}/{{name}}.js' ,", "commit_type": "fix"}
{"commit_tokens": ["allow", "passing", "in", "a", "method", "option", "to", "specify", "which", "method", "is", "added", "to", "the", "app", "for", "generating", "a", "tree", "hierarchy"], "add_tokens": "* @ param { String } ` ` Optional method name defined on the ` ` . Defaults to ` ` . options . method = options . method || 'tree' ; if ( typeof app [ options . method ] !== 'undefined' ) { app . define ( options . method , function ( opts ) { if ( typeof child [ opts . method ] === 'function' ) { nodes . push ( child [ opts . method ] ( opts ) ) ;", "del_tokens": "if ( typeof app . tree !== 'undefined' ) { app . define ( 'tree' , function ( opts ) { if ( typeof child . tree === 'function' ) { nodes . push ( child . tree ( opts ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["Move", "error", "generation", "to", "GiftedManager", "(", "Programmatic", "Submit", ")"], "add_tokens": "details : details , } ) ;", "del_tokens": "} ) ;", "commit_type": "move"}
{"commit_tokens": ["Use", "single", "instance", "of", "module", "even", "if", "required", "multiple", "times", "(", "singleton", "-", "type", "behavior", ")", "."], "add_tokens": "var activePrimitives = [ ] ; var activeMesh = null ; module . exports = function ( THREE ) {", "del_tokens": "module . exports = function ( THREE ) { var activePrimitives = [ ] ; var activeMesh = null ;", "commit_type": "use"}
{"commit_tokens": ["removed", "reference", "to", "leaflet", "in", "base", "map"], "add_tokens": "_ . defauls ( this . options , options ) ;", "del_tokens": "L . Util . setOptions ( this , options ) ;", "commit_type": "remove"}
{"commit_tokens": ["fix", "programtransformer", "&", "test", ".", "html"], "add_tokens": "return ClassTransformer . transform ( this . reporter_ , tree ) ;", "del_tokens": "return ClassTransformer . transform ( this . reporter_ , this . project_ , tree ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "frame", "option", "to", "replicate", "that", "can", "disable", "framing"], "add_tokens": "var Protocol = function ( opts ) { if ( ! ( this instanceof Protocol ) ) return new Protocol ( opts ) var frame = ! opts || opts . frame !== false this . _encoder = frame ? lpstream . encode ( ) : through . obj ( ) this . _decoder = frame ? lpstream . decode ( ) : through . obj ( ) Duplexify . call ( this , this . _decoder , this . _encoder , frame ? { } : { objectMode : true , highWaterMark : 16 } )", "del_tokens": "var Protocol = function ( ) { if ( ! ( this instanceof Protocol ) ) return new Protocol ( ) this . _encoder = lpstream . encode ( ) this . _decoder = lpstream . decode ( ) Duplexify . call ( this , this . _decoder , this . _encoder )", "commit_type": "add"}
{"commit_tokens": ["Add", "arc", "meter", "support", "to", "node", "detailed", "view"], "add_tokens": "} , arc : { }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["make", "event", "social_shares_click", "root", "access"], "add_tokens": "this . $root . $emit ( 'social_shares_click' , network , this . url ) ; this . $root . $emit ( 'social_shares_click' , network , this . url ) ; module . exports = SocialSharing ;", "del_tokens": "this . $emit ( 'social_shares_click' , network , this . url ) ; this . $emit ( 'social_shares_click' , network , this . url ) ; module . exports = SocialSharing ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "issue", "with", "null", "references"], "add_tokens": "if ( ! ( 'data' in obj . relationships [ ref ] ) ) { return ; } if ( ! ( ref in record ) || ref in record [ '__data' ] ) { record . assignRef ( ref , [ ] ) ; } else if ( record ) { if ( items ) { var models = utils_1 . mapItems ( items , function ( _a ) { var id = _a . id , type = _a . type ; return _this . find ( type , id ) || id ; } ) ; var itemType = items instanceof Array ? items [ 0 ] . type : items . type ; record . assignRef ( ref , models , itemType ) ; } else { record . assignRef ( ref , null ) ; }", "del_tokens": "// it's only possible to update items with one ore more refs. Early exit return ; if ( items && record ) { var models = utils_1 . mapItems ( items , function ( _a ) { var id = _a . id , type = _a . type ; return _this . find ( type , id ) || id ; } ) ; var itemType = items instanceof Array ? items [ 0 ] . type : items . type ; record . assignRef ( ref , models , itemType ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "lodash", "-", "template", "/", "html", "-", "comment", "-", "spacing", "rule"], "add_tokens": "\"<body> <div style=\\\" \\\" class=\\\" foo \\\" attr=foo ></div> </body>\" ,", "del_tokens": "\"<body> <div :style=\\\" \\\" :class=\\\" foo \\\" v-if=foo ></div> </body>\" ,", "commit_type": "add"}
{"commit_tokens": ["fixed", "marking", "of", "natives", "to", "only", "look", "at", "types", "from", "lib", ".", "d", ".", "ts"], "add_tokens": "if ( type . properties [ k ] . meta . origin === LIB_ORIGIN ) { visitPrty ( obj . propertyMap . get ( k ) , type . properties [ k ] . type ) }", "del_tokens": "visitPrty ( obj . propertyMap . get ( k ) , type . properties [ k ] . type ) } if ( type . numberIndexer ) { obj . propertyMap . forEach ( function ( name , prty ) { if ( isNumberString ( name ) ) visitPrty ( prty , type . numberIndexer ) } ) } if ( type . stringIndexer ) { obj . propertyMap . forEach ( function ( name , prty ) { if ( prty . enumerable ) { visitPrty ( prty , type . stringIndexer ) } } )", "commit_type": "fix"}
{"commit_tokens": ["added", "duck", "-", "type", "assertions"], "add_tokens": "var methods = [ 'writeln' , 'error' , 'warning' , 'success' , 'accent' , 'muted' , 'toString' ] ; function checkMiniWrite ( target ) { var missing = [ ] ; for ( var i = 0 ; i < methods . length ; i ++ ) { if ( typeof target [ methods [ i ] ] !== 'function' ) { missing . push ( methods [ i ] ) ; } } return missing ; } function isMiniWrite ( target ) { return ( checkMiniWrite ( target ) . length === 0 ) ; } function assertMiniWrite ( target ) { var missing = checkMiniWrite ( target ) ; if ( missing . length > 0 ) { throw new Error ( 'target is missing required methods: ' + missing . join ( ) ) ; } } assertMiniWrite : assertMiniWrite , checkMiniWrite : checkMiniWrite , isMiniWrite : isMiniWrite ,", "del_tokens": "} , clear : function ( ) { //abstract", "commit_type": "add"}
{"commit_tokens": ["allow", "specification", "of", "irc", "client", "options"], "add_tokens": "var client = new irc . Client ( network , config . nick , config . connect_opts ? config . connect_opts [ network ] : undefined ) ;", "del_tokens": "var client = new irc . Client ( network , config . nick ) ;", "commit_type": "allow"}
{"commit_tokens": ["Change", "use", "of", "promise", ".", "progress", "to", "event", "emitters"], "add_tokens": "var Promise = require ( 'bluebird' ) ; return new Promise ( function ( resolve , reject ) { _resolve ( id , opts , function ( err , res ) { if ( err ) { reject ( err ) ; } else { resolve ( res ) ; } } ) ;", "del_tokens": "var Q = require ( 'q' ) ; var deferred = Q . defer ( ) ; _resolve ( id , opts , function ( err , res ) { if ( err ) { deferred . reject ( err ) ; } else { deferred . resolve ( res ) ; } return deferred . promise ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "iPhone", "/", "iPad", "detection", "."], "add_tokens": "var device = window . navigator . userAgent . indexOf ( \"iPad\" ) >= 0 ? \"iPad\" : \"iPhone\" ; var size = sizes [ device ] [ isLandscape ? \"landscape\" : \"portrait\" ] ;", "del_tokens": "var size = sizes [ window . navigator . userAgent ] [ isLandscape ? \"landscape\" : \"portrait\" ] ;", "commit_type": "fix"}
{"commit_tokens": ["Made", "exam", "-", "cover", "work", "with", "npm", "3"], "add_tokens": "var examCli = require . resolve ( 'exam/exam.js' ) var istanbulCli = require . resolve ( 'istanbul/lib/cli.js' )", "del_tokens": "var examCli = __dirname + '/exam.js' var istanbulCli = __dirname + '/node_modules/istanbul/lib/cli.js'", "commit_type": "make"}
{"commit_tokens": ["Use", "yamljs", "to", "parse", "a", "YML", "file"], "add_tokens": "var api = aOptions . apiDef ;", "del_tokens": "var aApiDef = aOptions . apiDef ; var api = JSON . parse ( aApiDef ) ;", "commit_type": "use"}
{"commit_tokens": ["update", "source", "-", "map", "support"], "add_tokens": "// Set sourceMapURL to enable separate source-map file. options . compiler . sourceMapURL = path . basename ( lessPath , '.less' ) + '.css.map' ; // To generate the exact source-map file. options . compiler . writeSourceMap = function ( sourceMap ) { var mapPath = path . join ( options . compiler . sourceMapBasepath , options . compiler . sourceMapURL ) ; fs . writeFile ( mapPath , sourceMap , function ( err ) { log ( 'sourcemap' , 'write sourcemap to ' + mapPath + ' error:' , err ) ; } ) ; } ; var isSourceMap = utilities . isSourceMap ( pathname ) ; // If it's source-map, just translate it to a .css request ( which will update the source-map either ). if ( isSourceMap ) { pathname = pathname . replace ( / \\.map$ / , '' ) ; } var cssPath = path . join ( options . dest , pathname ) ;", "del_tokens": "var cssPath = path . join ( options . dest , pathname ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "String#beforeLast", "(", "needle", ")", "and", "String#afterLast", "(", "needle", ")"], "add_tokens": "* @ return { String } The string after the needle / ** * Return the string after the last occurence of the given needle * * @ author Jelle De Loecker < jelle @ codedor . be > * @ since 0.1 .2 * @ version 0.1 .2 * * @ param { String } needle The string to look for * * @ return { String } The string after the needle * / Blast . definePrototype ( 'String' , 'afterLast' , function afterLast ( needle ) { return this . after ( needle , false ) ; } ) ; / ** * Return the string before the last occurence of the given needle * * @ author Jelle De Loecker < jelle @ codedor . be > * @ since 0.1 .2 * @ version 0.1 .2 * * @ param { String } needle The string to look for * * @ return { String } The string after the needle * / Blast . definePrototype ( 'String' , 'beforeLast' , function beforeLast ( needle ) { return this . before ( needle , false ) ; } ) ;", "del_tokens": "* @ return { String } The string without any tags", "commit_type": "add"}
{"commit_tokens": ["Add", "shared", "task", "queue", "to", "context"], "add_tokens": "if ( metrics !== undefined ) { metrics . timing ( metricPrefix + name , value ) } if ( metrics !== undefined ) { metrics . increment ( metricPrefix + name ) }", "del_tokens": "metrics . timing ( metricPrefix + name , value ) metrics . increment ( metricPrefix + name )", "commit_type": "add"}
{"commit_tokens": ["add", "example", "and", "fix", "bugs"], "add_tokens": "this . response = Object . create ( res ) ;", "del_tokens": "this . reponse = Object . create ( res ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "undefined", "options", ".", "react", "for", "wait", "&", "nsMode"], "add_tokens": "if ( ! wait && this . i18n . options && ( this . i18n . options . wait || ( this . i18n . options . react && this . i18n . options . react . wait ) ) ) wait = true ; this . nsMode = options . nsMode || ( this . i18n . options && this . i18n . options . react && this . i18n . options . react . nsMode ) || 'default' ;", "del_tokens": "if ( ! wait && this . i18n . options . wait || ( this . i18n . options . react && this . i18n . options . react . wait ) ) wait = this . i18n . options . wait || this . i18n . options . react . wait ; this . nsMode = options . nsMode || ( this . i18n . options . react && this . i18n . options . react . nsMode ) || 'default' ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "quality", "flag", "for", "jpgmin"], "add_tokens": "exports . processImageFiles = function ( tools , files , dest , quality , task , done ) { case ' < quality > ' remappedFlags = quality ? '-m' + quality : '' ; break ;", "del_tokens": "exports . processImageFiles = function ( tools , files , dest , task , done ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "dns", "server", "rinfo", "to", "each", "discovered", "service"], "add_tokens": "this . _onresponse = function ( packet , mdnsRinfo ) { var matches = buildServicesFor ( name , packet , self . _txt , mdnsRinfo ) function buildServicesFor ( name , packet , txt , mdnsRinfo ) { service . mdnsRinfo = mdnsRinfo", "del_tokens": "this . _onresponse = function ( packet ) { var matches = buildServicesFor ( name , packet , self . _txt ) function buildServicesFor ( name , packet , txt ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", ".", "pzlrrc", ".", "js"], "add_tokens": "const jsConfigPath = path . join ( process . cwd ( ) , '.pzlrrc.js' ) , jsonConfigPath = path . join ( process . cwd ( ) , '.pzlrrc' ) ; if ( fs . existsSync ( jsonConfigPath ) ) { $C . extend ( true , config , fs . readJsonSync ( jsonConfigPath ) ) ; } if ( fs . existsSync ( jsConfigPath ) ) { $C . extend ( { deep : true , withAccessors : true } , config , require ( jsConfigPath ) ) ;", "del_tokens": "configPath = path . join ( process . cwd ( ) , '.pzlrrc' ) , configExists = fs . existsSync ( configPath ) , if ( configExists ) { $C . extend ( true , config , fs . readJsonSync ( configPath ) ) ; } else { console . warn ( 'Warning: .pzlrrc doesn\\'t exist' ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "getNamespaceDeclaration", "to", "declare", "namespace", "and", "JSON", ".", "stringify", "to", "escape", "template", "names"], "add_tokens": "var helpers = require ( 'grunt-contrib-lib' ) . init ( grunt ) ; var nsInfo = helpers . getNamespaceDeclaration ( options . namespace ) ; templates . push ( nsInfo . namespace + \"[\" + JSON . stringify ( filename ) + \"] = \" + compiled + \";\" ) ; output . unshift ( nsInfo . declaration ) ;", "del_tokens": "var namespace = \"this['\" + options . namespace + \"']\" ; templates . push ( namespace + \"['\" + filename + \"'] = \" + compiled + \";\" ) ; output . unshift ( namespace + \" = \" + namespace + \" || {};\" ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "problems", "with", "tests", "running", "in", "node", "."], "add_tokens": "var root = ( typeof window !== \"undefined\" && window ) || this ;", "del_tokens": "var root = window ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "code", "match", "author", "style"], "add_tokens": "var element = CKEDITOR . dom . element . createFromHtml ( content ) ; var instance = this . getParentEditor ( ) ; instance . insertElement ( element ) ;", "del_tokens": "var element = CKEDITOR . dom . element . createFromHtml ( content ) ; var instance = this . getParentEditor ( ) ; instance . insertElement ( element ) ;", "commit_type": "make"}
{"commit_tokens": ["Change", "true", "/", "false", "result", "from", "new_mapper", "comparator", "to", "1", "/", "0"], "add_tokens": "'newMapper' : ( uid > vidhatri ) ? 1 : 0", "del_tokens": "'newMapper' : uid > vidhatri", "commit_type": "change"}
{"commit_tokens": ["Changed", "watch", "to", "use", "invoke", "local"], "add_tokens": "usage : 'Path to JSON or YAML file holding input data' , data : { usage : 'input data' , shortcut : 'd' , } , . then ( this . makePathOptionAbsolute )", "del_tokens": "usage : 'Path to JSON file holding input data' ,", "commit_type": "change"}
{"commit_tokens": ["allow", "for", "different", "annotation", "types", "in", "a", "collection"], "add_tokens": "import { drawEach , d3Callout } from './Types-d3' import { select } from 'd3-selection' type = d3Callout ; const group = drawEach ( selection . select ( 'g.annotations' ) , collection ) group . each ( function ( d ) { const annotationType = d . type || type annotationType . draw ( select ( this ) , d , editMode ) } )", "del_tokens": "type = { draw : ( ) => { } } ; type . draw && type . draw ( selection . select ( 'g.annotations' ) , collection , editMode )", "commit_type": "allow"}
{"commit_tokens": ["Implemented", "the", "sync", "delete", "method", "in", "the", "client", "APIs"], "add_tokens": "mediator . subscribe ( 'sync:' + datasetId + ':read' , function ( data ) { mediator . publish ( 'done:sync:' + datasetId + ':read:' + object . id , object ) ; mediator . subscribe ( 'sync:' + datasetId + ':delete' , function ( data ) { manager . delete ( data ) . then ( function ( deleted ) { mediator . publish ( 'done:sync:' + datasetId + ':delete:' + data . id , deleted ) ; } , function ( error ) { console . error ( error ) ; } ) } ) ;", "del_tokens": "mediator . subscribe ( 'sync:' + datasetId + ':load' , function ( data ) { mediator . publish ( 'done:sync:' + datasetId + ':load:' + object . id , object ) ;", "commit_type": "implement"}
{"commit_tokens": ["Added", "back", "the", "semantic", "validation", "for", "default", "values"], "add_tokens": "return new types . Parameter ( operation , ptr , paramDef , vHelpers . getParameterSchema ( paramDef ) ) ;", "del_tokens": "// https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#parameter-object var parameterSchemaProperties = [ 'default' , 'description' , 'enum' , 'exclusiveMaximum' , 'exclusiveMinimum' , 'format' , 'items' , 'maxItems' , 'maxLength' , 'maximum' , 'minItems' , 'minLength' , 'minimum' , 'multipleOf' , 'pattern' , 'type' , 'uniqueItems' ] ; function getParameterSchema ( parameter ) { var schema ; if ( _ . isUndefined ( parameter . schema ) ) { schema = { } ; // Build the schema from the schema-like parameter structure _ . each ( parameterSchemaProperties , function ( name ) { if ( ! _ . isUndefined ( parameter [ name ] ) ) { schema [ name ] = parameter [ name ] ; } } ) ; } else { schema = parameter . schema ; } return schema ; } return new types . Parameter ( operation , ptr , paramDef , getParameterSchema ( paramDef ) ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "functions", "to", "start", "and", "stop", "a", "runloop", "in", "the"], "add_tokens": "page_count : 0 // the number of 'pages' // status:'atv' //jstonkers.Status.ACTIVE", "del_tokens": "page_count : 0 , // the number of 'pages' status : 'atv' //jstonkers.Status.ACTIVE", "commit_type": "add"}
{"commit_tokens": ["changed", "grammar", "for", "blank", "object", "literals"], "add_tokens": "t . equal ( err , null ) ; t . equal ( err , null ) ; 'jade/parser' , 'react/vcon'", "del_tokens": "'jade/parser'", "commit_type": "change"}
{"commit_tokens": ["Added", "swipe", "-", "support", "package", "and", "implemented", "swipe", "actions"], "add_tokens": "import Swipeable from 'react-swipeable' ; < Swipeable onSwipedLeft = { this . gotoNext } onSwipedRight = { this . gotoPrev } > < img className = { classes . image } onClick = { this . handleImageClick } onLoad = { e => this . handleImageLoad ( e , currentImage ) } sizes = { sizes } src = { image . src } srcSet = { srcset } style = { { cursor : this . props . onClickShowNextImage ? 'pointer' : 'auto' , maxHeight : windowHeight } } / > < / Swipeable >", "del_tokens": "< img className = { classes . image } onClick = { this . handleImageClick } onLoad = { e => this . handleImageLoad ( e , currentImage ) } onTouchEnd = { this . handleImageClick } sizes = { sizes } src = { image . src } srcSet = { srcset } style = { { cursor : this . props . onClickShowNextImage ? 'pointer' : 'auto' , maxHeight : windowHeight } } / >", "commit_type": "add"}
{"commit_tokens": ["Add", "GET", "query", "data", "to", "the", "payload", "+", "the", "clean", "url", "without", "parameters"], "add_tokens": "* @ since 0.0 .1 * @ version 0.0 .8 * @ param { Object } req The request object * @ param { Object } res The response object * @ param { Function } next The express callback // Add the url without parameters h . cleanUrl = h . originalUrl . split ( '?' ) [ 0 ] ; // Add GET parameters h . query = req . query ; * @ since 0.0 .1 * @ version 0.0 .1 * @ param { Object } variables The variables passed along with the element", "del_tokens": "* @ since 2013.01 .20 * @ version 2013.01 .28 * @ param { object } req The request object * @ param { object } res The response object * @ param { function } next The express callback * @ since 2013.01 .20 * @ version 2013.01 .20 * @ param { object } variables The variables passed along with the element", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "multiple", "block", "issue"], "add_tokens": "this . $wrapper = this . $outer . find ( '.st-blocks' ) ; console . log ( this . $wrapper ) ;", "del_tokens": "this . $wrapper = this . $form . find ( '.st-blocks' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Move", "prevValue", "into", "block", "where", "needed"], "add_tokens": "var prevValue = this . __cachedGetters . getIn ( [ code , 'value' ] )", "del_tokens": "var prevValue = this . __cachedGetters . getIn ( [ code , 'value' ] )", "commit_type": "move"}
{"commit_tokens": ["Fixed", "TypeError", ":", "Path", "must", "be", "a", "string", ".", "Received", "undefined", "when", "gitDir", "isn", "t", "defined", "in", "the", "config", "."], "add_tokens": "const gitDir = config . gitDir ? path . resolve ( config . gitDir ) : process . cwd ( )", "del_tokens": "const gitDir = path . resolve ( config . gitDir ) || process . cwd ( )", "commit_type": "fix"}
{"commit_tokens": ["Moved", "the", "API", "key", "into", "a", "secrets", "file", "that", "s", "not", "checked", "into", "github", "."], "add_tokens": "* - reviews ( ) - Get reviews for a given user , as host or guest cheerio = require ( 'cheerio' ) , secrets = require ( './_secrets' ) ; API_KEY = secrets . API_KEY , DEFAULT_REQUEST_CONFIGS = secrets . DEFAULT_REQUEST_CONFIGS ,", "del_tokens": "* - review ( ) - Get reviews for a given user , as host or guest cheerio = require ( 'cheerio' ) ; API_KEY = 'd306zoyjsyarp7ifhu67rjxn52tv0t20' , // This was obtained by tracing back airbnb XHR, might be revoked anytime. TODO Find a more reliable key DEFAULT_REQUEST_CONFIGS = { headers : { 'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36' } } ,", "commit_type": "move"}
{"commit_tokens": ["Add", "more", "test", "conditions", "for", "multiple", "meaning", "characters"], "add_tokens": "it ( 'should look up a definition with multiple meanings with a common character' , function ( ) { it ( 'should look up a definition with multiple meanings with a more obscure character' , function ( ) { var expected = [ { traditional : '糺', simplified : '糺', pinyin : 'jiu1' , definition : 'archaic variant of 糾|纠[jiu1]' }, { traditional : '糺', simplified : '糺', pinyin : 'jiu3' , definition : 'army (used during the Liao, Jin and Yuan dynasties)' } ] ; assert . deepEqual ( hanzi . definitionLookup ( '糺'), e pected); } ) ;", "del_tokens": "it ( 'should look up a definition with multiple meanings' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["fixed", "tracking", "of", "unwanted", "events"], "add_tokens": "if ( tag !== this . _allAudienceTag ) { this . _reportEvent ( 'subscribed' , tag , { senderId , pageId } ) ; }", "del_tokens": "this . _reportEvent ( 'subscribed' , tag , { senderId , pageId } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "separate", "parsers", "library", "so", "parsers", "can", "be", "tested", "independently"], "add_tokens": "var parsers = require ( './parsers' ) , zlib = require ( 'zlib' ) , var result = this . process ( parsers . parseText ( message , kwargs ) ) ; parsers . parseError ( err , kwargs , function ( kw ) { var result = self . process ( kw ) ;", "del_tokens": "var zlib = require ( 'zlib' ) , kwargs [ 'message' ] = message ; kwargs [ 'sentry.interfaces.Message' ] = { message : message , params : [ ] } ; var result = this . process ( kwargs ) ; utils . parseStack ( err . stack , function ( e , frames ) { kwargs [ 'message' ] = err . name + ': ' + err . message ; kwargs [ 'sentry.interfaces.Exception' ] = { type : err . name , value : err . message } ; kwargs [ 'sentry.interfaces.Stacktrace' ] = { frames : frames } ; kwargs [ 'culprit' ] = err . name + ' in ' + err . stack . split ( '\\n' ) [ 1 ] . match ( / ^.*?\\((.*?):\\d+:\\d+\\)$ / ) [ 1 ] . replace ( process . cwd ( ) + '/' , '' ) ; var result = self . process ( kwargs ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "jshint", "errors", "in", "the", "Car", "fixture", "."], "add_tokens": "} ; } ; } ; return ( 'No oil change is needed at this time.' ) ; } ; return ( 'No tire rotation is needed at this time.' ) ; } ; // Create the 'private prototype'. // Add methods to the 'private prototype'. return this . getMilesSinceLastOilChange ( ) > 5000 ? true : false ; return this . getMilesSinceLastTireRotation ( ) > 5000 ? true : false ;", "del_tokens": "} } } return ( \"No oil change is needed at this time.\" ) } return ( \"No tire rotation is needed at this time.\" ) } // Create the \"private prototype\". // Add methods to the \"private prototype\". return this . getMilesSinceLastOilChange ( ) > 5000 ? true : false return this . getMilesSinceLastTireRotation ( ) > 5000 ? true : false", "commit_type": "fix"}
{"commit_tokens": ["Update", "the", "way", "environment", "variables", "/", "default", "config", "is", "loaded"], "add_tokens": "// Load default env related config const envConfig = { project : { name : process . env . AWS_PROJECT_NAME } , url : { base : process . env . BASE_URL } , aws : { stage : process . env . AWS_STAGE , region : process . env . AWS_REGION } } ; // Ignore return envConfig ; return _ . merge ( { } , defaultConfig , environmentConfig , envVarsConfig ) ;", "del_tokens": "const envConfig = { } ; return envConfig ; return { } ; // Try deriving some common config attributes from the environment const config = { project : { name : process . env . AWS_PROJECT_NAME } , url : { // Base URL is read from ENV, or overwritten by configuration file or finally a default is used base : process . env . BASE_URL || 'http://localhost' } , aws : { stage : process . env . AWS_STAGE , region : process . env . AWS_REGION } } ; return _ . merge ( config , defaultConfig , environmentConfig , envVarsConfig ) ;", "commit_type": "update"}
{"commit_tokens": ["Improved", "computed", "value", "generation", "logic", "(", "avoid", "duplicate", "calls", ")"], "add_tokens": "unsetDependencyTracker , queueCallbackAndScheduleRun queueCallbackAndScheduleRun ( setPropValue ) ; // if there is no longer a need to regenerate the value, exit. // this can happen when other logic accesses the computed getter // between scheduled updates. if ( ! needsNewValue ) { return ; } dependencyTracker . asDependent = true ; dependencyTracker . forProp = setPropValue . forProp = prop ;", "del_tokens": "unsetDependencyTracker setPropValue ( ) ; dependencyTracker . asDependent = true ; dependencyTracker . forProp = prop ;", "commit_type": "improve"}
{"commit_tokens": ["add", "support", "for", "passing", "in", "spawn", "-", "like", "options"], "add_tokens": "function runCommand ( name , args , options , cb , stdoutHandler , stderrHandler ) { options = options || { cwd : cwd , env : env } ; var child = spawn ( name , args , options ) ; var cb , stdoutHandler , stderrHandler , options ; //if the last arg is an object, it's the options object if ( typeof args [ args . length - 1 ] == 'object' ) { options = args . pop ( ) ; } return runCommand ( name , args , options , cb , stdoutHandler , stderrHandler ) ;", "del_tokens": "function runCommand ( name , args , cb , stdoutHandler , stderrHandler ) { var child = spawn ( name , args , { cwd : cwd , env : env } ) ; cwd = '.' ; var cb , stdoutHandler , stderrHandler ; runCommand ( name , args , cb , stdoutHandler , stderrHandler ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "gulp", "icon", "switch", "in", "runner", "selector"], "add_tokens": "selected_run_configuration . find ( '.type' ) . removeClass ( 'node' ) . removeClass ( 'mocha' ) . removeClass ( 'npm' ) . removeClass ( 'gulp' ) . addClass ( run_configuration . type ) ;", "del_tokens": "selected_run_configuration . find ( '.type' ) . removeClass ( 'node' ) . removeClass ( 'mocha' ) . removeClass ( 'npm' ) . addClass ( run_configuration . type ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "Validation", "of", "Role", "Based", "Authorization", "."], "add_tokens": "// user.roles is an empty array, so switching to _ctx.user.roles for ( let i = 0 ; i < _ctx . user . roles . length ; i ++ ) { userRole = _ctx . user . roles [ i ] . name ;", "del_tokens": "for ( let i = 0 ; i < user . roles . length ; i ++ ) { userRole = user . roles [ i ] . name ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "miscalculating", "contrast", "ratio", "for", "elements", "with", "background", "-", "image", "and", "not", "calculating", "contrast", "ratio", "for", "elements", "with", "overlapping", "elements", "with", "alpha", "==", "0", "."], "add_tokens": "var style = window . getComputedStyle ( element ) ; var contrastRatio = AccessibilityUtils . getContrastRatioForElementWithComputedStyle ( style , element ) ; return ( contrastRatio && AccessibilityUtils . isLowContrast ( contrastRatio , style ) ) ;", "del_tokens": "var style = window . getComputedStyle ( element ) ; var contrastRatio = AccessibilityUtils . getContrastRatioForElementWithComputedStyle ( style , element ) ; return ( contrastRatio && AccessibilityUtils . isLowContrast ( contrastRatio , style ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "coffee", "file", "for", "module"], "add_tokens": "'ui.directives.select2' ,", "del_tokens": "'ui.directives.chosen' ,", "commit_type": "remove"}
{"commit_tokens": ["Updated", "to", "work", "with", "latest", "ProjectManager", "changes"], "add_tokens": "NativeFileSystem . showOpenDialog ( false , false , \"Open File\" , ProjectManager . getProjectRoot ( ) . fullPath ,", "del_tokens": "NativeFileSystem . showOpenDialog ( false , false , \"Open File\" , ProjectManager . projectRoot . fullPath ,", "commit_type": "update"}
{"commit_tokens": ["Fix", "false", "positives", "for", "isChromeDesktop"], "add_tokens": "isChromeDesktop = ( agent . indexOf ( 'chrome' ) > - 1 && ( ( agent . indexOf ( 'windows' ) > - 1 ) || ( agent . indexOf ( 'macintosh' ) > - 1 ) || ( agent . indexOf ( 'linux' ) > - 1 ) ) && agent . indexOf ( 'mobile' ) < 0 ) , alert ( isChromeDesktop ) ;", "del_tokens": "isChromeDesktop = ( ( agent . indexOf ( 'chrome' ) > - 1 ) && ( ( agent . indexOf ( 'windows' ) > - 1 ) || ( agent . indexOf ( 'macintosh' ) > - 1 ) || ( agent . indexOf ( 'linux' ) > - 1 ) ) ) ,", "commit_type": "fix"}
{"commit_tokens": ["Allow", "param", "/", "params", "secret", "/", "secrets"], "add_tokens": "if ( options . secrets && Object . keys ( options . secrets ) . length > 0 ) params . ectx = options . secrets ; if ( options . params && Object . keys ( options . params ) . length > 0 ) params . pctx = options . params ; var method = _ . get ( methodMap , config . method , config . method ) ;", "del_tokens": "var method = _ . get ( methodMap , options . method , options . method ) ;", "commit_type": "allow"}
{"commit_tokens": ["adds", "get", "back", "to", "meyda", "-", "wa"], "add_tokens": "self . inputData = null ; self . inputData = e . inputBuffer . getChannelData ( 0 ) ; var features = self . extract ( self . _featuresToExtract , self . inputData ) ; get ( features ) { if ( self . inputData !== null ) { return self . extract ( ( features || self . _featuresToExtract ) , self . inputData ) ; } else { return null ; } }", "del_tokens": "var inputData = e . inputBuffer . getChannelData ( 0 ) ; var features = self . extract ( self . _featuresToExtract , inputData ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "check", "for", "root", "permission"], "add_tokens": "* CLI loadConfig < path > * * CLI useConfig < config > *", "del_tokens": "* @ cli loadConfig * @ cli useConfig", "commit_type": "add"}
{"commit_tokens": ["Implemented", "kb", "-", "cyclic", "+", "kb", "-", "reached", "-", "begin", "+", "kb", "-", "reached", "-", "end"], "add_tokens": "this . cyclic = false ; this . multiple = angular . isDefined ( options . attrs . multiple ) ; this . cyclic = angular . isDefined ( options . attrs . kbCyclic ) ; return angular . element ( el ) . controller ( 'kbItem' ) ; } } , / ** * Returns the first item . * @ returns { kbItemController } * / _last : function ( ) { var nodes = this . _element . querySelectorAll ( '[kb-item]' ) ; if ( nodes . length ) { return angular . element ( nodes [ nodes . length - 1 ] ) . controller ( 'kbItem' ) ;", "del_tokens": "return el . controller ( 'kbItem' ) ;", "commit_type": "implement"}
{"commit_tokens": ["Remove", "restriction", "which", "only", "returned", "WebUSB", "devices"], "add_tokens": "if ( ! watching ) return del ( [ nodeDir , typesDir ] ) ;", "del_tokens": "return del ( [ nodeDir , typesDir ] ) ;", "commit_type": "remove"}
{"commit_tokens": ["Make", "init", "optional", "in", "fetchWithRetries"], "add_tokens": "* Makes a POST request to the server with the given data as the payload . initWithRetries ? : ? InitWithRetries var { fetchTimeout , retryDelays , ... init } = initWithRetries || { } ;", "del_tokens": "* Posts a request to the server with the given data as the payload . initWithRetries : InitWithRetries var { fetchTimeout , retryDelays , ... init } = initWithRetries ;", "commit_type": "make"}
{"commit_tokens": ["fixed", "issue", "with", "blank", "data", "when", "zero", "namespaces", "provided"], "add_tokens": "if ( this . namespaces . length === 0 ) { this . namespaces = Object . keys ( docs ) ; } var namespaces = Lazy ( this . namespaces )", "del_tokens": "var namespaces = Lazy ( this . namespaces || Object . keys ( docs ) )", "commit_type": "fix"}
{"commit_tokens": ["Add", "force", "-", "ssl", "validation"], "add_tokens": "var packages = void 0 ; // Determine current release/packages from '.meteor' directory packages = _fs2 . default . readFileSync ( '.meteor/packages' , 'utf8' ) ; / * Abort the program if files are not found, this is a strong indication we may not be in the root project directory * / // Ensure project does not use 'force-ssl' package if ( packages . includes ( 'force-ssl' ) ) { throw new Error ( 'The \"force-ssl\" package is not supported. Please read the docs to configure an HTTPS redirect in your web config.' ) ; }", "del_tokens": "// Determine current Meteor release based on release file / * Abort the program if a release file is not found, this is a strong indication we are not in the root project directory * /", "commit_type": "add"}
{"commit_tokens": ["Fix", "vogue", "root", "URL", "detection", "."], "add_tokens": "io : script . rootUrl + 'socket.io/socket.io.js' var socket = io . connect ( script . rootUrl ) ; var rootUrl = src . match ( / ^https?\\:\\/\\/(.*?)\\/ / ) [ 0 ] ; rootUrl : rootUrl ,", "del_tokens": "io : script . url + 'socket.io/socket.io.js' var socket = io . connect ( \"http://\" + script . domain + \":\" + script . port ) ; var rootMatch = src . match ( / https?\\:\\/\\/(.*?)\\/ / ) ; var url = rootMatch [ 0 ] ; var domain = rootMatch [ 1 ] ; url : url , domain : domain , port : getPort ( url ) ,", "commit_type": "fix"}
{"commit_tokens": ["Allow", "clicking", "on", "inputs", "directly"], "add_tokens": "swalForm . allowClickingDirectlyOnInputs ( ) } , allowClickingDirectlyOnInputs : function ( ) { // sweet-alert attaches an onblur handler which prevents clicks on of non // button elements until click is made on the modal document . querySelector ( '.sweet-alert button.confirm' ) . onblur = function ( ) { }", "del_tokens": "// by default swal modals have tabIndex=-1 which prevents // text selection and user input on tags swalForm . makeInputsWritable ( )", "commit_type": "allow"}
{"commit_tokens": ["removed", "window", "-", "reference", "."], "add_tokens": "function Class ( params , body )", "del_tokens": "window . Class = function ( params , body )", "commit_type": "remove"}
{"commit_tokens": ["fixing", "test", "output", "for", "travis"], "add_tokens": "return Knex . Schema . table ( 'test_table_two' , function ( t ) { t . json ( 'json_data' ) . nullable ( ) ; } ) . then ( function ( ) { return Knex . Schema . table ( 'test_table_one' , function ( t ) { t . string ( 'phone' ) . nullable ( ) ; } ) ;", "del_tokens": "table . json ( 'json_data' ) . nullable ( ) ; return Knex . Schema . table ( 'test_table_one' , function ( t ) { t . string ( 'phone' ) . nullable ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "to", "abort", "connecting", "to", "Firebase", "if", "auth", "fails"], "add_tokens": "if ( this . authTokenPath || this . authToken ) { this . _authenticateWithToken ( ) ; FirebaseSync . prototype . _authenticateWithToken = function ( ) { this . firebaseRoot . authWithCustomToken ( this . authToken , function ( error , authData ) { if ( this . TRACE ) { console . log ( \"Authentication payload:\" , authData ) ; } if ( error ) { throw new Error ( \"Authentication failed: \" + error . message ) ; } console . log ( \"Authentication successful: \" , authData . auth ) ; this . _joinRoom ( ) ; } . bind ( this ) ) ; } ; FirebaseSync . prototype . _joinRoom = function ( ) {", "del_tokens": "if ( this . authTokenPath && ! this . authToken ) { this . _joinRoom ( ) ; FirebaseSync . prototype . _joinRoom = function ( ) { if ( this . authToken ) { this . firebaseRoot . authWithCustomToken ( this . authToken , function ( error , authData ) { if ( this . TRACE ) { console . log ( \"Authentication payload:\" , authData ) ; } if ( error ) { throw new Error ( \"Authentication failed: \" + error . message ) ; } console . log ( \"Authentication successful: \" , authData . auth ) ; } . bind ( this ) ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "check", "for", "Java", "bin", "being", "on", "PATH"], "add_tokens": "// Check that the PATH includes the jdk's bin directory class JavaOnPathCheck extends DoctorCheck { async diagnose ( ) { let javaHomeBin = path . resolve ( process . env . JAVA_HOME , 'bin' ) ; if ( process . env . PATH . indexOf ( javaHomeBin ) ) { return nok ( 'Bin directory of $JAVA_HOME is not set' ) ; } return ok ( 'Bin directory for $JAVA_HOME is set' ) ; } fix ( ) { return ` ${ path . sep } ` ; } } checks . push ( new JavaOnPathCheck ( ) ) ; export { EnvVarAndPathCheck , AndroidToolCheck , JavaOnPathCheck } ;", "del_tokens": "export { EnvVarAndPathCheck , AndroidToolCheck } ;", "commit_type": "add"}
{"commit_tokens": ["use", "extend", "method", "clean", "up", "deps"], "add_tokens": "template = utils . extend ( { options : { engine : '' } } , template ) ;", "del_tokens": "var merge = require ( 'mixin-deep' ) ; template = merge ( { options : { engine : '' } } , template ) ;", "commit_type": "use"}
{"commit_tokens": ["Made", "regex", "less", "specific", "so", "it", "catches", "levels", "that", "are", "not", "officially", "supported", "but", "also", "shouldn", "t", "get", "stuck", "in", "the", "dom", "if", "for", "some", "reason", "they", "get", "added", "at", "some", "point", "."], "add_tokens": ". attr ( 'class' , classes . replace ( / es-headingView-level[0-9] / , '' ) )", "del_tokens": ". attr ( 'class' , classes . replace ( / es-headingView-level[1-6] / , '' ) )", "commit_type": "make"}
{"commit_tokens": ["Fix", "encoding", "of", "string", "in", "Solidity", "tight", "data", "packing"], "add_tokens": "ret . push ( new Buffer ( utf8 . encode ( value ) ) ) ;", "del_tokens": "ret . push ( utf8 . encode ( value ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "unexpected", "behavior", "when", "dealing", "with", "nodejs", "buffer", ".", "(", "NodeJS", "buffer", "will", "use", "memory", "pool", "to", "reuse", "memory", "regions", ")"], "add_tokens": "let buff = Buffer . alloc ( buffer . length ) ; buffer . copy ( buff , 0 ) ; buffer = buff . buffer ;", "del_tokens": "buffer = buffer . buffer ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "prettyprint", "option", "and", "exclude", "gauges", "metric", "from", "cache"], "add_tokens": "this . config = config . console || { } ; var out = { counter : this . statsCache . counters , timers : this . statsCache . timers , gauges : metrics . gauges , pctThreshold : metrics . pctThreshold } ; if ( this . config . prettyprint ) { console . log ( util . inspect ( out , false , 5 , true ) ) ; } else { console . log ( out ) ; }", "del_tokens": "gauges : { } , console . log ( util . inspect ( self . statsCache , false , 5 , true ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "cocumentation", "and", "type", "info", "."], "add_tokens": "* For JQuery output , deferred functions is slight different and adapt * the deferred to jquery style . * @ define { boolean } true if target compile output is Jquery . * @ return { ! goog . async . Deferred } newly created deferred object . * @ define { boolean } if true , a default key - value text store should be created * in the abscent of configuration option . * @ define { boolean } flag to indicate to enable encryption . ydn . db . base . ENABLE_ENCRYPTION = false ;", "del_tokens": "* Target for jquery * @ define { boolean } * @ return { ! goog . async . Deferred } * @ define { boolean } * @ define { boolean } ydn . db . base . ENABLE_ENCRYPTION = false ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "empty", "bundle", "directories", "to", "avoid", "issues", "on", "rebuild"], "add_tokens": "annotation : 'Bundles Location Funnel' , allowEmpty : true", "del_tokens": "annotation : 'Bundles Location Funnel'", "commit_type": "allow"}
{"commit_tokens": ["fix", "livereload", "script", "for", "npm@3", "and", "remove", "vm"], "add_tokens": "var server = tinylr ( { livereload : require . resolve ( 'livereload-js/dist/livereload.js' ) } )", "del_tokens": "var server = tinylr ( )", "commit_type": "fix"}
{"commit_tokens": ["remove", "zoom", "background", "when", "baselayer", "has", "a", "mask"], "add_tokens": "} var baseLayer = map . getBaseLayer ( ) ; if ( ! map . options [ 'zoomBackground' ] || baseLayer . getMask ( ) ) { delete this . _canvasBg ;", "del_tokens": "} if ( param [ 'type' ] === '_baselayerload' ) { if ( ! map . options [ 'zoomBackground' ] ) { delete this . _canvasBg ; }", "commit_type": "remove"}
{"commit_tokens": ["Add", "grunt", "and", "relevant", "tasks", "for", "building", "and", "doc", "generation", "."], "add_tokens": "* @ module MapParser * @ alias module : MapParser * @ property { Array . < MPShape > } walls - The parsed walls . * @ property { Array . < MPShape > } obstacles - The parsed obstacles .", "del_tokens": "* @ module map / parse * @ property { Array . < MPShape } walls - The parsed walls . * @ property { Array . < MPShape } obstacles - The parsed obstacles .", "commit_type": "add"}
{"commit_tokens": ["using", "CommonUtil", "to", "specify", "server", "listening", "port"], "add_tokens": "var commonUtil = require ( './../common/CommonUtil.js' ) ; var server = new Server ( commonUtil . ServerPort ) ;", "del_tokens": "var server = new Server ( 8081 ) ;", "commit_type": "use"}
{"commit_tokens": ["Changed", "the", "name", "of", "the", "directive", "s", "element", "type", "from", "type", "to", "elementtype", "to", "prevent", "conflicts", ".", "markerlabel", "already", "had", "a", "type", "property", "for", "a", "different", "purpose"], "add_tokens": "plasmid . elementtype = \"plasmid\" ; plasmidTrack . elementtype = \"plasmidtrack\" ; trackScale . elementtype = \"trackscale\" ; trackLabel . elementtype = \"tracklabel\" ; marker . elementtype = \"trackmarker\" ; markerLabel . elementtype = \"markerlabel\" ;", "del_tokens": "plasmid . type = \"plasmid\" ; plasmidTrack . type = \"plasmidtrack\" ; trackScale . type = \"trackscale\" ; trackLabel . type = \"tracklabel\" ; marker . type = \"trackmarker\" ; markerLabel . type = \"markerlabel\" ;", "commit_type": "change"}
{"commit_tokens": ["Adding", "automated", "addition", "of", "version", "and", "copyright", "banner"], "add_tokens": "src : [ \"src/<%= pkg.name %>.js\" ] , dest : \"dist/<%= pkg.name %>.js\" , \"dist/<%= pkg.name %>.min.js\" : [ \"<%= browserify.build.dest %>\" ] commitMessage : 'Release v<%= version %>' , afterBump : [ 'build' ] } } , usebanner : { \"build\" : { options : { position : 'top' , banner : \"/** <%= pkg.name %> v<%= pkg.version %> - <%= grunt.template.today('yyyy-mm-dd') %>. (c) <%= grunt.template.today('yyyy') %> Miguel Castillo. Licensed under MIT */\" , linebreak : true } , files : { src : [ 'dist/**.js' ] } grunt . loadNpmTasks ( \"grunt-banner\" ) ; grunt . registerTask ( \"build\" , [ \"jshint:all\" , \"browserify:build\" , \"uglify:build\" , \"usebanner:build\" ] ) ;", "del_tokens": "files : { \"dist/bit-loader.js\" : [ \"src/bit-loader.js\" ] } , \"dist/bit-loader.min.js\" : [ \"dist/bit-loader.js\" ] commitMessage : 'Release v<%= version %>' grunt . registerTask ( \"build\" , [ \"jshint:all\" , \"browserify:build\" , \"uglify:build\" ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "tweening", "non", "-", "numeric", "properties", ".", "Ex", ".", "Tween", ".", "to", "(", "{", "alpha", ":", "0", "visible", ":", "false", "}", "1000", ")", ";"], "add_tokens": "if ( ( v0 = p0 [ n ] ) == null ) { p0 [ n ] = v0 = this . _initQueueProps [ n ] ; } if ( v0 == ( v1 = p1 [ n ] ) || ratio == 0 || ratio == 1 || ( typeof ( v0 ) != \"number\" ) ) { // no interpolation - either at start, end, values don't change, or the value is non-numeric.", "del_tokens": "if ( ( v0 = p0 [ n ] ) == ( v1 = p1 [ n ] ) || ratio == 0 || ratio == 1 ) { // no interpolation - either at start, end, or values don't change. if ( v0 == null ) { v0 = this . _initQueueProps [ n ] ; } if ( v0 == null ) { p0 [ n ] = v0 = this . _initQueueProps [ n ] ; }", "commit_type": "add"}
{"commit_tokens": ["Fix", "certain", "resources", "not", "displaying", "properly", "under", "namespaces", "."], "add_tokens": ", pagePath , page ; if ( / \\/$ / . test ( ctx . url ) ) { // if the url ends with a slash, we have a page resourceId = parts . slice ( 0 , parts . length - 1 ) . join ( '/' ) || parts [ 0 ] ; page = parts . length > 1 ? parts . slice ( - 1 ) [ 0 ] : null ; } else { // otherwise, the resource is the full url resourceId = parts . join ( '/' ) ; }", "del_tokens": ", pagePath ; resourceId = parts . slice ( 0 , parts . length - 1 ) . join ( '/' ) || parts [ 0 ] ; var page = parts . length > 1 ? parts . slice ( - 1 ) [ 0 ] : null ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "support", "for", "Rackspace", "ServiceNet"], "add_tokens": "region : this . options . region , useInternal : this . options . useSNET o1 . _log ( 'Probing for container ' + o1 . options . prefix + next ) ; o1 . _log ( 'Got ' + aContainers . length + ' containers' ) ;", "del_tokens": "region : this . options . region o1 . _log ( 'Got ' + aContainers . count + ' containers' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "build", "and", "simplify", "clientStub", "tests"], "add_tokens": "DgraphClient . prototype . alter = function ( op , options ) { return [ 4 , c . alter ( op , options ) ] ;", "del_tokens": "DgraphClient . prototype . alter = function ( op ) { return [ 4 , c . alter ( op ) ] ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "views", "in", "database"], "add_tokens": "module . exports = 33 ;", "del_tokens": "module . exports = 32 ;", "commit_type": "add"}
{"commit_tokens": ["remove", "unused", "functionality", "(", "until", "tested", ")"], "add_tokens": "return [ ] . concat . apply ( [ ] , levels )", "del_tokens": "var utils = require ( './utils' ) return utils . flatten ( levels )", "commit_type": "remove"}
{"commit_tokens": ["added", "retrieve", "per", "entity", "ids"], "add_tokens": "this . id = interaction . id ;", "del_tokens": "this . id = interaction . id !== undefined ? interaction . id : idGen . uuidv4 ( ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "mount", "function", "to", "mount", "a", "local", "path", "to", "a", "subpath", "of", "a", "running", "server"], "add_tokens": "if ( options . server && options . mount ) { //use an existing server object var _self = this ; this . setBaseUri ( \"/\" + options . mount . replace ( / ^[\\/]+ / , \"\" ) ) ; options . server . addListener ( \"request\" , function ( req , resp ) { var path = Url . parse ( req . url ) . pathname ; if ( path . indexOf ( _self . baseUri ) === 0 ) _self . exec ( req , resp ) ; } ) ; } else { this . setBaseUri ( this . guessBaseUri ( ) ) ; Http . Server . call ( this , this . exec ) ; } exports . mount = function ( path , mountpoint , server ) { return new Server ( { node : path , mount : mountpoint , server : server } ) ; } ;", "del_tokens": "this . setBaseUri ( this . guessBaseUri ( ) ) ; Http . Server . call ( this , this . exec ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "addType", "method", "to", "content"], "add_tokens": "documents : { } , addType : function ( name , config ) { this . documents [ name ] = config ; }", "del_tokens": "documents : { }", "commit_type": "add"}
{"commit_tokens": ["add", "unit", "-", "tests", "for", "commonjs", "module", "loading"], "add_tokens": "const assert = require ( 'assert' ) ;", "del_tokens": "const assert = require ( 'assert' ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "type", "specifier", "syntax", "more", "expressive"], "add_tokens": "// b: [<number>] // c: <number> var c = a . pop ( ) // d: [<string>] var d = [ ] . concat ( [ \"hi\" ] ) ; // e: [<bool>] var e = [ true , false , true ] . filter ( function ( x ) { return x ; } ) ; // f: [<string>] var f = [ ] . map ( function ( ) { return \"x\" ; } ) ; // g: <number> var g = [ ] . reduce ( function ( a , b ) { return a + b ; } , 0 ) ; // h: <number> var h = Math . cos . call ( null , 10 ) ;", "del_tokens": "// b: [<?>]", "commit_type": "make"}
{"commit_tokens": ["fixed", "rendering", "issue", "with", "url", "query"], "add_tokens": "var url = require ( 'url' ) ; View . call ( this , url . parse ( name ) . pathname , options ) ;", "del_tokens": "View . call ( this , name , options ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "admin", "user", "at", "startup"], "add_tokens": "var users = require ( '../lib/resources/users' ) ; factory ( 50 , function ( ) { users . createUser ( { username : 'admin' , password : 'admin' , imageUrl : '30.png' , email : 'amin@acme.com' , isStaff : true } , function ( ) { done ( ) } ) ; } ) ;", "del_tokens": "factory ( 50 , function ( ) { done ( ) } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "the", "bug", "in", "the", "list", "of", "comments"], "add_tokens": "_root . version = '1.1.7-rc3' ;", "del_tokens": "_root . version = '1.1.7-rc2' ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "WebVTT", "to", "have", "trailing", "spaces"], "add_tokens": "if ( lines . length > 0 && lines [ 0 ] . includes ( '-->' ) ) {", "del_tokens": "if ( lines [ 0 ] . includes ( '-->' ) ) {", "commit_type": "allow"}
{"commit_tokens": ["Add", "in", "tests", "for", "the", "Entry#run", "()", "function", "."], "add_tokens": "var args = Array . prototype . slice . call ( arguments ) , handler = this . getHandler ( args ) ; this . last = args ; this . queue . forEach ( handler ) ; return this ; } , // Get the iteration handler function. // @param {array} // @return {function} 'getHandler' : function ( args ) { return function ( element ) { element . apply ( null , args ) ; } ; module . exports = Entry ;", "del_tokens": "this . last = arguments ; var iterator = ( function ( args ) { return function ( element ) { element . apply ( null , args ) ; } ; } ( arguments ) ) ; this . queue . forEach ( iterator ) ; return Entry ; module . exports = Entry ;", "commit_type": "add"}
{"commit_tokens": ["Created", "route", "to", "get", "an", "access", "token", "."], "add_tokens": "LOGGING_CATEGORY = \"EXPRESS_SERVICE\" , api = { } ; app . configure ( function ( ) { app . use ( function ( req , res , next ) { res . setHeader ( \"Access-Control-Allow-Origin\" , \"*\" ) ; return next ( ) ; } ) ; app . use ( express . logger ( 'dev' ) ) ; app . use ( express . bodyParser ( ) ) ; app . use ( express . methodOverride ( ) ) ; } ) ; api . token = require ( './api/token' ) ( grasshopper ) ; api . users = require ( './api/users' ) ( grasshopper ) ; app . get ( '/token' , api . token . get ) ; app . get ( '/users/:id' , api . users . getById ) ; grasshopper . log . info ( LOGGING_CATEGORY , \"GRASSHOPPER SDK LOADED!!!!!!!!!!\" ) ;", "del_tokens": "LOGGING_CATEGORY = \"EXPRESS_SERVICE\" ; grasshopper . log . info ( LOGGING_CATEGORY , \"GRASSHOPPER SDK LOADED!!!!!!\" ) ;", "commit_type": "create"}
{"commit_tokens": ["changed", "the", "source", "to", "the", "original", "an", "not", "the", "uglified", "destribution"], "add_tokens": "const Store = require ( '../src/store.js' ) ; const test = require ( 'tape' ) ; var age = 33 ;", "del_tokens": "const Store = require ( '../dist/store.min.js' ) ; const test = require ( 'tape' ) ; var age = 33 ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "async", "events", "first", "release", "of", "codesearch", "and", "filesearch", "REPORT", "plugins"], "add_tokens": "if ( jsDAV . debugMode ) console . log ( \"report\" + reportName + \", \" + node . path + \", \" + require ( \"sys\" ) . inspect ( options ) ) ; _self . handler . httpResponse . writeHead ( 207 , { \"Content-Type\" : \"text/xml; charset=utf-8\" } ) ; if ( jsDAV . debugMode ) console . log ( \"search command: \" + cmd ) ; aXml . push ( '><d:response query=\"' , Util . escapeXml ( options . query , '\"' ) , '\">' ) ; aXml . push ( '<d:href>' + encodeURI ( options . uri + '</d:href>' ) ; return aXml . join ( \"\" ) + '</d:response></d:multistatus>' ;", "del_tokens": "console . log ( \"report\" + reportName + \", \" + node . path + \", \" + require ( \"sys\" ) . inspect ( options ) ) ; _self . handler . httpResponse . writeHead ( 207 , { \"Content-Type\" : \"text/html; charset=utf-8\" } ) ; console . log ( \"search command: \" + cmd ) ; aXml . push ( '>' ) ; aXml . push ( '<d:response><d:href>' + encodeURI ( options . uri + '</d:href></d:response>' ) ; return aXml . join ( \"\" ) + '</d:multistatus>' ;", "commit_type": "fix"}
{"commit_tokens": ["changed", "pixel", ".", "stop", "to", "pixel", ".", "playing", ";", "started", "work", "on", "new", "animate", "type"], "add_tokens": "this . playing = true const source = this . animations [ name ] const animation = [ ] for ( let frame of source ) { if ( Array . isArray ( frame [ 0 ] ) ) { for ( let item of frame [ 0 ] ) { animation . push ( [ item , frame [ 1 ] ] ) } } else { animation . push ( frame ) } } this . animation = animation this . playing = true this . playing = false / ** * stops any animation * / stop ( ) { this . playing = false } if ( this . playing ) this . playing = false if ( this . moving ) if ( this . moving . update ( elapsed ) ) { this . moving = null } return true this . playing = false", "del_tokens": "this . stop = false this . animation = this . animations [ name ] this . stop = false this . stop = true if ( ! this . stop ) this . stop = true if ( this . moving && this . moving . update ( elapsed ) ) this . moving = null", "commit_type": "change"}
{"commit_tokens": ["Fixed", "&", "separated", "output_area", "-", ">", "widget_area", "logic"], "add_tokens": "this . _get_widget_area_element ( output_area , true ) . append ( view . $el ) ; // Get the output area corresponding to the msg_id. // output_area is an instance of // Gets widget output area (as a JQuery element) from the // output_area (Ipython.OutputArea instance) _get_widget_area_element : function ( output_area , show ) { var widget_area = output_area . element . parent ( ) // output_wrapper . parent ( ) // cell . find ( '.widget-area' ) ; if ( show ) { widget_area . show ( ) ; } return widget_area . find ( '.widget-subarea' ) ; } ,", "del_tokens": "output_area . element . find ( '.widget-area' ) . find ( '.widget-subarea' ) . append ( view . $el ) . parent ( ) . show ( ) ; // Show the widget_area (parent of widget_subarea) // Get the cell index corresponding to the msg_id. // output_area is a JQuery DOM element handle that has widget_area // and nested widget_subarea elements.", "commit_type": "fix"}
{"commit_tokens": ["Use", "npm", "version", "of", "element", "closest", "."], "add_tokens": "src : [ 'node_modules/element-closest/closest.legacy.js' , 'src/polyfill.getMatchedCSSRules.js' , 'node_modules/raf.js/raf.js' , 'src/polyfill.object-fit.core.js' ] , 'node_modules/element-closest/closest.legacy.js' ,", "del_tokens": "src : [ 'src/polyfill.closest.legacy.js' , 'src/polyfill.getMatchedCSSRules.js' , 'node_modules/raf.js/raf.js' , 'src/polyfill.object-fit.core.js' ] , 'src/polyfill.closest.legacy.js' ,", "commit_type": "use"}
{"commit_tokens": ["allow", "queryAndRun", "to", "take", "functions", "as", "well", "as", "commands"], "add_tokens": "function onComplete ( err ) { baton . log . infof ( msg , { name : name , ip : ip } ) ; } if ( typeof cmd === 'function' ) { cmd ( hostObj , onComplete ) ; } else { curCmd = cmd . map ( function ( arg ) { return sprintf ( arg , misc . merge ( args , { ip : ip } ) ) ; } ) ; misc . taskSpawn ( baton , args , curCmd , null , onComplete ) ; } baton . log . errorf ( '${type} failed on ${failed} out of ${length} nodes' , { type : ( typeof cmd === 'function' ) ? 'function' : 'command' , length : results . rows . length", "del_tokens": "curCmd = cmd . map ( function ( arg ) { return sprintf ( arg , misc . merge ( args , { ip : ip } ) ) ; } ) ; misc . taskSpawn ( baton , args , curCmd , null , function ( err , stdout , stderr ) { baton . log . infof ( msg , { name : name , ip : ip } ) ; } ) ; baton . log . errorf ( 'command failed ${failed} times: ${cmd}' , { cmd : cmd . join ( ' ' )", "commit_type": "allow"}
{"commit_tokens": ["Use", "new", "API", "in", "CLI", "tooling"], "add_tokens": "const cliutils = require ( '../includes/cliutils.js' ) ; // copyIfDefined ensures we don't overwrite defaults for // new methods with `undefined`. var opts = { } ; cliutils . copyIfDefined ( config , 'COUCH_BUFFER_SIZE' , opts , 'bufferSize' ) ; cliutils . copyIfDefined ( config , 'COUCH_PARALLELISM' , opts , 'parallelism' ) ; cliutils . copyIfDefined ( config , 'COUCH_LOG' , opts , 'log' ) ; cliutils . copyIfDefined ( config , 'COUCH_RESUME' , opts , 'bufferesumerSize' ) ; cliutils . copyIfDefined ( config , 'COUCH_MODE' , opts , 'mode' ) ; return couchbackup . backup ( cliutils . databaseUrl ( config . COUCH_URL , config . COUCH_DATABASE ) , ws , opts , error . terminationCallback ) ;", "del_tokens": "// backup to stdout or supplied file couchbackup . backupStream ( ws , config , error . terminationCallback ) ;", "commit_type": "use"}
{"commit_tokens": ["remove", "font", "-", "awesome", ";", "add", "lodash", "client", "side"], "add_tokens": "path . join ( config . srcJsDir , 'lodash.custom.js' ) ,", "del_tokens": "// FontAwesome Directories config . faDir = path . join ( config . nodeModulesDir , 'font-awesome' ) ; config . faFontsDir = path . join ( config . faDir , 'fonts' ) ; config . faLessDir = path . join ( config . faDir , 'less' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "an", "issue", "related", "to", "the", "JS", "compile", "(", "the", "fields", "of", "the", "configuration", "object", "need", "to", "be", "accessed", "using", "the", "square", "brackets", "syntax", "+", "string", "because", "the", "object", "is", "not", "known", "at", "compile", "time", "and", "the", "jscompiler", "will", "obfuscate", "the", "name", "of", "the", "fields", ")", "."], "add_tokens": "var key = this . configuration_ [ 'key' ] ; var fv = this . parseFamiliesAndVariations ( this . configuration_ [ 'families' ] ) ;", "del_tokens": "var key = this . configuration_ . key ; var fv = this . parseFamiliesAndVariations ( this . configuration_ . families ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "svn", ":", "keywords", "to", "jQuery", "core", "."], "add_tokens": "* $Date$ * $Rev$", "del_tokens": "* $Date : $ * $Rev : $", "commit_type": "add"}
{"commit_tokens": ["making", "the", "body", "config", "a", "path", "that", "is", "fetched", "for", "each", "page", "rather", "than", "read", "during", "init"], "add_tokens": "var read = require ( \"fs\" ) . readFile ; app . get ( \"/\" , function ( req , res , next ) { body ( app . get ( \"duo body\" ) , function ( err , body ) { if ( err ) return next ( err ) ; res . send ( html ( { title : app . get ( \"duo title\" ) , body : body || null , css : app . get ( \"duo css\" ) , js : app . get ( \"duo js\" ) } ) ) ; } ) ; // simple helper for retrieving the body (if exists) function body ( file , callback ) { if ( file ) { read ( file , \"utf8\" , callback ) ; } else { callback ( ) ; } }", "del_tokens": "app . get ( \"/\" , function ( req , res ) { res . send ( html ( { title : app . get ( \"duo title\" ) , body : app . get ( \"duo body\" ) , css : app . get ( \"duo css\" ) , js : app . get ( \"duo js\" ) } ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "an", "error", "code", "for", "404s", "in", "the", "crud", "methods", "."], "add_tokens": "callback . call ( this , buildError ( \"[404] getById:\" + COLLECTION_NAME + \": '\" + id + \"' could not be found.\" ) ) ;", "del_tokens": "callback . call ( this , buildError ( \"getById:\" + COLLECTION_NAME + \": '\" + id + \"' could not be found.\" ) ) ;", "commit_type": "add"}
{"commit_tokens": ["implement", "logging", "with", "sentry", "error", "catching"], "add_tokens": ", log = require ( 'book' ) . default ( ) , JOBS //~~ Initializing CONF . log = log . use ( require ( './lib/sentry' ) ) var msg = 'Worker started. Admin UI on HTTP port ' + CONF . port_www ; CONF . log . info ( msg )", "del_tokens": ", raven , _errlog , JOBS //~~ Logging if ( CONF . sentry ) { raven = require ( 'raven' ) _errlog = new raven . Client ( CONF . sentry ) } function LOGERR ( msg ) { if ( ! _errlog ) return console . log ( 'ERROR! - ' + msg ) ; if ( ! msg instanceof Error ) msg = new Error ( msg ) ; _errlog . captureError ( msg ) } //~~ console . log ( 'Worker started. Admin UI on HTTP port ' + CONF . port_www )", "commit_type": "implement"}
{"commit_tokens": ["make", "it", "optional", "to", "serve", "amcharts", "(", "i", ".", "e", ".", "if", "app", "is", "going", "to", "use", "CDN", "instead", ")"], "add_tokens": "// publicPath: amCharts will be included at this path in the public folder // use this if you are not loading amCharts from the CDN publicPath : 'amcharts' , // imports: an array of amcharts files to be imported (bundled) in vendor files imports : [ 'amcharts.js' , 'serial.js' , 'xy.js' , 'pie.js' , 'radar.js' , 'plugins/export/export.js' , 'plugins/export/export.css' ]", "del_tokens": "imports : [ 'amcharts.js' , 'serial.js' , 'xy.js' , 'pie.js' , 'radar.js' , 'plugins/export/export.js' , 'plugins/export/export.css' ]", "commit_type": "make"}
{"commit_tokens": ["Changed", ".", "compare", "to", ".", "equal"], "add_tokens": "* @ version 1.3 .7 vec3 . equal = function ( a , b ) { return a === b || ( mat3 . equal = function ( a , b ) { return a === b || ( mat4 . equal = function ( a , b ) { return a === b || ( quat4 . equal = function ( a , b ) { return a === b || ( vec2 . equal = function ( a , b ) { return a === b || ( mat2 . equal = function ( a , b ) { return a === b || ( vec4 . equal = function ( a , b ) { return a === b || (", "del_tokens": "* @ version 1.3 .6 vec3 . compare = function ( a , b ) { return ( mat3 . compare = function ( a , b ) { return ( mat4 . compare = function ( a , b ) { return ( quat4 . compare = function ( a , b ) { return ( vec2 . compare = function ( a , b ) { return ( mat2 . compare = function ( a , b ) { return ( vec4 . compare = function ( a , b ) { return (", "commit_type": "change"}
{"commit_tokens": ["adding", "back", "the", "temp", "key", "nothing", "works", "without", "it", "requires", "more", "research"], "add_tokens": "var safeProjectName = name . replace ( / (\\.\\s|\\s\\.|\\s+|\\.+) / g , '_' ) ; replaceInFile ( destPath + \"\\\\package.appxmanifest\" , \"$guid1$\" , newProjGuid ) ; replaceInFile ( destPath + \"\\\\package.appxmanifest\" , / \\$safeprojectname\\$ / g , safeProjectName ) ; replaceInFile ( destPath + \"\\\\package.appxmanifest\" , / \\$projectname\\$ / g , name ) ; replaceInFile ( destPath + \"\\\\cordova\\\\lib\\\\deploy.js\" , \"$guid1$\" , newProjGuid ) ; delete_if_exists ( destPath + \"\\\\*.vstemplate\" ) ; Log ( \"Project created\" ) ;", "del_tokens": "//replaceInFile(srcPath + \"\\\\Properties\\\\WMAppManifest.xml\",\"$guid1$\",newProjGuid); //replaceInFile(srcPath + \"\\\\Properties\\\\WMAppManifest.xml\",/\\$safeprojectname\\$/g,name); //replaceInFile(srcPath + \"\\\\Properties\\\\WMAppManifest.xml\",/\\$projectname\\$/g,name);", "commit_type": "add"}
{"commit_tokens": ["using", "path", "module", "to", "build", "template", "path"], "add_tokens": "var join = require ( 'path' ) . join ; 'description' : response + ' ' + swagger . paths [ path ] [ operation ] . responses [ response ] . description , var templatePath = join ( './templates' , config . testmodule , operation , operation + '.handlebars' ) ; source = read ( templatePath , 'utf8' ) ; if ( arguments . length < 3 ) { } if ( lvalue !== rvalue ) {", "del_tokens": "'description' : swagger . paths [ path ] [ operation ] . responses [ response ] . description , source = read ( './templates/' + config . testmodule + '/' + operation + '/' + operation + '.handlebars' , 'utf8' ) ; if ( arguments . length < 3 ) if ( lvalue != rvalue ) {", "commit_type": "use"}
{"commit_tokens": ["Updated", ":", "AssistantSetup", "now", "part", "of", "/", "config", "partial", "new", "swagger", "documentation"], "add_tokens": "webserver . use ( '/assistant/setup' , Express . static ( './lib/assistant/setup' ) ) ;", "del_tokens": "webserver . use ( '/assistant/setup/ui' , Express . static ( './lib/assistant/setup/ui' ) ) ;", "commit_type": "update"}
{"commit_tokens": ["move", "spec", "code", "to", "lib"], "add_tokens": "var EmbarkSpec = require ( 'embark-framework' ) . test ; EmbarkSpec ( done ) ;", "del_tokens": "var Embark = require ( 'embark-framework' ) ; var ethersim = require ( 'ethersim' ) ; var web3 = require ( 'web3' ) ; var Manager = ethersim . Manager ; var Provider = ethersim . Provider ; var manager = new Manager ( ) ; web3 . setProvider ( new Provider ( manager ) ) ; Embark . init ( web3 ) ; Embark . blockchainConfig . loadConfigFile ( 'config/blockchain.yml' ) ; Embark . contractsConfig . loadConfigFile ( 'config/contracts.yml' ) ; var files = [ \"app/contracts/simple_storage.sol\" ] ; Embark . contractsConfig . init ( files , 'development' ) ; console . log ( \"initializing\" ) ; Embark . deployContracts ( 'development' , files , \"/tmp/abi.js\" , \"chains.json\" , false , function ( abi ) { console . log ( \"return abi\" ) ; console . log ( abi ) ; eval ( abi ) ; done ( ) ; } ) ;", "commit_type": "move"}
{"commit_tokens": ["Added", "admin", "column", "to", "ClientList"], "add_tokens": "this . clientTable . setHeader ( [ this . selectAll , 'ID' , 'Type' , 'Admin' , 'Stage' , 'Connection' , 'SID' ] ) ; clientObj . admin ,", "del_tokens": "this . clientTable . setHeader ( [ this . selectAll , 'ID' , 'Type' , 'Stage' , 'Connection' , 'SID' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["updated", "app", ".", "js", "to", "include", "three", "Oauth", "credentials"], "add_tokens": "var Personify = require ( 'personify' ) ; translateConfig : { watsonConfig : { service_url : \"https://gateway.watsonplatform.net/systemu/service/\" , service_username : \"12312a68-fdff-4064-9928-eb088a960815\" , service_password : \"KUwy0neR5kpV\" } , //console.log(P) P . translation ( function ( data , err ) { console . log ( data , err ) ; } ) ; // //user method is Twitter's user_timeline get request", "del_tokens": "//var Personify = require('personify'); var Personify = require ( 'translate' ) ; watsonConfig : { P . translation ( ) ; //user method is Twitter's user_timeline get request", "commit_type": "update"}
{"commit_tokens": ["move", "cli", "to", "src", "use", "bailey", ".", "js", "as", "entry", "point", "for", "cli"], "add_tokens": "#!/usr/bin/env node if ( ! module . parent ) { require ( './src/cli' ) }", "del_tokens": "if ( ! module . parent ) { main ( ) ; }", "commit_type": "move"}
{"commit_tokens": ["add", "batch", "and", "table", "reporter"], "add_tokens": "ChildBench . prototype . do = function ( iters ) {", "del_tokens": "ChildBench . prototype . run = function ( iters ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "deprecation", "message", "to", "undefined", "resave", "option"], "add_tokens": "var resaveSession = options . resave ; if ( resaveSession === undefined ) { deprecate ( 'pass resave option; default value will change' ) ; resaveSession = true ; }", "del_tokens": "// TODO: switch default to false on next major var resaveSession = options . resave === undefined ? true : options . resave ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "the", "most", "uncommon", "bug", "ever"], "add_tokens": "var win = typeof window != 'undefined' ? window : null , isUndefined , if ( node && node . length == 2 && node !== win && ! node [ 1 ] . nodeName && ( node [ 1 ] . setValue || node [ 1 ] . getValue || node [ 1 ] . on ) ) {", "del_tokens": "var isUndefined , if ( node && node . length == 2 && ! node [ 1 ] . nodeName && ( node [ 1 ] . setValue || node [ 1 ] . getValue || node [ 1 ] . on ) ) {", "commit_type": "fix"}
{"commit_tokens": ["remove", "watchers", "before", "recycle", "group"], "add_tokens": "@ version 0.4 .4 this . _watchers = [ ] ;", "del_tokens": "@ version 0.4 .3 this . _watchers = null ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "strings", "for", "numbers", "and", "numbers", "for", "strings", "support", "edit", "in", "README"], "add_tokens": "docket . title ( ` ` ) ;", "del_tokens": "docket . title ( ` ` ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "CJS", "definition", "to", "require", "vex", ".", "js", "with", "relative", "path"], "add_tokens": "module . exports = vexDialogFactory ( require ( 'jquery' ) , require ( './vex.js' ) ) ;", "del_tokens": "module . exports = vexDialogFactory ( require ( 'jquery' ) , require ( 'vex' ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Move", "tests", "to", "proper", "subpage", "test", "some", "more", "options", "."], "add_tokens": "unecessaryPythonStuff : [ 'tasks/bin/*.egg-info' , ] , src : [ 'test/fixtures/test_package' ] , src : [ 'test/fixtures/test_package' ] src : [ 'test/fixtures/test_package' ] , src : 'test/fixtures/test_package' , src : 'test/fixtures/test_package' , } , multiFile : { options : { disable : [ 'C0103' , 'C0111' , 'W0612' ] , } , src : [ 'test/fixtures/test_package' , 'test/fixtures/missing_docstring.py' ] , } , shouldFail_colorized : { options : { outputFormat : 'colorized' , } , src : 'test/fixtures/test_package' , } , shouldFail_task_override_rc : { options : { rcfile : 'test/ignore_both' , enable : 'C0103' , } , src : 'test/fixtures/test_package' , src : 'test/fixtures/test_package' , src : 'test/fixtures/test_package' , } , shouldFail_colored : { options : { outputFormat : 'colorized' , } , src : 'test/fixtures/test_package' , src : 'test/fixtures/test_package' ,", "del_tokens": "tests : [ 'tmp' ] , src : [ 'test/fixtures' ] , src : [ 'test/fixtures' ] src : [ 'test/fixtures' ] , src : 'test/fixtures' , src : 'test/fixtures/' , src : 'test/fixtures' , src : 'test/fixtures' , src : 'test/fixtures' ,", "commit_type": "move"}
{"commit_tokens": ["Fixed", "problem", "with", "tooltips", "not", "closing", "due", "to", "opacity", "removal", "without", "setting", "display"], "add_tokens": "if ( state ) { if ( $ . browser . msie && $ ( this ) . get ( 0 ) . style ) { ieStyle = $ ( this ) . get ( 0 ) . style ; ieStyle . removeAttribute ( 'filter' ) ; ieStyle . removeAttribute ( 'opacity' ) ; } } else { $ ( this ) . hide ( ) ;", "del_tokens": "if ( state && $ . browser . msie && $ ( this ) . get ( 0 ) . style ) { ieStyle = $ ( this ) . get ( 0 ) . style ; ieStyle . removeAttribute ( 'filter' ) ; ieStyle . removeAttribute ( 'opacity' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "bug", "where", "tasks", "that", "are", "cancelled", "in", "a", "Pool", "s", "queue", "causes", "following", "tasks", "to", "not", "run", "."], "add_tokens": "var originalTimeout = resolver . promise . timeout ; } ; } else { // The task taken was already complete (either rejected or resolved), so just trigger next task in the queue me . _next ( ) ;", "del_tokens": "var originalTimeout = resolver . promise . timeout }", "commit_type": "fix"}
{"commit_tokens": ["fix", "disableCache", "for", "default", "layout"], "add_tokens": "layoutTemplate = hbs . cache [ tpl ] . layoutTemplate ; if ( ! layoutTemplate ) { layoutTemplate = yield hbs . getLayoutTemplate ( ) ; } / ** * Lazy load default layout in cache . * / Hbs . prototype . getLayoutTemplate = function * ( ) { if ( this . disableCache || ! this . layoutTemplate ) { this . layoutTemplate = yield this . cacheLayout ( ) ; } return this . layoutTemplate ; }", "del_tokens": "if ( ! hbs . layoutTemplate ) { hbs . layoutTemplate = yield hbs . cacheLayout ( ) ; } layoutTemplate = hbs . cache [ tpl ] . layoutTemplate || hbs . layoutTemplate ;", "commit_type": "fix"}
{"commit_tokens": ["make", "plugin", "replace", "browser", "-", "pack", "regardless", "of", "ordering", "."], "add_tokens": "function addHooks ( ) { var streams = b . pipeline . get ( 'pack' ) var index = streams . indexOf ( b . _bpack ) streams . splice ( index , 1 , pack ( assign ( opts , { standalone : b . _options . standalone , standaloneModule : b . _options . standaloneModule } ) ) ) } addHooks ( ) b . on ( 'reset' , addHooks )", "del_tokens": "b . pipeline . get ( 'pack' ) . splice ( 0 , 1 , pack ( assign ( opts , { standalone : b . _options . standalone , standaloneModule : b . _options . standaloneModule } ) ) ) b . on ( 'reset' , function ( ) { apply ( b , opts ) } )", "commit_type": "make"}
{"commit_tokens": ["Make", "localStorage", "data", "path", ".", "localStorage", "in", "root"], "add_tokens": "const dataPath = __dirname ; return exokit . load ( url , { dataPath , } ) _bindReplWindow ( exokit ( { dataPath , } ) ) ;", "del_tokens": "return exokit . load ( url ) _bindReplWindow ( exokit ( ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Updated", "the", "README", ".", "And", "add", "more", "debug", "information", "to", "the", "details", "object", "."], "add_tokens": "this . totalRetries = 0 ; if ( this . retries ) { if ( this . retries ) { res . retries = this . retries ; res . totalRetries = this . totalRetries res . totalReconnectsFailed = this . totalReconnectsAttempted - this . totalReconnectsSuccess ; res . totalDownTime = ( res . totalReconnectsFailed * this . reconnect ) + ( this . totalRetries * this . retry_timeout ) ; this . totalRetries ++ ;", "del_tokens": "this . totalRetrys = 0 ; if ( this . retrys ) { if ( this . retrys ) { res . retrys = this . retrys ; res . totalRetrys = this . totalretrys this . totalRetrys ++ ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "example", "again", "also", "fix", "only", "delimit", "when", "recursive", "is", "false"], "add_tokens": "var Through2 = require ( 'through2' ) var s3client = new Minio ( {", "del_tokens": "var Stream = require ( 'stream' ) ; var Through2 = require ( 'through2' ) ; var s3client = new minio ( {", "commit_type": "fix"}
{"commit_tokens": ["Add", "JSDoc", "processing", "sorting", "doclets", "by", "type"], "add_tokens": "var newTree = { 'class' : [ ] , 'function' : [ ] , 'member' : [ ] , 'event' : [ ] } for ( var i in tree ) { var item = tree [ i ] ; if ( item . undocumented === true || item . access === 'private' ) continue ; var group = item . kind ; if ( newTree [ group ] ) { if ( group === 'member' && item . memberof . indexOf ( 'defaults' ) < 0 ) continue ; newTree [ group ] . push ( item ) } } return newTree ;", "del_tokens": "return tree ;", "commit_type": "add"}
{"commit_tokens": ["Add", "static", "file", "favicon", "serving"], "add_tokens": "const favicon = require ( 'koa-favicon' ) const Koa = require ( 'koa-plus' ) const path = require ( 'path' ) const serve = require ( 'koa-static' ) / ** * Public folder , favicon rendering * / if ( config . public ) { this . use ( favicon ( path . join ( config . public , 'favicon.ico' ) ) ) this . use ( serve ( config . public ) ) }", "del_tokens": "const Koa = require ( 'koa-plus' )", "commit_type": "add"}
{"commit_tokens": ["Make", "ui5", "-", "lib", "-", "util", "work", "under", "windows"], "add_tokens": "const aPathChain = path . dirname . split ( path . sep ) const sFileName = oFile . path . split ( path . sep ) . pop ( )", "del_tokens": "const aPathChain = path . dirname . split ( '/' ) const sFileName = oFile . path . split ( '/' ) . pop ( )", "commit_type": "make"}
{"commit_tokens": ["remove", "prepublish", "and", "get", "/", "set", "property", "helper"], "add_tokens": "tickFactory : function ( xScale , tickCount , xData , xScaleType ) { return ( xScaleType === 'ordinal' ) ? xData : xScale . ticks ( tickCount ) ; } , var ticks = this . tickFactory ( xScale , tickCount , xData , xScaleType ) ;", "del_tokens": "var ticks = ( xScaleType === 'ordinal' ) ? xData : xScale . ticks ( tickCount ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "return", "for", "event", "handlers"], "add_tokens": "let result if ( this . plugins [ type ] . down ( ... arguments ) ) { result = true } return result let result if ( this . plugins [ type ] . move ( ... arguments ) ) { result = true } return result let result if ( this . plugins [ type ] . up ( ... arguments ) ) { result = true } return result let result if ( this . plugins [ type ] . wheel ( ... arguments ) ) { result = true } return result", "del_tokens": "this . plugins [ type ] . down ( ... arguments ) this . plugins [ type ] . move ( ... arguments ) this . plugins [ type ] . up ( ... arguments ) this . plugins [ type ] . wheel ( ... arguments )", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "in", "asynchronous", "actions", ".", "Removing", "it", "s", "support", "completely", ".", "Was", "only", "generating", "confusions", "and", "producing", "lots", "of", "errors", "."], "add_tokens": "async . eachSeries ( this . files , function ( f , callback ) {", "del_tokens": "async . eachLimit ( this . files , options . asyncLimit , function ( f , callback ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "message", "for", "empty", "report"], "add_tokens": "} , hr . List . prototype . defaults ) , displayEmptyList : function ( ) { return $ ( \"<div>\" , { 'class' : \"visualizations-list-empty\" , 'html' : '<span class=\"octicon octicon-pulse\"></span> <p>This report is empty.</p>' } ) ; } ,", "del_tokens": "} , hr . List . prototype . defaults )", "commit_type": "add"}
{"commit_tokens": ["Fix", "tests", "for", "retry", "logic"], "add_tokens": "tape = require ( 'tape' ) , function makeTest ( fn ) { return function ( t ) { // don't allow any http requests that we don't expect nock . disableNetConnect ( ) ; t . on ( 'end' , function ( ) { nock . enableNetConnect ( ) ; } ) ; fn ( t ) ; } ; } function test ( name , fn ) { tape ( name , makeTest ( fn ) ) ; } test . only = function ( name , fn ) { tape . only ( name , makeTest ( fn ) ) ; } ;", "del_tokens": "test = require ( 'tape' ) , // don't allow any http requests that we don't expect nock . disableNetConnect ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", ":", "markdown", "headers", "not", "limited", "from", "h1", "-", "h6", "as", "they", "should", "be"], "add_tokens": ". replace ( / ^\\s*(#{1,6})\\s?([^#][^\\n]*)(\\n|$) / gm , _createHeader )", "del_tokens": ". replace ( / ^\\s*(#+)\\s?([^\\n]*)(\\n|$) / gm , _createHeader )", "commit_type": "fix"}
{"commit_tokens": ["remove", "restriction", "on", "multiple", "key", "binding"], "add_tokens": "ensureNodes ( def . node , def . definition ) function ensureNodes ( parentNode , def ) { ensureNodes ( boundNode , branch . definition ) if ( branch . definition ) ensureNodes ( boundNode , branch . definition )", "del_tokens": "ensureNodes ( def . node , def . definition , new WeakMap ( ) ) * @ param { WeakMap } seen function ensureNodes ( parentNode , def , seen ) { ensureNodes ( boundNode , branch . definition , seen ) if ( ! seen . get ( boundNode ) ) seen . set ( boundNode , true ) else throw new Error ( 'Can not bind multiple keys to the same child ' + 'DOM Node. Collision found on key \"' + key + '\".' ) if ( branch . definition ) ensureNodes ( boundNode , branch . definition , seen )", "commit_type": "remove"}
{"commit_tokens": ["Add", "capability", "for", "polygons", "to", "subdivide", "their", "edges", "."], "add_tokens": "//var with_holes_removed = partitioner.removeHoles(polys); //var parts = partitioner.convexPartition(with_holes_removed); best_poly . subdivide ( 240 ) ; var parts = partitioner . convexPartition ( best_poly ) ; var tiles = tile_grids [ \"SNESv2\" ] ; //drawOutline(shapeArrays, c2d); var parts = getNavMesh ( polys ) ;", "del_tokens": "var with_holes_removed = partitioner . removeHoles ( polys ) ; var parts = partitioner . convexPartition ( with_holes_removed ) ; var tiles = tile_grids [ \"GamePad\" ] ; drawOutline ( shapeArrays , c2d ) ; / * * /", "commit_type": "add"}
{"commit_tokens": ["Change", "debug", "package", "to", "be", "optional", "dependency"], "add_tokens": "var debugModule ; try { debugModule = require ( 'debug' ) ; } catch ( e ) { // debug module not found, ignore and use a no-op debugModule = function ( name ) { return function ( ) { } ; } ; } main : debugModule ( 'pg-spice' ) , parsed : debugModule ( 'pg-spice:parsed' ) , params : debugModule ( 'pg-spice:params' ) , sql : debugModule ( 'pg-spice:sql' ) } ;", "del_tokens": "main : require ( 'debug' ) ( 'pg-spice' ) , parsed : require ( 'debug' ) ( 'pg-spice:parsed' ) , params : require ( 'debug' ) ( 'pg-spice:params' ) , sql : require ( 'debug' ) ( 'pg-spice:sql' ) } ;", "commit_type": "change"}
{"commit_tokens": ["Update", "hello", "example", "to", "listen", "before", "ready"], "add_tokens": "spooky . on ( 'error' , function ( e , stack ) { console . error ( e ) ; if ( stack ) { console . log ( stack ) ; } } ) ; / * // Uncomment this block to see all of the things Casper has to say. // There are a lot. // He has opinions. spooky . on ( 'console' , function ( line ) { console . log ( line ) ; } ) ; * / spooky . on ( 'log' , function ( log ) { if ( log . space === 'remote' ) { console . log ( log . message . replace ( / \\- .* / , '' ) ) ; } } ) ;", "del_tokens": "spooky . on ( 'error' , function ( e ) { console . error ( e ) ; } ) ; / * // Uncomment this block to see all of the things Casper has to say. // There are a lot. // He has opinions. spooky . on ( 'console' , function ( line ) { console . log ( line ) ; } ) ; * / spooky . on ( 'log' , function ( log ) { if ( log . space === 'remote' ) { console . log ( log . message . replace ( / \\- .* / , '' ) ) ; } } ) ;", "commit_type": "update"}
{"commit_tokens": ["removed", "some", "special", "chars", "from", "states", "state", "string"], "add_tokens": "\"state\" : \"leaving China Post Group city eCommerce dept. ,next station center\"", "del_tokens": "\"state\" : \"leaving China Post Group city eCommerce dept. ，next station center\"", "commit_type": "remove"}
{"commit_tokens": ["Fix", "shadowing", "behavior", "of", "catch", "parameters", "."], "add_tokens": "var bodyPath = path . get ( \"handler\" , \"body\" ) ; var safeParam = self . makeTempVar ( ) ; self . clearPendingException ( safeParam ) ; types . traverse ( bodyPath , function ( node ) { var scope = this . scope . lookup ( handler . param . name ) ; if ( scope && scope . depth >= bodyPath . scope . depth ) { return false ; } if ( n . Identifier . check ( node ) && node . name === handler . param . name ) { this . replace ( safeParam ) ; return false ; } } ) ; self . explodeStatement ( bodyPath ) ;", "del_tokens": "// TODO This doesn't have quite the right shadowing behavior. self . clearPendingException ( handler . param ) ; self . explodeStatement ( path . get ( \"handler\" , \"body\" ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixing", "a", "typo", "on", "a", "test", "message", ".", "Thanks", "@joelwallis", "."], "add_tokens": "it ( 'should store an extension' , function ( done ) {", "del_tokens": "it ( 'should store a extension' , function ( done ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "keen", "-", "js", "legacy", "methods", "examples"], "add_tokens": "var extend = require ( './utils/extend' ) ; // DEPRECATED 'addEvent' : addEvent , 'addEvents' : addEvents data = { } ; // ------------------------------ // DEPRECATED // Apply client.globalProperties // ------------------------------ if ( this . config . globalProperties ) { data = this . config . globalProperties ( eventCollection ) ; } extend ( data , eventBody ) ; // ------------------------------ // DEPRECATED // Apply client.globalProperties // ------------------------------ if ( this . config . globalProperties ) { // Loop over each set of events each ( eventsHash , function ( events , collection ) { // Loop over each individual event each ( events , function ( body , index ) { // Start with global properties for this collection var modified = self . config . globalProperties ( collection ) ; // Apply provided properties for this event body eventsHash [ collection ] [ index ] = extend ( modified , body ) ; } ) ; } ) ; } // ---------------------- // DEPRECATED // ---------------------- function addEvent ( ) { this . emit ( 'error' , 'This method has been deprecated. Check out #recordEvent: https://github.com/keen/keen-tracking.js#record-a-single-event' ) ; recordEvent . apply ( this , arguments ) ; } function addEvents ( ) { this . emit ( 'error' , 'This method has been deprecated. Check out #recordEvents: https://github.com/keen/keen-tracking.js#record-multiple-events' ) ; recordEvents . apply ( this , arguments ) ; }", "del_tokens": "// Backward-compatible with keen-js 'addEvent' : recordEvent , 'addEvents' : recordEvents data = eventBody || { } ;", "commit_type": "add"}
{"commit_tokens": ["fix", "https", ":", "//", "github", ".", "com", "/", "linkeddata", "/", "solid", "-", "app", "-", "set", "/", "issues", "/", "4"], "add_tokens": "var YAHOO = require ( './dragDrop.js' )", "del_tokens": "var YAHOO = require ( './dragdrop.js' )", "commit_type": "fix"}
{"commit_tokens": ["Created", "the", "webpart", "item", "form", "structure", "."], "add_tokens": "var Fields = require ( \"./fields\" ) ; exports . Fields = Fields ; //import * as WebParts from \"./webparts\";", "del_tokens": "var Fields = require ( \"./fields\" ) ; exports . Fields = Fields ;", "commit_type": "create"}
{"commit_tokens": ["add", "context", "to", "timer", "loop", "without", "which", "config", ".", "reload", "is", "not", "updating", "the", "shared", "object"], "add_tokens": "timeLoop . logic ( config . reload , this ) ;", "del_tokens": "timeLoop . logic ( config . reload ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "HTTPS", "requests"], "add_tokens": "var https = require ( 'https' ) ; this . httpService = options . https ? https : http ; var req = self . httpService . get ( requestOptions , function ( response ) {", "del_tokens": "var req = http . get ( requestOptions , function ( response ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "browser", "-", "based", "closure", "generator"], "add_tokens": ". pipe ( replace ( / ^(.*\\n)*var SFTP;\\n / g , '//\\r\\n//\\r\\n//\\r\\n//\\r\\n//\\r\\n\\r\\nvar SFTP;\\r\\n' ) )", "del_tokens": ". pipe ( replace ( / ^.*\\n.*\\n.*\\n.*\\n.*\\n.*\\nvar SFTP;\\n / g , '//\\r\\n//\\r\\n//\\r\\n//\\r\\n//\\r\\n\\r\\nvar SFTP;\\r\\n' ) ) . pipe ( replace ( / \\n};.*\\n.*\\n.*\\n.*\\n.*\\n.*\\nvar SFTP;\\n / g , '//\\r\\n//\\r\\n//\\r\\n//\\r\\n//\\r\\n\\r\\nvar SFTP;\\r\\n' ) )", "commit_type": "fix"}
{"commit_tokens": ["Add", "types", "reference", "to", "the", "chrome", "object"], "add_tokens": "function addType ( domainName , type ) { var self = this ; Chrome . prototype [ domainName ] [ type . id ] = type ; } // add commands // add events // add types var types = domain . types ; if ( types ) { for ( var typeIdx in types ) { var type = types [ typeIdx ] ; addType . call ( self , domainName , type ) ; } }", "del_tokens": "// TODO make dry", "commit_type": "add"}
{"commit_tokens": ["Fix", "wrong", "behavior", "when", "index", "file", "matches", "directory"], "add_tokens": "if ( ++ i >= self . _index . length ) { return self . error ( 404 ) ;", "del_tokens": "if ( i ++ >= self . _index . length ) { return self . redirect ( self . path ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "don", "t", "done", "with", "error", "on", "EACCES", "/", "Fix", "try", "to", "read", "socket"], "add_tokens": "var fs = require ( 'fs' ) , if ( err ) if ( err . code === 'EACCES' ) return done ( ) ; return done ( err ) ; } } else if ( stat && stat . isFile ( ) ) { if ( err ) { if ( err . code === 'EACCES' ) return next ( ) ; return done ( err ) ; } else { next ( ) ; } module . exports = readFiles ;", "del_tokens": "r f = r quire(' f s'), if ( err ) return done ( err ) ; } else { if ( err ) return done ( err ) ; module . exports = readFiles ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "the", "on", "(", "blocked", ")", "event", "."], "add_tokens": "// Multiply dbVersion with 10 will be needed to workaround upgrading bug in IE: // IE fails when deleting objectStore after reading from it. // A future version of Dexie.js will stopover an intermediate version to workaround this. // At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number. var req = indexedDB . open ( dbName , dbVersion * 10 ) ; req . onblocked = database . on ( \"blocked\" ) . fire ; this . on = events ( this , [ \"ready\" , \"error\" ] , \"populate\" , \"blocked\" ) ;", "del_tokens": "var req = indexedDB . open ( dbName , dbVersion * 10 ) ; // Multiply with 10 will be needed to workaround various bugs in different implementations of indexedDB. this . on = events ( this , \"populate\" , [ \"ready\" , \"error\" ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "some", "CSS", "things", "."], "add_tokens": "loader : extractCSS . extract ( 'style' , 'style-loader?sourceMap!css-loader?sourceMap!resolve-url?fail!sass?sourceMap' ) , loader : extractCSS . extract ( 'style' , 'style-loader?sourceMap!css-loader?sourceMap!stylus?sourceMap' ) , } , { test : / \\.css / , loader : extractCSS . extract ( 'style' , 'style-loader?sourceMap!css-loader?sourceMap' ) , extensions : [ '' , '.js' , '.es6' , '.jsx' , '.scss' , '.styl' , '.css' ] , 'bootstrap' : 'bootstrap/dist/js/bootstrap.js' ,", "del_tokens": "var extractStylus = new ExtractTextPlugin ( 'css/extra.css' , { disable : isDebug } ) ; extractStylus , loader : extractCSS . extract ( 'style' , 'style-loader?sourceMap!css-loader?sourceMap!resolve-url?fail!sass?sourceMap' ) loader : extractStylus . extract ( 'style' , 'style-loader?sourceMap!css-loader?sourceMap!stylus?sourceMap' ) extensions : [ '' , '.js' , '.es6' , '.jsx' , '.scss' , '.styl' ] , // 'bootstrap': 'bootstrap/dist/js/bootstrap.js',", "commit_type": "fix"}
{"commit_tokens": ["Move", "tests", "to", "top", "directory", "."], "add_tokens": "/* eslint-env mocha, node */ var jsx = require ( './jsx' ) ; var ternDir = path . resolve ( __dirname , 'node_modules/tern' ) ;", "del_tokens": "var jsx = require ( '../jsx' ) ; var ternDir = path . resolve ( __dirname , '../node_modules/tern' ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", "\\", "pm", "\\", "div"], "add_tokens": "\"*\" : \"\\u2217\" , \"-\" : \"\\u2212\" , \"cdot\" : \"\\u22C5\" , \"lvert\" : \" | \" \"rvert\" : \" | \" \"pm\" : \"\\u00b1\" , \"div\" : \"\\u00f7\"", "del_tokens": "'*' : '\\u2217' , '-' : '\\u2212' , 'cdot' : '\\u22C5' , 'lvert' : ' | ' 'rvert' : '|'", "commit_type": "add"}
{"commit_tokens": ["make", "doCreate", "return", "data", "in", "correct", "format"], "add_tokens": "mongo . collection ( dataset_id ) . insertOne ( data , function ( err , res ) { if ( err ) { return cb ( err ) ; } cb ( null , makeResponse ( res . ops [ 0 ] ) ) ; } ) ; function makeResponse ( res ) { var uid = res . _id ; var data = { uid : res . _id , data : res } ; delete res . _id ; return data ; }", "del_tokens": "mongo . collection ( dataset_id ) . insertOne ( data , cb ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "comments", "to", "all", "sensor", "-", "data", "sensor", "-", "hub", "and", "sensor", "formats"], "add_tokens": "{ _id : '902j3kfljwf0932' , _rev : '1-kdfj029ifj2kl3' , _meta : { _metaid : 'f2h0829i322' , _rev : '1-kdfj9028ijf3' } , _type : 'application/vnd.oada.sensor-hubs.1+json' , // The keys under serial-numbers are, obviously, serial numbers of // hubs that are associated with this sensor-hubs document. A list // of sensor hubs could be all hubs for an integration partner, or // just hubs for a particular client of the integration partner. serial - numbers : { 'df874j3' : { _id : '8f2ofj2308f2i' , _rev : '1-dmfj290fj2klf' } , '02kjf20' : { _id : 'mxmxh92f8hsdf' , _rev : '1-dmfj290fj2klf' } , } , }", "del_tokens": "module . exports = { 'serial-numbers' : { 'df874j3' : { _id : '8f2ofj2308f2i' , _rev : '1-dmfj290fj2klf' } , '02kjf20' : { _id : 'mxmxh92f8hsdf' , _rev : '1-dmfj290fj2klf' } } } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "issue", "when", "timeout", "=", "0"], "add_tokens": "var cbTimeout = 0 ; if ( timeout === objectType_undefined || timeout === null ) { cbTimeout = pbjs . bidderTimeout ; } else { cbTimeout = timeout ; }", "del_tokens": "var cbTimeout = timeout || pbjs . bidderTimeout ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "line", "teleport", "basic", "example"], "add_tokens": "hitCylinderHeight : { default : 0.3 } , cylinder . setAttribute ( 'position' , { x : 0 , y : this . data . hitCylinderHeight / 2 , z : 0 } ) ;", "del_tokens": "hitCylinderHeight : { default : 0.5 } , cylinder . setAttribute ( 'position' , { x : 0 , y : 0.125 , z : 0 } ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "arrays", "to", "pattern", "."], "add_tokens": ", unpacked : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1 , unpacked : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1 , unpacked : false , repeat : 1 , unpacked : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1 , unpacked : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1 , unpacked : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1 , unpacked : true , arrayed : false , repeat : 1", "del_tokens": ", arrayed : true , arrayed : true , arrayed : true , arrayed : true , arrayed : true , arrayed : true , arrayed : true , arrayed : true", "commit_type": "add"}
{"commit_tokens": ["Add", "an", "implementation", "of", "ImmutableArray", "that", "makes", "the", "tests", "pass", "."], "add_tokens": "function addMethodTo ( target , methodName , implementation ) { Object . defineProperty ( target , methodName , { enumerable : false , configurable : false , writable : false , value : implementation } ) ; } var privateArrayMethods = [ \"push\" , \"sort\" , \"splice\" , \"shift\" , \"unshift\" , \"reverse\" ] ; var result = [ ] ; // Fill the array while it still supports push(). result . push . apply ( result , arguments ) ; // Make all mutating methods throw exceptions. for ( var index in privateArrayMethods ) { ( function ( methodName ) { addMethodTo ( result , methodName , function ( ) { throw new ImmutableError ( \"The \" + methodName + \" method cannot be invoked on an ImmutableArray.\" ) ; } ) ; } ) ( privateArrayMethods [ index ] ) ; } // Freeze it and return it. Object . freeze ( result ) ; return result ;", "del_tokens": "// TODO: make it immutable return Array . prototype . slice . call ( arguments ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "replay", "race", "condition", "when", "deleting", "multiple", "times"], "add_tokens": "if ( vm . actionOnCommit === 'delete' && ! this . replayingVmsToDelete [ vm . id ] ) { var replVms = _ . map ( this . replayingVms , function ( vm ) { // return vm.toJSON(); // We just read, so this is ok and faster! return vm . attributes ; } ) ; function commit ( vm , callback ) { self . repository . commit ( vm , function ( err ) { if ( err ) { debug ( err ) ; debug ( vm ) ; } callback ( err ) ; } ) ; } async . series ( [ function ( callback ) { async . each ( replVmsToDelete , commit , callback ) ; } , function ( callback ) { async . each ( replVms , commit , callback ) ; } ] , function ( err ) {", "del_tokens": "if ( vm . actionOnCommit === 'delete' ) { var replVms = _ . map ( this . replayingVms , function ( vm ) { // return vm.toJSON(); // We just read, so this is ok and faster! return vm . attributes ; } ) ; async . each ( replVmsToDelete . concat ( replVms ) , function ( vm , callback ) { self . repository . commit ( vm , callback ) ; } , function ( err ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "cookies", "option", "with", "example", "in", "README"], "add_tokens": "bodyAttr : options . bodyAttr , cookies : options . cookies", "del_tokens": "bodyAttr : options . bodyAttr", "commit_type": "add"}
{"commit_tokens": ["change", "multistatus", "to", "writestatus", "and", "add", "helpers"], "add_tokens": "var WriteStatus = require ( './models/write_status' ) ; // @param {function(err, multiStatus)} callback Returns a WriteStatus with the results of the write return { error : null , payload : new WriteStatus } ; return { error : null , payload : new WriteStatus ( JSON . parse ( result . body ) ) } ;", "del_tokens": "var MultiStatus = require ( './models/multi_status' ) ; // @param {function(err, multiStatus)} callback Returns a MultiStatus with the results of the write return { error : null , payload : new MultiStatus } ; return { error : null , payload : new MultiStatus ( JSON . parse ( result . body ) ) } ;", "commit_type": "change"}
{"commit_tokens": ["updates", "for", "calculating", "destination", "files"], "add_tokens": "// some of the following code for figuring out // the destination files has been taken/inspired // by the grunt-contrib-copy project //https://github.com/gruntjs/grunt-contrib-copy var isExpandedPair = filePair . orig . expand || false ; var destFile ; if ( detectDestType ( filePair . dest ) === 'directory' ) { destFile = ( isExpandedPair ) ? filePair . dest : path . join ( filePair . dest , ( options . flatten ? path . basename ( srcFile ) : srcFile ) ) ; } else { destFile = filePair . dest ; } grunt . verbose . writeln ( 'Reading ' + filename . magenta ) ; // TODO: this needs to be looked at again after the // other dest changes path . resolve ( destFile ) ,", "del_tokens": "var dest = path . normalize ( filePair . dest ) ; grunt . verbose . writeln ( 'Reading ' + filename . magenta ) ; relative = path . dirname ( srcFile ) ; relative = _ ( relative ) . strRight ( basePath ) . trim ( path . sep ) ; relative = relative . replace ( / \\.\\.(\\/|\\\\) / g , '' ) ; destFile = path . join ( dest , relative , filename + options . ext ) ; path . resolve ( path . join ( dest , relative ) ) ,", "commit_type": "update"}
{"commit_tokens": ["Update", "default", "line", "height", "unit", "in", "font", "test"], "add_tokens": "line - height : 2 em ;", "del_tokens": "line - height : 2 ;", "commit_type": "update"}
{"commit_tokens": ["Add", "fin", "and", "rsv", "decoding"], "add_tokens": "data . fin = ! ! ( 128 & raw [ 0 ] ) ; data . rsv = [ ! ! ( 64 & raw [ 0 ] ) , ! ! ( 32 & raw [ 0 ] ) , ! ! ( 16 & raw [ 0 ] ) ] ;", "del_tokens": "// TODO: decode", "commit_type": "add"}
{"commit_tokens": ["Use", "Promise", "polyfill", "in", "old", "versions", "of", "node", "."], "add_tokens": "if ( ! global . Promise ) { global . Promise = require ( 'es6-promise' ) . Promise ; } if ( ! window . Promise ) { window . Promise = require ( 'es6-promise' ) . Promise ; }", "del_tokens": "window . Promise = require ( 'es6-promise' ) . Promise ;", "commit_type": "use"}
{"commit_tokens": ["Use", "the", "function", "to", "get", "the", "superclass", "pointer", "."], "add_tokens": "var superclassPointer = this . _getSuperclassPointer ( )", "del_tokens": "var superclassPointer = core . class_getSuperclass ( this . pointer )", "commit_type": "use"}
{"commit_tokens": ["Added", "callbacks", "behavioral", "settings", "and", "updated", "the", "readme", "."], "add_tokens": "marker : marker , maxWidth : '200px' , maxHeight : '200px' window . info = infowindow ;", "del_tokens": "//content: 'Cookies', position : 'top' , // top | left | bottom | right, infowindow . attach ( marker ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "typo", "in", "lodash", ".", "isArray"], "add_tokens": "var isArray = require ( 'lodash.isarray' ) ;", "del_tokens": "var isArray = require ( 'lodash.isArray' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "tests", "some", "more", "..."], "add_tokens": "console . log ( 'Finished benchmarking: ' + bench ) ;", "del_tokens": "console . log ( 'Finished benchmarking: ' + bench , bench . error ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "init", "speed", "if", "the", "user", "change", "speed", "BEFORE", "hitting", "Play"], "add_tokens": "_initPlayer : function ( ) { this . _player = new L . TimeDimension . Player ( this . options . playerOptions , this . _timeDimension ) ; //Update TransitionTime with the one setted on the slider if ( this . _sliderSpeed ) { this . _sliderSpeedValueChanged ( this . _sliderSpeed . slider ( \"value\" ) ) ; } } , this . _initPlayer ( ) ;", "del_tokens": "this . _player = new L . TimeDimension . Player ( this . options . playerOptions , this . _timeDimension ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "locale", "to", "describe", "data"], "add_tokens": "locale : null , plugin . locale = data . locale ; locale : plugin . options . locale , format : plugin . options . strings . DT_DATE_TIME_FORMAT locale : plugin . options . locale , format : plugin . options . strings . DT_DATE_TIME_FORMAT locale : plugin . options . locale ,", "del_tokens": "format : plugin . options . strings . DT_DATE_TIME_FORMAT format : plugin . options . strings . DT_DATE_TIME_FORMAT", "commit_type": "add"}
{"commit_tokens": ["add", "test", "for", "record", "creation", "and", "lookup"], "add_tokens": "test . only ( 'create: id generation and lookup' , run ( ( t , adapter ) => { let id return adapter . create ( type , [ { name : 'joe' } ] ) . then ( records => { id = records [ 0 ] . id t . ok ( testIds ( records ) , 'id type is correct' ) stderr . warn . call ( t , id ) return adapter . find ( type , [ id ] ) } ) . then ( records => { t . equal ( records . length , 1 , 'match length is correct' ) t . equal ( records [ 0 ] . id , id , 'id is matching' ) t . ok ( testIds ( records ) , 'id type is correct' ) } ) } ) ) . then ( ( ) => adapter . disconnect ( ) )", "del_tokens": ". then ( number => { t . equal ( number , records . length , 'number deleted is correct' ) return adapter . disconnect ( ) } )", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "enums", "array", "update", "the", "is", "Map", "backing"], "add_tokens": "* @ return { mixed } typically a String but any valid type supplied * @ param { Map } map the map containing the key < - > value and } , set ( obj , key , value ) { if ( isFinite ( key ) && value instanceof _symbol2 . default ) { map . set ( value . name , value ) ; map . set ( value . value , value ) ; } // Some accessor on the receiving array obj [ key ] = value ; // Arrays return length when pushing. Assume value as return // otherwise. ¯\\_(ツ)_/¯ return isFinite ( key ) ? obj . length : obj [ key ] ;", "del_tokens": "* @ return { [ type ] } [ description ] * @ param { Map < mixed , Symbol } map the map containing the key < - > value and", "commit_type": "make"}
{"commit_tokens": ["Removing", "my", "ugly", "comments", "in", "the", "JS"], "add_tokens": "var relativeY = ( e . pageY - pos . top ) ; var relativeX = ( e . pageX - pos . left ) ; relativeY = ( e . touches [ 0 ] . pageY - pos . top ) ; relativeX = ( e . touches [ 0 ] . pageX - pos . left ) ;", "del_tokens": "var relativeY = ( e . pageY - pos . top ) ; //- 45 var relativeX = ( e . pageX - pos . left ) ; //- 45 relativeY = ( e . touches [ 0 ] . pageY - pos . top ) ; //- 45 relativeX = ( e . touches [ 0 ] . pageX - pos . left ) ; //- 45", "commit_type": "remove"}
{"commit_tokens": ["fix", "core", "migrate", "to", "cck", ".", "mongo", ".", "core"], "add_tokens": "newObj [ key ] = patchObject ( newObj [ key ] , patcher [ key ] ) function showStartTime ( processName , chainDescription ) { if ( chainDescription != '' ) { console . warn ( '[INFO] ' + String ( chainDescription ) ) } console . warn ( '[INFO] PROCESS : ' + processName ) function execute ( chainConfigs , argv , presets , executeCallback , chainDescription ) { startTime = showStartTime ( jsScript , chainDescription ) startTime = showStartTime ( cmdCommand , chainDescription ) let chainDescription = '' chainDescription = 'FILE : ' + chain chainDescription = 'CHAIN : ' + chain console . warn ( String ( chainString ) ) execute ( chainConfigs , argv , presets , alteredCallback , chainDescription )", "del_tokens": "newObj [ key ] = patchnewObject ( newObj [ key ] , patcher [ key ] ) function showStartTime ( processName ) { console . warn ( '[INFO] PROCESS : ' + processName ) function execute ( chainConfigs , argv , presets , executeCallback ) { startTime = showStartTime ( jsScript ) startTime = showStartTime ( cmdCommand ) console . warn ( chainString ) execute ( chainConfigs , argv , presets , alteredCallback )", "commit_type": "fix"}
{"commit_tokens": ["Add", "further", "functions", "to", "library"], "add_tokens": "function convertToChartData ( sessions ) { function createOutcomeChart ( div , title , data ) { var chartConfig = createConfig ( data , title ) ; return new Chart ( document . getElementById ( div ) , chartConfig ) ; } function createConfig ( data , title ) { return { type : 'radar' , data : convertToChartData ( data ) , options : { legend : { position : 'top' , } , title : { display : true , text : title } , scale : { ticks : { beginAtZero : true } } , tooltips : { enabled : true , callbacks : { label : function ( tooltipItem , data ) { var datasetLabel = data . datasets [ tooltipItem . datasetIndex ] . label || '' ; //This will be the tooltip.body return datasetLabel + ': ' + tooltipItem . yLabel + ': ' + data . datasets [ tooltipItem . datasetIndex ] . notes [ tooltipItem . index ] ; } } } } } ; }", "del_tokens": "function convertToChart ( sessions ) {", "commit_type": "add"}
{"commit_tokens": ["Improve", "messages", "and", "add", "tests"], "add_tokens": "me . actual = me . value = value ; me . actual = me . value = values . pop ( ) ; me . actual = A . print ( me . actual ) ; this . actual = this . value = Util . copy ( { } , value ) ;", "del_tokens": "me . value = value ; me . value = values . pop ( ) ; me . actual = A . print ( me . value ) ; this . value = Util . copy ( { } , value ) ;", "commit_type": "improve"}
{"commit_tokens": ["fixed", "parsing", "errors", "for", "riot", "compiler"], "add_tokens": "fucss . harvestClassesFromRiot = function ( riot , opts ) { riot = riot . replace ( / [⁗]/g , ' '); if ( opts . escape ) riot = riot . replace ( / (\\r\\n|\\n|\\r) / gm , '' ) . replace ( / (\\s+) / g , ' ' ) ; //.replace(/data:image(.*)?==/g, ''); var patternMain = ( / class[a-zA-Z]*=\"(.*?)\"|class[a-zA-Z]*[=> ({a-zA-Z,})]*{(.*?)} / gi ) ;", "del_tokens": "fucss . harvestClassesFromRiot = function ( riot ) { // var patternMain = (/class[a-z]*=\"(.*?)\"/gi); riot = riot . replace ( / (\\r\\n|\\n|\\r) / gm , '' ) . replace ( / (\\s+) / g , ' ' ) . replace ( / [⁗]/g , ' '); / .replace(/data:image(.*)?==/g, ''); var patternMain = ( / class[a-z]*=\"(.*?)\"|class[a-zA-Z]*[=> ({a-zA-Z,})]*{(.*?)} / gi ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "more", "testing", "demo", "data", "."], "add_tokens": "[ \"^/topical/i\" , \"Topical\" ] ,", "del_tokens": "[ \"^/(topical)\" , \"Topical\" ] ,", "commit_type": "add"}
{"commit_tokens": ["Fixed", "another", "instance", "of", "ChangeDB"], "add_tokens": "setup : function ( app ) { var self = this ; var collection = self . db . collection ( coll . name ) ;", "del_tokens": "setup : function ( app , path ) { var changeDB = db . db ( dbName ) ; var collection = changeDB . collection ( coll . name ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "small", "simulation", "using", "pubfood", "and", "make", "namespace", "room", "for", "a", "simulated", "auction", "provider"], "add_tokens": "// var self = this; // var getFramework = function() { // return self.PROVIDER_GLOBAL || (self.PROVIDER_GLOBAL = {}); // }; // var setIfNotAlreadySet = function(name, defaultValue) { // var framework = getFramework(); // framework.hasOwnProperty(name) || (framework[name] = e); // }; var initURL = '/simulated-bid-provider/PROVIDER_GLOBAL/refresh?' + queryParams ;", "del_tokens": "var initURL = '/simulated-provider/PROVIDER_GLOBAL/refresh?' + queryParams ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "lib", "/", "partition", ":", "Added", ".", "isEmpty", "()"], "add_tokens": "if ( ! part . isEmpty ( ) ) { // NOTE: headerCRC must be zeroed prior to it's calculation, // so do not `header.writeUInt32LE( this.headerCRC, 16 )`", "del_tokens": "if ( part . type . toString ( ) !== '00000000-0000-0000-0000-000000000000' ) { // NOTE: headerCRC must be zeroed prior to it's calculation // header.writeUInt32LE( this.headerCRC, 16 )", "commit_type": "update"}
{"commit_tokens": ["Add", "the", "track", "s", "position", "in", "the", "queue", "to", "the", "data", "returned", "from", "currentTrack", "()"], "add_tokens": "var queuePosition = parseInt ( data [ 0 ] . Track [ 0 ] ) track . queuePosition = queuePosition var track = { position : position , duration : duration , queuePosition : queuePosition }", "del_tokens": "var track = { position : position , duration : duration }", "commit_type": "add"}
{"commit_tokens": ["Allow", "tabs", "for", "line", "continuations", "in", "data", "being", "parsed"], "add_tokens": "while ( j + 1 < data . length && ( data [ j + 1 ] [ 0 ] === ' ' || data [ j + 1 ] [ 0 ] === '\\t' ) )", "del_tokens": "while ( j + 1 < data . length && data [ j + 1 ] [ 0 ] == ' ' )", "commit_type": "allow"}
{"commit_tokens": ["Use", "helper", ".", "extend", "to", "add", "methods"], "add_tokens": "ret [ type ] = helper . extend ( ret [ type ] , ext ) ;", "del_tokens": "for ( let name in ext ) { let descriptor = Object . getOwnPropertyDescriptor ( ext , name ) ; if ( descriptor . value ) { ret [ type ] [ name ] = descriptor . value ; } if ( descriptor . get ) { ret [ type ] . __defineGetter__ ( name , descriptor . get ) ; } if ( descriptor . set ) { ret [ type ] . __defineSetter__ ( name , descriptor . set ) ; } }", "commit_type": "use"}
{"commit_tokens": ["Fix", "Variable", "undefined", "in", "strict", "mode"], "add_tokens": "for ( var k in obj ) { result [ k ] = obj [ k ] ; } for ( var k in obj ) { result [ k ] = obj [ k ] ; }", "del_tokens": "for ( k in obj ) { result [ k ] = obj [ k ] ; } for ( k in obj ) { result [ k ] = obj [ k ] ; }", "commit_type": "fix"}
{"commit_tokens": ["added", "web", "port", "and", "debug", "port", "defaults", "to", "config", ".", "json"], "add_tokens": "var defaults = { webPort : config . webPort } , wsServer = WebSocket . createServer ( { server : httpServer } ) , debugPort = config . debugPort . toString ( ) ; var port = parseInt ( ( / \\?port=(\\d+) / . exec ( conn . _req . url ) || [ null , debugPort ] ) [ 1 ] , 10 ) ,", "del_tokens": "var defaults = { webPort : 8080 } , wsServer = WebSocket . createServer ( { server : httpServer } ) ; var port = parseInt ( ( / \\?port=(\\d+) / . exec ( conn . _req . url ) || [ null , '5858' ] ) [ 1 ] , 10 ) ,", "commit_type": "add"}
{"commit_tokens": ["improve", "CallExpression", "to", "remove", "line", "breaks", "between", "arguments"], "add_tokens": "var next = _tk . findNextNonEmpty ( arg . endToken ) ; if ( next . value === ',' ) { _tk . removeWsBrInBetween ( arg . endToken , _tk . findNextNonEmpty ( next ) ) ; _ws . aroundIfNeeded ( next , 'ArgumentComma' ) ; } else { _tk . removeWsBrInBetween ( arg . endToken , next ) ;", "del_tokens": "if ( arg . endToken . next . value === ',' ) { _ws . aroundIfNeeded ( arg . endToken . next , 'ArgumentComma' ) ;", "commit_type": "improve"}
{"commit_tokens": ["changed", "image", "path", "in", "darknetImageTest", ".", "js"], "add_tokens": "image : './data/dog.jpg' , } ) ;", "del_tokens": "image : './test.jpg' , } ) ;", "commit_type": "change"}
{"commit_tokens": ["updating", "logger", "adapter", "to", "allow", "multiple", "instances", "and", "use", "bluebird"], "add_tokens": "_ . extend ( FileLogger . prototype , { function FileLogger ( config ) { var logger = new FileLogger ( config ) ;", "del_tokens": "_ . extend ( Logger . prototype , { function Logger ( config ) { var logger = new Logger ( config ) ;", "commit_type": "update"}
{"commit_tokens": ["add", "sinon", "for", "mocking", "test", "passthrough", "strategy", "by", "mocking"], "add_tokens": "function Passthrough ( gearman ) { this . _worker = new gearman . Worker ( 'gearsloth-strategy-passthrough' , this . workHandler ) ;", "del_tokens": "var gearman = require ( 'gearman-coffee' ) ; var Worker = new gearman . Worker function Passthrough ( ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "a", "lot", "of", "configuration", "and", "for", "now", "add", "a", "test", "maxRetries", "of", "1", "to", "test", ":", "ci"], "add_tokens": "'ie9-multiple' : [ [ 'Windows 7' , 'internet explorer' , '9' ] , [ 'Windows 7' , 'internet explorer' , '9' ] , [ 'Windows 7' , 'internet explorer' , '9' ] , [ 'Windows 7' , 'internet explorer' , '9' ] , [ 'Windows 7' , 'internet explorer' , '9' ] , [ 'Windows 7' , 'internet explorer' , '9' ] , ] , [ 'OSX 10.10' , 'safari' , '8' ] , [ 'Linux' , 'opera' , '12.15' ] , //['Windows 7', 'opera', '12.12'], [ 'Windows 7' , 'opera' , '11.64' ] ,", "del_tokens": "[ 'OSX 10.10' , 'safari' , '8' ] [ 'Linux' , 'opera' , '12.15' ] //['Windows 7', 'opera', '12.12'] [ 'Windows 7' , 'opera' , '11.64' ]", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "classes", "that", "contain", "body", "-", "text"], "add_tokens": "'[class*=\"body-text\"]' , '<div></div>' ,", "del_tokens": "'<div></div>'", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "to", "cover", "keyfile", "derivation", "and", "crypto"], "add_tokens": "var path = require ( \"path\" ) , fs = require ( \"fs\" ) ; } , encryptsUsingData : function ( test ) { fs . readFile ( filename , function ( err , data ) { var text = \"some random text\" ; lib . crypto . encryptWithKeyFile ( text , filename ) . then ( function ( encrypted ) { test . notStrictEqual ( encrypted , text , \"Encrypted text should not match original\" ) ; test . ok ( encrypted . length > text . length , \"Encrypted text should be longer\" ) ; test . done ( ) ; } ) . catch ( function ( err ) { console . error ( err ) ; } ) ; } ) ;", "del_tokens": "var path = require ( \"path\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "gamepad", "example", "and", "other", "ble", "handlers", "."], "add_tokens": "this . logger ( 'driveStepsRemaining' , this . driveStepsRemaining ) ; if ( ! this . driveStepsRemaining || steps < 0 ) { this . logger ( 'setting state' ) ; this . logger ( this . speeds ) ; if ( callback ) { callback ( ) ; }", "del_tokens": "if ( ! this . driveStepsRemaining ) { callback ( ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "$", "so", "HTML", "reporter", "doesnt", "break", "the", "SS"], "add_tokens": ", root = $ ( '#mocha' ) , stat = $ ( statsTemplate ) . appendTo ( root ) ; var el = $ ( '<div class=\"suite\"><h1>' + suite . title + '</h1></div>' ) ; var el = $ ( '<div class=\"test ' + str + '\"><h2>' + test . title + '</h2></div>' ) var pre = $ ( '<pre><code>' + clean ( test . fn . toString ( ) ) + '</code></pre>' ) ;", "del_tokens": "/ ** * $ is annoying . * / var o = $ ; , root = o ( '#mocha' ) , stat = o ( statsTemplate ) . appendTo ( root ) ; var el = o ( '<div class=\"suite\"><h1>' + suite . title + '</h1></div>' ) ; var el = o ( '<div class=\"test ' + str + '\"><h2>' + test . title + '</h2></div>' ) var pre = o ( '<pre><code>' + clean ( test . fn . toString ( ) ) + '</code></pre>' ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "space", "before", "function", "parens", "to", "fix", "linting", "error"], "add_tokens": "types . forEach ( function ( type ) {", "del_tokens": "types . forEach ( function ( type ) {", "commit_type": "add"}
{"commit_tokens": ["Added", ".", "target", "&", ".", "position", "properties", "."], "add_tokens": "/ ** * Read - only . The current normalized position of the tween . This will always be a value between 0 and duration . * Changing this property directly will have no effect . * @ property target * @ type Object ** / p . position = null ; this . position = this . _prevPos = t ; // in case an action changes the current frame.", "del_tokens": "this . _prevPos = t ; // in case an action changes the current frame.", "commit_type": "add"}
{"commit_tokens": ["adding", "new", "response", "validation", "level", "fail"], "add_tokens": "if ( responseModelValidationLevel === 'error' || responseModelValidationLevel === 'fail' ) { if ( responseModelValidationLevel === 'error' ) { if ( Array . isArray ( body ) ) { if ( body . length === 0 ) { body . push ( validationErrors ) ; } else { body [ 0 ] . _response_validation_errors = validationErrors ; if ( body . length > 1 ) { body [ body . length - 1 ] . _response_validation_errors = validationErrors ; } } else { body = body || { } ; body . _response_validation_errors = validationErrors ; } else { //level is fail body = { response : body , validationErrors : validationErrors } ; res . statusCode = validationErrors . status ; status : 522 ,", "del_tokens": "if ( responseModelValidationLevel === 'error' ) { if ( Array . isArray ( body ) ) { if ( body . length === 0 ) { body . push ( validationErrors ) ; } else { body [ 0 ] . _response_validation_errors = validationErrors ; if ( body . length > 1 ) { body [ body . length - 1 ] . _response_validation_errors = validationErrors ; } else { body = body || { } ; body . _response_validation_errors = validationErrors ; status : 422 ,", "commit_type": "add"}
{"commit_tokens": ["Add", "function", "to", "enable", "header", "retrieval"], "add_tokens": "module . exports = getUrl ; module . exports . getUrl = getUrl ; module . exports . getServiceCallHeaders = getServiceCallHeaders ; / ** * Normalise a host string to { HOST } . feedhenry . com * @ param { String } host * @ return { String } * / / ** * Provides the required headers to make a service call * @ return { Object } * / function getServiceCallHeaders ( ) { return { 'x-fh-auth-app' : process . env . FH_APP_API_KEY || '' , 'x-request-with' : process . env . FH_WIDGET || '' } ; } ; / ** * Retrieve the cloud URL for a given GUID * @ param { Object } opts * @ param { Function } callback * / function getUrl ( opts , callback ) { if ( ! WIDGET ) { if ( ! ENV ) {", "del_tokens": "module . exports = function getUrl ( opts , callback ) { if ( ! WIDGET ) { if ( ! ENV ) {", "commit_type": "add"}
{"commit_tokens": ["updates", "colors", "for", "windows", "users", "too"], "add_tokens": "console . log ( chalk . bgYellow . black ( '\\n' + JSON . stringify ( msg , null , 2 ) ) ) ; console . log ( chalk . bgYellow . black ( msg ) ) ; console . log ( chalk . bgCyan . white ( '\\n' + JSON . stringify ( msg , null , 2 ) ) ) ; console . log ( chalk . bgCyan ( msg ) ) ;", "del_tokens": "console . log ( chalk . bgYellow . red ( '\\n' + JSON . stringify ( msg , null , 2 ) ) ) ; console . log ( chalk . bgYellow . red . bold ( msg ) ) ; console . log ( chalk . bgCyan . black ( '\\n' + JSON . stringify ( msg , null , 2 ) ) ) ; console . log ( chalk . bgCyan . black ( msg ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "wording", "[", "ci", "skip", "]"], "add_tokens": "beforeMsg : 'Running npm install in functions folder...' , errorMsg : 'Error installing functions dependencies.' , successMsg : 'Functions dependencies installed successfully!'", "del_tokens": "beforeMsg : 'Installing firebase-tools...' , errorMsg : 'Error installing firebase-tools.' , successMsg : 'Firebase tools installed successfully!'", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "unbindAll", "issue", "when", "no", "classes", "are", "included"], "add_tokens": "// for now we'll make a naive assumption that a function // named __init__ will only occur inside a class if ( node . name && node . name . name == '__init__' ) { output . indent ( ) ; output . print ( '_$rapyd$_unbindAll' ) ; output . with_parens ( function ( ) { output . print ( 'this' ) ; output . comma ( ) ; output . print ( 'true' ) ; } ) ; output . semicolon ( ) ; output . newline ( ) ; bind_methods ( node . bound , output ) ; }", "del_tokens": "output . indent ( ) ; output . print ( '_$rapyd$_unbindAll' ) ; output . with_parens ( function ( ) { output . print ( 'this' ) ; output . comma ( ) ; output . print ( 'true' ) ; } ) ; output . semicolon ( ) ; output . newline ( ) ; bind_methods ( node . bound , output ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "dir", "()", "tweaked", "in", "to", "work", "better"], "add_tokens": "else { for ( i in arr ) { if ( arr . hasOwnProperty ( i ) && i === val ) return true ; } return false ; }", "del_tokens": "else return val in arr ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "bug", ":", "css", "file", "not", "always", "would", "be", "last"], "add_tokens": "console . log ( 'can\\'n load clean-css \\n' + 'to use css-minification you need to install clean-css \\n' + 'npm install clean-css\\n' + console . log ( 'can\\'n load html-minifier \\n' + 'to use html-minification you need to install html-minifier\\n' + 'npm install html-minifier\\n' + var lCSS_o ; if ( ! lCSS_o ) { lCSS_o = lMoreProcessing_f ; if ( typeof lCSS_o === 'object' ) { lMoreProcessing_f = lCSS_o . moreProcessing ; } } } else return ; lCSS_o === true ) ) { return lReadedHash !== lFileHash ;", "del_tokens": "console . log ( 'can\\'n load clean-css \\n' + 'npm install clean-css\\n' + console . log ( 'can\\'n load html-minifier \\n' + 'npm install html-minifier\\n' + var lCSS_o = lMoreProcessing_f ; if ( typeof lCSS_o === 'object' ) { lMoreProcessing_f = lCSS_o . moreProcessing ; } lCSS_o === true ) ) { } else return ; return lReadedHash !== lFileHash ;", "commit_type": "fix"}
{"commit_tokens": ["use", "Date", ".", "now", "()", "instead", "of", "new", "Date", "()", ".", "getTime", "()"], "add_tokens": "var _t = Date . now ( ) ; var _t = Date . now ( ) ;", "del_tokens": "var _t = new Date ( ) . getTime ( ) ; var _t = new Date ( ) . getTime ( ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "edit", "mode", "to", "example"], "add_tokens": "< label style = \"color:#ccc\" > < input type = \"checkbox\" ng-init = \"isEdit=false\" ng-model = \"isEdit\" / > Enable edit mode < / label > < td ng-repeat = \"key in keys track by $index\" > { { key } } < / td > < tr ng-repeat = \"record in $ctrl.table track by $index\" > < td ng-repeat = \"key in keys track by $index\" > < span ng-if = \"$index===0\" > { { record [ key ] } } < / span > < input ng-if = \"$index!==0 && isEdit\" ng-model = \"record[key]\" > < span ng-if = \"$index!==0 && !isEdit\" > { { record [ key ] } } < / span > < / td >", "del_tokens": "< td ng-repeat = \"key in keys\" > { { key } } < / td > < tr ng-repeat = \"record in $ctrl.table\" > < td ng-repeat = \"key in keys\" > { { record [ key ] } } < / td >", "commit_type": "add"}
{"commit_tokens": ["Added", "check", "to", "ensure", "setPause", "doesn", "t", "register", "a", "tween", "multiple", "times", ".", "Added", "useTicks", "action", "mode", "."], "add_tokens": "p . _paused = true ; if ( this . _paused == ! ! value ) { return ; }", "del_tokens": "p . _paused = false ;", "commit_type": "add"}
{"commit_tokens": ["Add", "commissions", "to", "Loan", "Simulator"], "add_tokens": "const KarlLoanSimulatorWithCommission = defaultProps ( KarlLoanSimulator , { displayCommission : true , commissionLabel : ` ${ nbsp } ` , commissionRate : function ( duration ) { if ( duration <= 9 ) return 0.03 else if ( duration <= 18 ) return 0.04 else if ( duration <= 24 ) return 0.05 else return 0.06 } , initialAmount : 2500 , actionLabel : null , } ) export { KarlLoanSimulator , KarlLoanSimulatorWithCommission }", "del_tokens": "export { KarlLoanSimulator }", "commit_type": "add"}
{"commit_tokens": ["Add", "include", "feature", "to", "include", "serializing", "methods"], "add_tokens": "if ( ! utils . shouldApplyJsonApi ( ctx , defaults ) && ! matches . length ) {", "del_tokens": "if ( ! matches . length ) {", "commit_type": "add"}
{"commit_tokens": ["Change", "<", "=", "minLength", "to", "<", "minLength"], "add_tokens": "if ( name . length < this . minLength ) {", "del_tokens": "if ( name . length <= this . minLength ) {", "commit_type": "change"}
{"commit_tokens": ["Use", "screenstory", ".", "yml", "wd", "options"], "add_tokens": "options = resolveGridConfiguration ( screenstoryConfig , options , serverType ) ; function resolveGridConfiguration ( screenstoryConfig , options , serverType ) { var wd = screenstoryConfig . wd || } ; // Add config from file options . wdUsername = options . wdUsername || wd . username ; options . wdKey = options . wdKey || wd . key ; options . wdHost = options . wdHost || wd . host ; options . wdPort = options . wdPort || wd . port ; // Ensure capabilities are defined", "del_tokens": "options = resolveGridConfiguration ( options , serverType ) ; function resolveGridConfiguration ( options , serverType ) { // keep webdriverio default configuration", "commit_type": "use"}
{"commit_tokens": ["Remove", "readable", "-", "stream", "dep"], "add_tokens": "var PassThrough = require ( 'stream' ) . PassThrough ;", "del_tokens": "var PassThrough = require ( 'readable-stream' ) . PassThrough ;", "commit_type": "remove"}
{"commit_tokens": ["Removed", "some", "breaking", "error", "handling", "from", "mkdirp", "when", "a", "folder", "already", "exists"], "add_tokens": "if ( err && err . message . substring ( 0 , 6 ) !== 'EEXIST' ) { if ( err && err . message . substring ( 0 , 6 ) !== 'EEXIST' ) {", "del_tokens": "if ( err ) { if ( err ) {", "commit_type": "remove"}
{"commit_tokens": ["Allow", "methods", "for", "customizing", "value", "title", "class", "name", "and", "label", "format"], "add_tokens": "const column = columnMap [ key ] ; const { getValueTitle = ( ) => undefined , getValueClassName = ( ) => undefined , getValueLabel = ( ) => { let labelValue = value ; if ( _ . isBoolean ( value ) ) { labelValue = value ? 'Yes' : 'No' ; } return ` ${ column . header } ${ labelValue } ` ; } , } = column ; const title = getValueTitle ( value ) ; const label = getValueLabel ( value ) ; const className = getValueClassName ( value ) ; label , value , title , className , valueFilter : true ,", "del_tokens": "let labelValue = value ; if ( _ . isBoolean ( value ) ) { labelValue = value ? 'Yes' : 'No' ; } label : ` ${ columnMap [ key ] . header } ${ labelValue } ` , valueFilter : true , value ,", "commit_type": "allow"}
{"commit_tokens": ["Created", "new", "minimized", "version", "."], "add_tokens": "b . requestFullscreen || b . webkitRequestFullscreen || b . webkitRequestFullScreen || b . msRequestFullscreen || b . mozRequestFullScreen ) && c . call ( b ) : ( c = a . exitFullscreen || a . webkitExitFullscreen || a . webkitCancelFullScreen || a . msExitFullscreen || a . mozCancelFullScreen ) && c . call ( a ) ; return this } jQuery . fn . fullScreen = d ; jQuery . fn . toggleFullScreen = function ( ) { return d . call ( this , ! d . call ( this ) ) } ; var e , f , g ; e = document ;", "del_tokens": "b . requestFullscreen || b . webkitRequestFullscreen || b . webkitRequestFullScreen || b . msRequestFullscreen || b . mozRequestFullScreen ) && ( Element . ALLOW_KEYBOARD_INPUT ? c . call ( b , Element . ALLOW_KEYBOARD_INPUT ) : c . call ( b ) ) : ( c = a . exitFullscreen || a . webkitExitFullscreen || a . webkitCancelFullScreen || a . msExitFullscreen || a . mozCancelFullScreen ) && c . call ( a ) ; return this } jQuery . fn . fullScreen = d ; jQuery . fn . toggleFullScreen = function ( ) { return d . call ( this , ! d . call ( this ) ) } ; var e , f , g ; e = document ;", "commit_type": "create"}
{"commit_tokens": ["update", "version", "number", "/", "npm"], "add_tokens": "* Anime v1 .1 .0", "del_tokens": "* Anime v1 .0 .0", "commit_type": "update"}
{"commit_tokens": ["Add", "Css", "Variable", "Support", "for", "Property", "Validation"], "add_tokens": "} else if ( CSS . globalValues . includes ( value ) || CSS . variableRegex . test ( value ) ) {", "del_tokens": "* TODO : support variables as values } else if ( CSS . globalValues . includes ( value ) ) {", "commit_type": "add"}
{"commit_tokens": ["use", "solvency", "server", "solvency", ".", "syskall", ".", "com"], "add_tokens": "// @TODO: only use browser-request when doing browserify command. use // request otherwise var SOLVENCY_SERVER = process . env . SOLVENCY_SERVER || 'http://solvency.syskall.com/domain/' ;", "del_tokens": "var SOLVENCY_SERVER = process . env . SOLVENCY_SERVER || 'http://localhost:3000/domain/' ;", "commit_type": "use"}
{"commit_tokens": ["Allow", "to", "create", "Color", "from", "RGB", "by", "default"], "add_tokens": "function Color ( r , g , b ) { if ( 3 == arguments . length ) { this . setRGB ( r , g , b ) ; }", "del_tokens": "function Color ( ) {", "commit_type": "allow"}
{"commit_tokens": ["Move", "ListToggle", "out", "of", "cards", "file", "to", "help", "with", "HMR"], "add_tokens": "import ListToggle from './ListToggle' ;", "del_tokens": "var ListToggle = React . createClass ( { options : [ 'Food Processor' , 'Fondue Set' , 'Cuddly Toy' , 'Dinner Service' ] , getInitialState ( ) { var n = parseInt ( this . props . default ) ; return { current : n >= 0 ? n : 2 } ; } , render ( ) { var current = this . state . current ; return ( < ul className = \"list-group\" > { this . options . map ( ( o , i ) => < li key = { i } className = { ` ${ current == i ? 'active' : '' } ` } onClick = { ( ) => this . setState ( { current : i } ) } > { o } < / li > ) } < / ul > ) ; } } ) ;", "commit_type": "move"}
{"commit_tokens": ["added", "check", "for", "extension", "to", "exist"], "add_tokens": "grunt . registerTask ( 'default' , [ 'jshint' ] ) ;", "del_tokens": "grunt . registerTask ( 'default' , [ 'jshint' , 'grep' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "missed", "Confluence", "v4", "support", "for", "getSpace", "method"], "add_tokens": ". get ( this . config . baseUrl + this . apiPath + \"/space\" + this . extension + \"?spaceKey=\" + space )", "del_tokens": ". get ( this . config . baseUrl + this . apiPath + \"/space?spaceKey=\" + space )", "commit_type": "fix"}
{"commit_tokens": ["Allow", "setting", "retry", "options", "on", "a", "per", "-", "request", "basis"], "add_tokens": "const allowRetry = opts . shouldRetry || defaultShouldRetry const max = options . maxRetries || maxRetries const shouldRetry = options . shouldRetry || allowRetry if ( ! shouldRetry ( err , attemptNumber ) || attemptNumber >= max ) {", "del_tokens": "const shouldRetry = opts . shouldRetry || defaultShouldRetry if ( ! shouldRetry ( err , attemptNumber ) || attemptNumber >= maxRetries ) {", "commit_type": "allow"}
{"commit_tokens": ["Improving", "tests", "on", "Entity", ".", "specify", "regarding", "options", "isAbstract", "and", "dataName", "-", "some", "bugs", "were", "found", "and", "solved"], "add_tokens": "expect ( [ 'name' , 'attributes' , 'methods' , 'isAbstract' , 'dataName' ] ) . to . include ( '\"methods\", \"isAbstract\" and \"dataName\")' Object . preventExtensions ( _dataName ) ; Object . seal ( _dataName ) ; Object . freeze ( _dataName ) ;", "del_tokens": "expect ( [ 'name' , 'attributes' , 'methods' , 'dataName' ] ) . to . include ( '\"methods\" and \"dataName\")' Object . preventExtensions ( _dataName ) ; Object . seal ( _dataName ) ; Object . freeze ( _dataName ) ;", "commit_type": "improve"}
{"commit_tokens": ["Add", "custom", "className", "to", "svg"], "add_tokens": ". replace ( / viewBox / , 'height={height || size} width={width || size} onClick={onClick} style={style} className={className} viewBox' ) ;", "del_tokens": ". replace ( / viewBox / , 'height={height || size} width={width || size} onClick={onClick} style={style} viewBox' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "proxy", "methods", "to", "index", "module", "."], "add_tokens": "module . exports . getNew = require ( './getNew' ) ; module . exports . impersonate = require ( './impersonate' )", "del_tokens": "module . exports . create = require ( '../db' ) ( db . tokens , db . tokens . create ) ; module . exports . getById = require ( '../db' ) ( db . tokens , db . tokens . getById ) ; module . exports . validate = require ( './validate' ) ; module . exports . getNew = require ( './getNew' ) ;", "commit_type": "add"}
{"commit_tokens": ["create", "a", "first", "working", "prototype", "with", "knockout", "-", "dragdrop", "(", "CMS", "-", "11", ")"], "add_tokens": "this . jsBuilder = new WebforgeBuilder ( gulp , { root : rootDir , dest : \"www/assets\" , moduleSearchPaths : [ cmsDir ] } , rootRequire ) ; builder . add ( 'js' , 'knockout-dragdrop' ) . src ( builder . resolveModule ( 'knockout-dragdrop' ) + '/knockout.dragdrop.js' ) . pipe ( rename , 'knockout-dragdrop.js' ) ;", "del_tokens": "this . jsBuilder = new WebforgeBuilder ( gulp , { root : rootDir , dest : \"www/assets\" , moduleSearchPaths : [ cmsDir ] } , require ) ;", "commit_type": "create"}
{"commit_tokens": ["Add", "tests", "and", "refactoring", "popup", "sizing", "properties"], "add_tokens": "expect ( vm . popupLeft ) . toBe ( 187 ) // 1000 / 2 - 626 / 2 = 187 expect ( vm . popupTop ) . toBe ( 132 ) // 700 / 2 - 436 / 2 = 132 } ) // Sets correct popup size it ( 'sets correct popup size' , ( ) => { const vm = mountShareNetwork ( { propsData : { network : 'facebook' , url : 'http://vuejs.org/' , title : 'The Progressive JavaScript Framework' , popup : { height : 100 , width : 100 } } } ) . vm expect ( vm . popup . height ) . toBe ( 100 ) expect ( vm . popup . width ) . toBe ( 100 ) expect ( vm . popupTop ) . toBe ( 0 )", "del_tokens": "expect ( vm . popup . left ) . toBe ( 187 ) // 1000 / 2 - 626 / 2 = 187 expect ( vm . popup . top ) . toBe ( 132 ) // 700 / 2 - 436 / 2 = 132", "commit_type": "add"}
{"commit_tokens": ["added", "gulp", "-", "util", "to", "help", "debug", "if", "there", "is", "any", "error", "with", "our", ".", "js", "files"], "add_tokens": "var rename = require ( 'gulp-rename' ) ; var gutil = require ( 'gulp-util' ) ; //to help log any error found in our .js file gulp . task ( 'build-js' , function ( ) { console . log ( \"Build Our js\" ) ; return gulp . src ( [ 'js/product-tour.js' ] ) . pipe ( uglify ( ) ) . pipe ( gulp . dest ( 'dist/js' ) ) . pipe ( rename ( 'product-tour.min.js' ) ) . pipe ( gulp . dest ( 'dist/js' ) ) . pipe ( browserSync . reload ( { stream : true } ) ) ; } ) ;", "del_tokens": "gulp . task ( 'build-js' , function ( ) { console . log ( \"Build js\" ) ; browserSync . reload ( ) ; } )", "commit_type": "add"}
{"commit_tokens": ["fixed", "code", "style", "in", "protractor", ".", "conf"], "add_tokens": "browserName : 'chrome' ,", "del_tokens": "browserName : 'chrome' ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "issue", "https", ":", "//", "github", ".", "com", "/", "GoblinDBRocks", "/", "GoblinDB", "/", "issues", "/", "69"], "add_tokens": "'DB_DELETE_MISSING_POINT' : 'Database delete error: Missing point that indicates where to delete. It\\'s mandatory, if you want to delete from root use truncate() instead.' , 'DB_UPDATE_POIN_NOT_EXIST' : 'Database update error: You\\'re trying to store data in a key that doesn\\'t exist. Please use a valid pointer or the method set() which create the structure if not exist.'", "del_tokens": "'DB_DELETE_MISSING_POINT' : 'Database delete error: Missing point that indicates where to delete. It\\'s mandatory, if you want to delete from root use truncate() instead.'", "commit_type": "fix"}
{"commit_tokens": ["changed", "default", "port", "/", "device", "back", "to", "/", "dev", "/", "ttyUSB0"], "add_tokens": "port : _cli . port || '/dev/ttyUSB0' ,", "del_tokens": "port : _cli . port || '/dev/ttyUSB' ,", "commit_type": "change"}
{"commit_tokens": ["Add", "search", "()", "method", "that", "uses", "Mongo", "s", "$text", "search", "feature", "to", "return", "paged", "results", "sorted", "by", "relevancy", "."], "add_tokens": "var search = require ( './src/search' ) ; find , search", "del_tokens": "find", "commit_type": "add"}
{"commit_tokens": ["Fix", "pub", "/", "sub", "with", "0", "nanos"], "add_tokens": "if ( is . defined ( publishTime . seconds ) && is . defined ( publishTime . nanos ) ) {", "del_tokens": "if ( publishTime . seconds && publishTime . nanos ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "retry", "add", "integration", "test"], "add_tokens": "* with that instance of TorAgent . The optional verbose param will enable * console output while initializing Tor . * @ param { boolean } verbose TorAgent . create = function ( verbose ) { if ( verbose ) { console . log ( 'Spawning Tor' ) ; } if ( verbose ) { console . log ( 'Tor spawned with pid' , tor . process . pid , 'listening on' , tor . port ) ; }", "del_tokens": "* with that instance of TorAgent . TorAgent . create = function ( ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "tests", "for", "contains", "and", "within"], "add_tokens": "test ( 'With a ST_Contains geometry predicate' , ( t ) => { spatialPredicate : 'ST_Contains' test ( 'With a ST_Within geometry predicate' , ( t ) => { spatialPredicate : 'ST_Within'", "del_tokens": "test ( 'With a ST_Within geometry predicate' , ( t ) => { spatialPredicate : 'ST_Within' test ( 'With a ST_Contains geometry predicate' , ( t ) => { spatialPredicate : 'ST_Contains'", "commit_type": "fix"}
{"commit_tokens": ["Changed", "color", "of", "instructions", "in", "init", "command", "."], "add_tokens": "cli . info ( 'Transforms allow you to change aspects of the generated code, such as the names of services, operations and models.' ) ; cli . info ( ` ` ) ; cli . info ( ` ` ) ; cli . info ( ` ` ) ; cli . info ( ` ` ) ; cli . info ( ` ` ) ; cli . info ( ` ` ) ; cli . info ( ` ` ) ; cli . info ( ` ` ) ; return true ; console . log ( ) ; cli . error ( ` ` ) ; cli . error ( ` ` ) message : answers => ` ${ answers . generator } ` ,", "del_tokens": "console . log ( 'Transforms allow you to change aspects of the generated code, such as the names of services, operations and models.' ) ; console . log ( ` ` ) ; console . log ( ` ` ) ; console . log ( ` ` ) ; console . log ( ` ` ) ; console . log ( ` ` ) ; console . log ( ` ` ) ; console . log ( ` ` ) ; console . log ( ` ` ) ; message : answers => ` ${ answers . generator } ` ,", "commit_type": "change"}
{"commit_tokens": ["Added", "support", "for", "baking", "extra", "files", "."], "add_tokens": "\"tmp/recursive_path_with_placeholder.html\" : \"test/expected/recursive_path_with_placeholder.html\" , \"tmp/extra_bake.html\" : \"test/expected/extra_bake.html\" , \"tmp/extra_bake_multiple.html\" : \"test/expected/extra_bake_multiple.html\" , \"tmp/extra-page.html\" : \"test/expected/extra/extra-page.html\" , \"tmp/extra-0-a-team.html\" : \"test/expected/extra/extra-0-a-team.html\" , \"tmp/extra-1-b-team.html\" : \"test/expected/extra/extra-1-b-team.html\"", "del_tokens": "\"tmp/recursive_path_with_placeholder.html\" : \"test/expected/recursive_path_with_placeholder.html\"", "commit_type": "add"}
{"commit_tokens": ["Remove", "any", "existing", "Makefile", ".", "gyp", "file", "before", "executing", "the", "configure", "step", "."], "add_tokens": ", next = win ? go : cleanupMakefile gyp . commands . install ( [ version ] , next ) next ( ) / ** * Removes any existing Makefile . gyp file , if it exists . * Fixes : https : //github.com/TooTallNate/node-gyp/issues/18 * / function cleanupMakefile ( err ) { if ( err ) return callback ( err ) gyp . verbose ( 'checking for Makefile.gyp' ) fs . stat ( 'Makefile.gyp' , function ( err , stat ) { if ( err ) { if ( err . code == 'ENOENT' ) { // No Makefile.gyp, we're good gyp . verbose ( 'no Makefile.gyp exists, continuing with \"configure\"' ) go ( ) } else { // Some other error, report it callback ( err ) } return } // Makefile.gyp exists, gotta remove it gyp . verbose ( 'found a Makefile.gyp file, removing' ) fs . unlink ( 'Makefile.gyp' , function ( err ) { if ( err ) return callback ( err ) gyp . verbose ( 'removed the Makefile.gyp file successfully' ) go ( ) } ) } ) }", "del_tokens": "gyp . commands . install ( [ version ] , go ) go ( )", "commit_type": "remove"}
{"commit_tokens": ["Remove", "PROMISE_IMPL", "in", "favor", "of", "register", "."], "add_tokens": "* 2. global . Promise if node . js version >= 0.12 * 3. Auto detected promise based on first sucessful require of * 4. Throws error . implementation = implementation || null", "del_tokens": "* 2. Implementation specified by PROMISE_IMPL * 3. global . Promise if node . js version >= 0.12 * 4. Auto detected promise based on first sucessful require of * 5. Throws error . implementation = implementation || process . env . PROMISE_IMPL || null", "commit_type": "remove"}
{"commit_tokens": ["Removes", "snapshots", "for", "new", "-", "component", "tests"], "add_tokens": "const newJsxFileContent = renameTransform ( jsxFileContent , 'component' , componentName , eslintConfig", "del_tokens": "const newJsxFileContent = prettier . format ( renameTransform ( jsxFileContent , 'component' , componentName ) , prettierConfig", "commit_type": "remove"}
{"commit_tokens": ["Add", "integer", "to", "nullable", "fix"], "add_tokens": "` \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ ${", "del_tokens": "` \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ ${", "commit_type": "add"}
{"commit_tokens": ["added", "implementation", "for", "AddressAliasTransaction", "and", "fixed", "MosaicAliasTransaction", "draft"], "add_tokens": "* Mosaic alias transaction schema", "del_tokens": "* Mosaic supply change transaction schema", "commit_type": "add"}
{"commit_tokens": ["Improved", "checking", "$$isAuthorizationFinished", "flag", "."], "add_tokens": "* Show / hide elements based on provided permissions / roles", "del_tokens": "* Show / hide elements based on provided permissions", "commit_type": "improve"}
{"commit_tokens": ["Fix", "for", "breaking", "shimmed", "setImmediate"], "add_tokens": "// setImmediate is not a standard function // avoid adding the prop to the window object if not present if ( 'setImmediate' in global ) { global . setImmediate = glbl . setImmediate ; global . clearImmediate = glbl . clearImmediate ; }", "del_tokens": "global . setImmediate = glbl . setImmediate ; global . clearImmediate = glbl . clearImmediate ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "opacity", "inherit", "from", "parent"], "add_tokens": "if ( this . options . opacity !== null ) { ctx . globalAlpha = this . options . opacity ; } * @ prop { Number } [ opacity = null ] - Opacity level from 0 to 1 ( null mean inherited from parent ) * @ prop { Number } [ rotation = 0 ] - Rotation ratio from 0 to 1 ( clockwise ) * @ prop { Number } [ zIndex = 1 ] - Depth ordering opacity : null ,", "del_tokens": "* @ prop { Number } [ rotation = 0 ] - Rotation in degree ( clockwise ) * @ prop { Number } [ zIndex = 0 ] -", "commit_type": "make"}
{"commit_tokens": ["Add", "my", "start", "on", "the", "colour", "page", "."], "add_tokens": "import React from 'react' ; import Link from 'gatsby-link' ; import BradFrostQuote from '../../components/BradFrostQuote' ; < li > < Link to = \"atoms/colors\" > Colors < / Link > < / li > ) ; export default Page ;", "del_tokens": "import React from 'react' import Link from 'gatsby-link' import BradFrostQuote from '../../components/BradFrostQuote' ) export default Page", "commit_type": "add"}
{"commit_tokens": ["Changed", "Regex", "escaping", "to", "Google", "Closure", "s", "one", "and", "avoid", "having", "request", "object", "in", "Detector", "constructor"], "add_tokens": "this . request = null ; this . requestParameters . url = 'http://google.com' ; //currentUrl;", "del_tokens": "this . requestParameters . url = currentUrl ;", "commit_type": "change"}
{"commit_tokens": ["removed", "concept", "of", "default", "avatar", "in", "network", "-", "scene"], "add_tokens": "app : { default : 'default' } , connection . connect ( this . data . app , this . data . room , this . data . audio ) ;", "del_tokens": "appId : { default : 'default' } , avatar : { default : true } , connection . enableAvatar ( this . data . avatar ) ; connection . connect ( this . data . appId , this . data . room , this . data . audio ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "an", "issue", "when", "calling", "bindTo", "multiple", "times", "for", "same", "scope", ".", "In", "that", "case", "each", "call", "would", "lose", "all", "existing", "bindings", "and", "cause", "additional", "$destroy", "handlers", "to", "be", "added", "to", "the", "scope", "."], "add_tokens": "// Only initialize once to allow multiple calls for same scope. if ( ! ( scope . $id in boundScopes ) ) { // Add the scope to the list of bound scopes boundScopes [ scope . $id ] = [ ] ; scope . $on ( '$destroy' , function ( ) { var i = boundScopes [ scope . $id ] . length ; while ( i -- ) { _del ( boundScopes [ scope . $id ] [ i ] ) ; delete boundScopes [ scope . $id ] [ i ] ; } } ) ; }", "del_tokens": "// Add the scope to the list of bound scopes boundScopes [ scope . $id ] = [ ] ; scope . $on ( '$destroy' , function ( ) { var i = boundScopes [ scope . $id ] . length ; while ( i -- ) { _del ( boundScopes [ scope . $id ] [ i ] ) ; delete boundScopes [ scope . $id ] [ i ] ; } } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "the", "database", "models", "getter", "actual", "models", "."], "add_tokens": "database . start ( ( err , ontology ) => { database . set ( \"models\" , ontology . collections ) . set ( \"connections\" , ontology . connections )", "del_tokens": "database . start ( ( err , models ) => { database . set ( \"models\" , models )", "commit_type": "make"}
{"commit_tokens": ["Move", "test", "resources", "into", "their", "own", "dir"], "add_tokens": "var file = path . resolve ( __dirname , 'resources/COMMIT_EDITMSG' ) ;", "del_tokens": "var file = path . resolve ( __dirname , './COMMIT_EDITMSG' ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", ".", "unorderedSets", "option", "analogous", "to", "e442e26d4"], "add_tokens": "* - ` ` { true | * false } Sort ` ` and ` ` instances before hashing options . unorderedSets = options . unorderedSets !== true ? false : true ; // default to false var arr = Array . from ( map ) ; if ( options . unorderedSets !== false && options . unorderedArrays === false ) { arr = arr . sort ( ) ; } return typeHasher ( hashFn , options , context ) . dispatch ( arr ) ; var arr = Array . from ( set ) ; if ( options . unorderedSets !== false && options . unorderedArrays === false ) { arr = arr . sort ( ) ; } return typeHasher ( hashFn , options , context ) . dispatch ( arr ) ;", "del_tokens": "return typeHasher ( hashFn , options , context ) . dispatch ( Array . from ( map ) ) ; return typeHasher ( hashFn , options , context ) . dispatch ( Array . from ( set ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Implement", "raw", "data", "type", "that", "simply", "passes", "through", "data", "from", "data", "sources", "as", "is", "."], "add_tokens": "return checkWhitelist ( type , [ 'string' , 'int' , 'float' , 'boolean' , 'date' , 'datetime' , 'time' , 'raw' ] , context ) ;", "del_tokens": "* Parses 'string' , 'int' , 'float' , 'boolean' , 'date' , 'datetime' , 'time' . * return checkWhitelist ( type , [ 'string' , 'int' , 'float' , 'boolean' , 'date' , 'datetime' , 'time' ] , context ) ;", "commit_type": "implement"}
{"commit_tokens": ["Created", "property", "indicating", "if", "the", "shiftKey", "is", "pressed"], "add_tokens": "let NodeHookAddon = require ( './build/Release/iohook.node' ) ; this . lastKeydownShift = false ; if ( this . active === false || ! msg ) return ; const event = msg . mouse || msg . keyboard || msg . wheel ; // Assign the shiftKey boolean to the event. // If the last keyup was the shift key, the assume the shiftKey // is no longer pressed. if ( event . type === 'keyup' && event . shiftKey ) { this . lastKeydownShift = false ; } // Otherwise if the last keydown was the shift key, our next // keypress needs to be shift. if ( event . type === 'keydown' && event . shiftKey ) { this . lastKeydownShift = true ; } // Set shiftKey to true if the shift key is current pressed and // key is pressed. if ( event . type === 'keypress' && this . lastKeydownShift ) { event . shiftKey = true ; } // If there is any registered shortcuts then handle them.", "del_tokens": "'use strict' ; let NodeHookAddon = require ( modulePath ) ; if ( this . active === false ) { return ; } if ( ! msg ) { return ; } let event = msg . mouse || msg . keyboard || msg . wheel ; } else { console . warn ( 'Unregistered iohook event' , msg ) ;", "commit_type": "create"}
{"commit_tokens": ["Adding", "IE", "support", "(", "supposedly", ")"], "add_tokens": "this . child = this . frame . contentWindow || this . frame . contentDocument . parentWindow ; const loaded = ( ) => { if ( this . frame . attachEvent ) { this . frame . attachEvent ( \"onload\" , loaded ) ; } else { this . frame . onload = loaded ; }", "del_tokens": "this . child = this . frame . contentWindow ; this . frame . onload = ( ) => {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "user", "management", "tabs", "tile", "."], "add_tokens": "title : 'User management tabs' ,", "del_tokens": "title : 'User management toolbar' ,", "commit_type": "fix"}
{"commit_tokens": ["Remove", "empty", "object", "argument", "to", "report", "function", "."], "add_tokens": "function report ( ) { return { size : size , nextAddress : nextAddress , cache : Object . keys ( cache ) } function balancerReport ( ) { return extend ( report ( ) , { referenced : Object . keys ( referenced ) , lengths : extend ( { } , lengths ) } ) ;", "del_tokens": "function report ( object ) { object . size = size ; object . nextAddress = nextAddress ; object . cache = Object . keys ( cache ) ; return object ; function balancerReport ( object ) { object . referenced = Object . keys ( referenced ) ; object . lengths = extend ( { } , lengths ) ; return report ( object ) ;", "commit_type": "remove"}
{"commit_tokens": ["change", "to", ".", "setTimeout", "and", "enable", "e2e", "protractor", "support"], "add_tokens": "} ) . factory ( 'nowTime' , function ( $window ) { $window . setTimeout ( function ( ) {", "del_tokens": "} ) . factory ( 'nowTime' , function ( $timeout ) { $timeout ( function ( ) {", "commit_type": "change"}
{"commit_tokens": ["Fixing", "base", "object", "copy", "bug", "."], "add_tokens": "provider . model ( \"Users\" , { defaults : { username : \"anon\" } , url : \"http://api/users\" } ) . model ( \"Projects\" , { expect ( JSON . stringify ( newProject ) ) . toEqual ( '{\"name\":\"New Project\",\"$links\":{}}' ) ; var newUser = model ( \"Users\" ) . create ( ) ; expect ( JSON . stringify ( newUser ) ) . toBe ( '{\"username\":\"anon\"}' ) ;", "del_tokens": "provider . model ( \"Projects\" , { expect ( newProject . name ) . toEqual ( \"New Project\" ) ; expect ( newProject . $links ) . toEqual ( jasmine . any ( Object ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["using", "mocks", "instead", "of", "stubs", "for", "unit", "tests"], "add_tokens": "apkPackage . should . equal ( 'com.example.android.contactmanager' ) ; apkActivity . should . equal ( 'com.example.android.contactmanager.ContactManager' ) ;", "del_tokens": "apkPackage . should . be . equal ( 'com.example.android.contactmanager' ) ; apkActivity . should . be . equal ( 'com.example.android.contactmanager.ContactManager' ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "find", "()", "findLast", "()", "and", "make", "findIndex", "()", "and", "findLastIndex", "()", "using", "the", "same", "inner", "functions", "to", "implement", "them", "."], "add_tokens": "find , findLast , findIndex , findLastIndex , head , fromPairs , initial JSON . stringify ( find ( x => x % 2 == 0 , [ 1 , 3 , 4 , 2 , 6 ] ) ) . should . equal ( '4' ) ; JSON . stringify ( findLast ( x => x % 2 == 0 , [ 1 , 3 , 4 , 2 , 6 ] ) ) . should . equal ( '6' ) ;", "del_tokens": "findIndex , findLastIndex , head , fromPairs , initial", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "Argon", "NCP", "binaries", "in", "binary", "-", "version", "-", "reader"], "add_tokens": "'u' , '_' , // unused 'c'", "del_tokens": "'u'", "commit_type": "add"}
{"commit_tokens": ["Make", "prefix", "logging", "consistent", "in", "clogger"], "add_tokens": "args . unshift ( prefix ) ; console . log . apply ( console , args ) ; } ;", "del_tokens": "if ( typeof args [ 0 ] === 'string' ) { args [ 0 ] = prefix + ' ' + args [ 0 ] ; } else { args . unshift ( prefix ) ; } console . log . apply ( this , args ) ; }", "commit_type": "make"}
{"commit_tokens": ["Fix", "wrong", "bitmap", "while", "removing", "item", "from", "multi", "-", "value", "node"], "add_tokens": "var bitmap = this . bitmap & ( ~ toBitmap ( child . hcode ) ) ; // console.log(bit, this.children); // console.log(child)", "del_tokens": "var bitmap = this . bitmap & ( ~ toBitmap ( index + 1 ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "_pointer", "instead", "of", "pointer"], "add_tokens": "var store store = arg store = new Buffer ( constructor . size ) this . _pointer = store return ref . get ( this . _pointer , field . offset , type ) return ref . set ( this . _pointer , field . offset , value , type ) // set a placeholder variable on the prototype so that defineProperty() will // throw an error if you try to define a struct field with the name \"_pointer\" proto . _pointer = ref . NULL return this . _pointer", "del_tokens": "this . pointer = arg this . pointer = new Buffer ( constructor . size ) return ref . get ( this . pointer , field . offset , type ) return ref . set ( this . pointer , field . offset , value , type ) proto . _isStructInstance = true return this . pointer", "commit_type": "use"}
{"commit_tokens": ["added", "experimental", "support", "for", "KeyboardEvent", "and", "MouseEvent"], "add_tokens": "try { new KeyboardEvent ( '' , { } ) ; } catch ( o_O ) {", "del_tokens": "try { new KeyboardEvent ( { } ) ; } catch ( o_O ) {", "commit_type": "add"}
{"commit_tokens": ["Remove", "stale", "TODO", "items", ".", "Make", "broadcastAddress", "configurable", "through", "Service", "constructor", "options", "."], "add_tokens": "// TODO: consider creating Name class instead of using name+suffix everywhere var broadcastAddress = options . broadcastAddress || '255.255.255.255' ;", "del_tokens": "// TODO: write tests for broadcast mode // TODO: rework service tests now that the mode is external // TODO: create Name class var broadcastAddress = '255.255.255.255' ;", "commit_type": "remove"}
{"commit_tokens": ["changed", "return", "value", "for", "get", "element"], "add_tokens": "let result = await this . broker . call ( this . services . query + action , { processId : token . processId , elementId : token . elementId } , opts ) ; if ( result && result [ 0 ] ) element = result [ 0 ] ;", "del_tokens": "element = await this . broker . call ( this . services . query + action , { processId : token . processId , elementId : token . elementId } , opts ) ;", "commit_type": "change"}
{"commit_tokens": ["Added", "form", "for", "username", "/", "password", "which", "generates", "private", "key", "/", "address", ";", "client", "uses", "static", "HTML", "/", "JS", "host", "as", "rendezvous", "server", "instead", "of", "assuming", "localhost"], "add_tokens": "host : \"localhost\" , /** default to localhost **/ self . getPeers ( ) ; } ) ; this . getPeers = function refreshPeers ( ) { } ;", "del_tokens": "host : \"localhost\" , } ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "camelCasing", "for", "isThatEvenAthing", "method", "to", "isThatEvenAThing"], "add_tokens": "\"isThatEvenAThing\" : function ( ) { if ( Bro ( bro ) . isThatEvenAThing ( ) === Bro . TOTALLY ) { if ( Bro ( item ) . isThatEvenAThing ( ) === Bro . NOWAY ) { if ( Bro ( exports ) . isThatEvenAThing ( ) === Bro . TOTALLY ) { else if ( Bro ( module ) . isThatEvenAThing ( ) === Bro . TOTALLY ) { else if ( Bro ( require ) . isThatEvenAThing ( ) === Bro . TOTALLY ) { else if ( Bro ( window ) . isThatEvenAThing ( ) === Bro . TOTALLY ) {", "del_tokens": "\"isThatEvenAthing\" : function ( ) { if ( Bro ( bro ) . isThatEvenAthing ( ) === Bro . TOTALLY ) { if ( Bro ( item ) . isThatEvenAthing ( ) === Bro . NOWAY ) { if ( Bro ( exports ) . isThatEvenAthing ( ) === Bro . TOTALLY ) { else if ( Bro ( module ) . isThatEvenAthing ( ) === Bro . TOTALLY ) { else if ( Bro ( require ) . isThatEvenAthing ( ) === Bro . TOTALLY ) { else if ( Bro ( window ) . isThatEvenAthing ( ) === Bro . TOTALLY ) {", "commit_type": "fix"}
{"commit_tokens": ["adding", "custom", "proto", "file", "with", "clients", "."], "add_tokens": "clients : { get : getClients , decode : decodeClients } , function decodeClients ( data ) { return proto . custom . krpc . schema . Clients . decode ( data ) ; }", "del_tokens": "getClients : getClients ,", "commit_type": "add"}
{"commit_tokens": ["adding", "minified", "version", "to", "dist", "task", "adding", "opengraph", "tags", "to", "site"], "add_tokens": "webpackConfig = require ( \"./webpack.config.js\" ) , webpackMinConfig = require ( './webpack.config.min.js' ) ; function createScripts ( watch , config ) { var config = Object . create ( config ) ; gulp . task ( 'compileMinifiedScripts' , [ 'clean' ] , function ( ) { return createScripts ( false , webpackMinConfig ) ; } ) ; return createScripts ( false , webpackConfig ) ; return createScripts ( true , webpackConfig ) ; gulp . task ( 'dist' , [ 'fonts' , 'images' , 'sass' , 'compileScriptsWithDependencies' , 'compileMinifiedScripts' ] ) ;", "del_tokens": "webpackConfig = require ( \"./webpack.config.js\" ) ; function createScripts ( watch ) { var config = Object . create ( webpackConfig ) ; return createScripts ( false ) ; return createScripts ( true ) ; gulp . task ( 'dist' , [ 'fonts' , 'images' , 'sass' , 'compileScriptsWithDependencies' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "fast", "binding", "for", "al", "-", "checked"], "add_tokens": "date : '2017-01-14'", "del_tokens": "date : '2017-01-13'", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "for", "memory", "maps"], "add_tokens": "getTraps ( address ) { for ( let name of Object . keys ( this . map ) ) { // TODO: switch map to ES6 Map let info = this . map [ name ] ; if ( address >= info . start && address <= info . end ) { return { read : info . read , write : info . write } ; } } return { } ; } const traps = this . getTraps ( address ) ; if ( traps . read ) { const value = traps . read ( address ) ; if ( value !== undefined ) { this . array [ address ] = value ; } } const traps = this . getTraps ( address ) ; if ( traps . write ) { traps . write ( address , this . array [ address ] ) ; }", "del_tokens": "// TODO: trap reads // TODO: trap writes", "commit_type": "add"}
{"commit_tokens": ["fix", "bug", "with", "axes", "label", "placement"], "add_tokens": "offset [ i ] += 0.5 * ( bounds [ 0 ] [ i ] + bounds [ 1 ] [ i ] )", "del_tokens": "offset [ i ] += 0.5 * ( bounds [ 0 ] [ i ] + bounds [ 1 ] [ i ] ) * pixelScaleF", "commit_type": "fix"}
{"commit_tokens": ["Updated", "libs", "&", "docs", "."], "add_tokens": "o . buildDate = /*date*/ \"Thu, 09 May 2013 21:56:21 GMT\" ; // injected by build process", "del_tokens": "o . buildDate = /*date*/ \"Mon, 29 Apr 2013 17:26:13 GMT\" ; // injected by build process", "commit_type": "update"}
{"commit_tokens": ["Made", "sym", "key", "and", "s2k", "writable", "."], "add_tokens": "this . algorithm = openpgp . hash . sha256 ; this . c = 10 ; / ** @type {openpgp_bytearray} * Eight bytes of salt . * / this . salt = openpgp_crypto_getRandomBytes ( 8 ) ; bytes += String . fromCharCode ( this . c ) ;", "del_tokens": "this . algorithm = null ; this . c = 1000 ; bytes += this . c ;", "commit_type": "make"}
{"commit_tokens": ["Added", "shim", "for", "new", "spec", "support"], "add_tokens": "var size = require ( 'gulp-size' ) ; var files = [ './src/DOMTokenList-newest.js' , './src/DOMTokenList.js' , './src/classList.js' , './src/relList.js' ] ; . pipe ( size ( { showFiles : true } ) )", "del_tokens": "var files = [ './src/DOMTokenList.js' , './src/classList.js' , './src/relList.js' ] ;", "commit_type": "add"}
{"commit_tokens": ["added", "public", "accessor", "for", "lineHeight"], "add_tokens": "if ( lineHeight === void 0 ) lineHeight = constant ( Math . ceil ( fontSize ( ) * 1.1 ) ) ; box . lineHeight = function ( _ ) { return arguments . length ? ( lineHeight = typeof _ === \"function\" ? _ : constant ( _ ) , box ) : lineHeight ; } ;", "del_tokens": "lineHeight = constant ( Math . ceil ( fontSize ( ) * 1.1 ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "issue", "in", "generic", "directives"], "add_tokens": "var value = chewPath ( originalObj , originalPath ) ; if ( value === undefined || value === null ) { return defaultValue ; } else { return value ; }", "del_tokens": "return chewPath ( originalObj , originalPath ) || defaultValue ;", "commit_type": "fix"}
{"commit_tokens": ["changed", "regexp", "for", "killing", "breaks", "(", "does", "support", "<", "/", "br", ">", "now", ")"], "add_tokens": "mergeObjects ( settings , options ) ; . replace ( / (<\\/?br\\s*\\/?>(\\s|&nbsp;?)*)+ / g , '<br/>' )", "del_tokens": "settings = mergeObjects ( settings , options ) ; . replace ( / (<br\\s*\\/?>(\\s|&nbsp;?)*){1,} / g , '<br/>' )", "commit_type": "change"}
{"commit_tokens": ["Fix", "tests", "related", "to", "non", "-", "json", "-", "serializable", "builtin", "objects", "."], "add_tokens": "const nonSerializableObjectVal = require ( '../utils' ) . nonSerializableObjectVal ; const param = primitiveVal . concat ( objectVal ) . concat ( nonSerializableObjectVal ) . concat ( funcVal ) . concat ( symbolVal ) . concat ( undefinedVal ) ; const param = primitiveVal . concat ( objectVal ) . concat ( nonSerializableObjectVal ) . concat ( funcVal ) . concat ( symbolVal ) . concat ( undefinedVal ) ;", "del_tokens": "const param = primitiveVal . concat ( objectVal ) . concat ( funcVal ) . concat ( symbolVal ) . concat ( undefinedVal ) ; const param = primitiveVal . concat ( objectVal ) . concat ( funcVal ) . concat ( symbolVal ) . concat ( undefinedVal ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adds", "functionality", "for", "instance", "providers", "that", "construct", "a", "newly", "created", "instance", "each", "time", "they", "re", "called", ";"], "add_tokens": "* BottleJS v1 .3 .0 - 2016 - 07 - 06 / ** * Register an instance provider inside a generic provider . * * @ param { String } name - The name of the service * @ param { Function } Factory - The factory function , matches the signature required for the * ` ` method * @ return Bottle * / var instanceProvider = function instanceProvider ( name , Factory ) { return provider . call ( this , name , function GenericProvider ( ) { this . $get = function ( container ) { return new InstanceProvider ( container , Factory ) ; } } ) ; } ; function InstanceProvider ( container , factoryFunction ) { this . container = container ; this . factoryFunction = factoryFunction ; } InstanceProvider . prototype . instance = function ( ) { return this . factoryFunction ( this . container ) ; } ; instanceProvider : instanceProvider ,", "del_tokens": "* BottleJS v1 .3 .0 - 2016 - 04 - 29", "commit_type": "add"}
{"commit_tokens": ["Fix", "name", "of", "event", "ballDisppear", "-", ">", "ballDisappear", "."], "add_tokens": "this . client . emitEvent ( 'ballDisppear' , this . id ) ; //typo https://github.com/pulviscriptor/agario-client/pull/144 this . client . emitEvent ( 'ballDisappear' , this . id ) ;", "del_tokens": "this . client . emitEvent ( 'ballDisppear' , this . id ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "document", "getter", "for", "npm"], "add_tokens": "_doc : document || { } ,", "del_tokens": "_doc : global . document || { } ,", "commit_type": "fix"}
{"commit_tokens": ["move", "connection", "api", "to", "a", "new", "file"], "add_tokens": "* @ param { ModbusRTU } Modbus the ModbusRTU object .", "del_tokens": "* @ param { ModbusRTU } client the ModbusRTU object .", "commit_type": "move"}
{"commit_tokens": ["add", "chatReceieved", "event", "and", "escape", "hatch", "for", "playerResult"], "add_tokens": "const { observation , chat } = responseObservation ; frame . _result = responseObservation . playerResult ; if ( chat . length > 0 ) { chat . forEach ( ( line ) => { events . write ( { name : 'chatReceived' , data : line , } ) ; } ) ; }", "del_tokens": "const { observation } = responseObservation ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "where", "a", "callback", "that", "doesn", "t", "exist", "would", "be", "called", "when", "refreshing", "the", "store"], "add_tokens": "if ( _ . isFunction ( callback ) ) { callback ( ) ; }", "del_tokens": "callback ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Create", "Source", ".", "mapToSource", "and", "rename", "normalizeMapFilter", "to", "mapFromSource"], "add_tokens": "* Will normalize , map , and filter data from a source . * If a type is given , the itemDef with this type will be used . Otherwise , * all itemDefs of this Source will be used . * @ param { string } type - The type of the itemDef to use , or null to use all async mapFromSource ( data , type = null ) { if ( type && this . items [ type ] ) { return processOne ( this . items [ type ] ) async mapToSource ( data ) { // const item = itemDef.mapItem(data) return this . mapFromSource ( data )", "del_tokens": "* Will normalize , map , and filter data from a source with the given itemDef . * If no itemDef is given , all itemDefs of this Source will be used . * @ param { Item } itemDef - An itemDef to map and filter through async normalizeMapFilter ( data , itemDef = null ) { if ( itemDef ) { return processOne ( itemDef ) async serializeMapFilter ( data ) { return this . normalizeMapFilter ( data )", "commit_type": "create"}
{"commit_tokens": ["Add", "support", "for", "params", "in", "components", "fetch", "method"], "add_tokens": "fetches = [ ] , params = { } fetches . push ( component . fetchData ( params ) ) params = state . params", "del_tokens": "fetches = [ ] fetches . push ( component . fetchData ( ) )", "commit_type": "add"}
{"commit_tokens": ["Changed", "for", "-", "in", "loops", "on", "arrays", "in", "Clones", "module", "into", "for", "loops", "."], "add_tokens": "var i ; for ( i = 0 ; i < map . length ; i ++ ) { var i ; for ( i = 0 ; i < pattern . length ; i ++ ) { var i ; for ( i = 0 ; i < this . items . length ; i ++ ) { var i ; for ( i = 0 ; i < this . items . length ; i ++ ) {", "del_tokens": "for ( var i in map ) { for ( var i in pattern ) { for ( var i in this . items ) { for ( var i in this . items ) {", "commit_type": "change"}
{"commit_tokens": ["remove", "_del", "call", "from", "_add"], "add_tokens": "_del ( 'esc' ) ; includeCheatSheat : this . includeCheatSheat , purgeHotkeys : purgeHotkeys", "del_tokens": "// unbind any previous hotkeys on that combo: _del ( combo ) ; includeCheatSheat : this . includeCheatSheat", "commit_type": "remove"}
{"commit_tokens": ["fix", "old", "template", "removing", "bug"], "add_tokens": "if ( fs . existsSync ( tmp ) && clear ) {", "del_tokens": "if ( fs . exists ( tmp ) && clear ) { / ** * * * @ param { any } msg * /", "commit_type": "fix"}
{"commit_tokens": ["Added", "passable", "label", "and", "clazz", "properties"], "add_tokens": "label : field . label || '' , clazz : field . clazz || '' , // Should this label be set to title or id instead of value? input . label = input . isRadioOrCheckbox ( ) && input . label === '' ? input . value : input . label input . clazz += input . isRadioOrCheckbox ( ) ? ' patch-swal-styles-for-inputs' : ' nice-input'", "del_tokens": "input . label = input . isRadioOrCheckbox ( ) ? ( typeof field . label !== 'undefined' ? field . label : input . value ) : '' input . clazz = ! input . isRadioOrCheckbox ( ) ? 'nice-input' : 'patch-swal-styles-for-inputs'", "commit_type": "add"}
{"commit_tokens": ["Use", "var", "instead", "of", "const"], "add_tokens": "var hue = HexToHSB ( colorInput ) [ 0 ] ; var red = parseInt ( hex . substr ( 0 , 2 ) , 16 ) / 255 , var cMax = Math . max ( red , green , blue ) ,", "del_tokens": "const hue = HexToHSB ( colorInput ) [ 0 ] ; const red = parseInt ( hex . substr ( 0 , 2 ) , 16 ) / 255 , const cMax = Math . max ( red , green , blue ) ,", "commit_type": "use"}
{"commit_tokens": ["fixed", "issue", "with", "webworkers", "running", "too", "fast", "and", "overwriting", "each", "other"], "add_tokens": "var callbacks = { } , signature = 0 , MAX_SAFE_INT = Math . pow ( 2 , 53 ) - 1 ; signature ++ ; if ( signature > MAX_SAFE_INT ) { signature = 0 ; }", "del_tokens": "var callbacks = { } ; var signature = Date . now ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "nested", "key", "handling", "to", "resolve"], "add_tokens": "if ( ! row ) return ; if ( row [ key ] ) return row [ key ] ; var parts = key . split ( '.' ) ; return _ . reduce ( parts , function ( memo , part ) { return memo && memo [ part ] ; } , row ) ;", "del_tokens": "return row && row [ key ] ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "docs", "theme", "usage", "."], "add_tokens": "themePath : '../CloudKidTheme'", "del_tokens": "themePath : '../SpringRollTheme'", "commit_type": "fix"}
{"commit_tokens": ["ADD", "e2e", "-", "test", "for", "leader", "-", "election"], "add_tokens": "boxEl . innerHTML = 'Leader' ;", "del_tokens": "boxEl . innerHTML = 'Leader ♛';", "commit_type": "add"}
{"commit_tokens": ["Fixing", "trailing", "comma", "in", "function", "params", "for", "Node", "6"], "add_tokens": "'utf8'", "del_tokens": "'utf8' ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "in", "mapping", "function"], "add_tokens": "return entity ; return entity . getId ( ) ;", "del_tokens": "ids . push ( entity ) ; } else { ids . push ( entity . getId ( ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "plugin", "directory", "to", "node_modules"], "add_tokens": "plugin_dir : root + '/node_modules/' ,", "del_tokens": "plugin_dir : root + '/plugins/' ,", "commit_type": "change"}
{"commit_tokens": ["Use", "require", "(", "java", ")", "instead", "of", "require", "(", "redseal", "-", "java", ")"], "add_tokens": "var _java = require ( 'java' ) ;", "del_tokens": "var _java = require ( 'redseal-java' ) ;", "commit_type": "use"}
{"commit_tokens": ["changed", "pixel", ".", "time", "to", "pixel", ".", "animationTime"], "add_tokens": "* @ param { number = 150 } animationTime in milliseconds per frame constructor ( data , sheet , animationTime ) this . animationTime = animationTime || 150 this . next = this . animationTime * Random . range ( entry [ 1 ] [ 0 ] , entry [ 1 ] [ 1 ] ) + leftover this . next = this . animationTime * entry [ 1 ] + leftover", "del_tokens": "* @ param { number = 150 } time in milliseconds per frame constructor ( data , sheet , time ) this . time = time || 150 this . next = this . time * Random . range ( entry [ 1 ] [ 0 ] , entry [ 1 ] [ 1 ] ) + leftover this . next = this . time * entry [ 1 ] + leftover", "commit_type": "change"}
{"commit_tokens": ["fixed", "codesearch", "and", "filesearch", "plugins"], "add_tokens": "//\"skipped\" : \"q\"{\"Files but not directories normally skipped by ack (\"default\": \"off\")}, cbsearch ( err , _self . parseSearchResult ( data || \"\" , node . path , options ) ) ; s = Util . trim ( s ) ; if ( parts . length < 3 ) continue ;", "del_tokens": "//\"skipped\" : \"q\"{\"Files\", \"but\", \"not\", \"directories\", \"normally\", \"skipped\", \"by\", \"ack\" (\"default\": \"off\")}, cbsearch ( err , _self . parseSearchResult ( data || \"\" , node . path , options ) ) ; if ( ! parts [ 0 ] ) continue ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "default_span_tags", "and", "a", "user_id", "mechanism"], "add_tokens": "// NB: Older versions of IE don't support `String.prototype.startsWith()` if ( key . substr ( 0 , constants . JOIN_ID_PREFIX . length ) === constants . JOIN_ID_PREFIX ) { this . setJoinID ( key , keyValuePairs [ key ] ) ; } else { this . _tags [ key ] = keyValuePairs [ key ] ; }", "del_tokens": "this . _tags [ key ] = keyValuePairs [ key ] ; this . _addTagAsJoinID ( joinIDs , 'end_user_id' ) ; // Add any runtime global join IDs (give preference to local tags, // though). let globalJoinIDs = this . _tracer . _options . join_ids ; for ( let key in globalJoinIDs ) { if ( this . _tags [ key ] !== undefined ) { continue ; } let value = globalJoinIDs [ key ] ; joinIDs . push ( new crouton_thrift . TraceJoinId ( { TraceKey : coerce . toString ( key ) , Value : coerce . toString ( value ) , } ) ) ; }", "commit_type": "add"}
{"commit_tokens": ["Using", "the", "delims", "from", "settings"], "add_tokens": "( function ( ) { this . delimStart = reckonSettings . delimStart ; this . delimEnd = reckonSettings . delimEnd ; var re = new RegExp ( [ '{%(.+?)%}|' , this . delimStart , '(.+?)' , this . delimEnd ] . join ( '' ) , 'g' ) ; rInstance . text = rInstance . text . replace ( re , function ( _ , $1 , $2 ) {", "del_tokens": "( function ( ) { var delimStart = reckonSettings . delimStart ; var delimEnd = reckonSettings . delimEnd ; var re = new RegExp ( [ '/{%(.+?)%}|' , this . delimStart , '(.+?)' , this . delimEnd , '/g' ] . join ( '' ) ) ; rInstance . text = rInstance . text . replace ( / {%(.+?)%}|{{(.+?)}} / g , function ( _ , $1 , $2 ) {", "commit_type": "use"}
{"commit_tokens": ["Made", "sure", "we", "do", "not", "recreate", "the", "middleware", "on", "each", "request"], "add_tokens": "const hotMiddleware = require ( 'webpack-hot-middleware' ) ( compiler ) ; yield hotMiddleware . bind ( null , this . req , this . res ) ;", "del_tokens": "yield require ( 'webpack-hot-middleware' ) ( compiler ) . bind ( null , this . req , this . res ) ;", "commit_type": "make"}
{"commit_tokens": ["fixed", ":", "bundle", ".", "js"], "add_tokens": "* Date : 2017 - 06 - 21 T08 : 04 : 23.201 Z", "del_tokens": "* Date : 2017 - 06 - 21 T00 : 47 : 12.714 Z", "commit_type": "fix"}
{"commit_tokens": ["update", "basic", "package", "-", "file", "testing"], "add_tokens": "if ( fileContentReadme . indexOf ( '## License' ) === - 1 ) { console . log ( 'Warning: The README.md should have a section ## License' ) ; console . log ( ) ; } if ( fileContentReadme . indexOf ( '## Changelog' ) === - 1 ) { console . log ( 'Warning: The README.md should have a section ## Changelog' ) ; console . log ( ) ; }", "del_tokens": "expect ( fileContentReadme . indexOf ( '## License' ) , 'The README.md needs to have a section ## License' ) . not . equal ( - 1 ) ; expect ( fileContentReadme . indexOf ( '## Changelog' ) , 'The README.md needs to have a section ## Changelog' ) . not . equal ( - 1 ) ; expect ( fileContentReadme . indexOf ( '## Changelog' ) , 'The README.md needs to have a section ## License' ) . to . be . below ( fileContentReadme . indexOf ( '## License' ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "for", "Angular", "s", "ZoneAwarePromise", "implementation"], "add_tokens": "var selfPromise = ( Promise . toString ( ) !== 'function Promise() { [native code] }' ) ?", "del_tokens": "var selfPromise = ( Promise . toString ( ) . indexOf ( '[native code]' ) === - 1 ) ?", "commit_type": "fix"}
{"commit_tokens": ["Moved", "some", "js", "to", "work", "better", "with", "html5", "boilerplate", "updated", "to", "prod", "settings"], "add_tokens": "} , 4000 ) ;", "del_tokens": "} , 4000 )", "commit_type": "move"}
{"commit_tokens": ["Changed", "test", "resolver", "port", "number", "."], "add_tokens": "var PORT = 49160 ;", "del_tokens": "var PORT = 8080 ;", "commit_type": "change"}
{"commit_tokens": ["Added", "custom", "handling", "of", "error", "handlers"], "add_tokens": "if ( ret [ \"$render_view\" ] != undefined ) { function handleRequestErrorMiddlewares ( err , req , res , next ) { for ( let i = 0 ; i < U . errorHandlers . length - 1 ; i ++ ) { U . errorHandlers [ i ] ( err , req , res , U . errorHandlers [ i + 1 ] ) ; } if ( U . errorHandlers . length > 0 ) { U . errorHandlers [ U . errorHandlers . length - 1 ] ( err , req , res , onRequestError ) ; } else { onRequestError ( err , req , res , next ) ; } } app . use ( handleRequestErrorMiddlewares ) ;", "del_tokens": "if ( ret [ \"$render_view\" ] ) { if ( U . errorHandlers . length > 0 ) { app . use ( U . errorHandlers ) ; } app . use ( onRequestError ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "debugging", "for", "_id", "do", "not", "connect", "mongoose", "if", "already", "connected"], "add_tokens": "logger . debug ( \"Loading pristine instance as base\" , invocation . clazz , _id )", "del_tokens": "logger . trace ( \"Loading pristine instance as base\" , invocation . clazz , _id )", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "detecting", "HTTP", "-", "based", "transports", "for", "get", "()", "test", "shortcut", "."], "add_tokens": "get = function ( path , port , opts , fn ) { if ( / \\/(xhr-polling|htmlfile|jsonp-polling)\\/ / . test ( path ) ) { data = transportParse ? transportParse ( data ) : data ; return req ( path , port , opts , fn ) ; post = function ( path , port , opts , fn ) { return req ( path , ports , opts , fn ) ;", "del_tokens": "get = function ( url , port , opts , fn ) { if ( / \\/(xhr-polling|htmlfile|jsonp-polling)\\/ / . test ( opts . url ) ) { data = transportParser ? transportParser ( data ) : data ; return req ( url , port , opts , fn ) ; post = function ( url , port , opts , fn ) { return req ( url , ports , opts , fn ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "querySelector", "support", "to", "dom", ".", "getChild", "()"], "add_tokens": "if ( noval ( child , true ) ) return ( typeof element . querySelector === 'function' ) ? element . querySelector ( name ) : null ; return child ;", "del_tokens": "return ( noval ( child , true ) ? null : child ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "compile", ".", "both", "for", "optimization"], "add_tokens": "module . exports = function ( source , options , _jsCode ) { // Used internally, to avoid parsing the file twice in compile.both() if ( _jsCode ) { _jsCode . code = jsCode } / ** * Execute both { @ link compile } and { @ link compile . standAlone } * This twice as faster then calling both in sequence , since the source will be parsed once * @ returns { { render : Render , code : string } } * / module . exports . both = function ( source , options ) { let jsCode = { } return { render : module . exports ( source , options , jsCode ) , code : ` ${ escape . html . standAloneCode } ${ jsCode . code } ` } }", "del_tokens": "module . exports = function ( source , options ) {", "commit_type": "add"}
{"commit_tokens": ["Updating", "to", "fix", "missing", "method", "call"], "add_tokens": "this . _setupFileStorage ( ) ; let storage = multer . diskStorage ( { this . _uploadImageHandler = multer ( { storage : storage } ) . single ( \"file\" ) ;", "del_tokens": "this . _storageSetup = multer . diskStorage ( { this . _uploadImageHandler = multer ( { storage : this . _storageSetup } ) . single ( \"file\" ) ;", "commit_type": "update"}
{"commit_tokens": ["Remove", "dialog", "placeholder", "element", "."], "add_tokens": "this . dialogEl = this . getEl ( ) ; this . dialogEl . parentNode . replaceChild ( this . dialogEl , this . dialogEl ) ;", "del_tokens": "this . dialogEl = this . getEl ( 'dialog' ) ; this . el . replaceChild ( this . dialogEl , this . dialogEl ) ;", "commit_type": "remove"}
{"commit_tokens": ["Change", "toggle", "functions", "to", "use", "the", "cycleProperty", "method"], "add_tokens": "this . socket . cycleProperty ( \"pause\" ) ; this . socket . cycleProperty ( \"mute\" ) ; this . socket . cycleProperty ( \"fullscreen\" ) ; this . socket . cycleProperty ( \"sub-visibility\" ) ; } , } ,", "del_tokens": "if ( this . observed . pause ) { this . socket . setProperty ( \"pause\" , false ) ; } else { this . socket . setProperty ( \"pause\" , true ) ; } if ( this . observed . mute ) { this . socket . setProperty ( \"mute\" , false ) ; } else { this . socket . setProperty ( \"mute\" , true ) ; } if ( this . observed . fullscreen ) { this . socket . setProperty ( \"fullscreen\" , false ) ; } else { this . socket . setProperty ( \"fullscreen\" , true ) ; } if ( this . observed [ \"sub-visibility\" ] ) { this . socket . setProperty ( \"sub-visibility\" , false ) ; } else { this . socket . setProperty ( \"sub-visibility\" , true ) ; } } }", "commit_type": "change"}
{"commit_tokens": ["using", "CSS", "preload", "in", "Edge", "to", "support", "onerror", "events"], "add_tokens": "isLegacyIECss , e . href = pathStripped ; // tag IE9+ isLegacyIECss = 'hideFocus' in e ; // use preload in IE Edge (to detect load errors) if ( isLegacyIECss && e . relList ) { isLegacyIECss = 0 ; e . rel = 'preload' ; e . as = 'style' ; } // treat empty stylesheets as failures to get around lack of onerror // support in IE9-11 if ( isLegacyIECss ) { } else if ( e . rel == 'preload' && e . as == 'style' ) { // activate preloaded stylesheets return e . rel = 'stylesheet' ; // jshint ignore:line", "del_tokens": "isCss , isCss = true ; e . href = pathStripped ; //.replace(/^css!/, ''); // remove \"css!\" prefix // Note: The following code isolates IE using `hideFocus` and treats empty // stylesheets as failures to get around lack of onerror support if ( isCss && 'hideFocus' in e ) {", "commit_type": "use"}
{"commit_tokens": ["Updated", "the", "BSON_TO_JS_STRING", "representation", "for", "Date", "to", "be", "ISODate", "."], "add_tokens": "return ` ${ v . toISOString ( ) } ` ; return ` ${ v . toISOString ( ) } ` ;", "del_tokens": "return ` ${ v . toISOString ( ) } ` ; return ` ${ v . toISOString ( ) } ` ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "fatal", "error", "exit", "+", "ghost", "pid", "files"], "add_tokens": "gna . env . isWin32 = process . env . isWin32 = function ( ) { return ( os . platform ( ) == 'win32' ) ? true : false ; } ; //if ( !process.env.isWin32() ) { var bundleProcess = new Proc ( appName , process ) ; bundleProcess . register ( appName , process . pid ) //} var core = gna . core ; // TODO - Remove this ... // console.log('fucking source ', tmpSource, project.packages[core.startingApp].release.target);", "del_tokens": "var bundleProcess = new Proc ( appName , process ) ; // if (env == 'dev' || env == 'debug') { // appName = p[p.length-2].split(\".\")[0]; // } else { // //magic case... // appName = p[p.length-2].split(\".\")[0]; // } var core = gna . core ; console . log ( 'fucking source ' , tmpSource , project . packages [ core . startingApp ] . release . target ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "leftover", "at", "-", "word", "logic", "."], "add_tokens": "export const comment = - 1 ; export const word = - 2 ;", "del_tokens": "export const atWord = - 1 ; export const comment = - 2 ; export const word = - 3 ;", "commit_type": "remove"}
{"commit_tokens": ["added", "support", "for", "indexing", "approved", "temp", "target", "languages"], "add_tokens": "'temp-langnames' : 'Indexing Temporary Target Languages' , 'approved-temp-langnames' : 'Indexing Approved Temporary Target Languages'", "del_tokens": "'temp-langnames' : 'Indexing Temporary Target Languages'", "commit_type": "add"}
{"commit_tokens": ["added", "js", "packer", "to", "precommit", "hook"], "add_tokens": "MaSha . version = \"02.09.2011-14:46:07\" ; // filled automatically by hook", "del_tokens": "MaSha . version = \"02.09.2011-14:24:26\" ; // filled automatically by hook", "commit_type": "add"}
{"commit_tokens": ["Added", "ability", "to", "use", "custom", "tokens", "in", "format", "and", "pass", "the", "custom", "values", "in", "update", "()", "."], "add_tokens": "var b1 = new _progress . Bar ( { format : 'progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total} | Speed: {speed}' , custom : { speed : \"N/A\" } } ) ; var speedData = [ ] ; speedData . push ( Math . random ( ) * 2 + 5 ) ; var currentSpeedData = speedData . splice ( - 10 ) ; b1 . update ( value , { speed : ( currentSpeedData . reduce ( function ( a , b ) { return a + b ; } , 0 ) / currentSpeedData . length ) . toFixed ( 2 ) + \"mb/s\" } ) ;", "del_tokens": "var b1 = new _progress . Bar ( ) ; b1 . update ( value )", "commit_type": "add"}
{"commit_tokens": ["fix", "import", "meta", "included", "webpack", "to", "generate", "cjs", "version"], "add_tokens": "import { join } from 'path' import { default as __dirname } from './dirname.cjs' // eslint-disable-line // use this as soon as import.meta is standardized // const __dirname = dirname(fileURLToPath(import.meta.url)); export const fontDir = join ( __dirname , '../../' , 'fonts/' )", "del_tokens": "import { dirname , join } from 'path' import { fileURLToPath } from 'url' const __dirname = dirname ( fileURLToPath ( import . meta . url ) ) ; export const fontDir = join ( __dirname , '..' , 'fonts/' )", "commit_type": "fix"}
{"commit_tokens": ["update", "message", "emit", "event", "to", "match", "API"], "add_tokens": "destination . on ( 'message' , function ( data , delivery ) { console . log ( data ) ; console . log ( delivery ) ;", "del_tokens": "destination . on ( 'message' , function ( msg ) { console . log ( msg ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "api", "to", "get", "meta", "from", "matched", "routes", "+", "added", "default", "component", "for", "routes"], "add_tokens": "import Placeholder from './Placeholder' ; export function getMetaFromMatchedRoutes ( matchedRoutes , filter ) { if ( filter ( route ) ) return filter ( route ) ; return null ; } , null ) ; } export function getPageName ( matchedRoutes ) { return getMetaFromMatchedRoutes ( matchedRoutes , route => route . title ) ; // if no component is used, just add a place holder component if ( ! route . component ) { route . component = Placeholder ; }", "del_tokens": "export function getPageName ( matchedRoutes ) { if ( route . title ) return route . title ; return '' ; } , '' ) ; invariant ( route . component , 'missing `component` property in route config' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "some", "of", "the", "string", "escaping", "tests", "."], "add_tokens": "test . equals ( format ( 'My favorite color is {colors[\"\"favorite\"\"]}.' , { test . equals ( format ( \"My favorite color is {colors[''favorite'']}.\" , { test . ok ( strDouble === 'te\\'\\\"\\\"st' ) ; test . ok ( strSingle === 'te\\'\\'\\\"st' ) ; custom ( '{:test(true, false, 1, -1, \"\", \"te\\'\\\\\"\\\\\"st\", \\'te\\\\\\'\\\\\\'\"st\\')}' , '' ) ;", "del_tokens": "test . equals ( format ( 'My favorite color is {colors[\"\\\"favorite\\\"\"]}.' , { test . equals ( format ( 'My favorite color is {colors[\\'\\'favorite\\'\\']}.' , { test . ok ( strDouble === 'te\\'\\\"st' ) ; test . ok ( strSingle === 'te\\'\\\"st' ) ; custom ( '{:test(true, false, 1, -1, \"\", \"te\\'\\\\\"st\", \\'te\\\\\\'\"st\\')}' , '' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "option", "to", "override", "root", "path"], "add_tokens": "opt . rootPrefix = opt . rootPrefix || '/' ; opt . rootPrefix = opt . rootPrefix . replace ( / \\/$ / , '' ) + '/' ; // console.log('key:',key,'path:',path,'root:',opt.rootPrefix,'regular:',opt.prefix+key); app . use ( ( key == 'root' ? opt . rootPrefix : opt . prefix + key ) , express . static ( path , { maxAge : 1000 } ) ) ;", "del_tokens": "app . use ( ( key == 'root' ? '/' : opt . prefix + key ) , express . static ( path ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "validation", "issues", "and", "making", "validation", "chainable"], "add_tokens": "parser , updateOn : updater = identity eventActions [ updateOn ] . push ( updater ( dispatchChange ) ) ; let dispatchValidate = ( value ) => { console . log ( value , validateOn ) ; ( validator ) => validator ( getValue ( value ) ) ) ; return value ; let dispatchAsyncValidate = ( value ) => { console . log ( value ) ; ( validator , key ) => dispatch ( asyncSetValidity ( model , ( _ , done ) => { validator ( getValue ( value ) , outerDone ) ; return value ;", "del_tokens": "parser if ( typeof props . updateOn === 'function' ) { dispatchChange = props . updateOn ( dispatchChange ) ; } eventActions [ updateOn ] . push ( dispatchChange ) ; let dispatchValidate = ( e ) => { let validatingValue = control . props . hasOwnProperty ( 'value' ) ? value : e . target . value ; ( validator ) => validator ( validatingValue ) ) ; let dispatchAsyncValidate = ( e ) => { let validatingValue = control . props . hasOwnProperty ( 'value' ) ? value : e . target . value ; ( validator , key ) => dispatch ( asyncSetValidity ( model , ( value , done ) => { validator ( value , outerDone ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "use", "of", "isFase", "instead", "of", "equal"], "add_tokens": "assert . isFalse ( resolved ) ;", "del_tokens": "assert . equal ( resolved , false ) ;", "commit_type": "make"}
{"commit_tokens": ["update", "query", "generation", "unit", "tests"], "add_tokens": "return [ \"$identifier.born > 1976\" , \"$identifier.born <= 1990\" ] ; returnAttributes : [ \"title\" , \"released\" ] , getPredefinedConstraints : function ( ) { return [ \"$identifier.released > 1976\" , \"$identifier.released <= 1990\" ] ; } test ( \"Movie\" , ( ) => { var countQuery = query . generateTaxonomyCountQuery ( \"Movie\" ) ; expect ( countQuery ) . toMatchSnapshot ( ) ; } ) ;", "del_tokens": "return [ \"$identifier.born > 1976\" ] ; returnAttributes : [ \"title\" , \"born\" ] ,", "commit_type": "update"}
{"commit_tokens": ["Fixed", "regex", "for", "trimming", "multiple", "spaces"], "add_tokens": ", MULTI_SPACES = / [^\\S\\r\\n]{2,} / g", "del_tokens": ", MULTI_SPACES = / \\s{2,} / g", "commit_type": "fix"}
{"commit_tokens": ["Update", "to", "work", "with", "async", "plugin", "loading"], "add_tokens": "'use strict' var after = lab . after after ( function ( done ) { seneca . close ( done ) } )", "del_tokens": "Util . log ( res ) Util . log ( res ) Util . log ( res ) Util . log ( res )", "commit_type": "update"}
{"commit_tokens": ["Moved", "default", "-", "adapter", "into", "/", "adapters"], "add_tokens": "require ( './../adapters/terminal-adapter.js' ) ; module . exports = require ( './../adapters/default-adapter.js' ) ;", "del_tokens": "require ( './terminal-adapter.js' ) ; module . exports = require ( './default-adapter.js' ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "module", "determination", "for", "node", "globals"], "add_tokens": "type . name = type . name . replace ( / ^require\\. / , 'module.prototype.require.' ) ; type . name = type . name . replace ( / ^console\\. / , 'console.Console.prototype.' ) ; var parts = type . name . split ( '.' ) ;", "del_tokens": "if ( type . path && type . path . indexOf ( '!node' ) == 0 && type . origin == 'node' ) { type . path = type . name ; } type . path = type . name = type . name . replace ( / ^require\\. / , 'module.prototype.require.' ) ; type . path = type . name = type . name . replace ( / ^console\\. / , 'console.Console.prototype.' ) ; if ( ! type . path ) type . path = type . name ; var parts = type . path . split ( '.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["make", "child", "logger", "pipe", "all", "events", "to", "parent"], "add_tokens": "it ( 'should call the interceptors along the chain' , function ( next ) { var called = [ ] ; logger . intercept ( function ( ) { called . push ( 1 ) ; } ) ; var childLogger = logger . child ( ) ; childLogger . intercept ( function ( ) { called . push ( 2 ) ; } ) ; childLogger . on ( 'logged' , function ( ) { called . push ( 3 ) ; } ) ; logger . on ( 'logged' , function ( ) { called . push ( 4 ) ; } ) ; childLogger . log ( 'warn' , 'foo' , 'bar' ) ; assert . deepEqual ( called , [ 1 , 2 , 3 , 4 ] ) ; next ( ) ; } ) ;", "del_tokens": "//it('should call the interceptors along the chain', function (next) { // var called = []; // var childLogger = logger.geminate(); // // childLogger.intercept(function () { // called.push(1); // }); // logger.intercept(function () { // called.push(3); // }); // // childLogger.on('log', function () { // called.push(2); // }); // logger.on('log', function () { // called.push(4); // }); // // childLogger.log('warn', 'foo', 'bar'); // // assert.deepEqual(called, [1, 2, 3, 4]); // next(); //});", "commit_type": "make"}
{"commit_tokens": ["added", "names", "browserify", "helpers", "etc", "."], "add_tokens": "const random_name = require ( './random_name.js' ) ; const r_helpers = require ( './r_helpers.js' ) ; TableNormalizer : table_normalizer , RandomName : new random_name ( ) , r_helpers : r_helpers", "del_tokens": "TableNormalizer : table_normalizer", "commit_type": "add"}
{"commit_tokens": ["Add", "makecert", "option", "to", "skip", "installation"], "add_tokens": "let install = true if ( typeof parametersOrPublisherName . install === 'boolean' ) { install = parametersOrPublisherName . install } certFilePath = certFilePath || '' // If the private key file doesn't exist, makecert.exe will generate one and prompt user to set password if ( ! fs . existsSync ( pvk ) ) { utils . log ( chalk . green . bold ( 'When asked to enter a password, please select \"None\".' ) ) } . then ( ( ) => { if ( install ) { utils . executeChildProcess ( 'powershell.exe' , installPfxArgs ) } } )", "del_tokens": "// Inform the user about the password utils . log ( chalk . green . bold ( 'When asked to enter a password, please select \"None\".' ) ) . then ( ( ) => utils . executeChildProcess ( 'powershell.exe' , installPfxArgs ) )", "commit_type": "add"}
{"commit_tokens": ["Use", "all", "lower", "bits", "as", "voxel", "index", "increasing", "max", "from", "255", "to", "32767", "(", "8", "-", "bit", "to", "15", "-", "bit", ")"], "add_tokens": "return voxelSideTextureIDs ? voxelSideTextureIDs . get ( voxel & 0x7fff , side ) : voxel & 0x7fff", "del_tokens": "return voxelSideTextureIDs ? voxelSideTextureIDs . get ( voxel & 0xff , side ) : voxel & 0xff", "commit_type": "use"}
{"commit_tokens": ["Fix", "bug", "when", "detecting", "issue", "refs", "location"], "add_tokens": "var firstIssue = ghIssues [ ghIssues . length - 1 ] . match ; // https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions var escaped = firstIssue . replace ( / [.*+?^${}()|[\\]\\\\\\/] / g , \"\\\\$&\" ) ; var p = new RegExp ( '(' + escaped + '.*\\n\\n|^[^\\n]*' + escaped + ')' ) ;", "del_tokens": "var firstIssue = ghIssues [ ghIssues . length - 1 ] . toString ( ) ; var p = new RegExp ( firstIssue + '.*\\n\\n' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "a", "bad", "fsevents", "flag"], "add_tokens": "var wrongEventFlags = [ 69888 , 70400 , 71424 , 72704 , 73472 , 131328 , 131840 ] ;", "del_tokens": "var wrongEventFlags = [ 69888 , 70400 , 71424 , 72704 , 131328 , 131840 ] ;", "commit_type": "add"}
{"commit_tokens": ["Add", "isNumber", "function", "and", "check"], "add_tokens": "function isNumber ( value ) { let val = parseFloat ( value ) ; return ! isNaN ( val ) && isFinite ( val ) && ! / [^\\d.] / . test ( value ) ; } if ( isNumber ( arg ) ) { return parseFloat ( arg ) ; } else if ( typeof arg === 'string' ) {", "del_tokens": "if ( typeof arg === 'string' ) {", "commit_type": "add"}
{"commit_tokens": ["remove", "un", "-", "needed", "code", "and", "add", "ability", "to", "set", "Espruino", "s", "clock", "when", "uploading", "code"], "add_tokens": "The plugin that actually writes code out to Espruino Espruino . Core . Utils . getEspruinoPrompt ( function ( ) { sendSerial ( code ) ; } ) ;", "del_tokens": "An Example Plugin var sendSerialAfterPrompt = function ( data ) { Espruino . Core . Utils . getEspruinoPrompt ( function ( ) { sendSerial ( data ) ; } ) ; } ; if ( Espruino . Config . SEND_MINIFIED === true ) { Espruino . Plugins . Minify . MinifyCode ( code , sendSerialAfterPrompt ) ; } else { sendSerialAfterPrompt ( code ) ; }", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "HOME", "for", "Windows", "environments"], "add_tokens": "HOME : process . env . HOME || ( process . env . HOMEDRIVE + process . env . HOMEPATH ) ,", "del_tokens": "HOME : process . env . HOME ,", "commit_type": "fix"}
{"commit_tokens": ["allow", "the", "title", "to", "be", "a", "function"], "add_tokens": "if ( $ . isFunction ( this . options . title ) ) { title = this . options . title . apply ( this . $element [ 0 ] , arguments ) ; } else { title = this . options . title ; } $titleEl . html ( title ) ;", "del_tokens": "$titleEl . html ( title ) ;", "commit_type": "allow"}
{"commit_tokens": ["Created", "separate", "npm", "packages", "for", "non", "-", "development", "versions"], "add_tokens": "root = typeof window === 'undefined' ? global : window ; var constructor_or_root , date , instance , json_as_JSON , json_type , key , namespace_root , result , type , value , _i , _j , _len , _len1 , _ref ; namespace_root = _ref [ _j ] ; constructor_or_root = keyPath ( namespace_root , type ) ;", "del_tokens": "root = this ; var constructor_or_root , date , instance , json_as_JSON , json_type , key , result , type , value , _i , _j , _len , _len1 , _ref ; root = _ref [ _j ] ; constructor_or_root = keyPath ( root , type ) ;", "commit_type": "create"}
{"commit_tokens": ["Adding", "processor", "stages", ".", "before", "&", "after", "on", "success", "&", "fail", "."], "add_tokens": "_getFakePromise ( ) , { beforeSuccess : ( dispatch , data ) => { console . log ( 'Processing data before success!' ) ; } , afterSuccess : ( dispatch , data ) => { console . log ( 'Processing data after success!' ) ; } }", "del_tokens": "_getFakePromise ( )", "commit_type": "add"}
{"commit_tokens": ["improve", "doc", "&", "dev", "dependencies", "protect", "attributes"], "add_tokens": "const APP_FILES = [ path . join ( __dirname , \"lib\" , \"**\" , \"*.js\" ) ] ; gulp . task ( \"istanbul\" , gulp . series ( \"eslint\" , ( ) => { } ) ) ; gulp . task ( \"mocha\" , gulp . series ( \"istanbul\" , ( ) => { } ) ) ; gulp . task ( \"coveralls\" , gulp . series ( \"mocha\" , ( ) => { } ) ) ; gulp . task ( \"tests\" , gulp . series ( ISTRAVIS ? \"coveralls\" : \"mocha\" ) ) ; gulp . task ( \"default\" , gulp . series ( \"mocha\" ) ) ;", "del_tokens": "const APP_FILES = [ path . join ( __dirname , \"lib\" , \"*.js\" ) ] ; gulp . task ( \"istanbul\" , [ \"eslint\" ] , ( ) => { } ) ; gulp . task ( \"mocha\" , [ \"istanbul\" ] , ( ) => { } ) ; gulp . task ( \"coveralls\" , [ \"mocha\" ] , ( ) => { } ) ; gulp . task ( \"tests\" , [ ISTRAVIS ? \"coveralls\" : \"mocha\" ] ) ; gulp . task ( \"default\" , [ \"mocha\" ] ) ;", "commit_type": "improve"}
{"commit_tokens": ["moved", "from", "env", "/", "to", "envs", "/", "and", "added", "some", "code", "to", "the", "linter"], "add_tokens": "Parser = require ( './parser' ) , envs = require ( 'require-all' ) ( __dirname + '/envs' ) ; var presets = ( opts && opts [ preset ] ) ? opts [ preset ] : [ 'default' ] , env for ( var i = 0 ; i < presets . length ; i ++ ) { var preset = presets [ i ] ; //console.log(preset); if ( envs && envs [ preset ] && envs [ preset ] [ preset ] ) { env = lodash . merge ( envs [ preset ] [ preset ] , env ) ; } } env = lodash . merge ( envs [ 'none' ] [ 'none' ] , env ) ; opts = lodash . merge ( env , opts ) ; console . log ( presets ) ; console . log ( env ) ;", "del_tokens": "Parser = require ( './parser' ) ; opts = opts || { } ;", "commit_type": "move"}
{"commit_tokens": ["remove", "return", "from", "forEach", "that", "fills", "binExts"], "add_tokens": "var binExts = Object . create ( null ) ; _binExts . forEach ( function ( ext ) { binExts [ ext ] = true ; } ) ;", "del_tokens": "var binExts = Object . create ( null ) ; _binExts . forEach ( function ( extension ) { return binExts [ extension ] = true ; } ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "strip", "whitespaces", "and", "optional", "spec", "bodies"], "add_tokens": "if ( bodyFunc ) { bodyFunc ( ) ; } return { \"And\" : ( description , bodyFunc ) => exports . Given . call ( this , description , bodyFunc ) } ; if ( bodyFunc ) { bodyFunc ( ) ; }", "del_tokens": "bodyFunc ( ) ; bodyFunc ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "debug", "flag", "in", "npm", "publish", "tool", "."], "add_tokens": "if ( action == 'debug' ) { console . log ( JSON . stringify ( json , null , 2 ) + '\\n' ) ; } else { fs . writeFileSync ( jsonPath , JSON . stringify ( json , null , 2 ) + '\\n' , { encoding : 'UTF-8' } ) ; }", "del_tokens": "fs . writeFileSync ( jsonPath , JSON . stringify ( json , null , 2 ) + '\\n' , { encoding : 'UTF-8' } ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "code", "to", "revert", "working", "directory", "to", "what", "it", "was", "before", "migration", "module", "was", "ran", "before", "performing", "migration"], "add_tokens": "//Revert working directory to previous state process . chdir ( previousWorkingDirectory ) ;", "del_tokens": "process . chdir ( previousWorkingDirectory ) ;", "commit_type": "update"}
{"commit_tokens": ["Make", "the", "signin", "modal", "to", "be", "a", "real", "popup", "-", "thingy", "add", "preliminary", "google", "maps", "support"], "add_tokens": "_ . bindAll ( this , \"search\" , \"jobs\" , \"signedIn\" , \"maps\" ) ; this . mapView = new MapView ( ) ; \"jobs\" : \"jobs\" , \"maps\" : \"maps\" maps : function ( ) { this . setNavigationHighlight ( \"maps\" ) ; $ ( \"#content\" ) . detach ( ) ; $ ( \"#content-container\" ) . append ( this . mapView . el ) ; this . mapView . render ( ) ; } ,", "del_tokens": "_ . bindAll ( this , \"search\" , \"jobs\" , \"signedIn\" ) ; \"jobs\" : \"jobs\"", "commit_type": "make"}
{"commit_tokens": ["Remove", "the", "deprecated", "mediaStream", ".", "stop", "()"], "add_tokens": "if ( ! ! videoStream ) { if ( videoStream . getVideoTracks ) { // get video track to call stop in it // videoStream.stop() is deprecated and may be removed in the // near future var tracks = videoStream . getVideoTracks ( ) ; if ( tracks && tracks [ 0 ] && tracks [ 0 ] . stop ) { tracks [ 0 ] . stop ( ) ; } } else if ( videoStream . stop ) { // deprecated, may be removed in the near future videoStream . stop ( ) ; }", "del_tokens": "if ( ! ! videoStream && typeof videoStream . stop === 'function' ) { videoStream . stop ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Adding", "events", "to", "the", "hide", "/", "show", "overlay", "methods", "of", "the", "dataAttributeFramework", "jquery", "plugin", "."], "add_tokens": "var $el = $ ( this ) . getElementByDataAttribute ( CONST . DATA_ATTRIBUTES . SHOW_OVERLAY ) , data = $ ( this ) . data ( CONST . DATA_ATTRIBUTES . SHOW_OVERLAY_DATA ) ; $el . addClass ( CONST . CSS . ACTIVE ) . trigger ( CONST . EVENTS . RHYTHM . OVERLAY . SHOW , data ) ; $ ( this ) . getElementByDataAttribute ( CONST . DATA_ATTRIBUTES . HIDE_OVERLAY ) . removeClass ( CONST . CSS . ACTIVE ) . trigger ( CONST . EVENTS . RHYTHM . OVERLAY . HIDE ) ;", "del_tokens": "$ ( this ) . getElementByDataAttribute ( CONST . DATA_ATTRIBUTES . SHOW_OVERLAY ) . addClass ( CONST . CSS . ACTIVE ) ; $ ( this ) . getElementByDataAttribute ( CONST . DATA_ATTRIBUTES . HIDE_OVERLAY ) . removeClass ( CONST . CSS . ACTIVE ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "for", "Program", "PEG", "rule"], "add_tokens": "test ( 'name @ a \\\\ b <=> c' , function ( t ) { var res = parse ( 'name @ a \\\\ b <=> c' ) t . equal ( res . type , 'SimpagationRule' ) t . equal ( res . name , 'name' ) t . end ( ) } ) test ( 'name @ a / b <=> c' , function ( t ) { var res = parse ( 'name @ a / b <=> c' ) t . equal ( typeof res , 'object' ) t . equal ( res . type , 'SimpagationRule' )", "del_tokens": "/ * test ( 'name @ a \\ b <=> c' , function ( t ) { var res = parse ( 'name @ a \\ b <=> c' ) t . equal ( res . type , 'SimplificationRule' ) * /", "commit_type": "add"}
{"commit_tokens": ["Fixed", "Relative", "Path", "for", "Electron"], "add_tokens": "relbase = \"./\" + path . relative ( path . dirname ( require . main . filename ) , __dirname ) ,", "del_tokens": "relbase = \"/\" + path . relative ( path . dirname ( require . main . filename ) , __dirname ) ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "before", "to", "jshint", "globals"], "add_tokens": "it : true , before : true", "del_tokens": "it : true", "commit_type": "add"}
{"commit_tokens": ["Added", "optional", "range", "selector", "+", "live", "mode", "support", "in", "Time", "Travel", "."], "add_tokens": "// The most granular zoom is 1px per second, probably we don't want any more granular than that. return moment . duration ( 1 , 'second' ) . asMilliseconds ( ) ; export function maxDurationMsPerTimelinePx ( earliestTimestamp , rangeMs ) { let durationMsUpperBound = moment . duration ( 3 , 'days' ) . asMilliseconds ( ) ; if ( rangeMs ) { // If a time range is shown on the timeline, allow only so much zooming // out that at least 10px of that range is shown in the timeline. durationMsUpperBound = Math . min ( durationMsUpperBound , rangeMs / 10 ) ; }", "del_tokens": "// The most granular zoom is 4px per second, probably we don't want any more granular than that. return moment . duration ( 250 , 'milliseconds' ) . asMilliseconds ( ) ; export function maxDurationMsPerTimelinePx ( earliestTimestamp ) { const durationMsUpperBound = moment . duration ( 3 , 'days' ) . asMilliseconds ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "summary", "line", "orange", "if", "all", "tests", "skipped", "."], "add_tokens": "let allSkip = counts . skip && ! keys ( counts ) . some ( k => k !== 'skip' && counts [ k ] ) ; let color = allSkip ? 'orange' : counts . fail ? 'red' : 'green' ;", "del_tokens": "let color = counts . fail ? 'red' : 'green' ;", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "passing", "collapse", "-", "id", "to", "APNS"], "add_tokens": "let collapseId = \"collapseIdentifier\" ; let notification = APNS . _generateNotification ( data , { expirationTime : expirationTime , collapseId : collapseId } ) ; expect ( notification . collapseId ) . toEqual ( collapseId ) ; let collapseId = \"collapseIdentifier\" ; 'collapse_id' : collapseId , expect ( notification . collapseId ) . toEqual ( data [ 'collapse_id' ] ) ; let collapseId = \"collapseIdentifier\" ; 'collapse_id' : collapseId , expect ( notification . collapseId ) . toEqual ( data [ 'collapse_id' ] ) ; expect ( notification . collapseId ) . toEqual ( data [ 'collapse_id' ] ) ;", "del_tokens": "let notification = APNS . _generateNotification ( data , expirationTime ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "more", "leaky", "errors", "in", "futures"], "add_tokens": "console . log ( String ( ex . stack || ex . message || ex ) ) ;", "del_tokens": "console . log ( String ( ex ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "typo", "in", "docs", "for", "scroll", "action", "."], "add_tokens": "* Scrolls an element in a particular direction by setting the scrollTop or scrollLeft .", "del_tokens": "* Scrolls an element in a particular direction by setting the scrollTop or srollLeft .", "commit_type": "fix"}
{"commit_tokens": ["Add", "teardown", "-", "db", "and", "teardown", "-", "doc", "targets", "."], "add_tokens": "'setup-db' : { 'setup-doc' : { } , 'teardown-db' : { options : options , callback : _cb ( [ 'tearDownDatabases' ] ) } , 'teardown-doc' : { options : options , callback : _cb ( [ 'tearDownDocuments' ] )", "del_tokens": "\"setup-db\" : { \"setup-doc\" : {", "commit_type": "add"}
{"commit_tokens": ["Updated", "build", "tools", ".", "Moved", "tools", "to", "root", "to", "fix", "GitHub", "language", "detection", "."], "add_tokens": "var GOOGLE_CLOSURE_PATH = \"../tools/google-closure/compiler.jar\" ; var YUI_DOC_PATH = \"../tools/yuidoc/bin/yuidoc.py\" ;", "del_tokens": "var GOOGLE_CLOSURE_PATH = \"tools/google-closure/compiler.jar\" ; var YUI_DOC_PATH = \"tools/yuidoc/bin/yuidoc.py\" ;", "commit_type": "update"}
{"commit_tokens": ["add", "first", "tests", "using", "levelgraph", "backend"], "add_tokens": "const PlanBuilder = require ( './engine/plan-builder.js' ) const BGPExecutor = require ( './engine/executors/bgp-executor.js' ) const GraphExecutor = require ( './engine/executors/graph-executor.js' ) module . exports = { PlanBuilder , BGPExecutor , GraphExecutor }", "del_tokens": "module . exports = { }", "commit_type": "add"}
{"commit_tokens": ["Add", "missing", "return", "type", "to", "DataEditor"], "add_tokens": "} : Types . DataEditorProps < Cell , Value > ) : Node => {", "del_tokens": "} : Types . DataEditorProps < Cell , Value > ) => {", "commit_type": "add"}
{"commit_tokens": ["Add", "storageRequest", "()", "method", "for", "general", "requests"], "add_tokens": "} , function ( err , results ) { // Avoid passing the results parameter on return cb ( err ) ; } ) ; / ** * Sends requests to the cloud server . The beginning of the URL is automatically prepended with the base storage url . * @ param { string } method * @ param { string } url * @ param { Object } headers * @ param { function ( err ) } cb * / Rackit . prototype . storageRequest = function ( method , url , headers , cb ) { var o1 = this ; // Normalize parameters if ( typeof headers === 'function' ) { cb = headers ; headers = { } ; } var options = { method : method . toUpperCase ( ) , uri : o1 . config . storage + '/' + url , headers : headers } ; o1 . _cloudRequest ( options , cb ) ; } ;", "del_tokens": "} , cb ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "methods", "order", "in", "code", "and", "readme"], "add_tokens": "/ ** * https : //github.com/frictionlessdata/tableschema-js#schema * / addField ( descriptor ) { this . _nextDescriptor . fields . push ( descriptor ) return this . commit ( ) } / ** * https : //github.com/frictionlessdata/tableschema-js#schema * / removeField ( name ) { this . _nextDescriptor . fields = this . _nextDescriptor . fields . filter ( field => { if ( field . name !== name ) return true } ) return this . commit ( ) }", "del_tokens": "/ ** * https : //github.com/frictionlessdata/tableschema-js#schema * / addField ( descriptor ) { this . _nextDescriptor . fields . push ( descriptor ) return this . commit ( ) } / ** * https : //github.com/frictionlessdata/tableschema-js#schema * / removeField ( name ) { this . _nextDescriptor . fields = this . _nextDescriptor . fields . filter ( field => { if ( field . name !== name ) return true } ) return this . commit ( ) }", "commit_type": "update"}
{"commit_tokens": ["adding", "unit", "tests", "for", "staleContext", "fix"], "add_tokens": "if ( this . context . breakpoint && this . context . breakpoint !== newbreakpoint ) {", "del_tokens": "if ( this . context . breakpoint !== newbreakpoint ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "ember", "-", "inflector", "deprecations"], "add_tokens": "import { pluralize } from 'ember-inflector' ;", "del_tokens": "pluralize ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "where", "packages", "with", "no", "name", "would", "break"], "add_tokens": "main = this . _varNameForModule ( this . _getProjectName ( ) ) ; _getProjectName ( ) { return this . _pkg . name || path . basename ( path . resolve ( this . _dir ) ) ; } let projectName = this . _getProjectName ( ) ;", "del_tokens": "main = this . _varNameForModule ( this . _pkg . name ) ; let projectName = this . _pkg . name || path . basename ( path . resolve ( this . _dir ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "styles", "to", "doc", "attributes"], "add_tokens": "layout , classNames : [ 'fh-attributes' ] , tagName : 'ul'", "del_tokens": "layout", "commit_type": "add"}
{"commit_tokens": ["add", "a", "stream", "subscriptions", "class"], "add_tokens": "var utils = require ( './utils' ) ; var find = utils . find ; var pick = utils . pick ; var array = Array . isArray ; function Subscriptions ( ) { this . all = [ ] ; } Subscriptions . prototype . get = function ( key ) { return find ( this . all , function ( s ) { return ( s . apiKey === key ) ; } ) ; } ; Subscriptions . prototype . merge = function ( ) { } ; Subscriptions . prototype . add = function ( subscriptions ) { assert ( array ( subscriptions ) ) ; for ( var i = 0 , ii = subscriptions . length ; i < ii ; ++ i ) this . merge ( subscriptions [ i ] ) ; return this ; } ; //Subscriptions.prototype.remove = function (subscriptions) { //}; if ( ! array ( subscriptions ) ) if ( ! array ( subscriptions ) ) Stream . Subscriptions = Subscriptions ;", "del_tokens": "var pick = require ( './utils' ) . pick ; if ( ! Array . isArray ( subscriptions ) ) if ( ! Array . isArray ( subscriptions ) )", "commit_type": "add"}
{"commit_tokens": ["Move", "getLocalStream", "()", "and", "getRemoteStream", "()", "to", "prototype"], "add_tokens": "console . log ( 'Local description set' , offer ) ; { console . log ( 'Remote URL:' , remoteVideo . src ) } } inherits ( WebRtcPeer , EventEmitter ) WebRtcPeer . prototype . getLocalStream = function ( index ) { if ( this . peerConnection ) return this . peerConnection . getLocalStreams ( ) [ index || 0 ] } WebRtcPeer . prototype . getRemoteStream = function ( index ) { if ( this . peerConnection ) return this . peerConnection . getRemoteStreams ( ) [ index || 0 ]", "del_tokens": "var self = this console . log ( 'Local description set' ) ; this . getLocalStream = function ( index ) { return pc . getLocalStreams ( ) [ index || 0 ] } this . getRemoteStream = function ( index ) { return pc . getRemoteStreams ( ) [ index || 0 ] } inherits ( WebRtcPeer , EventEmitter )", "commit_type": "move"}
{"commit_tokens": ["Fix", "verb", "validation", "and", "add", "test"], "add_tokens": "imperative : [ new RegExp ( '^(' + ')(ped|s|ping))|' + '(gets|got|getting)|(takes|took|taking)|(keeps|kept|keeping)' + ')' , 'i' ) , Error . WARNING ]", "del_tokens": "imperative : [ new RegExp ( '^' + ')(ped|s|ping))' + '(gets|got|getting)|(takes|took|taking)|(keeps|kept|keeping)' , 'i' ) , Error . WARNING ]", "commit_type": "fix"}
{"commit_tokens": ["Added", "matchdep", "to", "load", "tasks", "and", "spec", "task", "for", "running", "unit", "or", "integration", "tests"], "add_tokens": "var globalConfig = { } ; globalConfig : globalConfig , } , spec : { src : [ 'test/<%= globalConfig.file %>Tests.js' ] grunt . registerTask ( 'default' , [ 'jshint' , 'simplemocha' ] ) ; grunt . registerTask ( 'spec' , 'Runs a task on a specified file' , function ( fileName ) { globalConfig . file = fileName ; grunt . task . run ( 'simplemocha:spec' ) ; } ) ; require ( 'matchdep' ) . filterDev ( 'grunt-*' ) . forEach ( grunt . loadNpmTasks ) ;", "del_tokens": "grunt . loadNpmTasks ( 'grunt-contrib-jshint' ) ; grunt . loadNpmTasks ( 'grunt-contrib-watch' ) ; grunt . loadNpmTasks ( 'grunt-simple-mocha' ) ; grunt . registerTask ( 'default' , [ 'jshint' ] ) ; grunt . registerTask ( 'test' , [ 'jshint' , 'simplemocha' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "base", "API", "to", "match", "new", "specs", "removed", "old", "endpoints", "updated", "matches"], "add_tokens": "var ENDPOINT_PREFIX = 'Matches' ; var endpoint = ENDPOINT_PREFIX + '/SearchUUID' ; var query = '{\\n \"UUID\": \"' + uuid . trim ( ) + '\",\\n \"StartTime\": ' + options . startTime + ',\\n \"EndTime\": ' + options . endTime + '\\n }' ;", "del_tokens": "var ENDPOINT_PREFIX = 'matches' ; var endpoint = ENDPOINT_PREFIX + '/search-uuid' ; var query = '{\\n \"Criteria\": {\\n \"UUID\": \"' + uuid . trim ( ) + '\",\\n \"StartTime\": ' + options . startTime + ',\\n \"EndTime\": ' + options . endTime + '\\n }\\n }' ;", "commit_type": "update"}
{"commit_tokens": ["use", "deep", "mixin", "over", "shallow", "to", "include", "exiting", "options"], "add_tokens": "var mixin = require ( 'mout/object/deepMixIn' )", "del_tokens": "var mixin = require ( 'mout/object/mixIn' )", "commit_type": "use"}
{"commit_tokens": ["Fix", "bug", ":", "hex", "input", "stops", "changing", "after", "editing", "it", "once"], "add_tokens": "const hex = hsluv . Hsluv . hsluvToHex ( [ H , S , L ] ) ; elSwatch . style . backgroundColor = hex ; elInputHex . value = hex ; elCounterHue . value = H . toFixed ( 1 ) ; elCounterSaturation . value = S . toFixed ( 1 ) ; elCounterLightness . value = L . toFixed ( 1 ) ; console . log ( 'input' , this ) ; if ( stringIsValidHex ( elInputHex . value ) ) { let hsl = hsluv . Hsluv . hexToHsluv ( elInputHex . value ) ;", "del_tokens": "function updateHexText ( ) { const hex = hsluv . Hsluv . hsluvToHex ( [ H , S , L ] ) ; elInputHex . setAttribute ( 'value' , hex ) ; } elSwatch . style . backgroundColor = hsluv . Hsluv . hsluvToHex ( [ H , S , L ] ) ; updateHexText ( ) ; elCounterHue . setAttribute ( 'value' , H . toFixed ( 1 ) ) ; elCounterSaturation . setAttribute ( 'value' , S . toFixed ( 1 ) ) ; elCounterLightness . setAttribute ( 'value' , L . toFixed ( 1 ) ) ; if ( stringIsValidHex ( this . value ) ) { let hsl = hsluv . Hsluv . hexToHsluv ( this . value ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "container", "execute", "blok", "if", "set", "in", "preference", "to", "containerDef", "execute", "block"], "add_tokens": "var executeOpts = container . specific . execute ? container . specific . execute : containerDef . specific . execute || { } ; var args = executeOpts . args || '-d' ;", "del_tokens": "var executeOpts = containerDef . specific . execute || { } ; var args = executeOpts . args || '' ;", "commit_type": "use"}
{"commit_tokens": ["used", "style", "tag", "in", "button"], "add_tokens": "import Style from './style' < div { ... omit ( attrs , [ 'href' , 'target' , 'class' ] ) } class = { [ attrs . class , 'button' ] } > < Style for = 'button' > { ` button { margin : auto ; border - radius : 3 px ; padding : 6 px 12 px ; background - color : # 2097e4 ; color : # ffffff ; text - decoration : none ; } . button__link { display : inline - block ; } ` } < / Style >", "del_tokens": "'use strict' < div { ... omit ( attrs , [ 'href' , 'target' , 'class' ] ) } class = { [ ... attrs . class , 'button' ] } > < style for = 'button' > { ` button { margin : auto ; border - radius : 3 px ; padding : 6 px 12 px ; background - color : # 2097e4 ; color : # ffffff ; text - decoration : none ; } . button__link { display : inline - block ; } ` } < / style >", "commit_type": "use"}
{"commit_tokens": ["Fix", "absent", "source", "files", "logging"], "add_tokens": "var src = f . src . filter ( function ( filepath ) { if ( ! grunt . file . exists ( filepath ) ) { grunt . log . warn ( 'Source file ' + chalk . cyan ( filepath ) + ' not found.' ) ; return false ; } return true ; } ) ; if ( src . length === 0 ) { grunt . log . error ( 'No source files were found.' ) ; return done ( ) ; src . forEach ( function ( filepath ) { process ( input , filepath , dest ) . then ( function ( result ) { result . warnings ( ) . forEach ( function ( msg ) { } ) . catch ( function ( error ) {", "del_tokens": "if ( ! f . src . length ) { return grunt . log . error ( 'No source files were found.' ) ; f . src . forEach ( function ( filepath ) { process ( input , filepath , dest ) . then ( function ( result ) { result . warnings ( ) . forEach ( function ( msg ) { } ) . catch ( function ( error ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "unicode", "-", "range", "and", "ligature", "issues"], "add_tokens": "* 13. 日文假名：[\\u3040-\\u 3 09F][\\ u 30A1-\\ u 3 0FA][\\ u 30FD-\\ u 3 0FF]（* * 註**：排除 片 假名中 點、 長音符 ） base : '[\\u4E00-\\u9FFF\\u3400-\\u4DB5\\u9FA6-\\u9FBB\\uFA70-\\uFAD9\\u9FBC-\\u9FC3\\u31C0-\\u31E3\\u3007\\u3040-\\u309F\\u30A1-\\u30FA\\u30FD-\\u30FF\\uFA0E-\\uFA0F\\uFA11\\uFA13-\\uFA14\\uFA1F\\uFA21\\uFA23-\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD869][\\uDC00-\\uDED6]|[\\uD869-\\uD86D]|[\\uDF00\\uDF34]|[\\uD86D-\\uD86E][\\uDF40\\uDC1D]' ,", "del_tokens": "* 13. 日文假名：[\\u3040-\\u 3 09E][\\ u 30A1-\\ u 3 0FA][\\ u 30FD\\u 3 0 FE]（**註**：排除 片 假名中 點、 長音符 ） base : '[\\u4E00-\\u9FFF\\u3400-\\u4DB5\\u9FA6-\\u9FBB\\uFA70-\\uFAD9\\u9FBC-\\u9FC3\\u31C0-\\u31E3\\u3007\\u3040-\\u309E\\u30A1-\\u30FA\\u30FD\\u30FE\\uFA0E-\\uFA0F\\uFA11\\uFA13-\\uFA14\\uFA1F\\uFA21\\uFA23-\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD869][\\uDC00-\\uDED6]|[\\uD869-\\uD86D]|[\\uDF00\\uDF34]|[\\uD86D-\\uD86E][\\uDF40\\uDC1D]' ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "the", "cache", "validation", "headers"], "add_tokens": "self . cacheStore . update ( request_path , file_extension , rendered_obj . body , header , function ( err , cache_obj ) { if ( err ) { console . log ( \"[Error in Cache] \" + err ) ; return self . getStatusPage ( response , 500 , \".html\" , header ) ; } return self . sendResponse ( response , status_code , cache_obj . options . header , cache_obj . body ) ;", "del_tokens": "self . cacheStore . update ( request_path , file_extension , rendered_obj . body , function ( err ) { return self . sendResponse ( response , status_code , header , rendered_obj . body ) ; //extend the default headers from the headers returned by the cache object", "commit_type": "add"}
{"commit_tokens": ["Updated", "the", "Beacon", "Finder", "example", "app", "."], "add_tokens": "//estimote.nearables.NearableTypeDog, estimote . nearables . NearableTypeAll ,", "del_tokens": "estimote . nearables . NearableTypeDog ,", "commit_type": "update"}
{"commit_tokens": ["Add", "support", "for", "inlined", "code", "."], "add_tokens": "qname : 'sequence-test2/mysequence1' , qname : 'sequence-test3/mysequence' ,", "del_tokens": "qname : 'mysequence1' , qname : 'mysequence' ,", "commit_type": "add"}
{"commit_tokens": ["Adding", "the", "filename", "in", "the", "error", "message", "for", "easier", "debugging"], "add_tokens": "} , function ( err , res ) { // res is an array of the content of each file in files (in the same order) for ( var i = 0 ; i < files . length ; i ++ ) { // We append a small banner to keep track of which file we are currently processing // super helpful for debugging var banner = \"/*** uncss> filename: \" + files [ i ] + \" ***/\\n\" ; res [ i ] = banner + res [ i ] ; } return callback ( err , res ) ; } ) ;", "del_tokens": "} , callback ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "column", "number", "of", "invalid", "attribute", "expression", "error"], "add_tokens": "var colnoBeginAttr = this . colno ; var colnoBeginVal ; colnoBeginAttr = this . colno ; if ( val . trim ( ) ) { var saved = this . colno ; this . colno = colnoBeginVal ; this . assertExpression ( val ) ; this . colno = saved ; val = val . trim ( ) ; tok . col = colnoBeginAttr ; colnoBeginVal = this . colno + 1 ;", "del_tokens": "var colno = this . colno ; colno = this . colno ; val = val . trim ( ) ; if ( val ) { this . incrementColumn ( - val . length ) ; this . assertExpression ( val ) this . incrementColumn ( val . length ) ; tok . col = colno ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "License", "readme", "and", "some", "stuff", "to", "help", "test", "live", "reloading", "."], "add_tokens": "updateColor = ( props , context ) => { const { appState , entityID } = context ; const { color , type } = props ; shouldComponentUpdate ( nextProps ) { console . log ( \"shouldComponentUpdate\" , nextProps ) ; for ( let i = 0 , l = 2 ; i < l ; i ++ ) { if ( nextProps . color [ i ] !== this . props . color [ i ] ) { console . log ( \"got a different number!\" ) ; return true ; } } if ( nextProps . type !== this . prosp . type ) { console . log ( \"different type.\" ) ; return true ; } console . log ( \"got through\" ) ; return false ; } componentWillUpdate ( ) { console . log ( \"componentWillUpdate in color!\" ) ; } componentDidMount ( ) { this . updateColor ( this . props , this . context ) ; }", "del_tokens": "componentDidMount ( ) { const { appState , entityID } = this . context ; const { color , type } = this . props ;", "commit_type": "add"}
{"commit_tokens": ["add", "jshint", "to", "grunt", "tasks", "configure", "jshint", "via", ".", "jshintrc"], "add_tokens": "} , jshint : { options : { jshintrc : true } , files : { src : [ 'src/**/*.js' , 'tests/**/*.js' ] } grunt . loadNpmTasks ( 'grunt-contrib-jshint' ) ; grunt . registerTask ( 'default' , [ 'lint' , 'test' , 'build' ] ) ; grunt . registerTask ( 'lint' , [ 'jshint' ] ) ;", "del_tokens": "grunt . registerTask ( 'default' , [ 'test' , 'build' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "autocomplete", "attribute", "to", "Field", ".", "Text"], "add_tokens": "if ( this . autocomplete ) this . tmpl . field . setAttribute ( 'autocomplete' , this . autocomplete ) ; if ( this . parentNode ) this . parentNode . hide ( ) ;", "del_tokens": "this . parentNode . hide ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "bug", "in", "recent", "commit", "for", "Mobx", "4", "/", "5", "compatibility"], "add_tokens": "var key = Array . from ( store . dataChanges ) [ 0 ] [ 0 ] ;", "del_tokens": "var key = Array . from ( store . dataChanges ) [ 0 ] ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "scalar", "value", "resolve", "by", "model", "and", "undefined", "value"], "add_tokens": "let error ; this . beforeExecuteHooks . forEach ( hook => ( error = hook ( query ) || error ) ) ; if ( error ) { return Promise . reject ( new Error ( error ) ) ;", "del_tokens": "let check ; this . beforeExecuteHooks . forEach ( hook => ( check = hook ( query ) || check ) ) ; if ( check instanceof Error ) { return Promise . reject ( check ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "eventData", "from", "#on", "API"], "add_tokens": "Delegate . prototype . on = function ( eventType , selector , handler ) { return listener . handler . call ( target , event , target ) ;", "del_tokens": "Delegate . prototype . on = function ( eventType , selector , handler , eventData ) { eventData = handler ; } // Normalise undefined eventData to null if ( eventData === undefined ) { eventData = null ; eventData : eventData , var returned , oldData ; if ( listener . eventData !== null ) { oldData = event . data ; event . data = listener . eventData ; returned = listener . handler . call ( target , event , target ) ; event . data = oldData ; } else { returned = listener . handler . call ( target , event , target ) ; } return returned ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "bsTagsInput", "angular", "directive", "&", "example", "for", "bootstrap3", "with", "typeahead", "."], "add_tokens": "} , elt ) ) ; angular . module ( 'AngularExample' , [ 'bsTagsInput' ] ) . controller ( 'Ctrl' , function Ctrl ( $scope ) { $scope . tags = [ 'Amsterdam' , 'Washington' ] ; $scope . tagsOptions = { typeahead : { local : [ 'Sydney' , 'Beijing' , 'Cairo' ] } } ; } ) ;", "del_tokens": "} , elt ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "passing", "in", "where", "sort", "limit", "and", "skip", "parameters", "via", "query", "string", "or", "post", "on", "search", "."], "add_tokens": "var where = req . param ( 'where' ) ; var sort = req . param ( 'sort' ) ; var limit = req . param ( 'limit' ) ; var skip = req . param ( 'skip' ) || 0 ; . where ( where ) . limit ( limit ) . skip ( skip ) . sort ( sort )", "del_tokens": "var params = req . body || { } ; . where ( params )", "commit_type": "add"}
{"commit_tokens": ["Adds", "test", "and", "fix", "for", "no", "-", "octal", "on", "0", "literal"], "add_tokens": "if ( typeof node . value === \"number\" && node . raw [ 0 ] === \"0\" && node . raw . length > 1 && node . raw . indexOf ( \"x\" ) < 0 ) {", "del_tokens": "if ( typeof node . value === \"number\" && node . raw [ 0 ] === \"0\" && node . raw . indexOf ( \"x\" ) < 0 ) {", "commit_type": "add"}
{"commit_tokens": ["add", "resourcemapWhitespace", "option", "for", "JSON", ".", "stringify"], "add_tokens": "this . resourcemapWhitespace = opts . resourcemapWhitespace || 2 ; return 'require.resourceMap(' + JSON . stringify ( { res : res , pkg : pkg } , null , self . resourcemapWhitespace ) + ');' ; return 'require.config({paths:' + JSON . stringify ( paths , null , self . resourcemapWhitespace ) + '});' ; return 'seajs.config({alias:' + JSON . stringify ( paths , null , self . resourcemapWhitespace ) + '});' ; configs . push ( 'map:' + JSON . stringify ( paths , null , self . resourcemapWhitespace ) ) ; configs . push ( 'bundles:' + JSON . stringify ( bundles , null , self . resourcemapWhitespace ) ) ;", "del_tokens": "return 'require.resourceMap(' + JSON . stringify ( { res : res , pkg : pkg } , null , 2 ) + ');' ; return 'require.config({paths:' + JSON . stringify ( paths , null , 2 ) + '});' ; return 'seajs.config({alias:' + JSON . stringify ( paths , null , 2 ) + '});' ; configs . push ( 'map:' + JSON . stringify ( paths , null , 2 ) ) ; configs . push ( 'bundles:' + JSON . stringify ( bundles , null , 2 ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "path", "-", "is", "-", "inside", "to", "check", "for", "invalid", "nesting"], "add_tokens": "var pathIsInside = require ( 'path-is-inside' ) ; // Ensure that the destination is outside the template location if ( pathIsInside ( dir , opts . url ) ) { ` ${ dir } ${ opts . url } `", "del_tokens": "// Make sure that the source www/ is not a direct ancestor of the // target www/, or else we will recursively copy forever. To do this, // we make sure that the shortest relative path from source-to-target // must start by going up at least one directory or with a drive // letter for Windows. var rel_path = path . relative ( opts . url , dir ) ; var goes_up = rel_path . split ( path . sep ) [ 0 ] === '..' ; if ( ! ( goes_up || rel_path [ 1 ] === ':' ) ) { 'Project dir \"' + dir + '\" must not be created at/inside the template used to create the project \"' + opts . url + '\".'", "commit_type": "use"}
{"commit_tokens": ["adding", "optional", "parser", "argument", "and", "test"], "add_tokens": "function parse ( contents , retained , parser ) { // optional parser if ( ! parser ) parser = JSON ; data . push ( parser . parse ( line ) ) ; function load ( path , parser , cb ) { // optional parser arg if ( typeof parser === 'function' ) { cb = parser ; parser = null ; } var res = parse ( contents , err , parser ) ; function sync ( path , parser ) { var res = parse ( contents , err , parser ) ;", "del_tokens": "function parse ( contents , retained ) { data . push ( JSON . parse ( line ) ) ; function load ( path , cb ) { var res = parse ( contents , err ) ; function sync ( path ) { var res = parse ( contents , err ) ;", "commit_type": "add"}
{"commit_tokens": ["Allowing", "longer", "error", "message", "."], "add_tokens": "expect ( std . err ) . to . match ( / ^error: EACCES.*, open '[\\/\\w-]*\\/.bash_profile'\\n$ / ) ;", "del_tokens": "expect ( std . err ) . to . match ( / ^error: EACCES, open '[\\/\\w-]*\\/.bash_profile'\\n$ / ) ;", "commit_type": "allow"}
{"commit_tokens": ["add", "uniform", "for", "time", "to", "shaders", "(", "and", "some", "commented", "out", "test", "code", "for", "using", "it", "to", "alter", "vertices", "and", "pixels", ")"], "add_tokens": "tile . xhr = null ; \"debug for \" + tile . key + ': [ ' +", "del_tokens": "tile . xhr = null ; \"debug for \" + tile . key + ': [ ' +", "commit_type": "add"}
{"commit_tokens": ["Fixed", "etherscan", "production", "url", "."], "add_tokens": "var url = ( testnet ? 'https://testnet.etherscan.io/api?' : 'https://api.etherscan.io/api?' ) ;", "del_tokens": "var url = ( testnet ? 'https://testnet.etherscan.io/api?' : 'https://etherscan.io/api?' ) ; console . log ( transaction ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "some", "source", "tests", "-", "more", "to", "do", "."], "add_tokens": "return typeof caps === 'object' && caps !== null && Array . isArray ( caps ) === false && Object . keys ( caps ) . length === 0 ;", "del_tokens": "return Object . keys ( caps ) . length === 0 ;", "commit_type": "add"}
{"commit_tokens": ["added", "text", "propert", "back", "to", "awards", "for", "now"], "add_tokens": "return { wins : 0 , nominations : 0 , text : '' } ; nominations : nominations ? + nominations [ 1 ] : 0 , text : raw", "del_tokens": "return { wins : 0 , nominations : 0 } ; nominations : nominations ? + nominations [ 1 ] : 0", "commit_type": "add"}
{"commit_tokens": ["removed", ":", "prefixes", "for", "the", "boolean", "attributes"], "add_tokens": "riot . tag2 ( 'root-attribs' , '' , '' , 'disabled=\"{x<y}\" style=\"display:none\" data-x=\"{x>0 ? 1 : 0}\" data-y=\"{y<0 ? -1 : 0}\" data-s=\"{\\'John\\\\\\'s\\'}\" id=\"{_id}\"' , function ( opts ) {", "del_tokens": "riot . tag2 ( 'root-attribs' , '' , '' , '__disabled=\"{x<y}\" style=\"display:none\" data-x=\"{x>0 ? 1 : 0}\" data-y=\"{y<0 ? -1 : 0}\" data-s=\"{\\'John\\\\\\'s\\'}\" id=\"{_id}\"' , function ( opts ) {", "commit_type": "remove"}
{"commit_tokens": ["adding", "support", "for", "object", "invarant"], "add_tokens": "blame ( neg , pos , \"precondition: \" + options . pre . toString ( ) , \"[failed precondition]\" , parents ) ; var res , invariant ; res = delete obj [ name ] ; if ( options . invariant ) { invariant = options . invariant . bind ( obj ) ; if ( ! invariant ( ) ) { blame ( neg , pos , \"invariant: \" + options . invariant . toString ( ) , \"[invariant violated]\" , parents ) ; } } var invariant ; if ( options . invariant ) { invariant = options . invariant . bind ( obj ) ; if ( ! invariant ( ) ) { blame ( neg , pos , \"invariant: \" + options . invariant . toString ( ) , \"[invariant violated]\" , parents ) ; } }", "del_tokens": "blameM ( neg , pos , \"failed precondition on: \" + that , parents ) ; return delete obj [ name ] ;", "commit_type": "add"}
{"commit_tokens": ["Added", "banner", "to", "dist", "files"], "add_tokens": "pkg : grunt . file . readJSON ( 'bower.json' ) , } , banner : '/*\\n * <%= pkg.title || pkg.name %> - v<%= pkg.version %> - ' + '<%= grunt.template.today(\"yyyy-mm-dd\") %>\\n' + ' * <%= pkg.homepage %>\\n' + ' * Copyright (c) <%= grunt.template.today(\"yyyy\") %> <%= pkg.author.name %>;*/\\n' options : { banner : '/*\\n * <%= pkg.title || pkg.name %> - v<%= pkg.version %> - ' + '<%= grunt.template.today(\"yyyy-mm-dd\") %>\\n' + ' * <%= pkg.homepage %>\\n' + ' * Copyright (c) <%= grunt.template.today(\"yyyy\") %> <%= pkg.author.name %>;*/\\n' } ,", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Fix", "running", "of", "pollyfill", "and", "local", "browser", "tests", "."], "add_tokens": "require ( '../register' ) ( 'es6-promise' , { Promise : require ( 'es6-promise' ) . Promise , global : false } ) var impl = require ( '../implementation' ) if ( impl !== 'es6-promise' ) { throw new Error ( 'Implementation not expected: ' + impl ) }", "del_tokens": "require ( '../register' ) ( 'my-when' , { Promise : require ( 'when' ) . Promise , global : false } )", "commit_type": "fix"}
{"commit_tokens": ["Added", "failover", "tests", "for", "replicaset"], "add_tokens": "if ( value ) values . flags |= flag ; if ( ! value ) values . flags ^= flag ;", "del_tokens": "if ( value ) values . flags |= values . flag ; if ( ! value ) values . flags ^= values . flag ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "default", "blocking", "score", "to", "100"], "add_tokens": "PX_DEFAULT . BLOCKING_SCORE = 100 ;", "del_tokens": "PX_DEFAULT . BLOCKING_SCORE = 70 ;", "commit_type": "update"}
{"commit_tokens": ["Added", "doc", "to", "exception", "list"], "add_tokens": "docs : [ \"*\" , \"!doc\" , \"!doc/*\" , \"!index.html\" , \"!node_modules\" , \"!node_modules/*\" ]", "del_tokens": "docs : [ \"*\" , \"!doc/*\" , \"!index.html\" , \"!node_modules\" , \"!node_modules/*\" ]", "commit_type": "add"}
{"commit_tokens": ["Add", "date", "-", "format", ":", "validation", "rule"], "add_tokens": "var dateFormat = require ( './validators/date-format' ) ; 'not-equal:$1' : notEqual . validator , 'date-format:$1' : dateFormat . validator 'not-equal:$1' : notEqual . message , 'date-format:$1' : dateFormat . message", "del_tokens": "'not-equal:$1' : notEqual . validator 'not-equal:$1' : notEqual . message", "commit_type": "add"}
{"commit_tokens": ["add", "mapping", "for", "gif", "png", "and", "jpg"], "add_tokens": "\"^.+\\\\.(css|less|scss|sass|png|jpg|gif)$\" : \"identity-obj-proxy\" ,", "del_tokens": "\"^.+\\\\.(css|less|scss|sass)$\" : \"identity-obj-proxy\" ,", "commit_type": "add"}
{"commit_tokens": ["Allow", "instantiation", "without", "an", "Express", "app"], "add_tokens": "if ( options . app ) { self . app = options . app ; self . app . use ( function ( req , res , next ) { req . barterer = self ; next ( ) ; } ) ; self . app . use ( '/whereis' , require ( './routes/whereis' ) ) ; self . app . use ( '/whatat' , require ( './routes/whatat' ) ) ; self . app . use ( '/whatnear' , require ( './routes/whatnear' ) ) ; self . app . use ( '/' , express . static ( path . resolve ( __dirname + '/../web' ) ) ) ; }", "del_tokens": "if ( ! options . app ) { console . error ( 'Barterer requires an Express instance as options.app' ) ; return ; } self . app = options . app ; self . app . use ( function ( req , res , next ) { req . barterer = self ; next ( ) ; } ) ; self . app . use ( '/whereis' , require ( './routes/whereis' ) ) ; self . app . use ( '/whatat' , require ( './routes/whatat' ) ) ; self . app . use ( '/whatnear' , require ( './routes/whatnear' ) ) ; self . app . use ( '/' , express . static ( path . resolve ( __dirname + '/../web' ) ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["fix", "tests", "related", "to", "getAttribute"], "add_tokens": "* VRObject represents all elements that are part of the 3 D scene . var position = this . hasAttribute ( 'position' ) ; var rotation = this . hasAttribute ( 'rotation' ) ; var scale = this . hasAttribute ( 'scale' ) ;", "del_tokens": "* VROBject represents all elements that are part of the 3 D scene . var position = this . getAttribute ( 'position' , { x : 0 , y : 0 , z : 0 } ) ; var rotation = this . getAttribute ( 'rotation' , { x : 0 , y : 0 , z : 0 } ) ; var scale = this . getAttribute ( 'scale' , { x : 1 , y : 1 , z : 1 } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "white", "/", "black", "font", "colours", "to", "match", "latest", "style", "guide"], "add_tokens": "paper : - 40 , yuzu : - 30 , 'positive-delta' : - 30 , 'negative-delta' : 10 ,", "del_tokens": "paper : - 30 , yuzu : - 20 , 'positive-delta' : - 20 , 'negative-delta' : 0 ,", "commit_type": "fix"}
{"commit_tokens": ["Allow", "extends", "syntax", "in", "git", "hook"], "add_tokens": "var util = require ( \"util\" ) ; var config = { } , subConfig ; encoding : \"utf8\" if ( config . extends ) { subConfig = JSON . parse ( fs . readFileSync ( config . extends , { encoding : \"utf8\" } ) ) ; util . _extend ( subConfig , config ) ; delete subConfig . extends ; config = subConfig ; } encoding : \"utf8\"", "del_tokens": "var config = { } ; encoding : \"utf-8\" encoding : \"utf-8\"", "commit_type": "allow"}
{"commit_tokens": ["Added", "spec", "-", "reporter", "for", "tests", "that", "outputs", "each", "describe", "and", "test", "title", "and", "whether", "it", "passes", "or", "fails", "to", "the", "console"], "add_tokens": "'karma-sinon' , 'karma-spec-reporter' reporters : [ 'spec' , 'coverage' ] ,", "del_tokens": "'karma-sinon' reporters : [ 'progress' , 'coverage' ] ,", "commit_type": "add"}
{"commit_tokens": ["Add", "touch", "support", "and", "custom", "events"], "add_tokens": "autoprefixer : { options : { browsers : [ \"last 2 versions\" , \"ie 8\" , \"ie 9\" , \"android 2.3\" , \"android 4\" , \"opera 12\" ] } , core : { options : { map : false } , src : \"dist/<%= pkg.name %>.css\" , dest : \"dist/<%= pkg.name %>.css\" } } , csscomb : { options : { config : \".csscomb.json\" } , core : { src : \"dist/<%= pkg.name %>.css\" , dest : \"dist/<%= pkg.name %>.css\" } } , grunt . registerTask ( \"default\" , [ \"clean\" , \"jshint\" , \"uglify\" , \"csslint\" , \"cssmin\" , \"copy:dist\" , \"autoprefixer\" , \"csscomb\" , \"usebanner\" , \"copy:build\" ] ) ;", "del_tokens": "grunt . registerTask ( \"default\" , [ \"clean\" , \"jshint\" , \"uglify\" , \"csslint\" , \"cssmin\" , \"copy:dist\" , \"usebanner\" , \"copy:build\" ] ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "sure", "gulp", ".", "src", "()", "throws", "if", "src", "not", "exist", "in", "Gulp", "4", ".", "X"], "add_tokens": "it ( 'should gulp.src() always return a stream in 3.X (prerequisite)' , function ( ) { if ( isGulp3 ( ) ) { var stream = gulp . src ( 'non-existent' ) ; expect ( stream ) . to . be . an . instanceof ( Stream ) ; expect ( stream ) . to . have . property ( 'on' ) ; } function isGulp3 ( ) { return ! ! gulp . run ; } } ) ; it ( 'should gulp.src() throws if src not exist in 4.X (prerequisite)' , function ( ) { if ( isGulp4 ( ) ) { expect ( function ( ) { gulp . src ( 'non-existent' ) ; } ) . to . throw ; } function isGulp4 ( ) { return ! ! gulp . registry ; }", "del_tokens": "it ( 'should gulp.src() always return a stream (prerequisite)' , function ( ) { var stream = gulp . src ( 'non-existent' ) ; expect ( stream ) . to . be . an . instanceof ( Stream ) ; expect ( stream ) . to . have . property ( 'on' ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "componentWillReceiveProps", "to", "handle", "late", "arriving", "value"], "add_tokens": "import PropTypes from 'prop-types' ; import React from 'react' ;", "del_tokens": "import * as React from 'react' ;", "commit_type": "add"}
{"commit_tokens": ["use", "correct", "type", "for", "chat", "room", "wrap", "PullReview", "in", "try", "/", "catch"], "add_tokens": "var chatRoom = options . chatRoom ; throw Error ( 'Review requests are disabled from room ' + chatRoom ) ;", "del_tokens": "var chatRoom = Boolean ( options . chatRoom ) ; throw Error ( 'Review requests are disabled from this chat room' ) ;", "commit_type": "use"}
{"commit_tokens": ["remove", "ecma5", "example", "(", "migrated", "to", "a", "seperate", "repo", ")"], "add_tokens": "options : { files : { src : [ 'src/**/*.ts' , 'test/**/*.ts' ] options : { 'bin/chevrotainSpecs.js' : specsFiles", "del_tokens": "var exampleSpecsFiles = require ( './scripts/findSpecs' ) ( \"bin/tsc/examples/\" , \"examples\" ) var ecma5Includes = findRefs ( './build/ecma5.ts' , \"bin/tsc/\" ) exampleSpecsFiles = _ . reject ( exampleSpecsFiles , function ( item ) { return _ . contains ( item , \"ecmascript5\" ) && ! _ . contains ( item , \"spec\" ) } ) exampleSpecsFiles = ecma5Includes . concat ( exampleSpecsFiles ) options : { files : { // performance_spec causes issues with TS-Lint randomly crashing due to a very large sample string it contains. src : [ 'src/**/*.ts' , 'test/**/*.ts' , 'examples/**/*.ts' , '!test/performance/performance_spec.ts' ] options : { } , ecma5 : { options : { src : 'bin/examples/ecma5.js' , objectToExport : 'chevrotain.examples.ecma5' , template : 'scripts/umd.hbs' , deps : { 'default' : [ '_' , 'chevrotain' ] , amd : [ 'lodash' , 'chevrotain' ] , cjs : [ 'lodash' , '../chevrotain' ] , global : [ '_' , 'chevrotain' ] } } 'bin/chevrotainSpecs.js' : specsFiles . concat ( exampleSpecsFiles ) } } , ecma5 : { files : { 'bin/examples/ecma5.js' : ecma5Includes grunt . registerTask ( 'ecma5' , releaseBuildTasks . concat ( [ 'concat:ecma5' , 'umd:ecma5' ] ) )", "commit_type": "remove"}
{"commit_tokens": ["Added", "in", "basic", "auth", "support"], "add_tokens": "// Basic auth this . needsAuth = false ; this . authUser = '' ; this . authPass = '' ; if ( crawler . needsAuth ) { var auth = 'Basic ' + new Buffer ( crawler . authUser + \":\" + crawler . authPass ) . toString ( 'base64' ) ; requestOptions . headers [ 'Authorization' ] = auth ; }", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["remove", "nodeID", "from", "log", "prefix"], "add_tokens": "// return utils.wrapLogger(this.options.logger, this.nodeID + (name ? \"-\" + name : \"\")); return utils . wrapLogger ( this . options . logger , name ) ;", "del_tokens": "return utils . wrapLogger ( this . options . logger , this . nodeID + ( name ? \"-\" + name : \"\" ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "broken", "field", "-", "reset", ".", "added", "other", "examples", "updated"], "add_tokens": "var tree = h ( \"div\" , [ console . log ( \"tree\" , tree ) return tree", "del_tokens": "return h ( \"div\" , [", "commit_type": "add"}
{"commit_tokens": ["Add", "more", "descriptive", "var", "name", "and", "comment"], "add_tokens": "// The particular joint that we are dealing with, and its weighting on this vertex var jointNumber = jointsAndWeights . shift ( ) var jointWeighting = jointsAndWeights . shift ( ) parsedVertexJointWeights [ index ] [ jointNumber ] = weightsArray [ jointWeighting ]", "del_tokens": "parsedVertexJointWeights [ index ] [ jointsAndWeights . shift ( ) ] = weightsArray [ jointsAndWeights . shift ( ) ]", "commit_type": "add"}
{"commit_tokens": ["Fix", "Less", "and", "Stylus", "engines"], "add_tokens": "paths : [ path . dirname ( this . file ) ] . concat ( context . environment . paths ) , optimization : 1 , filename : this . file , strictImports : false", "del_tokens": "paths : [ path . dirname ( this . file ) ] . concat ( context . environment . paths ) , optimization : 1 , filename : this . file , strictImports : false", "commit_type": "fix"}
{"commit_tokens": ["Add", "the", "ability", "to", "see", "the", "portal", "scene", "in", "the", "debug", "flat", "display", "."], "add_tokens": "if ( this . options . usesFlat ) this . _flatEl . appendChild ( childComponent . flatEl ) if ( this . options . usesPortalOverlay ) this . _portalEl . appendChild ( childComponent . portalEl ) if ( this . options . usesPortalSpatial ) this . _portalGraph . add ( childComponent . portalGraph ) if ( this . options . usesImmersive ) this . _immersiveGraph . add ( childComponent . immersiveGraph ) if ( this . options . usesFlat ) this . _flatEl . removeChild ( childComponent . flatEl ) if ( this . options . usesPortalOverlay ) this . _portalEl . removeChild ( childComponent . portalEl ) if ( this . options . usesPortalSpatial ) this . _portalGraph . remove ( childComponent . portalGraph ) if ( this . options . usesImmersive ) this . _immersiveGraph . remove ( childComponent . immersiveGraph )", "del_tokens": "this . _flatEl . appendChild ( childComponent . flatEl ) this . _portalEl . appendChild ( childComponent . portalEl ) this . _portalGraph . add ( childComponent . portalGraph ) this . _immersiveGraph . add ( childComponent . immersiveGraph ) this . _flatEl . removeChild ( childComponent . flatEl ) this . _portalEl . removeChild ( childComponent . portalEl ) this . _portalGraph . remove ( childComponent . portalGraph ) this . _immersiveGraph . remove ( childComponent . immersiveGraph )", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "the", "second", "replace", "is", "global", "as", "well"], "add_tokens": "combination = combination . replace ( / \\s+\\+\\s+ / g , '+' ) . replace ( / \\s+ / g , ' ' ) ;", "del_tokens": "combination = combination . replace ( / \\s+\\+\\s+ / g , '+' ) . replace ( / \\s+ / , ' ' ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "bug", "with", "location", "for", "auto", "-", "reload", "on", "post"], "add_tokens": "self . reload ( null , true ) ;", "del_tokens": "self . reload ( null , true , location ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "lib", "/", "gpt", ":", "Fixed", "ReferenceError", "in", ".", "compare", "()"], "add_tokens": "if ( this . table . crc !== other . table . crc ) { if ( this . table . crc !== other . table . crc ) {", "del_tokens": "if ( this . table . crc !== other . partitions . crc ) { if ( this . table . crc !== other . partitions . crc ) {", "commit_type": "update"}
{"commit_tokens": ["Fixed", "csv", "-", "parse", "defaults", "bug", "for", "piping", "to", "tty", "-", "table", "on", "terminal", "."], "add_tokens": "//Get list of all example scripts", "del_tokens": "//Get list of all test scripts", "commit_type": "fix"}
{"commit_tokens": ["Change", "openFieldList", "and", "openMiscList", "to", "just", "openList"], "add_tokens": "var utils = require ( 'keystone-utils' ) ; openList : function ( config ) { return this . clickPrimaryNavbar ( config . section ) . clickSecondaryNavbar ( config . list ) clickPrimaryNavbar : function ( key ) { var label = utils . keyToLabel ( key ) ; return this . click ( '.primary-navbar__item[data-section-label=\"' + label + '\"]' ) ; } , clickSecondaryNavbar : function ( key ) { var path = utils . keyToPath ( key , true ) ; return this . click ( '.secondary-navbar li[data-list-path=\"' + path + '\"]' ) ;", "del_tokens": "openMiscList : function ( list ) { var list = list . toLowerCase ( ) + 'List' ; var listSubmenu = '@' + list + 'Submenu' ; return this . click ( '@miscListsMenu' ) . click ( listSubmenu ) openFieldList : function ( field ) { var list = field . toLowerCase ( ) + 'List' ; var listSubmenu = '@' + list + 'Submenu' ; return this . click ( '@fieldListsMenu' ) . waitForListScreen ( ) . click ( listSubmenu ) . waitForListScreen ( ) ;", "commit_type": "change"}
{"commit_tokens": ["Use", "unique", "keyspaces", "and", "tables", "in", "tests"], "add_tokens": "var ks = 'prepared_test' ; var table = 'prepared_test' ;", "del_tokens": "var ks = 'paging_test' ; var table = 'test' ;", "commit_type": "use"}
{"commit_tokens": ["Add", "tests", "for", "scaffolding", "-", "close", "task", "."], "add_tokens": "var replacement = ( prop in replacements ) ? replacements [ prop ] : ( options . purge ? '' : match ) ;", "del_tokens": "var replacement = ( prop in replacements ) ? replacements [ prop ] : ( options . purge ? '' : '{{' + match + '}}' ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "timestamp", "hours", "to", "be", "only", "one", "digit"], "add_tokens": "const TIMESTAMP_REGEXP = / ([0-9]{1,2})?:?([0-9]{2}):([0-9]{2}\\.[0-9]{3}) / ;", "del_tokens": "const TIMESTAMP_REGEXP = / ([0-9]{2})?:?([0-9]{2}):([0-9]{2}\\.[0-9]{3}) / ;", "commit_type": "allow"}
{"commit_tokens": ["allow", "email", "to", "be", "a", "valid", "auth", "option", ";", "key", "on", "email", "or", "authEmail", "only", "for", "email", "auth", ";", "fix", "invalid", "reference", "to", "opt", ".", "token"], "add_tokens": "( opts . authEmail || opts . email ) || // Option 1: email auth ( opts . accessToken || opts . access_token ) || // Option 2: jwt auth", "del_tokens": "( opts . authEmail && opts . authPassword ) || // Option 1: email auth ( opts . token || opts . accessToken || opts . access_token ) || // Option 2: jwt auth", "commit_type": "allow"}
{"commit_tokens": ["Fix", "english", "typo", "in", "the", "comments"], "add_tokens": "// so this value is based in the number of rows", "del_tokens": "// so these value is based in the number of rows", "commit_type": "fix"}
{"commit_tokens": ["add", "isRegistered", "function", "if", "it", "doesn", "t", "exist"], "add_tokens": "if ( isRegistered ( 'base-plugins' , app ) ) return ; function isRegistered ( name , app ) { app = app || { } ; return app . isRegistered ( name ) ; app . registered = app . registered || { } ; app . isRegistered = function ( name , register ) { if ( app . registered . hasOwnProperty ( name ) ) { return true ; } if ( register !== false ) { app . registered [ name ] = true ; } return false ; } ;", "del_tokens": "if ( isRegistered ( app || { } ) ) return ; function isRegistered ( app ) { return app . isRegistered ( 'base-plugins' ) ; app . registered = true ;", "commit_type": "add"}
{"commit_tokens": ["Use", "more", "strict", "regex", "."], "add_tokens": "matches = type . match ( '(list|array)<(.*?)>' ) ; key = matches [ 2 ] ;", "del_tokens": "matches = type . match ( '<(.*?)>' ) ; key = matches [ 1 ] ;", "commit_type": "use"}
{"commit_tokens": ["implement", "crud", "spec", "in", "server", "bindings"], "add_tokens": "if ( ! force ) msg . setIfMatch ( state . version ) ;", "del_tokens": "msg . setIfMatch ( ! force ? state . version : '*' ) ;", "commit_type": "implement"}
{"commit_tokens": ["fix", "redis", "line", "in", "removeExisting"], "add_tokens": "RED . hdel ( mapkey ( jobType ) , id , $done )", "del_tokens": "RED . del ( KEYS . mapID ( id ) , $done )", "commit_type": "fix"}
{"commit_tokens": ["Removes", "the", "protocol", "to", "avoid", "mixing", "secure", "and", "insecure", "content", "on", "web", "pages", "."], "add_tokens": "webfont . FontApiUrlBuilder . DEFAULT_API_URL = '//themes.googleusercontent.com/fonts/api' ;", "del_tokens": "webfont . FontApiUrlBuilder . DEFAULT_API_URL = 'http://themes.googleusercontent.com/fonts/api' ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "the", "build", "process", "so", "requiring", "from", "npm", "works"], "add_tokens": "grunt . registerTask ( 'build' , [ 'clean:build' , 'build-env' , 'webpack:build' , 'sass' , 'babel' ] ) ;", "del_tokens": "grunt . registerTask ( 'build' , [ 'clean:build' , 'build-env' , 'webpack:build' ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "enabling", "/", "disabling", "embeds", "with", "http", ":", "//", "URLs"], "add_tokens": "function isAllowedSchema ( parsed , options ) { if ( ! options . isAllowedHttp && parsed . url . match ( '^http://' ) ) { return false ; } return true ; } function isAllowedToEmbed ( parsed , options ) { return isAllowedMimeType ( parsed , options ) && isAllowedSchema ( parsed , options ) ; } if ( ! isAllowedToEmbed ( parsed , options . html5embed ) ) { if ( ! isAllowedToEmbed ( parsed , options ) ) {", "del_tokens": "if ( ! isAllowedMimeType ( parsed , options . html5embed ) ) { if ( ! isAllowedMimeType ( parsed , options ) ) {", "commit_type": "allow"}
{"commit_tokens": ["make", "sure", "to", "bind", "target", "methods", "to", "the", "target", "itself", "in", "the", "proxy", "add", "test", "for", "session", ".", "clear", "()"], "add_tokens": "if ( [ 'clear' , 'setExpires' , 'updateCookie' ] . indexOf ( name ) > - 1 ) return this . target [ name ] . bind ( this . target ) ;", "del_tokens": "if ( [ 'clear' , 'setExpires' ] . indexOf ( name ) > - 1 ) return this . target [ name ] ;", "commit_type": "make"}
{"commit_tokens": ["Added", "handler", "for", "untagged", "responses", "(", "EXISTS", "EXPUNGE", "FETCH", ")"], "add_tokens": "BrowserBox . prototype . onupdate = function ( ) { } ; if ( response && response . hasOwnProperty ( 'nr' ) ) { this . onupdate ( 'exists' , response . nr ) ; } if ( response && response . hasOwnProperty ( 'nr' ) ) { this . onupdate ( 'expunge' , response . nr ) ; } this . onupdate ( 'fetch' , [ ] . concat ( this . _parseFETCH ( { payload : { FETCH : [ response ] } } ) || [ ] ) . shift ( ) ) ; case 'modseq' : value = Number ( ( value . shift ( ) || { } ) . value ) || 0 ; break ;", "del_tokens": "console . log ( 'Untagged EXISTS' ) ; console . log ( response ) ; console . log ( 'Untagged EXPUNGE' ) ; console . log ( response ) ; console . log ( 'Untagged FETCH' ) ; console . log ( response ) ;", "commit_type": "add"}
{"commit_tokens": ["changed", "$", ".", "execute", "back", "to", "eval", "()"], "add_tokens": "try { eval ( this . text || this . textContent || this . innerHTML || \"\" ) ; } catch ( e ) { } $ . xml ( mth , url , $ . param ( this . vars ) , function ( r ) { eval ( r . responseText ) ; } ) ;", "del_tokens": "try { $ . execute ( this . text || this . textContent || this . innerHTML || \"\" ) ; } catch ( e ) { } $ . xml ( mth , url , $ . param ( this . vars ) , function ( r ) { $ . execute ( r . responseText ) ; } ) ;", "commit_type": "change"}
{"commit_tokens": ["Added", "missing", "files", "and", "converted", "test", "builder", "to", "use", "the", "command", "line", "compiler", "."], "add_tokens": "var exec = require ( 'child_process' ) . exec ; require ( 'should' ) ; describe ( 'mjs' , function ( ) { it ( 'Should compile the test suite' , function ( ) { exec ( './bin/mjs ./test/meta-test.mjs' , function ( error , stdout , stderr ) { // FIXME: this is not performing the test... ( error === null ) . should . equal ( true ) ; stdout . should . have . length ( 0 ) ; stderr . should . have . length ( 0 ) ; } ) ; } ) ; } ) ;", "del_tokens": "var fs = require ( 'fs' ) ; var Meta = require ( '../lib/meta' ) ( ) ; var compiler = Meta . compilerFromFile ( './test/meta-test.mjs' ) ; var js = compiler . compile ( ) ; //compiler.logErrors(); fs . writeFileSync ( './test/meta-test.js' , js ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "protocol", "to", "client", "request"], "add_tokens": "const DEFAULT_OPTIONS = { protocol : 'http:' } ; const buildUrl = ( protocol , base , prefix , path ) => ` ${ protocol } ${ join ( base , prefix , path ) } ` ; const url = buildUrl ( this . options . protocol , this . options . base , this . options . prefix , request . path ) ;", "del_tokens": "const DEFAULT_OPTIONS = { } ; const buildUrl = ( base , prefix , path ) => join ( base , prefix , path ) ; const url = buildUrl ( this . options . base , this . options . prefix , request . path ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "gulp", "task", "for", "minifying"], "add_tokens": "! RateIt | v1.0.25 / 1 /2 0 /2 0 16", "del_tokens": "! RateIt | v1.0.24 / 0 /1 4 /2 0 16", "commit_type": "add"}
{"commit_tokens": ["Add", "in", "-", "view", "-", "container", "directive"], "add_tokens": "describe ( \"in-view-container directive\" , function ( ) { it ( \"should trigger in-view when scrolling a container\" , function ( done ) { makeTestForHtml ( '<div in-view-container style=\"height:100px; overflow:scroll\">' + ' <div in-view=\"spy($inview)\"></div>' + ' <div style=\"height:200%\"></div>' + '</div>' ) . then ( function ( test ) { expect ( test . spy . calls . count ( ) ) . toBe ( 1 ) ; expect ( test . spy ) . toHaveBeenCalledWith ( true ) ; return test ; } ) . then ( lazyScrollTestElementTo ( 100 ) ) . then ( function ( test ) { expect ( test . spy . calls . count ( ) ) . toBe ( 2 ) ; expect ( test . spy ) . toHaveBeenCalledWith ( false ) ; } ) . then ( done ) ; } ) ; } ) ; element . scrollLeft = position [ 0 ] ; element . scrollTop = position [ 1 ] ; function lazyScrollTestElementTo ( pos ) { return function ( test ) { return scrollTo ( test . element [ 0 ] , pos , true ) . then ( function ( ) { return test ; } ) ; } }", "del_tokens": "element . scrollLeft += position [ 0 ] ; element . scrollTop += position [ 1 ] ;", "commit_type": "add"}
{"commit_tokens": ["Removing", "variable", "c", "from", "the", "scope", "of", "modules", "loaded", "by", "noder"], "add_tokens": "wrapper : \"/*jshint undef:true, -W069, -W055*/\\n(function(global,callEval,packagedConfig){\\n'use strict';\\n$NODER_CONTENT$\\n})((function(){return this;})(),function(){\\n/*jshint evil:true */\\neval(arguments[0]);\\n},function(){\\n$PACKAGED_CONFIG$\\n});\" ,", "del_tokens": "wrapper : \"/*jshint undef:true, -W069, -W055*/\\n(function(global,callEval,packagedConfig){\\n'use strict';\\n$NODER_CONTENT$\\n})((function(){return this;})(),function(c){\\n/*jshint evil:true */\\neval(c);\\n},function(){\\n$PACKAGED_CONFIG$\\n});\" ,", "commit_type": "remove"}
{"commit_tokens": ["Upgraded", "ossindex", "API", "in", "use"], "add_tokens": "var ossi = require ( 'ossindexjs' ) ;", "del_tokens": "var ossi = require ( './ossindex.js' ) ;", "commit_type": "upgrade"}
{"commit_tokens": ["Adding", "toString", "()", "to", "GeoPoint"], "add_tokens": "assert . equal ( data . geoPointValue . latitude , 50.1430847 ) ; assert . equal ( data . geoPointValue . longitude , - 122.947778 ) ; assert . equal ( data . geoPointValue . toString ( ) , 'GeoPoint { latitude: 50.1430847, longitude: -122.947778 }' ) ;", "del_tokens": "assert . equal ( 50.1430847 , data . geoPointValue . latitude ) ; assert . equal ( - 122.947778 , data . geoPointValue . longitude ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", ".", "io", "from", "from", "console", "log", "message"], "add_tokens": "console . info ( '[Segment] ' , arguments ) ; // eslint-disable-line no-console", "del_tokens": "console . info ( '[Segment.io] ' , arguments ) ; // eslint-disable-line no-console", "commit_type": "remove"}
{"commit_tokens": ["Remove", "private", "methods", "from", "cube"], "add_tokens": "* Tuple is an ordered collection of one or more members from different dimensions", "del_tokens": "* tuple - the set of members of each of the dimensions", "commit_type": "remove"}
{"commit_tokens": ["Made", "the", "version", "exposing", "compatible", "with", "the", "browser"], "add_tokens": "version : '0.0.1' ,", "del_tokens": "version : require ( '../package.json' ) . version ,", "commit_type": "make"}
{"commit_tokens": ["implemented", "IActivity", ".", "isReadyForClosing", "()"], "add_tokens": "this . _viewMode = null ; Object , function getModalResult ( ) { return null ; } , Object , function isReadyForClosing ( ) { return true ; } , FINAL , ria . mvc . ActivityViewMode , function getViewMode ( ) { return this . _viewMode ; } , [ [ ria . mvc . ActivityViewMode ] ] , FINAL , VOID , function setViewMode ( mode ) { this . _viewMode = mode ; _DEBUG && Object . defineProperty ( this , '_viewMode' , { writable : false } ) }", "del_tokens": "Object , function getModalResult ( ) { return null ; }", "commit_type": "implement"}
{"commit_tokens": ["Add", "exception", "to", "message", "about", "exceptions", "being", "added", "after", "test", "run", "has", "finished", ".", "Place", "wrong", "number", "of", "tests", "exception", "before", "the", "state", "is", "changed", "to", "finished", "."], "add_tokens": "run . state = finishedState ; this . _checkRunning ( 'exception (' + ( exception . message || exception ) + ')' ) ;", "del_tokens": "run . state = finishedState ; this . _checkRunning ( 'exception' ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "withArgs", "helper", "because", "no", "arrow", "functions", ":", "("], "add_tokens": "var slice = require ( './slice' ) ;", "del_tokens": "var slice = Function . prototype . call . bind ( Array . prototype . slice ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "missing", "docs", "-", "config", "-", "local", "dependency", "to", "docs", "-", "local"], "add_tokens": "gulp . task ( 'docs-local' , [ 'docs-config-local' , 'docs-default' ] , shell . task ( 'bundle exec jekyll build --config=_config.yml,_config_local.yml' , {", "del_tokens": "gulp . task ( 'docs-local' , [ 'docs-default' ] , shell . task ( 'bundle exec jekyll build --config=_config.yml,_config_local.yml' , {", "commit_type": "add"}
{"commit_tokens": ["use", "glob", ".", "hasMagic", "()"], "add_tokens": "glob = require ( 'glob' ) , exports . isGlob = glob . hasMagic ;", "del_tokens": "var regexGlobPattern = / [!^{}|*?+@] / ; function isGlob ( pattern ) { return regexGlobPattern . test ( pattern ) ; } exports . isGlob = isGlob ;", "commit_type": "use"}
{"commit_tokens": ["changed", "formatting", "for", "disk", "io", "metrics"], "add_tokens": "} else if ( / disk / . test ( metric . name ) ) {", "del_tokens": "} else if ( / disk\\-space / . test ( metric . name ) ) {", "commit_type": "change"}
{"commit_tokens": ["Added", "screens", "info", "methods", "to", "Window"], "add_tokens": "var screens ; if ( Platform . isPlask ) { screens = plask . Window . screensInfo ( ) ; } else if ( Platform . isBrowser ) { screens = [ { width : window . innerWidth , height : window . innerHeight , highdpi : window . devicePixelRatio } ] ; } else { screens = [ ] ; } getScreens : function ( ) { return screens ; } , getScreenWidth : function ( id ) { id = ( typeof ( id ) === 'undefined' ) ? 0 : id ; return screens [ id ] . width ; } , getScreenHeight : function ( id ) { id = ( typeof ( id ) === 'undefined' ) ? 0 : id ; return screens [ id ] . height ; } , getScreenDPI : function ( id ) { id = ( typeof ( id ) === 'undefined' ) ? 0 : id ; return screens [ id ] . highdpi ; } ,", "del_tokens": "var screens ; if ( Platform . isPlask ) { screens = plask . Window . screensInfo ( ) ; } else { screens = [ { width : window . innerWidth , height : window . innerHeight } ] ; }", "commit_type": "add"}
{"commit_tokens": ["Remove", "unnecessary", "buildTarget", "from", "install", "action"], "add_tokens": "const env = plugins ( options )", "del_tokens": "const env = plugins ( { ... options , buildTarget : 'test' } )", "commit_type": "remove"}
{"commit_tokens": ["use", "rework", "instead", "of", "clean", "-", "css", "to", "rebase", "urls"], "add_tokens": ". include ( this . rootPath ) compiler . render ( function ( err , data ) { // empty string will make the next compiler to have source, not compiled if ( data === '' ) { data = '\\n' ; } callback ( err , { path : path , data : data , map : map } ) ; } ) ;", "del_tokens": ". include ( sysPath . join ( this . rootPath ) ) compiler . render ( callback ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "tests", "for", "event", "handling", "(", "it", "actually", "works", "now", ":", "p"], "add_tokens": "this . timeout ( 5000 ) ; it ( 'should set and handle `<a>` click events set with .on(\"click\", fn)' , function ( done ) { var listenToThis = listener ( 'body a#listen-to-anchor' ) ; done ( ) ; a . href = './index.html' ; a . href = './index.html' ; var listen = listener ( 'form#listen-to-form' ) ; var form = document . createElement ( 'FORM' ) ; form . action = \"./\" ; var input = window . input = document . createElement ( 'INPUT' ) ; // form.submit();", "del_tokens": "it ( 'should set and handle multiple `<a>` click events set with .on(\"click\", fn)' , function ( done ) { var listenToThis = listener ( 'body a#listen-to-anchor' ) , count = 0 ; count ++ ; if ( count === 3 ) { done ( ) ; listenToThis . off ( 'click' , callback ) ; } a . style . display = 'none' ; a . click ( ) ; a . click ( ) ; a . style . display = 'none' ; var form , input , listen ; listen = listener ( 'form#listen-to-form' ) ; form = document . createElement ( 'FORM' ) ; form . style . display = 'none' ; input = window . input = document . createElement ( 'INPUT' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "named", "function", "expression", "to", "middleware"], "add_tokens": "return function session ( req , res , next ) { }", "del_tokens": "return function ( req , res , next ) { }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "past", "-", "EOF", "offset", "in", "buffer", "stream"], "add_tokens": "* @ param { Point } point * @ param { Boolean } [ exclude ] Exclude node’s s art a d e d p sitions f om * search nodeForPoint ( point , exclude ) { if ( Range . fromObject ( [ ctx . start , ctx . end ] ) . containsPoint ( point , exclude ) ) {", "del_tokens": "* @ param { Point } point nodeForPoint ( point ) { if ( Range . fromObject ( [ ctx . start , ctx . end ] ) . containsPoint ( point , true ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Change", "the", "max", "option", "to", "capacity", "."], "add_tokens": "var locals = LruMap ( null , options . capacity || options . max || Infinity ) ;", "del_tokens": "var locals = LruMap ( null , options . max || Infinity ) ;", "commit_type": "change"}
{"commit_tokens": ["Moved", "to", "Provider", "provided", "inherits", "."], "add_tokens": "JsonRpcProvider . inherits ( InfuraProvider ) ;", "del_tokens": "var inherits = require ( 'inherits' ) ; inherits ( InfuraProvider , JsonRpcProvider ) ;", "commit_type": "move"}
{"commit_tokens": ["Remove", "the", "hardcoded", "strictSSL", "=", "false", "value", "."], "add_tokens": "const requestSettings = ( client . settings && client . settings . request ) ? client . settings . request : { } ; // merge the 3 objects together, make the options be the thing that can override // request settings will be request specific stuff that is overriden during the initial creation of the client const req = Object . assign ( { } , baseOptions , options , requestSettings ) ;", "del_tokens": "strictSSL : false , // Just for testing since self signed certs // merge the 2 objects together, make the options be the thing that can override const req = Object . assign ( { } , baseOptions , options ) ;", "commit_type": "remove"}
{"commit_tokens": ["fix", "wrong", "require", "add", "index", ".", "js"], "add_tokens": "var Channel = require ( './channel' ) ;", "del_tokens": "var Channel = require ( './Channel' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "invalid", "AST", "parse", "that", "prevented", "startup"], "add_tokens": "// @ComputedType * @ method GQLEnum # GenerateEnumsProxyHandler / ** * Get handler for the Map backed Array Proxy * * @ memberof ! GQLEnum * @ method get * * @ param { mixed } obj the object targeted by the Proxy * @ param { string } key ` ` of the value being requested * @ return { mixed } the ` ` being requested * / / ** * Set handler for the Map backed Array Proxy . * * @ memberof ! GQLEnum * @ method set * * @ param { mixed } obj the object the Proxy is targeting * @ param { string } key a string ` ` being set * @ param { mixed } value the ` ` being assigned to ` ` * /", "del_tokens": "if ( ! ours ) { console . error ( 'Cannot find `ours`' ) ; console . error ( new Error ( '`ours` missing' ) ) ; continue ; } * @ method GenerateEnumsProxyHandler", "commit_type": "fix"}
{"commit_tokens": ["add", "two", "different", "rendering", "strategies"], "add_tokens": "var process = require ( './lib/tokens' ) ;", "del_tokens": "var process = require ( './lib/interpolate' ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "bogus", "dataform", "test", "and", "add", "a", "missing", "one"], "add_tokens": "} // XXX SECURITY ALERT: sanity check propstr before eval'ing it!! NIY var rv ; } html_attrs [ 'class' ] = _class + ' ' + bindClass ; // Exported methods df . selected = function ( trueP ) { if ( trueP ) { // exception NIY : unexpected bindclass \"%s\" when setting a default unchecked value if ( ! prop ) { prop = '' ; } rv += parseSimpleOptionsArray ( options , selection ) ; } }", "del_tokens": "} // XXX SECURITY ALERT: sanity check propstr before eval'ing it!! NIY var rv ; } html_attrs [ 'class' ] = _class + ' ' + bindClass ; // Exported methods df . selected = function ( trueP ) { if ( trueP ) { // exception NIY : unexpected bindclass \"%s\" when setting a default unchecked value if ( prop === null ) { prop = 'none' ; } rv += parseSimpleOptionsArray ( options , selection ) ; } }", "commit_type": "fix"}
{"commit_tokens": ["Adding", "ability", "to", "pass", "an", "error", "to", "the", "setup", "callback", "to", "shut", "down", "the", "module"], "add_tokens": "self . options . setup ( self , function setupCallback ( e ) { callback ( e , setupCallback ) ; self . _setup ( function ( e , setupCallback ) { if ( e ) { self . fail ( \"Failed to setup module\" , setupCallback , e ) ; return self . close ( ) ; } // Run test", "del_tokens": "self . options . setup ( self , function setupCallback ( ) { callback ( ) ; self . _setup ( function ( ) {", "commit_type": "add"}
{"commit_tokens": ["add", "repos", "and", "activity", "endpoints", "w", "/", "example"], "add_tokens": "import GitHub from '../src' import bosom from 'bosom' try { const token = await bosom ( '.token.json' ) const name = 'github-example' const org = 'rqt' const github = new GitHub ( token ) const repo = await github . repos . create ( { name , org , homepage : 'https://rqt.biz' , license_template : 'mit' , description : 'An example repository.' , auto_init : true , gitignore_template : 'Node' , } ) console . log ( repo . html_url ) await github . activity . star ( org , name ) await github . repos . delete ( org , name ) } catch ( { message } ) { console . log ( message ) }", "del_tokens": "import github from '../src' const res = await github ( { text : 'example' , } ) console . log ( res )", "commit_type": "add"}
{"commit_tokens": ["Add", "cli", "-", "engine", "test", "cases", "(", "OK", "and", "NG", "cases", ")"], "add_tokens": "throw new Error ( \"Input path of too many\" ) ; throw new Error ( \"Must specify input path\" ) ; src = ` ${ src } ` ;", "del_tokens": "throw new Error ( \"Specify input path of too many\" ) ; throw new Error ( \"Must be specify input path\" ) ; src = ` ${ src } ` ;", "commit_type": "add"}
{"commit_tokens": ["Added", ".", "off", "()", "to", "pixels", "and", "a", "couple", "of", "tidy", "ups", "on", "documenttion", "and", "examples"], "add_tokens": "var fps = 10 ; // how many frames per second do you want to try?", "del_tokens": "var fps = 30 ; // how many frames per second do you want to try?", "commit_type": "add"}
{"commit_tokens": ["fixing", "wrap", "which", "should", "have", "been", "inserting", "json"], "add_tokens": "jsonParentPath = \"\" , if ( hasTagAttribute ( jsonPathAttribute , content ) ) jsonParentPath = getTagAttribute ( jsonPathAttribute , content ) ; if ( jsonParentPath && jsonParentPath !== \"this\" ) { content [ 0 ] = appendJsonParentPath ( content [ 0 ] , jsonParentPath ) ; content [ 1 ] = appendJsonParentPath ( content [ 1 ] , jsonParentPath ) ; } if ( jsonParentPath && jsonParentPath !== \"this\" ) console . log ( jsonPath ) ;", "del_tokens": "if ( jsonParentPath )", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "http", "proxy", "environment", "variables"], "add_tokens": "var protocol = parsedUrl . protocol . replace ( ':' , '' ) ; var interface = protocol === 'http' ? http : https ; if ( process . env [ ` ${ protocol } ` ] ) { / * * Proxied requests don 't work with Node' s https module so use http to * talk to the proxy server regardless of the endpoint protocol . This * is unsuitable for environments where requests are expected to be * using end - to - end TLS . * / interface = http ; const proxyUrl = url . parse ( process . env . http_proxy ) ; options = { hostname : proxyUrl . hostname , port : proxyUrl . port , path : parsedUrl . href , method : method , headers : { host : parsedUrl . host , ... headers , } } ; } module . exports = httpRequest ;", "del_tokens": "var isHttp = parsedUrl . protocol === 'http:' ; var interface = isHttp ? http : https ; module . exports = httpRequest ;", "commit_type": "add"}
{"commit_tokens": ["Adds", "Webpack", "5", "watch", "mode", "support"], "add_tokens": "if ( finalWatchFileSystem && ( finalWatchFileSystem . watcher . fileWatchers . size || finalWatchFileSystem . watcher . fileWatchers . length ) ) { var fileWatchers = finalWatchFileSystem . watcher . fileWatchers instanceof Map ? Array . from ( finalWatchFileSystem . watcher . fileWatchers . values ( ) ) : finalWatchFileSystem . watcher . fileWatchers ; fileWatchers . forEach ( function ( fileWatcher ) { delete fileWatcher . directoryWatcher . _cachedTimeInfoEntries ; fileWatcher . directoryWatcher . setFileTime ( filePath , time , false , false , null ) ;", "del_tokens": "if ( finalWatchFileSystem && finalWatchFileSystem . watcher . fileWatchers . length ) { finalWatchFileSystem . watcher . fileWatchers . forEach ( function ( fileWatcher ) { self . _compiler . fileTimestamps instanceof Map && self . _compiler . fileTimestamps . set ( file , + stats . mtime ) ; const virtualFiles = self . _compiler . inputFileSystem . _virtualFiles ; if ( virtualFiles ) { Object . keys ( virtualFiles ) . forEach ( function ( file ) { self . _compiler . fileTimestamps instanceof Map && self . _compiler . fileTimestamps . set ( file , + virtualFiles [ file ] . stats . mtime ) ; } ) ; }", "commit_type": "add"}
{"commit_tokens": ["add", "props", "and", "one", "more", "statement", "for", "false", "evaluations"], "add_tokens": "const result = tag ( attrs ) } else if ( child === false ) { // expression evaluated as false e.g. {false && <Elem />} console . log ( 'not appendable' , tag , attrs , children , child ) ;", "del_tokens": "const result = tag ( ) console . log ( 'not appendable' , child ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "PSON", "to", "benchmarks", "."], "add_tokens": ". on ( 'data' , function ( record ) { bufs . push ( record . $encode ( ) ) ; } )", "del_tokens": ". on ( 'data' , function ( record ) { bufs . push ( record . $encode ( true ) ) ; } )", "commit_type": "add"}
{"commit_tokens": ["added", "LIKE", "and", "NOT", "LIKE", "operators"], "add_tokens": "var regExpLIKE = require ( 'regexp-like' ) . cached ; '≠': { t st: f nction(a , b { r turn a ! = b } S L: ' >' } LIKE : { test : function ( a , b ) { return regExpLIKE ( b ) . test ( a ) ; } } , 'NOT LIKE' : { test : function ( a , b ) { return ! regExpLIKE ( b ) . test ( a ) ; } }", "del_tokens": "'≠': { t st: f nction(a , b { r turn a ! = b } S L: ' >' }", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "replyAndUpdate", "in", "Slack"], "add_tokens": "describe ( 'support replyAndUpdate' , ( ) => { beforeEach ( ( ) => { this . controller = Botmock ( { debug : false , } ) ; this . bot = this . controller . spawn ( { type : 'slack' } ) ; } ) ; it ( 'should log the updated message to replies as well' , ( ) => { this . userMessage = { user : 'some user id' , channel : 'some channel' } ; this . bot . replyAndUpdate ( this . userMessage , 'hello' , ( err , src , updateResponse ) => { updateResponse ( 'changed' , ( err ) => { if ( err ) fail ( this , err ) ; } ) ; assert . equal ( this . bot . detailed_answers [ this . userMessage . channel ] [ 0 ] . text , 'hello' ) ; assert . equal ( this . bot . detailed_answers [ this . userMessage . channel ] [ 1 ] . text , 'changed' ) ; } ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Update", "to", "new", "node", "-", "get", "with", "content", "-", "disposition", "test"], "add_tokens": "// Filename to Mapnik type var extToMapnik = { '.csv' : 'csv' } ; function download ( l , filepath , callback ) { var url = l . Datasource . file ; ( new get ( url ) ) . toDisk ( dl , function ( err , file , response , g ) { var guessed_ext = g . guessResponseExtension ( response ) ; if ( guessed_ext && extToMapnik [ guessed_ext ] ) { l . Datasource . type = extToMapnik [ guessed_ext ] ; } download ( l , filepath , symlink ) ;", "del_tokens": "function download ( url , filepath , callback ) { ( new get ( url ) ) . toDisk ( dl , function ( err , file ) { pool . release ( obj ) ; download ( l . Datasource . file , filepath , symlink ) ;", "commit_type": "update"}
{"commit_tokens": ["Allow", "#", "characters", "in", "paths", "to", "specify", "precise", "tree", "positions"], "add_tokens": "while ( match = / ^\\s*#([\\w$]+)(?:=([^\"]\\S*|\"(?:[^\"\\\\]|\\\\.)*\"))?\\s* / . exec ( text ) ) {", "del_tokens": "while ( match = / ^\\s*#([\\w$]+)(?:=([\\w\\.$]+|\"(?:[^\"\\\\]|\\\\.)*\"))?\\s* / . exec ( text ) ) {", "commit_type": "allow"}
{"commit_tokens": ["Use", "a", "symbol", "for", "binding", ".", "shouldRename"], "add_tokens": "var kShouldRename = Symbol ( 'should rename binding' ) binding [ kShouldRename ] = rows . usedGlobalVariables . has ( name ) if ( binding [ kShouldRename ] ) {", "del_tokens": "binding . shouldRename = rows . usedGlobalVariables . has ( name ) if ( binding . shouldRename ) {", "commit_type": "use"}
{"commit_tokens": ["add", "sinon", "as", "available", "karma", "framework"], "add_tokens": "frameworks : [ 'jasmine' , 'sinon' ] , 'test/leSpec.js'", "del_tokens": "frameworks : [ 'jasmine' ] , 'test/*.js'", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "the", "done", "()", "callback", "is", "invoked", "when", "processing", "server", ":", "restart", "."], "add_tokens": "done ( ) ;", "del_tokens": "done ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Move", "mean", "to", "Numbers", "type"], "add_tokens": "import add from './add' * @ category Number * mean ( [ ] ) // => 0 * mean ( ) // => 0 return x . reduce ( add , 0 ) / x . length", "del_tokens": "* @ category Array * mean ( [ ] ) // => NaN * mean ( ) // => NaN return x . reduce ( ( a , v ) => a + v , 0 ) / x . length", "commit_type": "move"}
{"commit_tokens": ["Updated", "configuration", "test", "files", "."], "add_tokens": "'BS_IE_10_win7' : { os_version : '7' } , 'BS_IE_11_win7' : { base : 'BrowserStack' , browser : 'ie' , browser_version : '11.0' , os : 'Windows' , os_version : '7' } , 'BS_IE_11' : { base : 'BrowserStack' , browser : 'ie' , browser_version : '11.0' , os : 'Windows' , os_version : '10' browsers : [ 'BS_Chrome' , 'BS_Safari' , 'BS_Firefox' , 'BS_Firefox_mac' , 'BS_IE_10_win7' , 'BS_IE_11_win7' , 'BS_IE_11' , 'BS_EDGE' ] ,", "del_tokens": "'BS_IE_10' : { os_version : '8' browsers : [ 'BS_Chrome' , 'BS_Safari' , 'BS_Firefox' , 'BS_Firefox_mac' , 'BS_IE_10' , 'BS_EDGE' ] ,", "commit_type": "update"}
{"commit_tokens": ["Move", "from", "SASS", "to", "LESS"], "add_tokens": "dataRotate . value = typeof data . rotate !== 'undefined' ? data . rotate : '' ; dataScaleX . value = typeof data . scaleX !== 'undefined' ? data . scaleX : '' ; dataScaleY . value = typeof data . scaleY !== 'undefined' ? data . scaleY : '' ; e . preventDefault ( ) ; e . preventDefault ( ) ; e . preventDefault ( ) ; e . preventDefault ( ) ;", "del_tokens": "var console = window . console || { log : function ( ) { } } ; var isUndefined = function ( obj ) { return typeof obj === 'undefined' ; } ; dataRotate . value = ! isUndefined ( data . rotate ) ? data . rotate : '' ; dataScaleX . value = ! isUndefined ( data . scaleX ) ? data . scaleX : '' ; dataScaleY . value = ! isUndefined ( data . scaleY ) ? data . scaleY : '' ; function preventDefault ( e ) { if ( e ) { if ( e . preventDefault ) { e . preventDefault ( ) ; } else { e . returnValue = false ; } } } preventDefault ( e ) ; preventDefault ( e ) ; preventDefault ( e ) ; preventDefault ( e ) ;", "commit_type": "move"}
{"commit_tokens": ["Add", ".", "debug", "()", "method", "to", "ReactWrapper"], "add_tokens": "* Returns an HTML - like string of the shallow render for debugging purposes .", "del_tokens": "* Returns an html - like string of the shallow render for debugging purposes .", "commit_type": "add"}
{"commit_tokens": ["add", "expiration", "for", "rpt", "and", "permission", "tickets"], "add_tokens": "async function addObject ( hashName , user , objectId , object , ttlInMs ) { if ( ttlInMs > 0 ) { return await redisClient . set ( keyname , JSON . stringify ( object ) , \"px\" , ttlInMs ) ; } else { return await redisClient . set ( keyname , JSON . stringify ( object ) ) ; } const TICKET_TTL = parseInt ( process . env . PERMISSION_TICKET_TTL ) || 20 ; return await addObject ( PERMISSIONS_HASH , user , permissionId , permission , TICKET_TTL * 1000 ) ; const RPT_TTL = parseInt ( process . env . RPT_TTL ) || 20 ; return await addObject ( RPTS_HASH , user , permissionId , permission , RPT_TTL * 1000 ) ; return await addObject ( POLICIES_HASH , user , policyId , policy , - 1 ) ;", "del_tokens": "//todo: add automatic expiration as another parameter async function addObject ( hashName , user , objectId , object ) { //client.set('foo', 'bar', 'px', 100, helper.isString('OK')); await redisClient . set ( keyname , JSON . stringify ( object ) ) ; await addObject ( PERMISSIONS_HASH , user , permissionId , permission ) await addObject ( RPTS_HASH , user , permissionId , permission ) await addObject ( POLICIES_HASH , user , policyId , policy ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "build", "scripts", "&", "remove", "obselete", "code"], "add_tokens": "import babel from 'rollup-plugin-babel' ; import commonjs from 'rollup-plugin-commonjs' ; import resolve from 'rollup-plugin-node-resolve' ; import { terser } from 'rollup-plugin-terser' ; jimp : 'window.jimp' , // fake jimp to document to avoid jimp load error resolve ( ) , commonjs ( ) , \"targets\" : \"> 0.25%, not dead\" jimp : 'window.jimp' , // fake jimp to document to avoid jimp load error resolve ( ) , commonjs ( ) , \"targets\" : \"> 0.25%, not dead\" jimp : 'window.jimp' , // fake jimp to document to avoid jimp load error resolve ( ) , commonjs ( ) , \"targets\" : \"> 0.25%, not dead\"", "del_tokens": "import babel from 'rollup-plugin-babel' import commonjs from 'rollup-plugin-commonjs' import resolve from 'rollup-plugin-node-resolve' import { terser } from 'rollup-plugin-terser' jimp : 'document' , // fake jimp to document to avoid jimp load error corejs : '3.0.0' , useBuiltIns : 'entry' , resolve ( ) , commonjs ( ) , jimp : 'document' , // fake jimp to document to avoid jimp load error corejs : '3.0.0' , useBuiltIns : 'entry' , resolve ( ) , commonjs ( ) , jimp : 'document' , // fake jimp to document to avoid jimp load error corejs : '3.0.0' , useBuiltIns : 'entry' , resolve ( ) , commonjs ( ) ,", "commit_type": "fix"}
{"commit_tokens": ["add", "per", "-", "arc", "coloring", "support"], "add_tokens": "color : [ i % 255 , 255 - i % 255 , Math . floor ( i / 255 ) % 255 ]", "del_tokens": "colors : { c0 : [ 255 , 0 , 0 ] , c1 : [ 0 , 0 , 255 ] }", "commit_type": "add"}
{"commit_tokens": ["change", "this", "to", "window", "in", "order", "to", "make", "uglifying", "more", "reliable"], "add_tokens": "window [ \"moment\" ] = require ( \"moment-jalaali\" ) ;", "del_tokens": "this [ \"moment\" ] = require ( \"moment-jalaali\" ) ;", "commit_type": "change"}
{"commit_tokens": ["fixing", "bug", "with", "error", "handling"], "add_tokens": "if ( err . status && err . status >= 400 && err . status < 600 ) { res . send ( { error : err . msg || err . message || 'unknown error' } ) ;", "del_tokens": "if ( err . status && err . msg && err . status >= 400 && err . status < 600 ) { res . send ( { error : err . msg } ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "font", "support", "for", "browser"], "add_tokens": "eventCount : 0 italic : \"SourceSansPro-ExtraLightItalic.ttf\" italic : \"SourceSansPro-LightItalic.ttf\" italic : \"SourceSansPro-Italic.ttf\" italic : \"SourceSansPro-SemiboldItalic.ttf\" italic : \"SourceSansPro-BoldItalic.ttf\" italic : \"SourceSansPro-BlackItalic.ttf\" } } } amino . native . registerFont ( args ) ; descender : amino . sgtest . getFontDescender ( size , this . getNative ( size , weight , style ) ) registerFont : function ( args ) { fontmap [ args . name ] = new JSFont ( args ) ; } , h : size . h / Core . DPIScale } \"cliprect\" : 34 } ; } ; } ; } ; } ; } ; } ; } ;", "del_tokens": "eventCount : 0 , italic : \"SourceSansPro-ExtraLightItalic.ttf\" , italic : \"SourceSansPro-LightItalic.ttf\" , italic : \"SourceSansPro-Italic.ttf\" , italic : \"SourceSansPro-SemiboldItalic.ttf\" , italic : \"SourceSansPro-BoldItalic.ttf\" , italic : \"SourceSansPro-BlackItalic.ttf\" , } , } , } , fontmap [ args . name ] = new JSFont ( args ) ; descender : amino . sgtest . getFontDescender ( size , this . getNative ( size , weight , style ) ) , h : size . h / Core . DPIScale , } , \"cliprect\" : 34 , } } } } } } } }", "commit_type": "fix"}
{"commit_tokens": ["Adding", "roles", "to", "private", "media", "files"], "add_tokens": "const Promise = require ( 'bluebird' ) ; Key : operation . target , ContentType : operation . contentType } ) . catch ( function ( err ) { if ( err . message . indexOf ( 'This copy request is illegal because it is trying to copy an object to itself' ) === 0 ) { return ; } if ( err . message . indexOf ( 'The specified key does not exist' ) === 0 ) { return ; } console . error ( operation ) ; return Promise . reject ( err ) ; if ( operation . source == operation . target ) { return ; }", "del_tokens": "Key : operation . target", "commit_type": "add"}
{"commit_tokens": ["Change", "how", "config", "works", ";", "consistency", "between", "commandline", "and", "mendelrc"], "add_tokens": "var name = self . config . manifest . replace ( 'bundle' , bundleId ) ; var bundlePath = path . join ( self . config . outdir , name ) ; self . bundles [ bundleId ] = require ( path . resolve ( bundlePath ) ) ; var entry = this . config . bundles [ bundle ] . outfile ;", "del_tokens": "var bundlePath = path . join ( self . config . basedir , self . config . dest , bundleId + '.manifest.json' ) ; self . bundles [ bundleId ] = require ( bundlePath ) ; var entry = this . config . bundles [ bundle ] . dest ;", "commit_type": "change"}
{"commit_tokens": ["added", "the", "configuration", "option", "for", "generating", "examples"], "add_tokens": "if ( options . generateExamples ) { generate ( ) ; }", "del_tokens": "generate ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "error", "handling", "to", "loadImage"], "add_tokens": "img . onerror = function ( ) { callback ( new Error ( 'Failed to load ' + url ) , null ) } } catch ( e ) { callback ( new Error ( e + ' ' + '\"' + path + '\"' ) , null )", "del_tokens": "} catch ( e ) { callback ( e + ' ' + '\"' + path + '\"' , null )", "commit_type": "add"}
{"commit_tokens": ["move", "stringify", "alignment", "to", "transforms"], "add_tokens": "test ( 'preserve formatting' , ( ) => {", "del_tokens": "test ( 'no formatting' , ( ) => { test ( 'align' , ( ) => { const source = ` / ** * Description may go * over multiple lines followed by @ tags * * @ my - tag { my . type } my - name description line 1 description line 2 * description line 3 * / `; const parsed = parse ( source ) ; const out = stringify ( parsed [ 0 ] , { format : 'align' } ) ; expect ( out ) . toBe ( ` / ** * Description may go * over multiple lines followed by @ tags * * @ my - tag { my . type } my - name description line 1 description line 2 * description line 3 * / `.slice(1) ) ; } ) ;", "commit_type": "move"}
{"commit_tokens": ["fixed", "no", "classess", "issue", "with", "filtering"], "add_tokens": "return Array . isArray ( arr ) && arr . filter ( function ( v , i , a ) { return a . indexOf ( v ) === i } ) || [ ] ; if ( ! str ) return ;", "del_tokens": "return arr . filter ( function ( v , i , a ) { return a . indexOf ( v ) === i } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "passing", "-", "through", "client", "cert", "and", "key"], "add_tokens": "auth : request . auth , key : request . key , cert : request . cert", "del_tokens": "auth : request . auth", "commit_type": "add"}
{"commit_tokens": ["Created", "updated", "docs", "and", "lib", "with", "the", "new", "build", "process", "."], "add_tokens": "s . buildDate = /*date*/ \"Tue, 10 Sep 2013 20:15:03 GMT\" ; // injected by build process", "del_tokens": "s . buildDate = /*date*/ \"Fri, 02 Aug 2013 20:46:42 GMT\" ; // injected by build process", "commit_type": "create"}
{"commit_tokens": ["Fix", "null", "values", "causing", "validateHash", "to", "fail"], "add_tokens": "validHash = a [ field ] === b [ field ] || jasmine . flight . validateHash ( a [ field ] , b [ field ] ) ;", "del_tokens": "validHash = jasmine . flight . validateHash ( a [ field ] , b [ field ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["updating", "local", "proxy", "agent", "to", "work", "with", "http", "urls"], "add_tokens": "var agentFactories = { 'https:https:' : tunnelAgent . httpsOverHttps , 'https:http:' : tunnelAgent . httpsOverHttp , 'http:https:' : tunnelAgent . httpOverHttps , 'http:http:' : tunnelAgent . httpOverHttp } ; function getAgentFactory ( targetProtocol , proxyProtocol ) { return agentFactories [ targetProtocol + proxyProtocol ] . bind ( tunnelAgent ) ; } module . exports = function ( agentConfig ) { var headers = agentConfig . headers , target = agentConfig . target , proxy = agentConfig . proxy ; return getAgentFactory ( target . protocol , proxy . protocol ) ( { host : proxy . hostname , port : proxy . port ,", "del_tokens": "module . exports = function ( headers ) { return tunnelAgent . httpsOverHttp ( { host : '127.0.0.1' , port : 8888 ,", "commit_type": "update"}
{"commit_tokens": ["Use", "toggle", "decorator", "for", "dropdown"], "add_tokens": "import withToggle from './../../decorators/withToggle' keyCode withToggle , onClickOutside ,", "del_tokens": "keyCode , withStateHandlers ( { isOpen : false , } , { toggle : ( { isOpen } ) => event => ( { isOpen : ! isOpen } ) , hide : ( { isOpen } ) => ( ) => ( { isOpen : false } ) , } ) , onClickOutside", "commit_type": "use"}
{"commit_tokens": ["Make", "all", "examples", "use", "arrows"], "add_tokens": "var a = new Project ( { a . collect ( ( error , entries ) => { var b = new Project ( { b . exclude ( [ 'b.js' ] ) ; b . exclude ( [ 'c.*' ] ) ; var p = b . collect ( ( error , entries ) => { console . log ( 'CALLBACK: b' , entries . length ) ; entries . forEach ( entry => console . log ( entry ) ) ; console . log ( 'RESOLVED: b' , entries . length ) ;", "del_tokens": "var b = new Project ( { b . collect ( function ( error , entries ) { var c = new Project ( { c . exclude ( [ 'b.js' ] ) ; c . exclude ( [ 'c.*' ] ) ; var p = c . collect ( function ( error , entries ) { console . log ( 'CALLBACK: c' , entries . length ) ; entries . forEach ( entry => console . log ( entry . file ) ) ; console . log ( 'RESOLVED: c' , entries . length ) ;", "commit_type": "make"}
{"commit_tokens": ["remove", "unused", "-", "moz", "-", "and", "-", "ms", "-", "prefixes", "to", "reduce", "output", "payload"], "add_tokens": "line = '-webkit-' + line + ( line . charCodeAt ( 5 ) === 102 ? '-ms-' + line : '' ) + line ;", "del_tokens": "line = '-webkit-' + line + ( line . charCodeAt ( 5 ) === 102 ? ( '-ms-' + line ) : '' ) + line ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "support", "for", "fixed", "width", "template", "elements"], "add_tokens": "t . is ( cursor [ test . cmd ] ? cursor [ test . cmd ] [ test . arg ] : null , test ( \"hide\" , function ( t ) { process . stderr . isTTY = false process . stderr . isTTY = true process . stderr . columns = 11 process . stderr . columns = 16 process . stderr . isTTY = false bar . template [ 0 ] . length = 6 process . stderr . isTTY = true [ 'write' , 'NAME |#-----|\\n' ] , [ 'write' , 'S \\\\ |----|\\n' ] ,", "del_tokens": "t . is ( cursor [ test . cmd ] ? cursor [ test . cmd ] [ test . arg ] : null , test ( \"hide\" , function ( t ) { process . stdout . isTTY = false process . stdout . isTTY = true process . stdout . columns = 10 process . stdout . columns = 16 process . stdout . isTTY = false process . stdout . isTTY = true [ 'write' , 'NAME |#-------|\\n' ] , [ 'write' , 'S \\\\ |#--------|\\n' ] ,", "commit_type": "add"}
{"commit_tokens": ["Added", "syntax", "highlighting", "+", "credits", "to", "the", "README"], "add_tokens": "* A wrapper for the Redis sorted set ( zset ) type . Each element has a", "del_tokens": "* A wrapper for the Redis sorted set ( zset ) type . Each element has an", "commit_type": "add"}
{"commit_tokens": ["Fix", "the", "URL", "in", "foa", "-", "decoder", "and", "add", "new", "HRIRs", "for", "future", "update", "."], "add_tokens": "var HRTFSET_URL = 'https://raw.githubusercontent.com/GoogleChrome/omnitone/master/build/resources/' ;", "del_tokens": "var HRTFSET_URL = 'https://raw.githubusercontent.com/GoogleChrome/omnitone/master/src/resources' ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "Stylus", "configuration", "from", "commonplace", "."], "add_tokens": ". pipe ( stylus ( MKT_CONFIG . stylusConfig ) )", "del_tokens": ". pipe ( stylus ( { compress : true } ) )", "commit_type": "use"}
{"commit_tokens": ["Added", "cojoined", "getter", "and", "setter", "style", "helpers", "and", "augmented", "sjl", ".", "extend", "with", "them", "."], "add_tokens": "/**! sjl-utilities-only.js Sat Jun 21 2014 12:44:07 GMT-0400 (Eastern Daylight Time) **/ / **", "del_tokens": "/**! sjl-utilities-only.js Thu Jun 19 2014 01:32:01 GMT-0400 (Eastern Daylight Time) **/ / **", "commit_type": "add"}
{"commit_tokens": ["Update", "todo", "s", "so", "I", "know", "which", "are", "needed", "for", "m1", "release", ".", "Add", "tests", "for", "accordion", "management", "on", "graph", "management", "and", "implement", "appropriate", "fixes"], "add_tokens": "for ( var i = 0 ; i < $scope . graphs . length ; i ++ ) { $scope . isOpen [ $scope . graphs [ i ] . id ] = false ; } $scope . isOpen [ id ] = false ; if ( $scope . graphs . length > 0 ) { var prevGraph = index == 0 ? 0 : index - 1 ; $scope . isOpen [ $scope . graphs [ prevGraph ] . id ] = true ; } else { $scope . firstOpen = true ; }", "del_tokens": "// Q: is it always this one open? // A: yes - currently you can only add a graph from the top section", "commit_type": "update"}
{"commit_tokens": ["add", "and", "improve", "comment", "lines"], "add_tokens": "//* / TODO remove on prod this . log ( chalk . blue ( '<<<<<BEFORE' ) ) ; this . log ( chalk . blue ( 'json' ) ; this . log ( this . fs . readJSON ( files . config ) ) ; //* / TODO remove on prod this . log ( chalk . blue ( 'AFTER>>>>>' ) ) ; this . log ( chalk . blue ( 'entityConfig' ) ) ; this . log ( this . entityConfig ) ; this . log ( chalk . blue ( 'fields' ) ) ; this . log ( this . fields ) ; this . log ( chalk . blue ( 'json' ) ; this . log ( this . fs . readJSON ( files . config ) ) ; this . log ( chalk . blue ( 'jhipsterVar' ) ) ; this . log ( jhipsterVar ) ; //*/", "del_tokens": "/ * / TODO remove on prod this . log ( this . entityConfig ) ; this . log ( this . fs . readJSON ( files . config ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "error", "in", "assigning", "txDate", "to", "transactions"], "add_tokens": "// console.log(i, tx.paymentNumber); tx . paymentDueDate = i > 0 && loan . amortizationTable [ tx . paymentNumber ] ? loan . amortizationTable [ tx . paymentNumber - 1 ] . txDate : loan . firstPaymentDate ;", "del_tokens": "console . log ( i , tx . paymentNumber ) ; tx . paymentDueDate = i > 0 ? loan . amortizationTable [ tx . paymentNumber - 1 ] . txDate : loan . firstPaymentDate ;", "commit_type": "fix"}
{"commit_tokens": ["add", "todo", "item", ":", "export", "tasks", "using", "registry", "so", "we", "don", "t", "have", "to", "pass", "gulp", "in", "configure", "()", "."], "add_tokens": "// TODO: export recipes using [Undertaker](https://github.com/gulpjs/undertaker#custom-registries) registry, so we need pass gulp no more.", "del_tokens": "// TODO: consider exporting recipes using [Undertaker](https://github.com/gulpjs/undertaker#custom-registries) registry.", "commit_type": "add"}
{"commit_tokens": ["moved", "object", "initialization", "to", "prevent", "awkward", "crash"], "add_tokens": "taskOverrides = taskOverrides || { } ;", "del_tokens": "taskOverrides = taskOverrides || { } ;", "commit_type": "move"}
{"commit_tokens": ["add", "small", "comment", "on", "getter"], "add_tokens": "get outputs ( ) { // output is kept as state for backpropagation", "del_tokens": "get outputs ( ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "prefer", "-", "filter", "to", "only", "warn", "when", "forEach", "has", "single", "param"], "add_tokens": "return astUtil . hasOnlyOneStatement ( func ) && func . params . length === 1 && isIfWithoutElse ( firstLine ) && canBeShorthand ( firstLine . test , astUtil . getFirstParamName ( func ) ) ;", "del_tokens": "return astUtil . hasOnlyOneStatement ( func ) && isIfWithoutElse ( firstLine ) && canBeShorthand ( firstLine . test , astUtil . getFirstParamName ( func ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "totalPages", "fix", "out", "of", "range", "pages"], "add_tokens": "var pager = $ ( '.paging_pagenums_container' ) ; var totalPages = pager . length > 0 ? parseInt ( pager . text ( ) , 10 ) : 1 ; return totalPages ; totalPages : [ ] if ( page > totalPages ) { return Promise . resolve ( ) ; } var totalPages = getPlayers ( first !== - 1 ? group : null , i , role , 1 , body , all ) ; group . totalPages . push ( { role : role , total : totalPages } ) ;", "del_tokens": "var total = parseInt ( $ ( '[name=\"ctl00$cphRoblox$rbxGroupRoleSetMembersPane$RolesetCountHidden\"]' ) . attr ( 'value' ) , 10 ) ; return total ; total : 0 var totalPlayers = getPlayers ( first !== - 1 ? group : null , i , role , 1 , body , all ) ; var totalPages = Math . ceil ( totalPlayers / maxPageSize ) ; if ( all && ! group . total ) { group . total = parseInt ( parser . load ( response . body ) ( '#MemberCount' ) . text ( ) . substring ( 9 ) , 10 ) ; } else if ( ! all ) { group . total += totalPlayers ; }", "commit_type": "use"}
{"commit_tokens": ["fix", "merge", "issues", ";", "revert", "back", "to", "using", "_", ".", "map", "for", "now", "--", "find", "better", "alternative", "later"], "add_tokens": "throw new Error ( 'Falied to extend ModelArray.classMethod. ' + throw new Error ( 'Falied to extend ModelArray.instanceMethod. ' +", "del_tokens": "< << << << Updated upstream === === = throw new Error ( 'Falied to extend Model.classMethod. ' + throw new Error ( 'Falied to extend Model.instanceMethod. ' + >>> >>> > Stashed changes", "commit_type": "fix"}
{"commit_tokens": ["Add", "option", "for", "Cancel", "button", "text", "and", "upload", "fail", "status", "text", "."], "add_tokens": "cancelButtonText : 'Cancel' , failUploadText : 'Cancel' , '<a class=\"qq-upload-cancel\" href=\"#\">{cancelButtonText}</a>' + '<span class=\"qq-upload-failed-text\">{failUploadtext}</span>' + // same for the Cancel button and Fail message text this . _options . template = this . _options . template . replace ( / \\{uploadButtonText\\} / g , this . _options . uploadButtonText ) ; this . _options . fileTemplate = this . _options . fileTemplate . replace ( / \\{cancelButtonText\\} / g , this . _options . cancelButtonText ) ; this . _options . fileTemplate = this . _options . fileTemplate . replace ( / \\{failUploadtext\\} / g , this . _options . failUploadtext ) ;", "del_tokens": "'<a class=\"qq-upload-cancel\" href=\"#\">Cancel</a>' + '<span class=\"qq-upload-failed-text\">Failed</span>' + this . _options . template = this . _options . template . replace ( / \\{uploadButtonText\\} / g , this . _options . uploadButtonText ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "SASS", "isomorphic", "-", "fetch"], "add_tokens": "var webpackMerge = require ( 'webpack-merge' ) ; var sass = require ( 'gulp-sass' ) ; var streamqueue = require ( 'streamqueue' ) ; 'process.env.NODE_ENV' : JSON . stringify ( 'production' ) var stylusStyles = gulp . src ( [ } ) ) ; var sassStyles = gulp . src ( 'app/styles/scss/**/*.scss' ) . pipe ( sass ( { errLogToConsole : true } ) ) ; return streamqueue ( { objectMode : true } , stylusStyles , sassStyles ) . pipe ( gulp . dest ( dest + '/static/css' ) ) ; gulp . watch ( 'app/**/*.styl' , [ 'styles' ] ) ; gulp . watch ( 'app/**/*.scss' , [ 'styles' ] ) ; new WebpackDevServer ( webpack ( webpackMerge ( webpackConfig , { devtool : 'eval' } ) ) , { } ) ;", "del_tokens": "var merge = require ( 'webpack-merge' ) ; 'process.env.NODE_ENV' : JSON . stringify ( 'development' ) return gulp . src ( [ } ) ) . pipe ( gulp . dest ( dest + '/static/css' ) ) gulp . watch ( 'app/**/*.styl' , [ 'styles' ] ) new WebpackDevServer ( webpackStream ( merge ( webpackConfig , { devtool : 'eval' } ) ) , { } )", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "ngn", "-", "dev", "module"], "add_tokens": "// Module Display Logic var display = function ( mod , hideIfNotExists ) { hideIfNotExists = hideIfNotExists || false ; console . log ( ( ' + ' + mod . cyan + ' v' + mpkg . version ) ) ; if ( hideIfNotExists ) { console . log ( ' - ' + mod + ' (Not Installed)' . red ) ; } } ; // Loop through modules and display them. for ( var m in pkg . ngn . modules ) { display ( m ) ; // Display dev tools if they're installed, hide if they're not. display ( 'ngn-dev' , true ) ;", "del_tokens": "for ( var mod in pkg . ngn . modules ) { console . log ( ( ' + ' + mod . cyan + ' v' + mpkg . version ) . bold ) ; console . log ( ' - ' + mod + ' (Not Installed)' . red ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "feed", "summary", "on", "private", "and", "channels", "too"], "add_tokens": "var Modules = require ( './modules' ) var plugs = require ( 'patchbay/plugs' ) var modules = Modules ( config , ssbClient ) } , 'Public' ) ,", "del_tokens": "var combine = require ( 'depject' ) var Modules = require ( 'patchbay/modules' ) var SbotApi = require ( './api' ) var extend = require ( 'xtend' ) var plugs = require ( 'patchbay/plugs' ) var api = SbotApi ( ssbClient , config ) var modules = combine ( extend ( Modules , { 'sbot-api.js' : api , 'public.js' : require ( './views/public-feed.js' ) , 'blob-url.js' : { blob_url : function ( link ) { var prefix = config . blobsPrefix != null ? config . blobsPrefix : ` ${ config . blobsPort } ` if ( typeof link . link === 'string' ) { link = link . link } return ` ${ prefix } ${ encodeURIComponent ( link ) } ` } } } ) ) } , 'Feed' ) ,", "commit_type": "use"}
{"commit_tokens": ["Fix", "dependencies", "and", "remove", "lint", "from", "test"], "add_tokens": "exports . stripQuotes = stripQuotes ;", "del_tokens": "exports . stripQuotes = stripQuotes ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "stage", "variable", "to", "set", "alias"], "add_tokens": "// Use the SERVERLESS_ALIAS stage variable to determine the called function alias uriParts . splice ( funcIndex + 1 , 0 , ':${stageVariables.SERVERLESS_ALIAS}' ) ;", "del_tokens": "uriParts . splice ( funcIndex + 1 , 0 , ` ${ this . _alias } ` ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "pointer", "to", "build", "."], "add_tokens": "/// <reference path=\"../src/core/angle.ts\" /> /// <reference path=\"../src/core/intersect.ts\" /> /// <reference path=\"../src/core/measure.ts\" /> /// <reference path=\"../src/core/units.ts\" /> Manager . prototype . isWithinMargin = function ( p ) { if ( ! makerjs . measure . isBetween ( p . fromCanvas [ 0 ] , this . margin [ 0 ] , this . view . offsetWidth - this . margin [ 0 ] , false ) ) return false ; if ( ! makerjs . measure . isBetween ( p . fromCanvas [ 1 ] , this . margin [ 1 ] , this . view . offsetHeight - this . margin [ 1 ] , false ) ) return false ; return true ; } ; var pointRelative = this . getPointRelative ( e ) ; if ( ! this . isWithinMargin ( pointRelative ) ) return ; var pointRelative = this . getPointRelative ( e ) ; if ( ! this . isWithinMargin ( pointRelative ) ) return ; pointer . current = pointRelative ;", "del_tokens": "var pointRelative = this . getPointRelative ( e ) ; pointer . current = this . getPointRelative ( e ) ; //# sourceMappingURL=pointer.js.map", "commit_type": "add"}
{"commit_tokens": ["Remove", "console", "log", "and", "reset", "periodDuration"], "add_tokens": "/ ** * jQuery Schedule v2 .0 .0 * https : //github.com/Yehzuna/jquery-schedule * Thomas BORUSZEWSKI < yehzuna @ outlook . com > * / periodDuration : 30 , // 15/30/60 console . error ( invalidPosition ) ;", "del_tokens": "periodDuration : 15 , // 15/30/60 console . log ( 'periodInterval' , this . periodInterval , 'periodHeight' , this . periodHeight , 'periodPosition' , this . periodPosition ) ; console . log ( 'generate' , index , period ) ; console . log ( 'position' , position , 'height' , height ) ; console . log ( ui ) ; console . log ( ui ) ; console . log ( invalidPosition ) ; console . log ( 'periodFormat' , position , hour , mn ) ; console . log ( 'positionFormat' , hour , mn , ind ) ; console . log ( hour * this . periodInterval , mn / 60 * this . periodInterval ) ; console . log ( position ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "support", "for", "checking", "device", "model", "type", "in", "search", "()"], "add_tokens": "search . on ( 'DeviceAvailable' , function ( device , model ) { console . log ( device , model ) ;", "del_tokens": "search . on ( 'DeviceAvailable' , function ( device ) { console . log ( device ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "some", "race", "condition", "in", "the", "test", "case", "."], "add_tokens": "var employees ; db . query ( sql , function ( error ) { if ( error ) return done ( error ) ; employees = db . extend ( 'employees' ) ; done ( ) ; } ) ;", "del_tokens": "var employees = db . extend ( 'employees' ) ; db . query ( sql , done ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "templateRenderer", "not", "rendering", "text", "node", "changes"], "add_tokens": "newDOM = $ ( templateRenderer . copyTopElement ( this . el ) ) ;", "del_tokens": "newDOM = templateRenderer . copyTopElement ( this . $el ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "Verb", "toString", "method", "leveraging", "display", "property"], "add_tokens": "/ ** @ property display @ type Object * / this . display = null ; LOG_SRC : \"Verb\" , \"id\" , \"display\" this . display = { und : this . id } ; toString : function ( lang ) { this . log ( \"toString\" ) ; return this . getLangDictionaryValue ( \"display\" , lang ) ; } , } , getLangDictionaryValue : TinCan . Utils . getLangDictionaryValue @ param { String } verbJSON String of JSON representing the verb", "del_tokens": "LOG_SRC : 'Verb' , \"id\" }", "commit_type": "add"}
{"commit_tokens": ["Added", "warning", "for", "header", "response"], "add_tokens": "if ( true ) { } headers : ( _ . isPlainObject ( headers ) ? headers : ( logger . warning ( 'headers must be an object' ) , { } ) ) ,", "del_tokens": "headers : ( _ . isPlainObject ( headers ) ? headers : { } ) ,", "commit_type": "add"}
{"commit_tokens": ["Use", "_", "isString", "instead", "of", "instanceof"], "add_tokens": "if ( _ . isString ( cols ) ) { return quote ( v ) ;", "del_tokens": "if ( cols instanceof String ) { return quote ( v )", "commit_type": "use"}
{"commit_tokens": ["Added", "generated", "text", "in", "posts"], "add_tokens": "var bogan = require ( 'boganipsum' ) ; var p = models . Post . build ( { title : 'post ' + i , slug : \"post-\" + i , body : bogan ( ) , published : i % 2 == 0 } ) ;", "del_tokens": "var p = models . Post . build ( { title : 'post ' + i , slug : \"post-\" + i , body : 'Cool' , published : i % 2 == 0 } ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "::", "desc", "to", "set", "custom", "error", "messages"], "add_tokens": "_ . desc = function ( expected ) { return this . or ( fail ( expected ) ) } ; var letter = Parsimmon . letter = regex ( / [a-z] / i ) . desc ( 'a letter' ) var letters = Parsimmon . letters = regex ( / [a-z]* / i ) var digit = Parsimmon . digit = regex ( / [0-9] / ) . desc ( 'a digit' ) ; var digits = Parsimmon . digits = regex ( / [0-9]* / ) var whitespace = Parsimmon . whitespace = regex ( / \\s+ / ) . desc ( 'whitespace' ) ; var lazy = Parsimmon . lazy = function ( desc , f ) { if ( arguments . length < 2 ) { f = desc ; desc = undefined ; } if ( desc ) parser = parser . desc ( desc )", "del_tokens": "var letter = Parsimmon . letter = regex ( / [a-z] / i ) ; var letters = Parsimmon . letters = regex ( / [a-z]* / i ) ; var digit = Parsimmon . digit = regex ( / [0-9] / ) ; var digits = Parsimmon . digits = regex ( / [0-9]* / ) ; var whitespace = Parsimmon . whitespace = regex ( / \\s+ / ) ; var lazy = Parsimmon . lazy = function ( f ) {", "commit_type": "add"}
{"commit_tokens": ["implement", "a", "basic", "sources", "tree"], "add_tokens": "loader : \"json\"", "del_tokens": "loader : \"json-loader\"", "commit_type": "implement"}
{"commit_tokens": ["Make", "sure", "the", "callee", "type", "is", "Identifier"], "add_tokens": "if ( node . callee . type === \"Identifier\" ) { var callee = node . callee . name ; if ( callee === \"setTimeout\" || callee === \"setInterval\" ) { var argument = node . arguments [ 0 ] ; if ( argument && argument . type === \"Literal\" && typeof argument . value === \"string\" ) { context . report ( node , \"Implied eval. Consider passing a function instead of a string.\" ) ; }", "del_tokens": "var callee = node . callee . name ; if ( callee === \"setTimeout\" || callee === \"setInterval\" ) { var argument = node . arguments [ 0 ] ; if ( argument && argument . type === \"Literal\" && typeof argument . value === \"string\" ) { context . report ( node , \"Implied eval. Consider passing a function instead of a string.\" ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "header", "rendering", "in", "docs"], "add_tokens": "React . createElement ( 'h' + this . props . level , { } , React . createElement ( 'a' , { className : 'anchor' , name : slug } ) , this . props . children , ' ' , React . createElement ( 'a' , { className : \"hash-link\" , href : '#' + slug } , '#' ) )", "del_tokens": "< h > < a className = \"anchor\" name = { slug } > < / a > { this . props . children } { ' ' } < a className = \"hash-link\" href = { '#' + slug } > # < / a > < / h >", "commit_type": "fix"}
{"commit_tokens": ["Change", "variable", "name", "to", "camel", "case"], "add_tokens": "* @ param { Number } trackNr Number of track in queue ( optional , indexed from 1 ) * @ param { Function } callback ( err , data ) Sonos . prototype . selectTrack = function ( trackNr , callback ) { if ( typeof trackNr === 'function' ) { callback = trackNr ; trackNr = 1 ; var body = '<u:Seek xmlns:u=\"urn:schemas-upnp-org:service:AVTransport:1\"><InstanceID>0</InstanceID><Unit>TRACK_NR</Unit><Target>' + trackNr + '</Target></u:Seek>' ;", "del_tokens": "* @ param { Number } track_nr Number of track in queue ( optional , indexed from 1 ) * @ param { Function } callback ( err , seeked ) Sonos . prototype . selectTrack = function ( track_nr , callback ) { if ( typeof track_nr === 'function' ) { callback = track_nr ; track_nr = 1 ; var body = '<u:Seek xmlns:u=\"urn:schemas-upnp-org:service:AVTransport:1\"><InstanceID>0</InstanceID><Unit>TRACK_NR</Unit><Target>' + track_nr + '</Target></u:Seek>' ;", "commit_type": "change"}
{"commit_tokens": ["Make", "code", "linenumber", "selector", "more", "specific", "."], "add_tokens": "lineNumber : '.CodeMirror-gutter-wrapper > .CodeMirror-linenumber' ,", "del_tokens": "lineNumber : '.CodeMirror-linenumber' ,", "commit_type": "make"}
{"commit_tokens": ["added", "Content", "-", "type", "header"], "add_tokens": "} xhr = new ActiveXObject ( 'Microsoft.XMLHTTP' ) ; // IE 6 xhr . setRequestHeader ( 'Content-type' , 'application/x-www-form-urlencoded' ) ; if ( '\\v' === 'v' && global . attachEvent ) { global . attachEvent ( 'onunload' , close ) ;", "del_tokens": "} ; xhr = new ActiveXObject ( \"Microsoft.XMLHTTP\" ) ; // IE 6 if ( '\\v' === 'v' && window . attachEvent ) { window . attachEvent ( 'onunload' , close ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "the", "write", "test", "file", "and", "move", "the", "one", "useful", "test", "case"], "add_tokens": "it ( 'counts points' , function ( ) { it ( 'errors if you write a point without time' , function ( ) { var timeless = { value : 1 , name : 'dave' } ; var write_program = util . format ( 'emit -points %s | remove time | writex elastic' , JSON . stringify ( [ timeless ] ) ) ; return check_juttle ( { program : write_program } ) . then ( function ( result ) { var message = util . format ( 'invalid point: %s because of missing time' , JSON . stringify ( timeless ) ) ; expect ( result . errors ) . deep . equal ( [ message ] ) ; } ) ; } ) ;", "del_tokens": "it ( 'count' , function ( ) {", "commit_type": "remove"}
{"commit_tokens": ["remove", "object", "literal", "value", "shorthand"], "add_tokens": "config . store . dispatch ( pusherAction ( { actionType : CONNECTED , data : data } ) ) ;", "del_tokens": "config . store . dispatch ( pusherAction ( { actionType : CONNECTED , data } ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "semicolon", "at", "line", "end"], "add_tokens": "console . log ( 'Please fix your resume.json file and try again' ) ; //wording? link to docs console . log ( 'You can easily pinpoint problems that may occur in a JSON file at: http://jsonlint.com/' ) ; //wording? link to docs", "del_tokens": "console . log ( 'please fix your resume.json file and try again' ) //wording? link to docs console . log ( 'You can easily pinpoint problems that may occur in a JSON file at: http://jsonlint.com/' ) //wording? link to docs", "commit_type": "add"}
{"commit_tokens": ["add", "app", "-", "server", "and", "lib", "-", "service"], "add_tokens": "module . exports . plugin = generate ( registry . plugins , [ 'app' , 'bundle' , 'lib' ] , [ 'server' , 'service' ] , [ 'lib-server' , 'app-serer' , 'lib-service' , 'app-service' ] ) ;", "del_tokens": "module . exports . plugin = generate ( registry . plugins , [ 'app' , 'bundle' , 'lib' ] , [ 'server' , 'service' ] , [ 'lib-service' , 'app-service' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "statusCode", "instead", "of", "status"], "add_tokens": "this . statusCode = 401 ;", "del_tokens": "this . status = 401 ;", "commit_type": "use"}
{"commit_tokens": ["Implement", "a", "less", "case", "-", "specific", "preflight", "phase"], "add_tokens": "this . files = this . getFiles ( args . testPaths ) ; this . options = this . getOptions ( this . files , args ) ; this . runner = new Mocha ( this . options ) ; this . files . specs . forEach ( s => { defaults . formatCode = true ; let run = Promise . resolve ( ) ; if ( \"function\" === typeof this . reporter . beforeStart ) run = this . reporter . beforeStart ( this ) ; return run . then ( _ => this . runner . run ( ) ) ;", "del_tokens": "const files = this . getFiles ( args . testPaths ) ; const options = this . getOptions ( files , args ) ; this . runner = new Mocha ( options ) ; files . specs . forEach ( s => { defaults . noHighlighting = false ; const run = new Promise ( resolve => this . runner . run ( failures => resolve ( failures ) ) ) ; return this . reporter . loadHighlighter ? this . reporter . loadHighlighter ( ) . then ( _ => run ) : run ;", "commit_type": "implement"}
{"commit_tokens": ["Fix", "issue", "with", "getting", "of", "models", "&", "controllers", "(", "inflections", ")"], "add_tokens": "var fullName = camelName ; // Make sure the full name ends with Controller if ( ! fullName . endsWith ( 'Controller' ) ) { fullName = fullName + 'Controller' ; } if ( typeof alchemy . classes [ fullName ] === 'undefined' ) return false ; if ( typeof alchemy . instances . controllers [ controllerName ] === 'undefined' ) { if ( options . base || typeof alchemy . classes . AppController === 'undefined' ) {", "del_tokens": "var fullName = camelName + 'Controller' ; if ( typeof alchemy . classes [ fullName ] == 'undefined' ) return false ; if ( typeof alchemy . instances . controllers [ controllerName ] == 'undefined' ) { if ( options . base || typeof alchemy . classes . AppController == 'undefined' ) {", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "some", "missing", "logic", "that", "was", "causing", "the", "tooltips", "not", "to", "show", "when", "supplying", "simple", "text"], "add_tokens": "* Date : Mon Sep 6 14 : 15 : 53 2010 + 0100 else { validTargets = targets ; }", "del_tokens": "* Date : Mon Sep 6 14 : 13 : 03 2010 + 0100", "commit_type": "implement"}
{"commit_tokens": ["Updated", "years", "in", "copyright", "restored", "100%", "code", "coverage"], "add_tokens": "* @ copyright Konfirm ⓒ 2 15-2 0 19 * @ license MIT if ( new RegExp ( '^' + type ( arg [ index ] , true ) + '!$' ) . test ( argument . type ) ) {", "del_tokens": "* @ copyright Konfirm ⓒ 2 15 * @ license GPLv2 if ( argument . type [ argument . type . length - 1 ] === '!' && type ( arg [ index ] , true ) ) {", "commit_type": "update"}
{"commit_tokens": ["Updated", "package", "file", "fixed", "dependency"], "add_tokens": "//var ossi = require('ossindexjs');", "del_tokens": "//var ossi = require('./ossindex.js');", "commit_type": "update"}
{"commit_tokens": ["Add", "iOS", "platform", "check", "in", "Media", ".", "prototype", ".", "setRate", "fix"], "add_tokens": "exec ( null , null , \"Media\" , \"setVolume\" , [ this . id , volume ] ) ; if ( cordova . platformId === 'ios' ) { exec ( null , null , \"Media\" , \"setRate\" , [ this . id , rate ] ) ; } else { console . warn ( 'media.setRate method is currently not supported for' , cordova . platformId , 'platform.' ) }", "del_tokens": "if ( device . platform == 'iOS' ) { exec ( null , null , \"Media\" , \"setVolume\" , [ this . id , volume ] ) ; } else { console . warn ( 'media.setRate method is currently not supported for' , device . platform , 'platform.' ) } exec ( null , null , \"Media\" , \"setRate\" , [ this . id , rate ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "middleware", "to", "parse", "numbers", "in", "requests", "parameters", "."], "add_tokens": "const { logger , parseNums } = require ( './middleware' ) let args = [ ` ${ path } ` , parseNums , logger ] args . push ( controller [ action ] ? controller [ action ] : ( req , res ) => { res . send ( 'Not a valid action.' ) } )", "del_tokens": "// Logs info on each request router . use ( require ( './logger' ) ) let args = [ ` ${ path } ` ] args . push ( controller [ action ] )", "commit_type": "add"}
{"commit_tokens": ["Make", "full_schema", "test", "only", "mappings", "."], "add_tokens": "schema . mappings , fullSchema . mappings ,", "del_tokens": "schema , fullSchema ,", "commit_type": "make"}
{"commit_tokens": ["fixed", "dates", "array", "in", "onSelect", "callback"], "add_tokens": "parsedDate . year , parsedDate . month , parsedDate . date , parsedDate . hours , parsedDate . minutes", "del_tokens": "parsedSelected . year , parsedSelected . month , parsedSelected . date , parsedSelected . hours , parsedSelected . minutes", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "serializing", "maps", "as", "query", "params", "."], "add_tokens": "serializeMap : function serialzeMap ( name , map , rules , fn ) { var n = 1 ; var that = this ; AWS . util . each ( map , function ( key , value ) { var position = '.' + ( n ++ ) + '.' ; var keyName = position + ( rules . k . n || 'key' ) ; var valueName = position + ( rules . m . n || 'value' ) ; that . serializeMember ( name + keyName , key , rules . k , fn ) ; that . serializeMember ( name + valueName , value , rules . m , fn ) ; } ) ; } , that . serializeMember ( name + suffix , v , rules , fn ) ; else if ( rules . t === 'm' ) this . serializeMap ( name , value , rules , fn ) ;", "del_tokens": "var memberName = name + suffix ; that . serializeMember ( memberName , v , rules , fn ) ;", "commit_type": "add"}
{"commit_tokens": ["implementing", "can", ".", "hasKey", "Symbol"], "add_tokens": "var canReflect = require ( 'can-reflect' ) ; canReflect . assignSymbols ( proto , { \"can.hasKey\" : function ( key ) { var defined = this . define && key in this . define ; var exists = this . _data && key in this . _data ; return defined || exists ; } } ) ;", "del_tokens": "", "commit_type": "implement"}
{"commit_tokens": ["Added", "support", "for", "H", "and", "V", "path", "types"], "add_tokens": "function calculateCoordinatesQuad ( startX , startY , ctrl1x , ctrl1y , endX , endY , minDistance , roundToNearest , sampleFrequency ) { t += sampleFrequency ; function calculateCoordinatesCubic ( startX , startY , ctrl1x , ctrl1y , ctrl2x , ctrl2y , endX , endY , minDistance , roundToNearest , sampleFrequency ) { t += sampleFrequency ; const interpolatedPoints = calculateCoordinatesCubic ( startX , startY , ctrlPt1 . x , ctrlPt1 . y , ctrlPt2 . x , ctrlPt2 . y , endPoint . x , endPoint . y , minDistance , roundToNearest , sampleFrequency ) ;", "del_tokens": "function calculateCoordinatesQuad ( startX , startY , ctrl1x , ctrl1y , endX , endY , minDistance , roundToNearest ) { t += .001 ; function calculateCoordinatesCubic ( startX , startY , ctrl1x , ctrl1y , ctrl2x , ctrl2y , endX , endY , minDistance , roundToNearest ) { t += .001 ; const interpolatedPoints = calculateCoordinatesCubic ( startX , startY , ctrlPt1 . x , ctrlPt1 . y , ctrlPt2 . x , ctrlPt2 . y , endPoint . x , endPoint . y , minDistance , roundToNearest ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "chalk", "instead", "of", "colors"], "add_tokens": "shell = require ( 'shelljs' ) , chalk = require ( 'chalk' ) ; console . log ( chalk . cyan ( ' create:' ) , path ) ; console . log ( chalk . cyan ( ' create:' ) , path ) ;", "del_tokens": "shell = require ( 'shelljs' ) ; require ( './colors' ) ; console . log ( ' create : ' . blue + path ) ; console . log ( ' create : ' . blue + path ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "features", "requiring", "polyfills", "to", "6to5", "blacklist", "amd", "now", "uses", "6to5", "runtime", "flag"], "add_tokens": ". pipe ( to5 ( { blacklist : [ 'forOf' , 'generators' , 'spread' , 'destructuring' ] } ) ) . pipe ( gulp . dest ( 'dist/cjs' ) ) . pipe ( to5 ( { modules : \"amd\" , moduleIds : true , runtime : true , blacklist : [ 'forOf' , 'generators' , 'spread' , 'destructuring' ] } ) ) 'node_modules/gulp-6to5/node_modules/6to5-core/runtime.js' ,", "del_tokens": ". pipe ( to5 ( ) ) . pipe ( gulp . dest ( 'dist/cjs' ) ) . pipe ( to5 ( { modules : \"amd\" , moduleIds : true } ) )", "commit_type": "add"}
{"commit_tokens": ["Add", "test", "and", "fix", "for", "locknode", "in", "root", "(", "bad", "idea", "but", "people", "do", "it", ")"], "add_tokens": "var lockpath = name . lastIndexOf ( '/' ) == 0 ? name : name . slice ( 0 , name . lastIndexOf ( '/' ) + 1 ) ; // client doesn't like paths ending in /, so chop it off if lockpath != '/' self . _zk . mkdirp ( lockpath . length <= 1 ? lockpath : lockpath . slice ( 0 , - 1 ) , callback ) ; self . _zk . getChildren ( lockpath . length <= 1 ? lockpath : lockpath . slice ( 0 , - 1 ) , function ( err , children ) {", "del_tokens": "var lockpath = name . slice ( 0 , name . lastIndexOf ( '/' ) + 1 ) ; self . _zk . mkdirp ( lockpath . slice ( 0 , - 1 ) , callback ) ; // client doesn't like paths ending in / self . _zk . getChildren ( lockpath . slice ( 0 , - 1 ) , function ( err , children ) {", "commit_type": "add"}
{"commit_tokens": ["updated", "react", "dep", ".", "upped", "version", "."], "add_tokens": "throw new Error ( 'It looks like you called `mount()` without having ' + 'called `useJsDom()` first. As a result, the DOM isn\\'t ' + 'loaded and `renderIntoDocument` will fail.' ) ;", "del_tokens": "throw new Error ( 'It looks like you called `mount()` without having ' + 'called `useJsDom()` first. As a result, the DOM isn\\'t' + 'loaded and `renderIntoDocument` will fail.' ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "missing", "semicolons", ".", "Optimizations", "."], "add_tokens": "var targetBase = path . resolve ( file . cwd , './build' ) ; var timeThen = new Date ( ) ; timeThen . setFullYear ( timeThen . getFullYear ( ) - 1 ) ; var targetBase = path . resolve ( file . cwd , './build' ) ;", "del_tokens": "var targetBase = path . resolve ( file . cwd , './build' ) var theDate = new Date ( ) ; var currentYear = new Date ( ) . getFullYear ( ) ; var yesterYear = currentYear - 1 ; var timeThen = new Date ( ) . setFullYear ( yesterYear ) ; var targetBase = path . resolve ( file . cwd , './build' )", "commit_type": "add"}
{"commit_tokens": ["updated", "styles", "to", "align", "and", "styles", "buttons"], "add_tokens": "< MoveButtonComponent store = { this . props . store } / >", "del_tokens": "< MoveButtonComponent className = \"buttons\" store = { this . props . store } / >", "commit_type": "update"}
{"commit_tokens": ["Fix", "unversioned", "app", "manager", "test"], "add_tokens": "await this . directory . setImplementation ( contract , this . implementation_v1 , { from : directoryOwner } ) assert . equal ( implementation , this . implementation_v1 )", "del_tokens": "assert . equal ( implementation , this . implementation_v0 ) await this . directory . setImplementation ( contract , this . implementation_v1 , { from : directoryOwner } )", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "to", "ensure", "parse", "preserves", "original", "line", "endings", "in", "parsed", "body", "."], "add_tokens": "let line = lines . pop ( ) ; parseField ( originalLine ) { // Trim left-side only as the right is needed to multiline fields. let line = originalLine . trimLeft ( ) ;", "del_tokens": "let line = lines . pop ( ) . trim ( ) ; parseField ( line ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "test", "for", "logging", "custom", "fields", "via", "array"], "add_tokens": "it ( \"Test custom fields log output (object)\" , function ( ) { it ( \"Test custom fields log output (array)\" , function ( ) { log ( \"info\" , \"Test\" , [ 1 , \"123\" , { \"field\" : \"values\" } ] ) ; logObject . msg . should . equal ( 'Test' ) ; JSON . stringify ( logObject . custom_fields ) . should . equal ( '[\"1\",\"123\",\"{\\\\\"field\\\\\":\\\\\"values\\\\\"}\"]' ) ; } ) ; it ( \"Test custom fields log type consistency (objects)\" , function ( ) { it ( \"Test custom fields log type consistency (arrays)\" , function ( ) {", "del_tokens": "it ( \"Test custom fields log output\" , function ( ) { it ( \"Test custom fields log type consistency (for objects)\" , function ( ) { it ( \"Test custom fields log type consistency (for arrays)\" , function ( ) { console . log ( envHeaderVariable ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "name", "argument", "in", "delete", "command", "variadic"], "add_tokens": ". command ( 'delete <names...>' ) . usage ( ` ${ chalk . green ( '<names...>' ) } ` ) . on ( '--help' , ( ) => { console . log ( ) ; console . log ( ` ${ chalk . green ( '<names...>' ) } ` ) ; console . log ( ) ; } ) . action ( ( names ) => { } ) ;", "del_tokens": ". command ( 'delete <name>' ) . usage ( ` ${ chalk . green ( '<name>' ) } ` ) . action ( ( name ) => { } ) ;", "commit_type": "make"}
{"commit_tokens": ["fixed", "lowercase", "bug", "updated", "captura2", "and", "readme"], "add_tokens": "if ( element . code [ 0 ] === \"E\" || element . code [ 0 ] === \"e\" ) { else if ( element . code [ 0 ] === \"W\" || element . code [ 0 ] === \"w\" ) { if ( element . code [ 0 ] === \"S\" || element . code [ 0 ] === \"s\" ) { else if ( element . code [ 0 ] === \"W\" || element . code [ 0 ] === \"w\" ) { else if ( element . code [ 0 ] === \"E\" || element . code [ 0 ] === \"e\" ) {", "del_tokens": "if ( element . code [ 0 ] === \"E\" ) { else if ( element . code [ 0 ] === \"W\" ) { if ( element . code [ 0 ] === \"S\" ) { else if ( element . code [ 0 ] === \"W\" ) { else if ( element . code [ 0 ] === \"E\" ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "a", "more", "solid", "way", "to", "reset", "the", "console"], "add_tokens": "process . stdout . write ( '\\x1bc' ) ;", "del_tokens": "process . stdout . write ( '\\x1B[2J\\x1B[0f' ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "bug", "to", "use", "crafty", "-", "preset", "-", "babel", "/", "bin", "/", "eslint", ".", "js", "the", "same", "way", "as", "eslint"], "add_tokens": "// Doesn't apply when we use the command as if we used eslint if ( process . argv [ 2 ] === \"jsLint\" ) { process . argv . splice ( 2 , 1 ) ; }", "del_tokens": "process . argv . splice ( 2 , 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "bug", "with", "output", "name", "of", "hashes", ".", "json", "was", "file", "true", "writed"], "add_tokens": "fs . writeFile ( './hashes.json' , JSON . stringify ( Hashes ) , fileWrited ( './hashes.json' ) ) ;", "del_tokens": "fs . writeFile ( './hashes.json' , JSON . stringify ( Hashes ) , fileWrited ( pLastFile_b ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "rotation", "of", "specific", "angle", "in", "ortho", "camera"], "add_tokens": "rotate45 : false , rotate : 0 var rotate45 = cameraFolder . add ( camUtils , 'rotate45' ) ; rotate45 . onChange ( function ( ) { var rotate = cameraFolder . add ( camera , 'angle' , 0 , 360 ) . step ( 1 ) . listen ( ) ;", "del_tokens": "rotate : false var rotate = cameraFolder . add ( camUtils , 'rotate' ) ; rotate . onChange ( function ( ) {", "commit_type": "allow"}
{"commit_tokens": ["added", "util", "to", "grunt", "+", "basic", "implementation", "of", "processShimQueue", "@brianr", "@sbezboro"], "add_tokens": "files : [ 'Gruntfile.js' , 'src/stacktrace.js' , 'src/util.js' , 'src/notifier.js' , 'src/init.js' ] src : [ 'src/notifier.js' , 'src/stacktrace.js' , 'src/util.js' , 'src/init.js' ] ,", "del_tokens": "files : [ 'Gruntfile.js' , 'src/stacktrace.js' , 'src/notifier.js' , 'src/init.js' ] src : [ 'src/notifier.js' , 'src/stacktrace.js' , 'src/init.js' ] ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "transformCursor", "for", "range", "selections"], "add_tokens": "if ( ! ~ cursor . indexOf ( ':' ) ) { var cursorOp = new Set ( cursor , null , null ) unpackOps ( ops ) . forEach ( ( op ) => cursorOp = cursorOp . transformAgainst ( op ) ) return cursorOp . target } else { // If the cursor contains a : it's a range, e.g. A1:C3 var range = cursor . split ( ':' ) , rangeStartTransformed = exports . transformCursor ( range [ 0 ] , ops ) , rangeEndTransformed = exports . transformCursor ( range [ 1 ] , ops ) return rangeStartTransformed + ':' + rangeEndTransformed }", "del_tokens": "var cursorOp = new Set ( cursor , null , null ) unpackOps ( ops ) . forEach ( ( op ) => cursorOp = cursorOp . transformAgainst ( op ) ) return cursorOp . target", "commit_type": "fix"}
{"commit_tokens": ["fix", "path", "error", "fix", "defer", "session", "setter"], "add_tokens": "function matchPath ( ctx ) { var pathname = ctx . path ; if ( pathname . indexOf ( cookie . path || '/' ) !== 0 ) { debug ( 'cookie path not match' ) ; return false ; } return true ; } if ( ! matchPath ( this ) ) { // defer session may has no sessionId if ( ! this . sessionId ) { this . sessionId = this . cookies . get ( key , { signed : cookie . signed } ) || uid ( 24 ) ; } // if path not match if ( ! matchPath ( this ) ) { return yield * next ; }", "del_tokens": "var originalPath = parse ( this . request . originalUrl ) . pathname ; if ( 0 !== originalPath . indexOf ( cookie . path || '/' ) ) { debug ( 'cookie path not match' ) ; if ( ! touchSession ) { debug ( 'do not touch session before, try to find session id from cookie' ) ; this . sessionId = this . cookies . get ( key , { signed : cookie . signed } ) ; // ignore if no sessionId if ( ! this . sessionId ) { debug ( 'can not found session id, set session does not work' ) ; return ; } }", "commit_type": "fix"}
{"commit_tokens": ["added", "proxied", "invalidation", "request", "to", "canvas", "added", "self", "removing", "option", "to", "sprite", "disposal", "routine"], "add_tokens": "* NOTE : will be null if the zSprite isn ' * the ZCanvas ' aChild . setParent ( null ) ; aChild . canvas = null ; //aChild.dispose(); // no, we might like to re-use the child at a later stage ? // in case this ZSprite was still on the ZCanvas, remove it if ( this . _parent != null ) { this . _parent . removeChild ( this ) ; }", "del_tokens": "* NOTE : will be null if the zSprite isn ' * the display list aChild . dispose ( ) ; aChild . canvas = null ; aChild . setParent ( null ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "use", "of", "tempo", "from", "code", "."], "add_tokens": "name : 'angular-http-loader' ,", "del_tokens": "name : 'tempo-http-loader' ,", "commit_type": "remove"}
{"commit_tokens": ["Fix", "getWaitListPosition", "if", "no", "DJs", "in", "waitlist", "."], "add_tokens": "var pos = booth . waitingDJs == null ? - 1 : booth . waitingDJs . indexOf ( uid ) ;", "del_tokens": "var pos = booth . waitingDJs . indexOf ( uid ) ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "the", "GitHub", "Pages", "URL", "in", "the", "comments"], "add_tokens": "* Project home : jedfoster . github . io / Readmore . js", "del_tokens": "* Project home : jedfoster . github . com / Readmore . js", "commit_type": "update"}
{"commit_tokens": ["added", "and", "tests", "audio", "file", "player"], "add_tokens": "\"AudioFile\" , \"http://robtowns.com/music/blind_willie.mp3\" , //\"https://archive.org/download/testmp3testfile/mpthreetest.mp3\", // does not pass test... too short? //];/* ] ; //*/ var targetPos = 0.998 ;", "del_tokens": "// \"AudioFile\", ] ; var targetPos = 0.999 ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "default", "value", "of", "LogoProgress", "size", "property"], "add_tokens": "const { size = 150 } = this . props ;", "del_tokens": "const { size } = 150 ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "new", "type", "schema", "validator", "implementation"], "add_tokens": "var validateAndPrepareWithSchema = require ( './schema' ) ; this . on ( 'prepare' , function ( object , callback ) { get : function ( ) { return schema } ,", "del_tokens": "var schema = require ( './schema' ) ; this . on ( 'validate' , function ( object , callback ) { get : function ( ) { return schema ; } ,", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "binary", "test", "file"], "add_tokens": "gravity . VERSION = '0.6.8' ;", "del_tokens": "gravity . VERSION = '0.6.7' ;", "commit_type": "add"}
{"commit_tokens": ["Add", "setAutoReconnect", "api", "in", "ApiInstance", "for", "some", "browser", "use", "case", "."], "add_tokens": "let autoReconnect = true ; / ** @ arg { boolean } auto means automatic reconnect if possible ( browser case ) , default true * / setAutoReconnect : function ( auto ) { autoReconnect = auto ; } , this . ws_rpc = new ChainWebSocket ( cs , this . statusCb , connectTimeout , autoReconnect ) ;", "del_tokens": "this . ws_rpc = new ChainWebSocket ( cs , this . statusCb , connectTimeout ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "multiple", "types", "in", "arrays"], "add_tokens": "var type = { type : \"Array\" , content : [ parse ( input ) ] } while ( ! input . eat ( \"]\" ) ) { if ( ! input . eat ( \",\" ) ) input . error ( \"Missing comma or closing square bracket\" ) type . content . push ( parse ( input ) ) }", "del_tokens": "var type = { type : \"Array\" , content : parse ( input ) } if ( ! input . eat ( \"]\" ) ) input . error ( \"Unclosed array type\" )", "commit_type": "allow"}
{"commit_tokens": ["Add", "support", "for", "cast", "silent", "halt", ";", "minor", "fixes", "and", "cleanup"], "add_tokens": "testPathIgnorePatterns : [ ] ,", "del_tokens": "testPathIgnorePatterns : [ \"tests/php_encapsed_curly\" ] ,", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "pre", "-", "splitting", "paths"], "add_tokens": "var path = this . path = Array . isArray ( str ) ? str : str . split ( this . delim ) ; if ( typeof parent . get === 'function' ) return parent . get ( key ) ;", "del_tokens": "var path = this . path = str . split ( this . delim ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "2", "physical", "connections", "to", "each", "redis"], "add_tokens": "this . numPhysical = 2 ;", "del_tokens": "this . numPhysical = 5 ;", "commit_type": "use"}
{"commit_tokens": ["fix", "up", "phantom", "console", "output"], "add_tokens": "self . _mapper = stack_mapper ( res . body ) ; var mapper = self . _mapper ; var message = details . message ;", "del_tokens": "mapper = stack_mapper ( res . body ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "nsp", "as", "a", "build", "step", "since", "the", "server", "isn", "t", "responding"], "add_tokens": "gulp . task ( 'prepublish' , [ /*'nsp',*/ 'babel' ] ) ;", "del_tokens": "gulp . task ( 'prepublish' , [ 'nsp' , 'babel' ] ) ;", "commit_type": "remove"}
{"commit_tokens": ["Use", "proper", "SHA", "-", "256", "by", "default"], "add_tokens": "var sha256 = require ( 'sha256' ) ; var sha256starbound = require ( 'starbound-sha256' ) ; var keyHash = sha256 ( key , { asString : true } ) ; try { return this . db . get ( keyHash ) ; } catch ( e ) { // Older versions of Starbound had a buggy hash implementation. Try to use // it, since we could be reading an old package file. if ( key . length == 55 ) { keyHash = sha256starbound ( key , { asString : true } ) ; return this . db . get ( keyHash ) ; } throw e ; }", "del_tokens": "var sha256 = require ( 'starbound-sha256' ) ; key = sha256 ( key , { asString : true } ) ; return this . db . get ( key ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixing", "position", "of", "point", "annotation", "when", "rotated"], "add_tokens": "node . setAttribute ( 'x' , viewport . width - y - width ) ; node . setAttribute ( 'y' , x ) ; node . setAttribute ( 'x' , y ) ; node . setAttribute ( 'y' , viewport . height - x - height ) ;", "del_tokens": "node . setAttribute ( 'x' , viewport . width - x - width ) ; node . setAttribute ( 'y' , viewport . height - y - height ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "incr", "LMDB", "and", "fixed", "env", "bugs"], "add_tokens": "db . setProcessRow ( 'account' , self . processAccountRow ) ; // Update with the actual geohash for postprocessing if any obj . geohash = geo . geohash ; self . sendJSON ( req , res , self . processAccountRow ( obj ) ) ; // // // // // api.registerAuthCheck('GET', '/account/get', function(req, status, cb) { if (status.status != 200) status = { status: 302, url: '/error.html' }; cb(status) }) // - path is a string or regexp of the request URL similar to registering Express routes", "del_tokens": "db . getPool ( 'account' ) . processRow = self . processAccountRow ; self . sendJSON ( req , res , self . processAccountRow ( obj ) ) ; // api.registerAuthCheck('GET', '/account/get', function(req, status, cb) { if (status.status != 200) status = { status: 302, url: '/error.html' }; cb(status) }) // - path is a string or regexp of the request URL similr to registering Express routes", "commit_type": "add"}
{"commit_tokens": ["Remove", "regex", "group", "names", "for", "full", "regex", "search", "since", "javascript", "doesn", "t", "support", "them"], "add_tokens": "pattern = new RegExp ( args . r . replace ( / \\(\\?\\<\\w+\\> / g , '(' ) ) ;", "del_tokens": "pattern = new RegExp ( args . r ) ;", "commit_type": "remove"}
{"commit_tokens": ["add", "$this", ".", "path", "management", "in", "getProp"], "add_tokens": "var start = 0 ; start = 1 ; for ( var i = start , len = path . length ; i < len ; ++ i )", "del_tokens": "return from ; for ( var i = 0 , len = path . length ; i < len ; ++ i )", "commit_type": "add"}
{"commit_tokens": ["Update", "some", "examples", "to", "use", "new", "router"], "add_tokens": "var Router = ReactRouter . Router ; Router ( < Route handler = { App } > < Route name = \"user\" path = \"user/:userId\" handler = { User } / > < / Route > ) . renderComponent ( document . body ) ;", "del_tokens": "var Routes = ReactRouter . Routes ; var Main = React . createClass ( { render : function ( ) { return ( < Routes handler = { App } > < Route name = \"user\" path = \"user/:userId\" handler = { User } / > < / Routes > ) ; } } ) ; React . renderComponent ( < Main / > , document . body ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "missing", "humidity", "byte", "to", "0x1605"], "add_tokens": "payload : new Buffer ( 'F82C0108280000010100' , 'hex' ) , humidity : 40 ,", "del_tokens": "payload : new Buffer ( 'F82C01080000010100' , 'hex' ) ,", "commit_type": "add"}
{"commit_tokens": ["Add", "web_root", "and", "fallback_page", "to", "dat", ".", "json", "manifest"], "add_tokens": "function generateManifest ( { url , title , description , type , author , web_root , fallback_page } = { } ) { if ( isString ( web_root ) ) manifest . web_root = web_root if ( isString ( fallback_page ) ) manifest . fallback_page = fallback_page", "del_tokens": "function generateManifest ( { url , title , description , type , author } = { } ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "commander", "and", "custom", "port"], "add_tokens": "var commander = require ( 'commander' ) var chain = solidbot . bots . chain queue . process ( 'chain' , chain ) commander . option ( '-p --port [num]' , 'Port Number' ) . parse ( process . argv ) var defaultPort = 3005 var port = commander . port || defaultPort kue . app . listen ( port )", "del_tokens": "kue . app . listen ( 3005 )", "commit_type": "add"}
{"commit_tokens": ["Improved", "Any", "-", "DB", "compatibility"], "add_tokens": "if ( callback && callback instanceof Function && ! callback . _done ) { callback . _done = true ; callback ( err , result ) ; }", "del_tokens": "if ( callback && callback instanceof Function && ! callback . _done ) { callback . _done = true ; callback ( err , result ) ; }", "commit_type": "improve"}
{"commit_tokens": ["Fix", "error", "css", "not", "a", "function", "when", "triangle", "is", "not", "an", "angular", "element"], "add_tokens": "if ( triangle && triangle . length ) {", "del_tokens": "if ( triangle ) {", "commit_type": "fix"}
{"commit_tokens": ["added", "Column", "-", "Column", "editor"], "add_tokens": "chooser = this . chooser = document . createElement ( 'select' ) ; this . chooserTarget = evt . target ; this . chooserTarget . classList . add ( 'as-menu-header' ) ; this . chooserTarget . classList . remove ( 'as-menu-header' ) ;", "del_tokens": "chooser = this . chooser = document . createElement ( 'select' ) , target = this . chooserTarget = evt . target ; target . style . backgroundColor = window . getComputedStyle ( chooser ) . backgroundColor ; this . chooserTarget . style . backgroundColor = null ;", "commit_type": "add"}
{"commit_tokens": ["Add", "the", "overridden", "description", "in", "a", "way", "that", "s", "compatible", "with", "load", "-", "grunt", "-", "tasks"], "add_tokens": "if ( options . description ) { parser . description = formatDescription ( options . description , formattingOptions ) ; } } ;", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Add", "second", "testing", "target", "in", "Gruntfile"], "add_tokens": "test_branch : { } , production : { options : { branch : 'prod' , // remote: 'git@github.com:robwierzbowski/grunt-version-build.git', message : 'Check *this* out.' , commit : true } }", "del_tokens": "message : 'Check *this* out.' def : { } //, // custom_options: { // options: { // remote: 'git@github.com:robwierzbowski/grunt-version-build.git', // other: 'test-branch-dos' // } // },", "commit_type": "add"}
{"commit_tokens": ["Use", "Angular", "$parse", "service", "to", "get", "named", "values", "from", "$scope"], "add_tokens": "if ( angular . equals ( val , self . _parse ( name ) ( $scope ) ) ) { var val = JSON . parse ( angular . toJson ( self . _parse ( name ) ( $scope ) ) ) ;", "del_tokens": "if ( angular . equals ( val , $scope [ name ] ) ) { var val = JSON . parse ( angular . toJson ( $scope [ name ] ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "error", "at", "startup", "with", "fullscreen", "plugin"], "add_tokens": "var ready = false ; ready = true ; if ( Reveal . getCurrentSlide ( ) . hasAttribute ( \"data-fullscreen\" ) ) { Reveal . configure ( { width : window . innerWidth , height : window . innerHeight , margin : 0 } ) ; } if ( ready && Reveal . getCurrentSlide ( ) . hasAttribute ( \"data-fullscreen\" ) ) {", "del_tokens": "if ( Reveal . getCurrentSlide ( ) . hasAttribute ( \"data-fullscreen\" ) ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "issues", "from", "recent", "refactory"], "add_tokens": "play ( 'Tab' ) . add ( 'Default' , require ( './components/tab/story/default' ) . default ) . add ( 'Vertical' , require ( './components/tab/story/vertical' ) . default )", "del_tokens": "play ( 'Tabs' ) . add ( 'Default' , require ( './components/tabs/story/default' ) . default ) . add ( 'Vertical' , require ( './components/tabs/story/vertical' ) . default )", "commit_type": "fix"}
{"commit_tokens": ["add", "views", "option", "to", "control", "view", "visibility"], "add_tokens": "var allViews = [ 'list' , 'creation' , 'edition' , 'show' ] ; var views = op . views || allViews ; views . map ( function ( item ) {", "del_tokens": "[ 'list' , 'creation' , 'edition' , 'show' ] . map ( function ( item ) {", "commit_type": "add"}
{"commit_tokens": ["Make", "test", "page", "ready", "timeout", "configurable"], "add_tokens": "TestRunner . prototype . jasmineRunner = function ( testTimeout , testInterval , testReadyTimeout , callback ) { browser . waitForElementByClassName ( 'alert' , testReadyTimeout , function ( err , el ) { TestRunner . prototype . qunitRunner = function ( testTimeout , testInterval , testReadyTimeout , callback ) { browser . waitForElementById ( testResult , testReadyTimeout , function ( ) { result . testReadyTimeout = data . testReadyTimeout || ( 1000 * 5 ) ; test . forEachBrowser ( arg . configs , test . jasmineRunner , arg . onTestComplete ) . testPages ( arg . pages , arg . testTimeout , arg . testInterval , arg . testReadyTimeout , function ( status ) {", "del_tokens": "TestRunner . prototype . jasmineRunner = function ( testTimeout , testInterval , callback ) { browser . waitForElementByClassName ( 'alert' , 1000 * 5 , function ( err , el ) { TestRunner . prototype . qunitRunner = function ( testTimeout , testInterval , callback ) { browser . waitForElementById ( testResult , 1000 * 5 , function ( ) { test . forEachBrowser ( arg . configs , test . jasmineRunner , arg . onTestComplete ) . testPages ( arg . pages , arg . testTimeout , arg . testInterval , function ( status ) {", "commit_type": "make"}
{"commit_tokens": ["fix", "regression", "for", "storing", "filename"], "add_tokens": "bucket : data . bucket , name : data . name", "del_tokens": "bucket : data . bucket", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "grunt", "-", "csso"], "add_tokens": "createJSAndCSSTasks : function ( cfg , filesToProcess , useCSSO ) { var cssmin = ! useCSSO ? cfg . cssmin = ( cfg . cssmin || { } ) : cfg . csso = ( cfg . csso || { } ) ;", "del_tokens": "createJSAndCSSTasks : function ( cfg , filesToProcess ) { var cssmin = cfg . cssmin = ( cfg . cssmin || { } ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "some", "dumb", "mistakes", "in", "the", "sensors", "library", "still", "not", "getting", "solid", "values", "back"], "add_tokens": "adapter . on ( \"ready\" , this . startReadLoop . bind ( this ) ) ; Sensor . prototype . _recalcMode = function ( newValue ) { var payload = packet . toString ( \"hex\" ) . substr ( 10 , 2 ) ; var payload = packet . toString ( \"hex\" ) . substr ( 10 , 2 ) ; var payload = packet . toString ( \"hex\" ) . substr ( 10 , 2 ) ;", "del_tokens": "this . startReadLoop ( ) ; Sensor . prototype . _recalcMode = function ( ) { var payload = packet . substr ( 10 , 2 ) ; var payload = packet . substr ( 10 , 2 ) ; var payload = packet . substr ( 10 , 2 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "propType", "and", "defaultProps", "declarations"], "add_tokens": "< ListItem key = { key } tag = { item . tag } attributes = { item . attributes } className = \"group\" > { that . getListItems ( item . items , childIndex ++ ) } < / ListItem > var Tag = this . props . tag ; List . defaultProps = { className : '' , tag : 'div' } ; List . propTypes = { className : React . PropTypes . string , items : React . PropTypes . array . isRequired , tag : React . PropTypes . string } ;", "del_tokens": "import ListItemGroup from './ListItemGroup' ; defaultProps : { className : '' , } propTypes : { className : React . PropTypes . string , items : React . PropTypes . array . isRequired , tag : React . PropTypes . string , } childIndex ++ ; < ListItemGroup key = { key } tag = { item . tag } attributes = { item . attributes } > { that . getListItems ( item . items , childIndex ) } < / ListItemGroup > var Tag = this . props . tag || 'div' ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "gettext", "from", "vendor", "instead", "of", "bower"], "add_tokens": "target : '^3.3.0' target : '^2.5.3' ] ) ;", "del_tokens": "target : '^2.6.0' target : '^2.4.1' ] ) . then ( ( ) => { return this . addBowerPackagesToProject ( [ { source : 'git://github.com/Cropster/gettext.js#master' , name : 'gettext.js' , target : '' } ] ) ; } ) ;", "commit_type": "use"}
{"commit_tokens": ["fix", "build", "support", "for", "jsx"], "add_tokens": "const babel = require ( 'rollup-plugin-babel' ) babel ( { exclude : 'node_modules/**' , runtimeHelpers : true", "del_tokens": "const buble = require ( 'rollup-plugin-buble' ) buble ( { objectAssign : 'Object.assign' , jsx : 'h'", "commit_type": "fix"}
{"commit_tokens": ["removed", "dependency", "delete", ";", "fixed", "error", "with", "file", "resets"], "add_tokens": "_this . modified = [ ] ; _this . modified . push ( dep ) ;", "del_tokens": "_this . modified = null ; } else { return file . dependencies . splice ( idx , 1 ) ;", "commit_type": "remove"}
{"commit_tokens": ["Make", "exec", "use", "node", "to", "run", "javascript", "files", "."], "add_tokens": "var args = ( isWin ) ? [ '/c' , script . slice ( - 2 ) === 'js' ? 'node ' + script : script ] : [ ] ;", "del_tokens": "var args = ( isWin ) ? [ '/c' , script ] : [ ] ;", "commit_type": "make"}
{"commit_tokens": ["Add", "basic", "wrapper", "over", "streamy", "blocks"], "add_tokens": "off ( self . from , '.' + self . id ) ; off ( self . to , '.' + self . id ) ; 'top' : fromCoord . top + fromCoord . height / 2 - h , self . to . update ( ) ;", "del_tokens": "off ( self . from , '.' + self . id ) self . from . restart ( ) ; off ( self . to , '.' + self . id ) self . to . restart ( ) ; 'top' : fromCoord . top + fromCoord . height / 2 - h / 2 , self . from . restart ( ) ; self . to . restart ( ) ; self . to . stop ( ) . update ( ) ;", "commit_type": "add"}
{"commit_tokens": ["create", "new", "internal", "error", "type", "NotEnoughDataError", "."], "add_tokens": "const NotEnoughDataError = require ( 'lib/not-enough-data-error' ) throw new NotEnoughDataError ( size , length )", "del_tokens": "throw new Error ( ` ${ size } ${ length } ` )", "commit_type": "create"}
{"commit_tokens": ["Fix", "API", "spec", "in", "source"], "add_tokens": "* 4 ) In case the browser does not support passing object using postMessage ( IE8 + , Opera Mini ) , and no special serialize / deserialize methods are supplied to PostMessageCourier , * 5 ) When Iframe is managed outside of PostMessageCourier ( passed by reference to the constructor ) , * a targetOrigin option is expected to be passed to the constructor , and a query parameter with the name \"lpHost\" is expected on the iframe url ( unless the PostMessageCourier function _registerProxy ( eventChannel ) { if ( eventChannel && \"function\" === typeof eventChannel . registerProxy ) { trigger : function ( ) { * @ param { PostMessageCourier . ACTION_TYPE } action - the action type name", "del_tokens": "* 4 ) In case the browser does not support passing object using postMessage ( IE8 + , Opera Mini ) , and no special serialize / deserialize methods are supplied to LPPostMessageCourier , * 5 ) When Iframe is managed outside of LPPostMessageCourier ( passed by reference to the constructor ) , * a targetOrigin option is expected to be passed to the constructor , and a query parameter with the name \"lphost\" is expected on the iframe url ( unless the LPPostMessageCourier function _registerProxy ( eventChannel ) { if ( eventChannel && eventChannel . registerProxy ) { trigger : function ( ) { * @ param { LPPostMessageCourier . ACTION_TYPE } action - the action type name", "commit_type": "fix"}
{"commit_tokens": ["Added", "getProfile", "login", "and", "logout", "functionality"], "add_tokens": "var fh = require ( \"fh-js-sdk\" ) ; UserService . prototype . getProfile = function ( $http , $window ) { var req = { method : 'GET' , url : fh . getCloudURL ( ) + '/profile' } ; return $http ( req , { withCredentials : true } ) . then ( function ( res ) { return res . data ; } , function ( err ) { if ( err . status === 401 ) { $window . location = fh . getCloudURL ( ) + '/login' ; } if ( err . status === 403 ) { console . log ( 'Forbidden' ) } return err ; } ) ;", "del_tokens": "UserService . prototype . getProfile = function ( userId ) { return this . readUser ( userId ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "formFiller", "bug", "on", "IE"], "add_tokens": "var elementTypes = [ ] ; if ( matchesSelector ( element , selector ) ) { function matchesSelector ( el , selector ) { if ( el . webkitMatchesSelector ) { matchesSelector = function ( el , selector ) { return el . webkitMatchesSelector ( selector ) ; } ; } else if ( el . mozMatchesSelector ) { matchesSelector = function ( el , selector ) { return el . mozMatchesSelector ( selector ) ; } ; } else if ( el . msMatchesSelector ) { matchesSelector = function ( el , selector ) { return el . msMatchesSelector ( selector ) ; } ; } else if ( el . oMatchesSelector ) { matchesSelector = function ( el , selector ) { return el . oMatchesSelector ( selector ) ; } ; } else { throw new Error ( 'Unsupported browser' ) ; } return matchesSelector ( el , selector ) ;", "del_tokens": "var elementTypes = [ ] , matchFunction = getMatchFunctionName ( ) ; if ( element [ matchFunction ] ( selector ) ) { function getMatchFunctionName ( ) { var el = document . querySelector ( 'body' ) ; return ( el . mozMatchesSelector || el . msMatchesSelector || el . oMatchesSelector || el . webkitMatchesSelector ) . name ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "global", "registries", "added", "default", "registry"], "add_tokens": "var _registries = ( window || global ) ; if ( ! _registries . _occamsrazor_registries ) { _registries . _occamsrazor_registries = { } ; _registries = _registries . _occamsrazor_registries ; registry_name = registry_name || \"default\" ;", "del_tokens": "var _registries = ( window || global ) . _occamsrazor_registry ; if ( ! _registries ) { _registries = { } ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "single", "page", "application", "routing", "to", "index", "html", "-", "via", "directly", "or", "url"], "add_tokens": "res . status ( 404 ) . sendFile ( path . resolve ( p404 ) ) res . status ( 404 ) . sendFile ( path . resolve ( index ) )", "del_tokens": "if ( ! staticPath . startsWith ( \"/\" ) ) staticPath = process . cwd ( ) + \"/\" + staticPath res . status ( 404 ) . sendFile ( p404 ) res . status ( 404 ) . sendFile ( index )", "commit_type": "fix"}
{"commit_tokens": ["update", "tests", "to", "use", "latest", "express", "2", ".", "x", "and", "3", ".", "x", "always"], "add_tokens": "npm . commands . install ( [ 'express@~2.5.10' ] , function ( ) {", "del_tokens": "npm . commands . install ( [ 'express@=2.5.10' ] , function ( ) {", "commit_type": "update"}
{"commit_tokens": ["add", "some", "more", "whitespace", "to", "be", "safe", "around", "comments"], "add_tokens": "source . append ( '\\n});' ) bundle . append ( '\\n}());' )", "del_tokens": "source . append ( '});' ) bundle . append ( '}());' )", "commit_type": "add"}
{"commit_tokens": ["move", "line", "width", "unit", "conversion"], "add_tokens": "// renderer.buildPolylines(feature.geometry.coordinates, feature, layer, { color: [1, 0, 0] /*[Math.random(), Math.random(), Math.random()]*/, width: Style.width.pixels(1, tile) }, tile, z + 0.01, triangles, lines, { closed_polygon: true, remove_tile_edges: true }); // renderer.buildPolylines(feature.geometry.coordinates[mpc], feature, layer, { color: [1, 0, 0], width: Style.width.pixels(1, tile) }, tile, z + 0.01, triangles, lines, { closed_polygon: true, remove_tile_edges: true });", "del_tokens": "style . width *= VectorRenderer . units_per_meter [ tile . coords . z ] ; // renderer.buildPolylines(feature.geometry.coordinates, feature, layer, { color: [1, 0, 0] /*[Math.random(), Math.random(), Math.random()]*/, width: (Style.width.pixels(2, tile) * VectorRenderer.units_per_meter[tile.coords.z]) }, tile, this.calculateZ(layer, tile, 0.01), triangles, lines, { closed_polygon: true, remove_tile_edges: true }); // renderer.buildPolylines(feature.geometry.coordinates[mpc], feature, layer, { color: [1, 0, 0], width: (Style.width.pixels(2, tile) * VectorRenderer.units_per_meter[tile.coords.z]) }, tile, this.calculateZ(layer, tile, 0.01), triangles, lines, { closed_polygon: true, remove_tile_edges: true });", "commit_type": "move"}
{"commit_tokens": ["Fixed", "js", "formatting", "+", "comment"], "add_tokens": "that . _animationEnd ( ) ; // Register custom Easing function easings [ name ] = fn ;", "del_tokens": "that . _animationEnd ( ) ; // Note that this does not prevent overriding easings; this could be a pitfall or a feature, // but we leave it to the developer to be intelligent about how they use this. easings [ name ] = fn ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "span", "instead", "of", "div", "for", "transclution"], "add_tokens": "'<span ng-transclude></span>' +", "del_tokens": "'<div ng-transclude></div>' +", "commit_type": "use"}
{"commit_tokens": ["Moved", "the", "configuration", "files", "to", "a", "dedicated", "folder"], "add_tokens": "out : join ( __dirname , '../doc/api' )", "del_tokens": "out : join ( __dirname , 'api' )", "commit_type": "move"}
{"commit_tokens": ["Fix", "deep", "nested", "routes", "to", "work", "as", "expected", "."], "add_tokens": "const port = process . env . PORT || 7777 // Evaluate initializer files before starting the server. _ . each ( glob . sync ( ` ${ process . cwd ( ) } ` ) , require )", "del_tokens": "const port = process . env . PORT || 7777 // Evaluate initializer files before starting the server. _ . each ( glob . sync ( ` ${ process . cwd ( ) } ` ) , require )", "commit_type": "fix"}
{"commit_tokens": ["Move", "to", "use", "@leo", "s", "args"], "add_tokens": "const args = require ( 'args' ) args . option ( 'header' , 'HTTP request header' ) // TODO update this -> header . option ( 'baseURL' , 'Base URL for sending HTTP requests' ) const flags = args . parse ( process . argv ) if ( args . sub && args . sub . length ) { checkPath ( ` ${ __dirname } ${ args . sub [ 0 ] } ` ) . catch ( ( ) => args . sub [ 0 ] ) . then ( sendQuery ( flags ) ) . then ( ( ) => process . exit ( ) ) } else { // REPL REPL ( flags )", "del_tokens": "const args = process . argv . slice ( 2 ) if ( args . length && args . length % 2 === 1 ) { const queryOrFile = args . pop ( ) checkPath ( ` ${ __dirname } ${ queryOrFile } ` ) . catch ( ( ) => queryOrFile ) . then ( sendQuery ( args ) ) process . exit ( ) // REPL REPL ( args )", "commit_type": "move"}
{"commit_tokens": ["Added", "examples", "and", "cleaned", "the", "source", "a", "bit", "more", "up", ".", "All", "exports", "are", "at", "the", "bottom", "."], "add_tokens": "bisection = function ( array , x , low , high ) { / * example usage : var sys = require ( 'sys' ) , hashing = require ( '../lib/hashring' ) , hashring = new hashing . hashRing ( [ '192.168.0.102:11212' , '192.168.0.103:11212' , '192.168.0.104:11212' ] , // Weights are optional, but can be usefull if you have memcached server that can use allot of memory { '192.168.0.102:11212' : 1 , '192.168.0.103:11212' : 2 , '192.168.0.104:11212' : 1 } ) ; sys . puts ( hashring . get_node ( \"my-super-secret-cache-key\" ) ) sys . puts ( hashring . get_node ( \"hello-world\" ) ) sys . puts ( hashring . get_node ( \"my-super-secret-cache-key\" ) ) * / hashRing = function ( nodes , weights ) { } ; // export the modules exports . bisection = bisection ; exports . hashRing = hashRing ;", "del_tokens": "exports . bisection = bisection = function ( array , x , low , high ) { exports . hashRing = hashRing = function ( nodes , weights ) { } ;", "commit_type": "add"}
{"commit_tokens": ["Changing", "the", "command", "/", "header", "representation", "object", "interface"], "add_tokens": "index : Infinity index : Infinity index : Infinity index : - 1 index : - 1 index : 38 index : Infinity", "del_tokens": "indexing : true indexing : true indexing : true indexing : false indexing : false indexing : true , substitution : 38 indexing : true", "commit_type": "change"}
{"commit_tokens": ["updating", "to", "replace", "all", "in", "navigation"], "add_tokens": "nav . prev = { label : \"MBINSERTPREVLABEL\" , href : \"MBINSERTPREVHREF\" } nav . next = { label : \"MBINSERTNEXTLABEL\" , href : \"MBINSERTNEXTHREF\" } contents = contents . replace ( / MBINSERTPREVLABEL / g , title ) ; contents = contents . replace ( / MBINSERTPREVHREF / g , href ) ; contents = contents . replace ( / MBINSERTNEXTLABEL / g , title ) ; contents = contents . replace ( / MBINSERTNEXTHREF / g , href ) ;", "del_tokens": "nav . prev = { label : \"MBINSERT:PREV:LABEL\" , href : \"MBINSERT:PREV:HREF\" } nav . next = { label : \"MBINSERT:NEXT:LABEL\" , href : \"MBINSERT:NEXT:HREF\" } contents = contents . replace ( \"MBINSERT:PREV:LABEL\" , title ) ; contents = contents . replace ( \"MBINSERT:PREV:HREF\" , href ) ; contents = contents . replace ( \"MBINSERT:NEXT:LABEL\" , title ) ; contents = contents . replace ( \"MBINSERT:NEXT:HREF\" , href ) ;", "commit_type": "update"}
{"commit_tokens": ["use", "ES6", "export", "statement", "in", "the", "ES7", "example", "project"], "add_tokens": "export default function ( app ) {", "del_tokens": "module . exports = function ( app ) {", "commit_type": "use"}
{"commit_tokens": ["Add", "a", "horizontal", "rule", "to", "the", "colours", "page"], "add_tokens": "foundation . < br / > We are committed to complying with { ' ' } < hr className = { styles . hr } / >", "del_tokens": "foundation . We are committed to complying with { ' ' }", "commit_type": "add"}
{"commit_tokens": ["Make", "restartAt", "less", "expensive", ".", "It", "is", "now", "a", "quasi", "-", "noop", "if", "the", "parser", "is", "already", "at", "the", "beginning", "of", "the", "document", "."], "add_tokens": "this . stop ( ) ; if ( ( this . _initialized ) && ( this . _events . length > 0 ) ) {", "del_tokens": "if ( this . _initialized ) {", "commit_type": "make"}
{"commit_tokens": ["Moved", "detection", "of", "conn", "errors", "to", "debugger", "."], "add_tokens": "contentLengthMatch , lastError ; if ( e . code == 'ECONNREFUSED' ) { e . helpString = 'Is node running with --debug port ' + port + '?' ; } else if ( e . code == 'ECONNRESET' ) { e . helpString = 'Check there is no other debugger client attached to port ' + port + '.' ; } lastError = e . toString ( ) ; if ( e . helpString ) { lastError += '. ' + e . helpString ; } debugr . emit ( 'close' , lastError || 'Debugged process exited.' ) ;", "del_tokens": "contentLengthMatch ; debugr . emit ( 'close' ) ;", "commit_type": "move"}
{"commit_tokens": ["Adds", "characters", "to", "toEmojis", "skip", "list"], "add_tokens": "// const skipRe = /[\\p{L}\\sA-Za-z!@$%^&()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/ const skipRe = / [0-9#@\\p{L}\\sA-Za-z!@$%^&()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?] /", "del_tokens": "const skipRe = / [\\p{L}\\sA-Za-z!@$%^&()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?] /", "commit_type": "add"}
{"commit_tokens": ["Fix", "move", "action", "cmd", "."], "add_tokens": "refactor . renameModuleSource ( targetPath , ` ${ source . name } ` , ` ${ dest . name } ` ) ;", "del_tokens": "utils . replaceStringLiteral ( targetPath , ` ${ source . name } ` , ` ${ dest . name } ` ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "BSVDM", "and", "ABVDM", "as", "possible", "message", "prefixes"], "add_tokens": "} else if ( nmea [ 0 ] !== \"!AIVDM\" && // AIVDM: others nmea [ 0 ] !== \"!AIVDO\" && // AIVDO: own AIS nmea [ 0 ] !== \"!BSVDM\" && // BSVDM: from base stations nmea [ 0 ] !== \"!ABVDM\" ) { // ABVDM: from base stations", "del_tokens": "} else if ( nmea [ 0 ] !== \"!AIVDM\" && nmea [ 0 ] !== \"!AIVDO\" ) { //AIVDM = standard, AIVDO = own ship", "commit_type": "add"}
{"commit_tokens": ["fix", "source", "tree", "not", "showing", "all", "sources", "sometimes"], "add_tokens": "subtree . contents . unshift ( createNode ( \"(index)\" , source . get ( \"url\" ) , source ) ) ;", "del_tokens": "subtree . contents = [ createNode ( \"(index)\" , source . get ( \"url\" ) , source ) ] ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "JS", "execution", "in", "before", "DOM", "Ready", "to", "the", "bad", "practices"], "add_tokens": "$scope . inBodyDomManipulations = 0 ; if ( node . data . timestamp < $scope . phantomasResults . metrics . domInteractive && node . data . type !== 'jQuery - onDOMReady' ) { $scope . inBodyDomManipulations ++ ; } $scope . phantomasResults . metrics . globalVariables / 20 + Math . sqrt ( $scope . inBodyDomManipulations ) ; if ( score > 10 ) { if ( score > 15 ) { if ( score > 20 ) { if ( score > 30 ) { if ( score > 45 ) {", "del_tokens": "$scope . phantomasResults . metrics . globalVariables / 20 ; if ( score > 5 ) { if ( score > 10 ) { if ( score > 15 ) { if ( score > 25 ) { if ( score > 40 ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "watch", "task", "improve", "test", "task"], "add_tokens": "var paths = { test : [ 'index.js' , 'rules/**/*.js' ] , watch : [ 'rules/**/*.js' , 'test/**/*.js' ] } ; var watching = false ; function handleError ( error ) { console . log ( error . toString ( ) ) ; if ( watching ) { this . emit ( 'end' ) ; } else { process . exit ( 1 ) ; } } gulp . src ( paths . test ) . pipe ( mocha ( { reporter : 'nyan' } ) . on ( 'error' , handleError ) ) gulp . task ( 'default' , [ 'watch' ] ) ; gulp . task ( 'watch' , function ( ) { watching = true ; gulp . watch ( paths . watch , [ 'test' ] ) ; } ) ;", "del_tokens": "var eslint = require ( 'gulp-eslint' ) ; gulp . task ( 'quality' , function ( ) { return gulp . src ( [ '*.js' , '{rules,test}/**/*.js' ] ) . pipe ( eslint ( ) ) . pipe ( eslint . format ( ) ) . pipe ( eslint . failAfterError ( ) ) ; } ) ; gulp . src ( [ 'index.js' , 'rules/**/*.js' ] ) . pipe ( mocha ( ) ) gulp . task ( 'default' , [ 'quality' , 'test' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "bcrypt", "work", "factor", "option", "."], "add_tokens": ", workFactor = ( options . workFactor || 10 ) bcrypt . gen_salt ( workFactor , function ( err , salt ) {", "del_tokens": "bcrypt . gen_salt ( 10 , function ( err , salt ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "onChange", "callback", "+", "addItem", "exception", "."], "add_tokens": "'change' : 'onChange' , active = this . $activeOption && $option [ 0 ] === this . $activeOption [ 0 ] ;", "del_tokens": "'on_change' : 'onChange' , active = $option [ 0 ] === this . $activeOption [ 0 ] ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "external", "official", "product", "map", "file"], "add_tokens": "var versionInfo = _ . pick ( msg , [ ] ) ; callback ( null , _ . assign ( versionInfo , utils . getHardwareDetails ( versionInfo . vendorId , versionInfo . productId ) ) ) ;", "del_tokens": "callback ( null , _ . pick ( msg , [ 'vendorName' , 'productName' , ] ) ) ;", "commit_type": "use"}
{"commit_tokens": ["updated", "README", "and", "added", "some", "comments"], "add_tokens": "/ ** * Create server * Params : * - server : server created by express * - spec : path to spore description file * - imple * /", "del_tokens": "", "commit_type": "update"}
{"commit_tokens": ["adding", "readyOnLoad", "fix", "to", "still", "call", "load", "callback"], "add_tokens": "tick ( function ( ) { if ( self . _readyOnLoad ) self . emit ( 'ready' ) ; callback && callback ( ) ; } ) ;", "del_tokens": "if ( self . _readyOnLoad ) { tick ( function ( ) { self . emit ( 'ready' ) ; callback && callback ( ) ; } ) ; }", "commit_type": "add"}
{"commit_tokens": ["Remove", "base", "64", "encoding", "from", "build", "process", ".", "Fix", "sass", "node", "asset", "paths"], "add_tokens": "// .pipe(base64({ // baseDir: 'app/assets', // extensions: ['svg', 'png', 'woff'], // maxImageSize: 200 * (1024 * 1024), // debug: false // })) // .pipe(gulp.dest(paths.assetsScss))", "del_tokens": ". pipe ( base64 ( { baseDir : 'app/assets' , extensions : [ 'svg' , 'png' , 'woff' ] , maxImageSize : 200 * ( 1024 * 1024 ) , debug : false } ) ) . pipe ( gulp . dest ( paths . assetsScss ) )", "commit_type": "remove"}
{"commit_tokens": ["Move", "Undefinable", "tests", "to", "ava"], "add_tokens": "import test from 'ava' ; import { andForUndefinable } from '../../__dist/cjs/Undefinable/and' ; import { nonNullableValue } from '../utils' ; test ( 'Undefinable::and' , ( t ) => { t . is ( andForUndefinable ( a , b ) , expected , ` ${ String ( a ) } ${ String ( b ) } ` ) ;", "del_tokens": "'use strict' ; const assert = require ( 'assert' ) ; const { andForUndefinable } = require ( '../../__dist/cjs/Undefinable/and' ) ; const { nonNullableValue } = require ( '../utils' ) ; describe ( 'Undefinable::and' , ( ) => { it ( ` ${ String ( a ) } ${ String ( b ) } ` , ( ) => { assert . strictEqual ( andForUndefinable ( a , b ) , expected ) ; } ) ;", "commit_type": "move"}
{"commit_tokens": ["Fix", "issue", "with", "listening", "to", "eventemitter2", "events", "incorrectly"], "add_tokens": "self . fsw . on ( 'esl::event::**' , function ( evt ) { self . fsw . on ( 'esl::event::MESSAGE::*' , function ( evt ) {", "del_tokens": "self . fsw . on ( 'esl::event::*' , function ( evt ) { self . fsw . on ( 'esl::event::MESSAGE' , function ( evt ) {", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "model", ".", "saveAttachment", "()", "."], "add_tokens": "modelfunc . prototype . saveAttachment = function ( name , callback ) { var self = this ; var payload = JSON . stringify ( this . __attachments [ name ] ) ; modelfunc . adapter . saveAttachment ( this . _idRevStruct ( ) , payload , function ( err , response ) { if ( err ) return callback ( err ) ; self . _rev = response . rev ; callback ( null , response ) ; } ) ; } ;", "del_tokens": "if ( ! this . __attachments ) return ; if ( ! this . __attachments ) this . __attachments = { } ;", "commit_type": "implement"}
{"commit_tokens": ["adding", "additional", "placement", "-", "center", "top"], "add_tokens": "attrs . $observe ( 'tourtipPlacement' , function ( val ) { scope . ttPlacement = ( val || tourConfig . placement ) . toLowerCase ( ) . trim ( ) ; scope . centered = ( scope . ttPlacement . indexOf ( 'center' ) === 0 ) ; top : top + 0.5 * ( position . height - ttHeight ) + scope . ttOffset , left : position . left + 0.5 * ( position . width - ttWidth ) } ; break ; case 'center-top' : ttPosition = { top : top + 0.1 * ( position . height - ttHeight ) + scope . ttOffset ,", "del_tokens": "attrs . $observe ( 'tourtipPlacement' , function ( val ) { scope . ttPlacement = ( val || tourConfig . placement ) . toLowerCase ( ) ; scope . centered = ( scope . ttPlacement === 'center' ) ; top : top + 0.5 * ( position . height - ttHeight ) ,", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "--", "binary", "-", "args"], "add_tokens": "var args = [ '-profile' , profile ] ; if ( options . binaryArgs ) args = args . concat ( options . binaryArgs . split ( \" \" ) ) ; var proc = execFile ( binary , args , function ( err , stdout , stderr ) {", "del_tokens": "var proc = execFile ( binary , [ \"-profile\" , profile ] , function ( err , stdout , stderr ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "parent", "position", "when", "walking", "child", "nodes"], "add_tokens": "walkNode ( child , node . layer . frame . x , node . layer . frame . y ) ;", "del_tokens": "walkNode ( child , node . layout . left , node . layout . top ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "glob", "as", "a", "registered", "factory", "."], "add_tokens": "bottle . factory ( 'node.fs' , function ( ) { return require ( 'fs' ) ; } ) ; bottle . factory ( 'glob' , function ( ) { return require ( 'glob' ) ; } ) ;", "del_tokens": "bottle . factory ( 'node.fs' , function ( ) { return require ( 'fs' ) } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "status", "token", "incorrectly", "displaying", "before", "response", "in", "dev", "format"], "add_tokens": "// get the status code if response written var status = res . _header ? res . statusCode : undefined", "del_tokens": "// get the status code var status = res . statusCode", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "endEvent", "issue", "on", "touch", "devices"], "add_tokens": "firstTap , origEvent ; origEvent = e . originalEvent ;", "del_tokens": "firstTap ; var origEvent = e . originalEvent ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "update", "method", "to", "VueWrapper", "-", "force", "update", "on", "component", "when", "simulate", "is", "called"], "add_tokens": "super ( mountedVm . _vnode , mountedVm . _watcher . run . bind ( mountedVm . _watcher ) ) ; this . mountedVm = mountedVm ;", "del_tokens": "super ( mountedVm . _vnode ) ; // eslint-disable-line no-underscore-dangle", "commit_type": "add"}
{"commit_tokens": ["Fixing", "test", "on", "middleware", "Content", "-", "Type"], "add_tokens": ". expect ( 'Content-Type' , / text\\/html / )", "del_tokens": ". expect ( 'Content-Type' , 'text/html' )", "commit_type": "fix"}
{"commit_tokens": ["Make", "amp", "-", "analytics", "dependencies", "explicit"], "add_tokens": "skipCanonical : document . hasCanonical ( ) , includesAnalytics : document . importsComponent ( 'amp-analytics' )", "del_tokens": "skipCanonical : document . hasCanonical ( )", "commit_type": "make"}
{"commit_tokens": ["fixed", "tests", "after", "the", "dup", "callback", "issue", "was", "fixed", ".", "no", "longer", "using", "setTimeout"], "add_tokens": "done ( ) ; done ( ) ;", "del_tokens": "setTimeout ( done , 300 ) ; // done(); // TODO: Should be called here setTimeout ( done , 500 ) ; // TODO: Remove", "commit_type": "fix"}
{"commit_tokens": ["added", "new", "test", "for", "twitterSearch"], "add_tokens": "//search all tweets params q is required W . searchTweets ( { q : '#nike' , count : 100 } , function ( data , err ) { console . log ( data , err ) ; } ) ;", "del_tokens": "// search all tweets params q is required // W.searchGeo(function(data, err){ // console.log(data, err); // }, '#nike', 'NY');", "commit_type": "add"}
{"commit_tokens": ["Added", "note", ".", "isNote", "scale", ".", "isScale", "chord", ".", "isChord", "and", "Note", ".", "fullName", ".", "Fixed", "issues", "with", "setting", "octave", "numbers", "internally", "."], "add_tokens": "this . fullName = this . octave ? this . name + this . octave : this . name ; return this . fullName ; if ( this . lowerThan ( note ) ) note = createNote ( note , note . octave - 1 ) ; if ( int . number > 7 ) note = createNote ( note , note . octave - 1 ) ; if ( this . higherThan ( note ) ) note = createNote ( note , note . octave + 1 ) ; if ( int . number > 7 ) note = createNote ( note , note . octave + 1 ) ; note = createNote ( note , random . integer ( lower . octave , upper . octave ) ) ; module . exports . isNote = isNote ;", "del_tokens": "return this . octave ? this . name + this . octave : this . name ; if ( this . lowerThan ( note ) ) note . octave -= 1 ; if ( int . number > 7 ) note . octave -= 1 ; if ( this . higherThan ( note ) ) note . octave += 1 ; if ( int . number > 7 ) note . octave += 1 ; note . octave = random . integer ( lower . octave , upper . octave ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "()", "now", "returns", "the", "model", "instead", "of", "undefined", "."], "add_tokens": "return this . set ( attrStr + '[' + current . length + ']' , value , opts ) ;", "del_tokens": "this . set ( attrStr + '[' + current . length + ']' , value , opts ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "wrong", "condition", "order", "in", "A", "*"], "add_tokens": "Version 0.7 ~ dev , generated on Wed Aug 2 16 : 49 : 07 CEST 2017. if ( item . x == fromX && item . y == fromY ) { break ; }", "del_tokens": "Version 0.7 ~ dev , generated on Wed Aug 2 16 : 32 : 49 CEST 2017. if ( item . x == fromX && item . y == fromY ) { break ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "the", "ability", "pass", "options", "to", "the", "gulp", "-", "ruby", "-", "sass", "preprocessor"], "add_tokens": "dest : opt . dest || 'styleguide/' , sass : opt . sass || { } preprocess ( Object . keys ( filesBuffer ) , opt , function ( ) { function preprocess ( files , opt , callback ) { opt . sass [ 'quiet' ] = true ; // Supress gulp-ruby-sass messages . pipe ( sass ( opt . sass ) ) . pipe ( vfs . dest ( opt . dest ) )", "del_tokens": "dest : opt . dest || 'styleguide/' preprocess ( Object . keys ( filesBuffer ) , opt . dest , function ( ) { function preprocess ( files , dest , callback ) { . pipe ( sass ( { quiet : true } ) ) . pipe ( vfs . dest ( dest ) )", "commit_type": "add"}
{"commit_tokens": ["fixed", "bug", "in", "router", "fixed", "bug", "in", "Widget", "s", "setClass"], "add_tokens": "function cleanRoute ( r ) { if ( r && r . length && ( r . indexOf ( '#' ) === 0 ) ) { return r . substr ( 1 ) ; } return r ; } function getRoute ( ) { var r = hash ( ) ; return cleanRoute ( r ) ; } function setRoute ( route , replace ) { return hash ( route , replace ) ; } route = cleanRoute ( route ) ; var current = getRoute ( ) ; setRoute ( route , replace ) ; evt . newURL = evt . newURL || getRoute ( ) ;", "del_tokens": "var current = hash ( ) ; hash ( route , replace ) ; evt . newURL = evt . newURL || hash ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "protocols", "to", "parse", "the", "protocols"], "add_tokens": "// Dependencies var Protocols = require ( \"protocols\" ) ; var protocols = Protocols ( input ) ; input = input . substring ( input . indexOf ( \"://\" ) + 3 ) ; if ( protocols . indexOf ( \"ssh\" ) !== - 1 || protocols . indexOf ( \"rsync\" ) !== - 1 ) {", "del_tokens": "var index = input . indexOf ( \"://\" ) , protocol = input . substring ( 0 , index ) . split ( \"+\" ) ; input = input . substring ( index + 3 ) ; if ( protocol . indexOf ( \"ssh\" ) !== - 1 || protocol . indexOf ( \"rsync\" ) !== - 1 ) {", "commit_type": "use"}
{"commit_tokens": ["add", "tests", "for", "reporter", "done"], "add_tokens": "console . log ( JSON . stringify ( msg ) ) ;", "del_tokens": "console . log ( JSON . stringify ( msg ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Create", "keyRange", "only", "when", "bounds", "are", "given"], "add_tokens": "var upper = nodeCache . upper . value , hasUpper = upper != '' , lower = nodeCache . lower . value , hasLower = lower != '' , keyRange , if ( hasUpper || hasLower ) { // create a keyRange only if bounds are given var options = { } ; if ( hasUpper ) { options . upper = upper ; options . excludeUpper = nodeCache . excludeUpper . checked ; } if ( hasLower ) { options . lower = lower ; options . excludeLower = nodeCache . excludeLower . checked ; } keyRange = customers . makeKeyRange ( options ) ;", "del_tokens": "var upperValue = nodeCache . upper . value , hasUpper = upperValue != '' , lowerValue = nodeCache . lower . value , hasLower = lowerValue != '' , var options = { } ; if ( hasUpper ) { options . upper = upperValue ; options . excludeUpper = nodeCache . excludeUpper . checked ; if ( hasLower ) { options . lower = lowerValue ; options . excludeLower = nodeCache . excludeLower . checked ; } var keyRange = customers . makeKeyRange ( options ) ;", "commit_type": "create"}
{"commit_tokens": ["Fix", "use", "of", ".", "pushState", "and", ".", "replaceState", "and", "backwards", "/", "forwards", "navigation"], "add_tokens": "this . _loc = location . pathname ; if ( this . _clickListener ) { return ; } this . goTo ( href , true ) ; Router . prototype . goTo = function ( path , push ) { this . refresh ( push ) ; Router . prototype . refresh = function ( push ) { var method = push ? 'pushState' : 'replaceState' ; window . history [ method ] ( { } , null , path ) ;", "del_tokens": "this . goTo ( href ) ; Router . prototype . goTo = function ( path ) { this . refresh ( ) ; Router . prototype . refresh = function ( ) { window . history . pushState ( { } , null , path ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "viewModel", "work", "with", "CanMap", "constructors"], "add_tokens": "// Backwards compatible with viewModel: Map // If this a CanMap constructor, use that as the ViewModel property. var protoViewModel = this . prototype . viewModel ; if ( protoViewModel && this . prototype . ViewModel ) { throw new Error ( \"Cannot provide both a ViewModel and a viewModel property\" ) ; } if ( protoViewModel && types . isMapLike ( protoViewModel . prototype ) ) { this . prototype . viewModel = undefined ; } else { protoViewModel = undefined ; } this . ViewModel = this . prototype . ViewModel || protoViewModel || types . DefaultMap ;", "del_tokens": "// Do nothing, assume constructor this . ViewModel = this . prototype . ViewModel || types . DefaultMap ;", "commit_type": "make"}
{"commit_tokens": ["Allow", "Range", "to", "be", "single", "argument"], "add_tokens": "const { assert , isArray } = Ember ; / * If just a value is provided for the range , we should just assume that ' * / if ( ! isArray ( range ) ) { range = [ 0 , range || 1 ] ; }", "del_tokens": "const { assert } = Ember ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "an", "option", "to", "using", "attribute", "name", "as", "a", "path", "(", "true", "by", "default", ")"], "add_tokens": "if ( this . options . attrNameAsPath === void 0 ) { this . options . attrNameAsPath = true ; } && ( ! attrRules || ! attrRules . length || matchAttributes ( node , attrRules , this . options ) )", "del_tokens": "&& ( ! attrRules || ! attrRules . length || matchAttributes ( node , attrRules ) )", "commit_type": "add"}
{"commit_tokens": ["Updated", "getRecentGames", "with", "additional", "name", "parameter"], "add_tokens": "getRecentGames ( { region , id , name } = { } , cb ) { if ( ( ! id || ! Number . isInteger ( id ) ) && ! name ) return this . _logError ( ` ${ chalk . yellow ( '`id` (int)' ) } ${ chalk . yellow ( '`name` (string)' ) } ` if ( id && Number . isInteger ( id ) ) return this . _gameRequest ( { endUrl : ` ${ id } ` , region } , cb ) if ( typeof name === 'string' ) { return this . getSummoner ( { name } , ( err , data ) => { return this . _gameRequest ( { endUrl : ` ${ data [ this . _sanitizeName ( name ) ] . id } ` , region } , cb ) } ) }", "del_tokens": "getRecentGames ( { region , id } = { } , cb ) { if ( ! id || ! Number . isInteger ( id ) ) return this . _logError ( ` ${ chalk . yellow ( '`id` (int)' ) } ` return this . _gameRequest ( { endUrl : ` ${ id } ` , region } , cb )", "commit_type": "update"}
{"commit_tokens": ["Improve", "calling", "of", "the", "internal", "boom", "function", "-", "call", "with", "the", "correct", "args"], "add_tokens": "const boomArgs = _ . take ( allArgs , funcDefaultArgs . length ) ; let result = func . call ( null , ... boomArgs ) ;", "del_tokens": "let result = func . call ( null , ... allArgs ) ;", "commit_type": "improve"}
{"commit_tokens": ["Add", "zos", "-", "lib", "dependency", "and", "update", "openzeppelin", "-", "zos", "dependency"], "add_tokens": "log . info ( \"<< Setting up AppManager >>\" ) log . info ( \"\\n<< Deploying version 1 >>\" ) log . info ( \"\\n<< Deploying version 2 >>\" ) log . info ( ` ${ contractName } ` ) log . info ( ` ${ proxyAddress } ` ) log . info ( \"Setting application's token...\" ) log . info ( \"Token set succesfully\" )", "del_tokens": "log ( \"<< Setting up AppManager >>\" ) log ( \"\\n<< Deploying version 1 >>\" ) log ( \"\\n<< Deploying version 2 >>\" ) log ( ` ${ contractName } ` ) log ( ` ${ proxyAddress } ` ) log ( \"Setting application's token...\" ) log ( \"Token set succesfully\" )", "commit_type": "add"}
{"commit_tokens": ["Use", "Print", "module", "for", "generating", "diffs"], "add_tokens": "const print = require ( \"print\" ) ; print ( error . expected ) , print ( error . actual )", "del_tokens": "JSON . stringify ( error . expected , null , \"\\t\" ) , JSON . stringify ( error . actual , null , \"\\t\" )", "commit_type": "use"}
{"commit_tokens": ["Added", "roomID", "and", "more", "buttons", "to", "monitor"], "add_tokens": "type : 'CLIENTS' , roomId : this . roomId var that ; that = this ; button = document . createElement ( 'button' ) ; button . innerHTML = 'Start' ; button . onclick = function ( ) { node . remoteCommand ( 'start' , 'ROOM_' + that . roomId ) ; } ; root . appendChild ( button ) ; button = document . createElement ( 'button' ) ; button . innerHTML = 'Stop' ; button . onclick = function ( ) { node . remoteCommand ( 'stop' , 'ROOM_' + that . roomId ) ; } ; root . appendChild ( button ) ; node . remoteCommand ( 'pause' , 'ROOM_' + that . roomId ) ; node . remoteCommand ( 'resume' , 'ROOM_' + that . roomId ) ;", "del_tokens": "type : 'CLIENTS' , roomId : this . roomId node . remoteCommand ( 'pause' , 'ALL' ) ; node . remoteCommand ( 'resume' , 'ALL' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "a", "test", ".", "(", "finally", ")"], "add_tokens": "src : [ 'test/*.js' ] } } , clean : { test : '.tmp' } , copy : { test : { expand : true , cwd : 'test/fixture/' , src : '**/*' , dest : '.tmp/' grunt . loadNpmTasks ( 'grunt-contrib-copy' ) ; grunt . loadNpmTasks ( 'grunt-contrib-clean' ) ; grunt . registerTask ( 'default' , [ 'jshint' , 'clean' , 'copy' , 'nodeunit' , 'clean' ] ) ;", "del_tokens": "src : [ 'test/**/*.js' ] grunt . registerTask ( 'default' , [ 'jshint' , 'nodeunit' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "Modernizr", "to", "the", "Gulp", "workflow"], "add_tokens": "define ( [ 'afontgarde' ] , function ( ) { 'use strict' ; // Old icon fonts, currently used in the platform. window . AFontGarde ( 'FontAwesome' , { glyphs : '&#61515;' // New icon fonts for UXPL to eventually replace FontAwesome. window . AFontGarde ( 'edx-icons' , { glyphs : '\\uE621\\uE622\\uE623' } ) ; } ) ;", "del_tokens": "define ( [ 'afontgarde' ] , function ( ) { 'use strict' ; window . AFontGarde ( 'edx-icons' , { // Check a few random icons to see if our font loads glyphs : '\\uE621\\uE622\\uE623' } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "the", "interleave", "function", "."], "add_tokens": "grob . interleave = function ( ) { if ( arguments . length === 0 ) return [ ] ; var results = [ ] ; var elIndex = 0 ; while ( true ) { for ( var i = 0 ; i < arguments . length ; i ++ ) { var arg = arguments [ i ] ; if ( arg . length > elIndex ) { results . push ( arg [ elIndex ] ) ; } else { return results ; } } elIndex += 1 ; } } ; module . exports = grob ;", "del_tokens": "module . exports = grob ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "heading", "content", "to", "not", "include", "stack"], "add_tokens": ". expect ( / <title>Error: boom!<\\/title> / ) . expect ( / <h2><em>500<\\/em> Error: boom!<\\/h2> / ) . expect ( / <li> &nbsp; &nbsp;at / )", "del_tokens": ". expect ( / <title> / ) . expect ( / Error: boom! / ) . expect ( / &nbsp; &nbsp;at / )", "commit_type": "fix"}
{"commit_tokens": ["Used", "gpf", ".", "defer", "to", "limit", "call", "stack", "size"], "add_tokens": "gpf . defer ( stream . read , 0 , stream , [ 0 , callback ] ) ; type = event . type ( ) , stream = event . scope ( ) ; gpf . defer ( stream . read , 0 , stream , [ 0 , this . callback ] ) ;", "del_tokens": "stream . read ( 0 /*as much as possible*/ , callback ) ; type = event . type ( ) ; event . scope ( ) . read ( 0 /*as much as possible*/ , this . callback ) ;", "commit_type": "use"}
{"commit_tokens": ["Use", "a", "local", "JSS", "instance", "to", "avoid", "conflicts"], "add_tokens": "import { create } from 'jss' ; import reactJss from 'react-jss' ; export let jss = create ( ) ; export let useSheet = reactJss ( jss ) ;", "del_tokens": "import useSheet from 'react-jss' ; import jss from 'jss' ;", "commit_type": "use"}
{"commit_tokens": ["implements", "all", "methods", "in", "blog", ".", "js"], "add_tokens": "// app.use(express.logger({ format: ':remote-addr - - [:date] \":method :url HTTP/:http-version\" :status :response-time \":referrer\" \":user-agent\"' }));", "del_tokens": "app . use ( express . logger ( { format : ':remote-addr - - [:date] \":method :url HTTP/:http-version\" :status :response-time \":referrer\" \":user-agent\"' } ) ) ;", "commit_type": "implement"}
{"commit_tokens": ["Fixing", "some", "naming", "of", "scope", "variables", "and", "making", "options", "optional", "(", "now", "that", "you", "can", "set", "app", "-", "wide", "config", "this", "makes", "a", "lot", "of", "sense", ")", "."], "add_tokens": "fields : '=' , options : '=?' , result : '=' ,", "del_tokens": "fields : '=fields' , options : '=options' , result : '=result' ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "slice", "&", "save", "test"], "add_tokens": "promise = Promise . resolve ( Audio ( Audio . cache [ source ] ) ) . then ( audio => { callback && callback ( null , audio ) return Promise . resolve ( audio ) } , error => { callback && callback ( error ) return Promise . reject ( error ) } )", "del_tokens": "promise = Promise . resolve ( Audio ( Audio . cache [ source ] ) )", "commit_type": "add"}
{"commit_tokens": ["Moving", "towards", "local", "browser", "tests"], "add_tokens": "if ( typeof require === 'function' ) { Qbus = require ( '../../index.js' ) ; test = require ( 'tape' ) ; } var expectProtos = { 'on' : 1 , 'once' : 1 , 'off' : 1 , 'emit' : 1 } ,", "del_tokens": "var Qbus = require ( '../../index.js' ) , test = require ( 'tape' ) , expectProtos = { 'on' : 1 , 'once' : 1 , 'off' : 1 , 'emit' : 1 } ,", "commit_type": "move"}
{"commit_tokens": ["Added", "support", "for", "parsing", "the", "--", "detective", "flag", "to", "override", "the", "parser", "that", "dependency", "-", "check", "uses"], "add_tokens": "boolean : [ 'debug' , 'json' ] , string : [ 'detective' ]", "del_tokens": "boolean : [ 'debug' , 'json' ]", "commit_type": "add"}
{"commit_tokens": ["Remove", "r2", "-", "bindings", "from", "this", "repository"], "add_tokens": "//this.colorbar_create (); //this.colorbar_create ();", "del_tokens": "this . colorbar_create ( ) ; this . colorbar_create ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "an", "awful", "bug", "in", "helpers", ".", "js"], "add_tokens": "month = ( date . getMonth ( ) + 1 < 10 ? '0' : '' ) + ( date . getMonth ( ) + 1 ) ; day = ( date . getDate ( ) < 10 ? '0' : '' ) + date . getDate ( ) ; hour = ( date . getHours ( ) < 10 ? '0' : '' ) + date . getHours ( ) ; min = ( date . getMinutes ( ) < 10 ? '0' : '' ) + date . getMinutes ( ) ; sec = ( date . getSeconds ( ) < 10 ? '0' : '' ) + date . getSeconds ( ) ;", "del_tokens": "month = ( date . getMonth ( ) + 1 < 10 ? '0' : ' day = ( date . getDate ( ) < 10 ? '0' : ' hour = ( date . getHours ( ) < 10 ? '0' : ' min = ( date . getMinutes ( ) < 10 ? '0' : ' sec = ( date . getSeconds ( ) < 10 ? '0' : '", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "bug", "where", "undo", "button", "would", "be", "enabled", "when", "initing", "froala", "with", "html", "and", "general", "cleanup"], "add_tokens": "\"use strict\" ; //Scope strict mode to only this directive } ; } ; element . editable ( 'initUndoRedo' ) ; } ; for ( var attrKey in attrs ) { if ( attrs . hasOwnProperty ( attrKey ) ) { var eventName = slugToEventName ( attrKey ) ; //returns false if not an event for ( var optKey in options . events ) { if ( options . events . hasOwnProperty ( optKey ) ) { registerEventAndCallback ( optKey , options . events [ optKey ] ) ; froala . destroy ( ) ;", "del_tokens": "'use strict' ; } } } for ( var key in attrs ) { if ( attrs . hasOwnProperty ( key ) ) { var eventName = slugToEventName ( key ) ; //returns false if not an event for ( var key in options . events ) { if ( options . events . hasOwnProperty ( key ) ) { registerEventAndCallback ( key , options . events [ key ] ) ; froala [ 'destroy' ] ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "ability", "to", "ignore", "directories", "and", "generate", "summary", "XML", "."], "add_tokens": "dir : [ 'php' ] , summaryXml : 'summaryXml.xml' , ignoreDirectories : [ 'ignore' ] }", "del_tokens": "summaryXml : 'summaryXml.xml' } , dir : [ 'php' ]", "commit_type": "implement"}
{"commit_tokens": ["Allow", "user", "to", "override", "assertions", "."], "add_tokens": "for ( name in assert ) { if ( context [ name ] || name === \"AssertionError\" ) { continue ; } context [ name ] = assertion ( name , assert [ name ] ) ; }", "del_tokens": "for ( name in assert ) { if ( context [ name ] || name === \"AssertionError\" ) { continue ; } context [ name ] = assertion ( name , assert [ name ] ) ; }", "commit_type": "allow"}
{"commit_tokens": ["Add", "coinstac", "-", "simulator", "to", "project", "."], "add_tokens": "const DECLARATION_INPUTS_KEY = require ( './constants' ) . DECLARATION_INPUTS_KEY ; * @ param { string } opts . consortiumId * @ param { ( Object | undefined ) } opts . previousData * @ param { string } opts . username let features = get ( opts , 'remoteResult.pluginState.inputs[0][0]' ) ; / ** * Retrieve plugin from user data . * * @ todo This is a hack for simulator . Add a simulator hook to modify plugin * state . * / if ( ! features && DECLARATION_INPUTS_KEY in opts . userData ) { features = opts . userData [ DECLARATION_INPUTS_KEY ] [ 0 ] [ 0 ] ; }", "del_tokens": "const features = get ( opts , 'remoteResult.pluginState.inputs[0][0]' ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "no", "file", "extension", "gives", "js", "highlighting"], "add_tokens": "fn = new Function ( 'component' , 'require' , 'Ractive' , definition . script + '\\n//# sourceURL=' + url . substr ( url . lastIndexOf ( '/' ) + 1 ) . replace ( '.html' , '' ) ) ;", "del_tokens": "fn = new Function ( 'component' , 'require' , 'Ractive' , definition . script + '\\n//# sourceURL=' + url . substr ( url . lastIndexOf ( '/' ) + 1 ) ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "author", "another", "template", "bug", "."], "add_tokens": "var BIN_PATH = path . resolve ( __dirname , '../bin/{{slugcase name}}.js' ) ;", "del_tokens": "var BIN_PATH = path . resolve ( __dirname , '../bin/{{slugcase name}}' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "BBB", "not", "building", "with", "r", ".", "js", "config", "correctly", "."], "add_tokens": "optimize : 'none' , wrap : true , name : 'config'", "del_tokens": "wrap : true", "commit_type": "fix"}
{"commit_tokens": ["Fix", "codacy", "issues", "(", "1", ")"], "add_tokens": "* Check requirements . * * @ param { * } rawValue compute : function ( rawValue ) { * Does NOT check requirements . * * @ param { * } rawValue computeWithoutCheck : function ( rawValue ) { return rawValue ; module . exports = iso7064 ;", "del_tokens": "* Check requirements . * * @ param { * } rawValue compute : function ( rawValue ) { * Does NOT check requirements . * * @ param { * } rawValue computeWithoutCheck : function ( rawValue ) { return rawValue ; module . exports = iso7064 ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "typo", "in", "PingppResource", ".", "js"], "add_tokens": "_timeoutHandler : function ( timeout , req , callback ) {", "del_tokens": "_timeoutHandler : function ( timeout , reg , callback ) {", "commit_type": "fix"}
{"commit_tokens": ["fix", "Table", "falsy", "state", "if", "no", "rows", "provided"], "add_tokens": "const totalSelected = Object . keys ( this . selected ) . length return totalSelected && totalSelected === this . rows . length", "del_tokens": "return this . rows . length === Object . keys ( this . selected ) . length", "commit_type": "fix"}
{"commit_tokens": ["Added", "flag", "for", "conditional", "cleaning", "added", "textLength", "to", "output", "added", "skipLevel"], "add_tokens": "else if ( ! nodes [ i ] . skip ) ret += getText ( nodes [ i ] . children ) ; cleanConditionally : true , //skipLevel is a shortcut to allow more elements of the page if ( options . skipLevel ) { if ( skipLevel > 0 ) stripUnlikelyCandidates = false ; if ( skipLevel > 1 ) weightClasses = false ; if ( skipLevel > 2 ) cleanConditionally = false ; } else if ( tagname === \"embed\" || tagname === \"object\" || tagname === \"iframe\" ) { //iframe added for html5 players else if ( settings . cleanConditionally && isPartOfArray ( cleanConditionaly , tagname ) ) { var nodes = getCandidateSiblings ( ) ; ret . textLength = 0 ; for ( var i = 0 , j = nodes . length ; i < j ; i ++ ) ret . textLength += nodes [ i ] . info . textLength ;", "del_tokens": "else ret += getText ( nodes [ i ] . children ) ; else if ( tagname === \"embed\" || tagname === \"object\" ) { else if ( isPartOfArray ( cleanConditionaly , tagname ) ) { var nodes = getCandidateSiblings ( ) , text = getText ( nodes ) ; if ( text . length < 250 ) { //TODO }", "commit_type": "add"}
{"commit_tokens": ["Make", "callback", "to", "impromptu", ".", "exec", "optional", "."], "add_tokens": "* @ param { function ( Error , Buffer , Buffer ) = } opt_callback module . exports = function ( command , opt_callback ) { if ( opt_callback ) { if ( executable . results ) { opt_callback . apply ( null , executable . results ) } else { executable . callbacks . push ( opt_callback ) }", "del_tokens": "* @ param { function ( Error , Buffer , Buffer ) } callback module . exports = function ( command , callback ) { if ( executable . results ) { callback . apply ( null , executable . results ) } else { executable . callbacks . push ( callback )", "commit_type": "make"}
{"commit_tokens": ["make", "tests", "work", "on", "mac"], "add_tokens": "jest . setTimeout ( 100000 ) ;", "del_tokens": "jest . setTimeout ( 50000 ) ;", "commit_type": "make"}
{"commit_tokens": ["Adding", "test", "around", "live", "/", "read", "events"], "add_tokens": "test . expect ( 7 + ( streamSize * 11 ) ) ; test . testReadEvent ( 'slice.events[' + i + ']' , slice . events [ i ] , i ) ;", "del_tokens": "test . expect ( 7 + ( streamSize * 6 ) ) ; test . areEqual ( 'slice.events[' + i + '].originalEventNumber' , slice . events [ i ] . originalEventNumber , i ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "SSH", "tunneling", "capability", "to", "BUS", "and", "RPC", "client", ".", "SSH", "tunnel", "creation", "abstracted", "to", "Utility", "."], "add_tokens": "log : { enumerable : false , get : function ( ) { return this . Log } } , bus : { enumerable : false , get : function ( ) { return this . BUS } } , } , RPC : { enumerable : false , get : function ( ) { return this . RPC } }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["add", "mesh", "for", "local", "title", "matched", "files"], "add_tokens": "var annoLib = require ( './annotateLib' ) , annotations = require ( '../../lib/annotations' ) , sites = require ( '../sites.js' ) , utils = require ( '../utils.js' ) , siteQueries = require ( '../../util/siteQueries' ) ; // FIXME: hack for finding mesh var match = GLOBAL . config . HOMEPAGE + 'files/' ; // it's a local file, try to locate it on databases if ( uri . indexOf ( match ) === 0 ) { siteQueries . findPubMedArticle ( uri . replace ( match , '' ) , function ( err , res , u ) { if ( res ) { console . log ( 'found' , u ) ; processFound ( u , function ( err , res ) { // now substitute back the local URI res . uri = uri ; res . annoRows . forEach ( function ( r ) { r . hasTarget = uri ; } ) ; callback ( null , res ) ; } ) ; } else { processFound ( uri , callback ) ; } } ) ; } else { processFound ( uri , callback ) ; } } function processFound ( uri , callback ) {", "del_tokens": "var annoLib = require ( './annotateLib' ) , annotations = require ( '../../lib/annotations' ) , sites = require ( '../sites.js' ) , utils = require ( '../utils.js' ) ; try { } catch ( e ) { callback ( e ) ; }", "commit_type": "add"}
{"commit_tokens": ["Implement", "when", "()", "including", "tests"], "add_tokens": "var patterns = [ \"progress/spec/*.js\" , \"promise/*-test.js\" ] ;", "del_tokens": "var patterns = [ \"progress/spec/*.js\" ] ;", "commit_type": "implement"}
{"commit_tokens": ["updated", "deps", "added", "features", "option"], "add_tokens": "if ( typeof options . stats === \"object\" && typeof options . stats . colors === \"undefined\" ) options . stats . colors = require ( \"supports-color\" ) ;", "del_tokens": "options . stats . colors = require ( \"supports-color\" ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "gulp", "-", "cli", "incorrectly", "logging", "transform", "instead", "of", "<anonymous", ">", "."], "add_tokens": "task . action = ( ) => transform ( )", "del_tokens": "task . action = transform", "commit_type": "fix"}
{"commit_tokens": ["added", "error", "check", "to", "text", "-", "app", "getPost"], "add_tokens": "if ( err ) return cb ( err ) if ( obj . plain ) cb ( null , obj . plain ) else cb ( new Error ( 'Unrecognized text object' ) )", "del_tokens": "if ( obj . plain ) cb ( null , obj . plain ) ; else cb ( new Error ( 'Unrecognized text object' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "function", "isNumericalNaN", "to", "check", "if", "a", "NaN", "is", "a", "numerical", "or", "non", "-", "numerical", "NaN"], "add_tokens": "exports . isNumericalNaN = isNumericalNaN ; return typeof val === 'number' || isNumericalNaN ( val ) ; } function isNumericalNaN ( val ) { return Number . isNaN ( val ) ;", "del_tokens": "return typeof val === 'number' ;", "commit_type": "add"}
{"commit_tokens": ["Change", "storageRequest", "()", "to", "also", "return", "response", "on", "error"], "add_tokens": "return cb ( new Error ( 'Error code ' + res . statusCode ) , res ) ;", "del_tokens": "return cb ( new Error ( 'Error code ' + res . statusCode ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Update", "video", "inview", "checker", "."], "add_tokens": "* @ param { boolean } opt_fromTop Whether to skip checking the sides of the * element and just verify tops and bottoms are in the viewport . function isElementInView ( el , opt_offset , opt_fromTop ) { var result = ( rect . top + offset >= 0 && rect . bottom - offset <= ( window . innerHeight || root . clientHeight ) if ( opt_fromTop !== true ) { return ( result && rect . left >= 0 && rect . right <= ( window . innerWidth || root . clientWidth ) ) ; } return result ;", "del_tokens": "function isElementInView ( el , opt_offset ) { return ( rect . top + offset >= 0 && rect . left >= 0 && rect . bottom - offset <= ( window . innerHeight || root . clientHeight ) && rect . right <= ( window . innerWidth || root . clientWidth )", "commit_type": "update"}
{"commit_tokens": ["Added", "a", "separated", "login", "view"], "add_tokens": "core = require ( 'captainjs-core' ) , app . use ( express . static ( core . settings . get ( 'MEDIA_ROOT' ) ) ) ; app . use ( express . cookieParser ( ) ) ; app . use ( core . middleware . authenticate ( ) ) ; app . on ( 'mount' , function ( parent ) { app . get ( '/' , function ( req , res ) { if ( ! req . session ) { res . redirect ( req . originalUrl + 'login' ) ; } else { res . sendfile ( __dirname + '/views/layout.html' ) ; } } ) ; app . get ( '/login' , function ( req , res ) { res . sendfile ( __dirname + '/views/login.html' ) ; } ) ;", "del_tokens": "var settings = require ( 'captainjs-core' ) . getSettings ( ) ; app . use ( express . static ( settings . get ( 'MEDIA_ROOT' ) ) ) ; app . get ( '/' , function ( req , res ) { res . sendfile ( __dirname + '/views/layout.html' ) ; } ) ; if ( require . main === module ) { app . listen ( 9000 , function ( ) { console . log ( 'Listening at http://localhost:9000' ) ; }", "commit_type": "add"}
{"commit_tokens": ["added", "power", "option", "and", "area", "function"], "add_tokens": "normalize : true , power : false , inputArray ( frame ) { const outFrame = this . outFrame ; let mag = sum ; mag /= frameSize ; } if ( ! this . params . power ) { mag = Math . sqrt ( mag ) ; outFrame [ 0 ] = mag ; return outFrame ; } process ( time , frame , metaData ) { this . inputArray ( frame ) ; this . output ( time , this . outFrame , metaData ) ;", "del_tokens": "normalize : false process ( time , frame , metaData ) { // sum is a mean here (for rms) sum /= frameSize ; this . time = time ; this . outFrame [ 0 ] = Math . sqrt ( sum ) ; this . metaData = metaData ; this . output ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "smooth", "scroller", "array", "test"], "add_tokens": "this . fixed = this . config . fixed ? ( this . config . fixed instanceof Array ? this . config . fixed : [ this . config . fixed ] ) : [ ] ;", "del_tokens": "this . fixed = this . config . fixed ? ( this . config . fixed . length ? this . config . fixed : [ this . config . fixed ] ) : [ ] ;", "commit_type": "fix"}
{"commit_tokens": ["add", "version", "info", "to", "modules"], "add_tokens": "var fs = require ( 'fs' ) var version = null ; try { var pd = JSON . parse ( fs . readFileSync ( path . join ( m . module_folder , \"package.json\" ) ) ) ; version = pd . version ; } catch ( x ) { } console . log ( \"*\" , m . module_name , \"(version: \" + version + \"; folder:\" , m . module_folder + \")\" ) ;", "del_tokens": "console . log ( \"*\" , m . module_name , \"(folder:\" , m . module_folder + \")\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "role", "=", "button", "and", "tabindex", "=", "0"], "add_tokens": "// <div class=\"selected\" title=\"Green\" style=\"background-color: #7bd148;\" role=\"button\"></div> var selected = '' ; if ( option . attr ( 'selected' ) ) { selected = 'class=\"selected\"' ; } colorList += '<div ' + selected + ' title=\"' + title + '\" style=\"background-color: ' + color + ';\" role=\"button\" tabindex=\"0\">' + fakeText + '</div>' ; this . icon = $ ( '<span class=\"colorpicker icon\" title=\"' + selectText + '\" style=\"background-color: ' + selectValue + ';\" role=\"button\" tabindex=\"0\">' // Mark this div as the selected one target . siblings ( ) . removeClass ( 'selected' ) ; target . addClass ( 'selected' ) ;", "del_tokens": "// <div title=\"Green\" style=\"background-color: #7bd148;\"></div> colorList += '<div title=\"' + title + '\" style=\"background-color: ' + color + ';\">' + fakeText + '</div>' ; this . icon = $ ( '<span class=\"colorpicker icon\" title=\"' + selectText + '\" style=\"background-color: ' + selectValue + ';\">' // Mark this div as the active one target . siblings ( ) . removeClass ( 'active' ) ; target . addClass ( 'active' ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "bin", "/", "foobarify", "-", "scripts", ".", "js", "to", "cli", ".", "js"], "add_tokens": "console . log ( 'Perhaps you need to update shopify-pipeline ?' )", "del_tokens": "console . log ( 'Perhaps you need to update foobarify-scripts?' )", "commit_type": "move"}
{"commit_tokens": ["Add", "Query", "Modifiers", "for", "Map", "and", "Set", "types"], "add_tokens": "case \"add\" : case \"remove\" : assignments . push ( key + \" = \" + key + ( statement . type === \"add\" ? \" + \" : \" - \" ) + formatter . parameterize ( statement . val , client ) ) ; case \"increment\" : assignments . push ( key + \" = \" + key + ( statement . type === \"increment\" ? \" + \" : \" - \" ) + formatter . parameterize ( statement . val , client ) ) ;", "del_tokens": "case \"increment\" : assignments . push ( key + \" = \" + key + \" + \" + formatter . parameterize ( statement . val , client ) ) ; assignments . push ( key + \" = \" + key + \" - \" + formatter . parameterize ( statement . val , client ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "ability", "to", "define", "more", "complex", "breakpoints", "."], "add_tokens": "function buildMediaQuery ( breakpoints ) { if ( _ . isString ( breakpoints ) ) { breakpoints = { min : breakpoints } if ( ! _ . isArray ( breakpoints ) ) { breakpoints = [ breakpoints ] } return _ ( breakpoints ) . map ( ( breakpoint ) => { return _ ( breakpoint ) . map ( ( value , feature ) => { feature = _ . get ( { min : 'min-width' , max : 'max-width' , } , feature , feature ) return ` ${ feature } ${ value } ` } ) . join ( ' and ' ) } ) . join ( ', ' )", "del_tokens": "function buildMediaQuery ( breakpoint ) { if ( _ . isString ( breakpoint ) ) { breakpoint = { min : breakpoint } return _ ( breakpoint ) . map ( ( value , feature ) => { feature = _ . get ( { min : 'min-width' , max : 'max-width' , } , feature , feature ) return ` ${ feature } ${ value } ` } ) . join ( ' and ' )", "commit_type": "add"}
{"commit_tokens": ["Updating", "grunt", "to", "build", "all", "the", "distribution", "builds", "."], "add_tokens": "'* https://github.com/misoproject/rig/blob/master/LICENSE-MIT \\n' + '* https://github.com/misoproject/rig/blob/master/LICENSE-GPL \\n' + node : { wrapper : \"src/node/compat.js\" , misoRig : \"dist/miso.rig.<%= pkg.version %>.js\" } , dest : \"dist/miso.rig.<%= pkg.version %>.js\" , \"src/rig.js\" , requirenodeps : { dest : \"dist/miso.rig.r.<%= pkg.version %>.js\" , src : [ \"<banner>\" , \"dist/miso.rig.<%= pkg.version %>.js\" , \"src/require.js\" ] } , dest : \"dist/miso.rig.deps.<%= pkg.version %>.js\" , \"components/lodash/lodash.js\" , \"components/underscore.deferred/underscore.deferred.js\" , \"dist/miso.rig.<%= pkg.version %>.js\" dest : \"dist/miso.rig.min.<%= pkg.version %>.js\" , \"dist/miso.rig.<%= pkg.version %>.js\" ] } , mindeps : { dest : \"dist/miso.rig.deps.min.<%= pkg.version %>.js\" , src : [ \"<banner>\" , \"dist/miso.rig.deps.<%= pkg.version %>.js\" predef : [ \"_\" , \"Miso\" , \"require\" , \"exports\" , \"define\" ] \"except\" : [ \"_\" ] // load available tasks. grunt . loadTasks ( \"tasks\" ) ; grunt . registerTask ( 'default' , 'lint testserver qunit concat min node' ) ;", "del_tokens": "'* https://github.com/misoproject/scene/blob/master/LICENSE-MIT \\n' + '* https://github.com/misoproject/scene/blob/master/LICENSE-GPL \\n' + dest : \"dist/miso.scene.<%= pkg.version %>.js\" , \"src/engine.js\" , dest : \"dist/miso.scene.deps.<%= pkg.version %>.js\" , \"lib/lodash.0.6.2.min.js\" , \"lib/underscore.deferred.js\" , \"dist/miso.scene.<%= pkg.version %>.js\" dest : \"dist/miso.scene.min.<%= pkg.version %>.js\" , \"dist/miso.scene.<%= pkg.version %>.js\" predef : [ \"_\" , \"moment\" , \"log\" , \"template\" , \"async\" , \"Miso\" ] \"except\" : [ \"_\" , \"$\" ] grunt . registerTask ( 'default' , 'lint qunit concat min' ) ;", "commit_type": "update"}
{"commit_tokens": ["Using", "Math", ".", "hypot", "to", "improve", "accuracy", "and", "performance"], "add_tokens": "expect : \"6.592104680806861 + 2.7305391633733636i\" expect : \"6.592104680806861 - 2.7305391633733636i\" expect : \"2.7305391633733636 + 6.592104680806861i\" expect : \"2.7305391633733636 - 6.592104680806861i\"", "del_tokens": "expect : \"6.59210468080686 + 2.730539163373364i\" expect : \"6.59210468080686 - 2.730539163373364i\" expect : \"2.730539163373364 + 6.59210468080686i\" expect : \"2.730539163373364 - 6.59210468080686i\"", "commit_type": "use"}
{"commit_tokens": ["fix", "3rd", "Coeff", "of", "sun", "mean", "anomaly"], "add_tokens": "const m = base . horner ( T , 357.5291092 * D2R , 35999.0502909 * D2R , - 0.0001536 * D2R , D2R / 24490000 )", "del_tokens": "const m = base . horner ( T , 357.5291092 * D2R , 35999.0502909 * D2R , - 0.0001535 * D2R , D2R / 24490000 )", "commit_type": "fix"}
{"commit_tokens": ["changing", "file", "structure", "adding", "test", "directory", "and", "npmignoring", "tests"], "add_tokens": "var tools = require ( './lib/utils/' ) ; // //Parameters: array of key words (required), country as a string (optional, 'US' is default) // module.exports = require('./lib/utils/');", "del_tokens": "var tools = require ( './utils/' ) ; // //Parameters: array of key words, country as a string (optional, 'US' is default) // module.exports = require('./utils/');", "commit_type": "change"}
{"commit_tokens": ["Updating", "server", "to", "be", "a", "wrapper", "interface"], "add_tokens": "var Q = require ( 'q' ) this . app = app this . httpServer = server , deferred = Q . defer ( ) , self = this try { console . log ( 'starting server on ' + port ) this . httpServer . listen ( port , onListening ) } catch ( error ) { deferred . reject ( error ) } return deferred . promise deferred . resolve ( self )", "del_tokens": "var createMiddleware = require ( '../commands/createMiddlewareCmd.js' ) , createServer = require ( '../commands/createServerCmd.js' ) assertRequirements ( config ) this . app = app || createMiddleware ( config ) this . httpServer = server || createServer ( config , this . app ) } function assertRequirements ( config ) { if ( ! config ) throw new Error ( 'server configuration must be present' ) console . log ( 'starting server on ' + port ) this . httpServer . listen ( port , onListening )", "commit_type": "update"}
{"commit_tokens": ["Use", "scrubFilename", "function", "and", "remove", "latinize"], "add_tokens": "S3Upload . prototype . scrubFilename = function ( filename ) { return filename . replace ( / [^\\w\\d_\\-\\.]+ / ig , '' ) ; } ; var fileName = this . scrubFilename ( file . name ) ; var fileName = this . scrubFilename ( file . name )", "del_tokens": "var latinize = require ( 'latinize' ) ; function identity ( path ) { return path ; } if ( ! options . normalisePath ) { options . normalisePath = identity ; } var normalizedFileName = this . normalisePath ( file . name . replace ( / [!\\^`><{}\\[\\]()*#%'\"~|&@:;$=+?\\s\\\\\\/\\x00-\\x1F\\x7f]+ / ig , '_' ) ) ; var fileName = latinize ( normalizedFileName ) ; var normalizedFileName = this . normalisePath ( file . name . replace ( / [!\\^`><{}\\[\\]()*#%'\"~|&@:;$=+?\\s\\\\\\/\\x00-\\x1F\\x7f]+ / ig , '_' ) ) ; var fileName = latinize ( normalizedFileName ) ;", "commit_type": "use"}
{"commit_tokens": ["Create", "a", "new", "router", "to", "ModelRouter"], "add_tokens": "error : err . toString ( ) , stack : err . stack . split ( '\\n' ) . slice ( 1 )", "del_tokens": "error : err", "commit_type": "create"}
{"commit_tokens": ["Remove", "images", "when", "no", "src", "present"], "add_tokens": "return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : '' ;", "del_tokens": "return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : node ;", "commit_type": "remove"}
{"commit_tokens": ["add", "hasMissingToken", "to", "undo", "what", "has", "been", "done", "in", "shouldTakeToken"], "add_tokens": "Semaphore . prototype . _hasMissingToken = function _hasMissingToken ( item ) { if ( typeof item . hasMissingToken === \"function\" ) { // avoid giving item as context when calling hasMissingToken ( 0 , item . hasMissingToken ) ( this ) ; } } ; this . _hasMissingToken ( item ) ; [ \"onTimeOut\" , \"onCancel\" , \"unfair\" , \"shouldTakeToken\" , \"hasMissingToken\" , \"sync\" , \"hasNext\" ] . forEach ( function ( prop ) {", "del_tokens": "[ \"onTimeOut\" , \"onCancel\" , \"unfair\" , \"shouldTakeToken\" , \"sync\" , \"hasNext\" ] . forEach ( function ( prop ) {", "commit_type": "add"}
{"commit_tokens": ["Implemented", "getting", "state", "through", "a", "reactive", "property"], "add_tokens": "it ( \"Should get state.\" , function ( ) { var model = ReactiveModel ( ) . addPublicProperty ( \"x\" , 5 ) . addPublicProperty ( \"y\" , 10 ) . x ( 10 ) . y ( 20 ) ; ReactiveModel . digest ( ) ; var state = model . state ( ) ; assert . equal ( Object . keys ( state ) . length , 2 ) ; assert . equal ( state . x , 10 ) ; assert . equal ( state . y , 20 ) ; } ) ; it ( \"Should get state and omit default values.\" , function ( ) { var model = ReactiveModel ( ) . addPublicProperty ( \"x\" , 5 ) . addPublicProperty ( \"y\" , 10 ) ; ReactiveModel . digest ( ) ; var state = model . state ( ) ; assert . equal ( Object . keys ( state ) . length , 0 ) ; } ) ;", "del_tokens": "//it(\"Should get state.\", function (){ // var model = ReactiveModel() // .addPublicProperty(\"x\", 5) // .addPublicProperty(\"y\", 10) // .x(10) // .y(20); // var state = model.getState(); // assert.equal(Object.keys(state).length, 2); // assert.equal(state.x, 10); // assert.equal(state.y, 20); //}); //it(\"Should get state and omit default values.\", function (){ // var model = ReactiveModel() // .addPublicProperty(\"x\", 5) // .addPublicProperty(\"y\", 10); // var state = model.getState(); // assert.equal(Object.keys(state).length, 0); //});", "commit_type": "implement"}
{"commit_tokens": ["Added", "--", "ignore", "flag", ".", "Added", "colors", "to", "stdout", "."], "add_tokens": "module . exports = function ( configDir , ignores ) { // export ignores exports . __ignores = ignores || [ ] ; pre = parts [ parts . length - 2 ] , name = parts [ parts . length - 3 ] ; return ! ! ( ext === \"dist\" && pre === \"json\" && exports . __ignores . indexOf ( name ) === - 1 && exports . __ignores . indexOf ( f ) === - 1 ) ;", "del_tokens": "module . exports = function ( configDir ) { pre = parts [ parts . length - 2 ] ; return ! ! ( ext === \"dist\" && pre === \"json\" ) ;", "commit_type": "add"}
{"commit_tokens": ["update", "node", "proton", "wrappers", "to", "support", "using", "Buffers", "to", "put", "and", "get", "binary", "data"], "add_tokens": "if ( message instanceof Buffer ) { protonMsg . body = message ; } else { protonMsg . body = JSON . stringify ( message ) ; }", "del_tokens": "protonMsg . body = JSON . stringify ( message ) ;", "commit_type": "update"}
{"commit_tokens": ["Use", "TaskName", "component", "for", "localization"], "add_tokens": "'task' : 'Úkol', 'task.ladder' : 'Žebřík', 'task.nameless-task' : 'Nepojmenovaná úloha', 'task.one-step-forward' : 'Jeden krok vpřed', 'task.three-steps-forward' : 'Tři kroky vpřed', 'task.zig-zag' : 'Cik cak' ,", "del_tokens": "TASK : 'Úkol', 'TASK.ladder' : 'Žebřík', 'TASK.nameless-task' : 'Nepojmenovaná úloha', 'TASK.one-step-forward' : 'Jeden krok vpřed', 'TASK.three-steps-forward' : 'Tři kroky vpřed', 'TASK.zig-zag' : 'Cik cak' ,", "commit_type": "use"}
{"commit_tokens": ["add", "contact", "availableExtensions", "to", "search", "source"], "add_tokens": "sourceName : 'extensions' , searchFn : ( { searchString } ) => { const searchText = searchString . toLowerCase ( ) ; return this . accountExtension . availableExtensions . filter ( ( extension ) => { if ( extension . ext . indexOf ( searchText ) >= 0 ) { return true ; } if ( extension . name . toLowerCase ( ) . indexOf ( searchText ) >= 0 ) { return true ; } return false ; } ) ; } , formatFn : entities => entities . map ( entity => ( { entityType : 'contact' , name : entity . name , phoneNumber : entity . ext , phoneType : 'extension' , } ) ) , readyCheckFn : ( ) => this . accountExtension . ready ,", "del_tokens": "sourceName : 'test' , searchFn : ( { searchString } ) => [ { entityType : 'account' , name : searchString , phoneNumber : searchString , phoneType : 'phone' , } ] , formatFn : entities => entities , readyCheckFn : ( ) => true ,", "commit_type": "add"}
{"commit_tokens": ["Changed", "variable", "name", "to", "better", "represent", "its", "content", "."], "add_tokens": "var sockets = io . listen ( server , { log : false } ) ; // Add io to the shell for advanced users. shell . socketIo = io ; var newCookies = shell . getVar ( 'newCookies' ) || { } ; newCookies [ shell . settings . namespace + '|' + name ] = { value : value , days : days } ; return shell . setVar ( 'newCookies' , newCookies ) ; sockets . of ( '/' + shell . settings . namespace ) // Add current socket to context for advanced users. context . socket = socket ; if ( shell . settings . debug ) console . log ( '%s: %s' , shell . settings . namespace , cmdStr ) ; sockets : sockets", "del_tokens": "var sio = io . listen ( server , { log : false } ) ; // todo: prepend cookie names with the shell and only send back cookies with the correct shell. if ( ! this . context . newCookies ) this . context . newCookies = { } ; this . context . newCookies [ name ] = { value : value , days : days } ; this . contextChanged ( ) ; return this ; sio . of ( '/' + shell . namespace ) if ( shell . settings . debug ) console . log ( '%s: %s' , shell . namespace , cmdStr ) ; socketIo : sio", "commit_type": "change"}
{"commit_tokens": ["fixing", "issue", "in", "getting", "response", "."], "add_tokens": "const _ = require ( 'lodash' ) ; * / * / * / * / * @ param { Object } procedureCall * / module . exports . addStream = function addStream ( procedureCall ) { var argument = new proto . Argument ( 0 , procedureCall . toArrayBuffer ( ) ) ; var newCall = new proto . ProcedureCall ( 'KRPC' , 'AddStream' , [ argument ] ) ; call : newCall , * / * / * / decode : decoders . enum ( { 0 : 'SpaceCenter' , 1 : 'Flight' , 2 : 'TrackingStation' , 3 : 'EditorVAB' , 4 : 'EditorSPH' } )", "del_tokens": "* / * / * / * / * @ param { Object } call * / module . exports . addStream = function addStream ( call ) { let encodedArguments = [ new proto . ProcedureCall ( call ) ] ; call : buildProcedureCall ( 'KRPC' , 'AddStream' , encodedArguments ) , * / * / * / decode : decoders . enum ( { 0 : 'SpaceCenter' , 1 : 'Flight' , 2 : 'TrackingStation' , 3 : 'EditorVAB' , 4 : 'EditorSPH' } )", "commit_type": "fix"}
{"commit_tokens": ["add", "ability", "to", "block", "jquery", "ajax", "errors", "from", "being", "reported", "automatically", "merge", "notifier", "extra", "params", "recursively"], "add_tokens": "\"notifier.plugins.jquery.version\" : '0.0.1' jquery_thrown_error : thrownError , jquery_ajax_error : true", "del_tokens": "\"notifier.plugins.jquery\" : { version : '0.0.1' } jquery_thrown_error : thrownError", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "set", "theory", "links", "to", "the", "docs"], "add_tokens": "* Performs a [ set intersection ] ( http : //en.wikipedia.org/wiki/Intersection_(set_theory)) * on this array and the input array ( s ) . * @ returns { Array } An array that is the [ union ] ( http : //en.wikipedia.org/wiki/Union_%28set_theory%29) * of this array and the input array ( s ) .", "del_tokens": "* Performs a set intersection on this array and the input array ( s ) . * @ returns { Array } An array that is the union of this array and the input array ( s ) .", "commit_type": "add"}
{"commit_tokens": ["updated", "to", "newest", "bookings", "spec", "added", "deprecated", "callbacks"], "add_tokens": "timezone : 'local' event : { event : {", "del_tokens": "//timekitCreateEvent: { }, timezone : 'local' , //minTime: '08:00:00', //maxTime: '19:00:00', details : { details : {", "commit_type": "update"}
{"commit_tokens": ["Use", "try", "/", "catch", "for", "error", "handling"], "add_tokens": "try { model . schema . eachPath ( function ( name ) { if ( ! reqQuery . hasOwnProperty ( name ) ) { return ; } var val = reqQuery [ name ] ; if ( thiz . restricted . indexOf ( name ) !== - 1 ) { var err = new Error ( 'Field is restricted.' ) ; err . status = 401 ; throw err ; } query . where ( name ) . equals ( val ) ; } ) ; } catch ( err ) { return res . error ( err . status , err . message ) ;", "del_tokens": "var fine = true ; model . schema . eachPath ( function ( name ) { if ( ! reqQuery . hasOwnProperty ( name ) ) { return ; } var val = reqQuery [ name ] ; if ( thiz . restricted . indexOf ( name ) !== - 1 ) { fine = false ; return res . error ( 401 , 'Field is restricted.' ) ; } query . where ( name ) . equals ( val ) ; } ) ; if ( ! fine ) { return ;", "commit_type": "use"}
{"commit_tokens": ["added", "one", "last", "fix", "to", "handle", "destinations", "without", "a", "trailing", "/"], "add_tokens": "host : \"server.sample.com\" , dest : \"test/html\" ,", "del_tokens": "host : \"sample.hello.com\" , dest : \"test/html/\" ,", "commit_type": "add"}
{"commit_tokens": ["Remove", "all", "references", "to", "deque", "and", "fix", "typo", "(", "offendingMsg", "-", ">", "offendingMessage", ")"], "add_tokens": "offendingMessage : msg", "del_tokens": "const Dequeue = require ( 'double-ended-queue' ) ; this . msgQueue = new Dequeue ( ) ; offendingMsg : msg", "commit_type": "remove"}
{"commit_tokens": ["Add", "includePath", "option", "to", "enable", "LESS", "parser", "to", "look", "in", "more", "places", "."], "add_tokens": "paths : [ path . dirname ( this . path ) ] . concat ( this . options . includePath )", "del_tokens": "paths : [ path . dirname ( this . path ) ]", "commit_type": "add"}
{"commit_tokens": ["changed", "block", "-", "ui", "link", "from", "post", "to", "pre"], "add_tokens": "} ) . factory ( 'blockUiCompileFn' , function ( blockUiPreLinkFn ) { return { pre : blockUiPreLinkFn } ; } ) . factory ( 'blockUiPreLinkFn' , function ( blockUI , blockUIUtils ) {", "del_tokens": "} ) . factory ( 'blockUiCompileFn' , function ( blockUiLinkFn ) { return blockUiLinkFn ; } ) . factory ( 'blockUiLinkFn' , function ( blockUI , blockUIUtils , blockUIConfig ) {", "commit_type": "change"}
{"commit_tokens": ["Added", "getPermissions", "()", "to", "the", "Channel"], "add_tokens": "'rename' , 'links-add' , 'links-remove' , 'move' , 'remove' , 'permissions-update' ] ) ;", "del_tokens": "'rename' , 'links-add' , 'links-remove' , 'move' , 'remove' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "passthrough", "to", "default", "daemon"], "add_tokens": "_this . _client . submitJob ( 'delayedJobDone' , task ) ;", "del_tokens": "_this . _client . submitJob ( 'delayedJobDone' , task ) ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "no", "-", "empty", "-", "file", "rule", "that", "broke", "due", "to", "a", "previous", "commit"], "add_tokens": "} else if ( error . message . indexOf ( '(1:0): unexpected end of file' ) > - 1 ) {", "del_tokens": "} else if ( error . message . indexOf ( '(1:0): unexpected end of file' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Allow", "to", "add", "a", "custom", "attribute", "to", "the", "body"], "add_tokens": "var sanitizeHtml = function ( html , options ) { //remove weird pseudo new lines and tabs html = html . replace ( / \\\\n|\\\\t / g , \"\" ) ; // add a custom attribute if so required if ( options . bodyAttr ) html = html . replace ( / <body / , \"<body \" + options . bodyAttr + \"='\" + options . bodyAttr + \"' \" ) ; sendMessage ( \"htmlSnapshot.pageReady\" , sanitizeHtml ( html , options ) , url ) ;", "del_tokens": "var sanitizeHtml = function ( html ) { //remove weird pseudo new lines html = html . replace ( / \\\\n|\\\\t / g , \"\" ) ; sendMessage ( \"htmlSnapshot.pageReady\" , sanitizeHtml ( html ) , url ) ;", "commit_type": "allow"}
{"commit_tokens": ["Upgraded", "to", "custom", "-", "event", "-", "polyfill", "v1", ".", "Split", "test", "bundles", "."], "add_tokens": "$_mod . ready ( ) ; // eslint-disable-line no-undef", "del_tokens": "$_mod . ready ( ) ;", "commit_type": "upgrade"}
{"commit_tokens": ["Change", "to", "proper", "module", "export"], "add_tokens": ". description ( 'deploys everything!' )", "del_tokens": ". description ( 'deploy everything!' )", "commit_type": "change"}
{"commit_tokens": ["Make", "prop", "types", "more", "specific"], "add_tokens": "React . PropTypes . arrayOf ( React . PropTypes . string , React . PropTypes . number ) ,", "del_tokens": "React . PropTypes . array ,", "commit_type": "make"}
{"commit_tokens": ["Fix", "deferred", "bug", "in", "doOpenWithOptionalPath", "()"], "add_tokens": "result = ( new $ . Deferred ( ) ) . reject ( ) ;", "del_tokens": "result = new $ . Deferred ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "basic", "debugging", "using", "debug", "module"], "add_tokens": "var fs = require ( 'fs' ) ; var util = require ( 'util' ) ; var async = require ( 'async' ) ; var debug = require ( 'debug' ) ( 'rpi-gpio' ) ; debug ( 'set up pin %d' , pin ) ; var pinVersion = ( revisionNumber < 3 ) ? 'v1' : 'v2' ; debug ( 'seen hardware revision %d; using pin mode %s' , revisionNumber , pinVersion ) ; pins . current = pins [ pinVersion ] ; debug ( 'listen for pin %d' , pin ) ; debug ( 'set direction %s on pin %d' , direction . toUpperCase ( ) , pin ) ; debug ( 'export pin %d' , pin ) ; debug ( 'unexport pin %d' , pin ) ;", "del_tokens": "var fs = require ( 'fs' ) ; var util = require ( 'util' ) ; var async = require ( 'async' ) ; if ( revisionNumber < 3 ) { pins . current = pins . v1 ; } else { pins . current = pins . v2 ; }", "commit_type": "add"}
{"commit_tokens": ["Adding", "swipe", "event", "constants", "."], "add_tokens": "'SWIPE' : 'swipe' , 'SWIPE_LEFT' : 'swipeleft' , 'SWIPE_RIGHT' : 'swiperight' , 'SWIPE_UP' : 'swipeup' , 'SWIPE_DOWN' : 'swipedown' ,", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "cost", "=", "31", "overflow", "bug"], "add_tokens": "var rounds = ( log_rounds < 31 ) ? 1 << log_rounds : 2147483648 ;", "del_tokens": "var rounds = 1 << log_rounds ;", "commit_type": "fix"}
{"commit_tokens": ["improve", "gamejs", ".", "transform", "docs"], "add_tokens": "* Returns a new surface which holds the original surface rotate by angle degrees . * @ returns { Surface } new , rotated surface * Returns a new surface holding the scaled surface . * @ param { Array } scale new [ widthScale , heightScale ] in range ; e . g . : [ 2 , 2 ] would double the size * @ returns { Surface } new , scaled surface", "del_tokens": "* @ param { Array } dims new [ width , height ]", "commit_type": "improve"}
{"commit_tokens": ["Make", "the", "template", "more", "developer", "-", "friendly", "*"], "add_tokens": "let deviceFilePath = path . join ( argv . destination , 'device.js' ) ; let indexFile = await fs . readFile ( path . join ( INIT_TEMPLATES , 'index.js' ) ) ; let deviceFile = await fs . readFile ( path . join ( INIT_TEMPLATES , 'device.js' ) ) ; await fs . writeFile ( indexPath , indexFile ) ; await fs . writeFile ( deviceFilePath , deviceFile ) ;", "del_tokens": "let content = await fs . readFile ( path . join ( INIT_TEMPLATES , 'index.js' ) ) ; await fs . writeFile ( indexPath , content ) ;", "commit_type": "make"}
{"commit_tokens": ["add", "recursive", "parent", "lookup", "so", "tiles", ">", "z7", "work"], "add_tokens": "getFuzzyTimezoneFromQuadkey : getFuzzyTimezoneFromQuadkey , getz7Parent : getz7Parent if ( tile [ 2 ] > 7 ) tile = getz7Parent ( tile ) ; function getz7Parent ( tile ) { if ( tile [ 2 ] > 7 ) return getz7Parent ( tilebelt . getParent ( tile ) ) ; else return tile ; }", "del_tokens": "getFuzzyTimezoneFromQuadkey : getFuzzyTimezoneFromQuadkey", "commit_type": "add"}
{"commit_tokens": ["Fixed", "small", "bug", "in", "Widget", ".", "js"], "add_tokens": "return def . when ( this . domNode , function ( ) { var waitNode = createWaitNode ( w ) ; return def . when ( defer , function ( ) { destroyWaitNode ( w , waitNode ) ; } , function ( ) { destroyWaitNode ( w , waitNode ) ; } ) ;", "del_tokens": "var waitNode = createWaitNode ( w ) ; return def . when ( defer , function ( ) { destroyWaitNode ( w , waitNode ) ; } , function ( ) { destroyWaitNode ( w , waitNode ) ;", "commit_type": "fix"}
{"commit_tokens": ["made", "corrections", "fixed", "a", "few", "places", "where", "options", "were", "outdated"], "add_tokens": "indent_scripts : \"keep\" , brace_style : \"expand\" ,", "del_tokens": "indent_scripts : \"normal\" , brace_style : \"collapse\" ,", "commit_type": "make"}
{"commit_tokens": ["update", "build", "script", "for", "new", "rollup", "version"], "add_tokens": "input : filePath , bundleOpts . name = moduleName ; input : filePath , bundleOpts . name = moduleName ; } ) ;", "del_tokens": "entry : filePath , bundleOpts . moduleName = moduleName ; entry : filePath , bundleOpts . moduleName = moduleName ; } ) ; ;", "commit_type": "update"}
{"commit_tokens": ["Added", "at", "to", "default", "datetime", "format", "."], "add_tokens": "format += ' at %l:%M %p' ;", "del_tokens": "format += ' %l:%M %p' ;", "commit_type": "add"}
{"commit_tokens": ["Make", "katex", "always", "clean", "up", "after", "itself"], "add_tokens": "clearNode ( baseNode ) ;", "del_tokens": "clearNode ( baseNode ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "resetParams", "renamed", "getParamDefinitions", "to", "getParamsDescription"], "add_tokens": "getParamsDescription ( ) { / ** * Reset all parameters to their initial value ( as defined on instantication ) * / resetParams ( ) { this . params . reset ( ) ; }", "del_tokens": "getParamDefinitions ( ) {", "commit_type": "add"}
{"commit_tokens": ["Move", "image", "logic", "to", "after", "allow", "node", "checks"], "add_tokens": "// Commonmark treats image description as children. We just want the text if ( leaving && node . type === 'Image' ) { node . react . props . alt = node . react . children [ 0 ] ; node . react . children = [ ] ; }", "del_tokens": "// Commonmark treats image description as children. We just want the text if ( leaving && node . type === 'Image' ) { node . react . props . alt = node . react . children [ 0 ] ; node . react . children = [ ] ; }", "commit_type": "move"}
{"commit_tokens": ["remove", "output", "colours", "for", "win32"], "add_tokens": "if ( process . platform === 'win32' ) { return string ; } else { return \"\\033[\" + colourCode + \"m\" + string + \"\\033[0m\" ; }", "del_tokens": "return \"\\033[\" + colourCode + \"m\" + string + \"\\033[0m\" ;", "commit_type": "remove"}
{"commit_tokens": ["removing", "polyfill", "for", ".", "assign"], "add_tokens": "function customEvent ( ) { customEvent ( ) ;", "del_tokens": "function _customEvent ( ) { / ** * Object Assign Polyfill * reference : https : //developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign * @ return { [ type ] } [ description ] * / function _objectAssign ( ) { if ( typeof Object . assign != 'function' ) { // Must be writable: true, enumerable: false, configurable: true Object . defineProperty ( Object , 'assign' , { value : function assign ( target , varArgs ) { // .length of function is 2 // 'use strict'; if ( target == null ) { // TypeError if undefined or null throw new TypeError ( 'Cannot convert undefined or null to object' ) ; } var to = Object ( target ) ; for ( var index = 1 ; index < arguments . length ; index ++ ) { var nextSource = arguments [ index ] ; if ( nextSource != null ) { // Skip over if undefined or null for ( var nextKey in nextSource ) { // Avoid bugs when hasOwnProperty is shadowed if ( Object . prototype . hasOwnProperty . call ( nextSource , nextKey ) ) { to [ nextKey ] = nextSource [ nextKey ] ; } } } } return to ; } , writable : true , configurable : true } ) ; } } _customEvent ( ) ; _objectAssign ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["make", "stack", "trace", "easier", "to", "read"], "add_tokens": "sys . puts ( c . greybg + \"Stack Trace:\\n\" + c . reset + c . red , o [ type ] . _stackTrace ) ;", "del_tokens": "sys . puts ( c . greybg + \"Stack Trace:\\n\" + c . red , o [ type ] . _stackTrace ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "for", "more", "than", "one", "window", "resize", "event", "listener", "per", "chart"], "add_tokens": "* AngularJS - nvD3 , v1 .0 .0 - beta ; MIT License ; 28 / 05 / 2015 12 : 10 if ( scope . chart . resizeHandler ) scope . chart . resizeHandler . clear ( ) ;", "del_tokens": "* AngularJS - nvD3 , v1 .0 .0 - beta ; MIT License ; 25 / 02 / 2015 22 : 27", "commit_type": "fix"}
{"commit_tokens": ["Fix", "the", "Karma", "test", "failures", "on", "Travis"], "add_tokens": "frameworks : [ 'jasmine-jquery' , 'jasmine' , 'requirejs' ] , // load the Karma spec runner 'test/spec-runner.js' , // load the RequireJS configuration 'test/require-config.js' , // load third party libraries 'node_modules/underscore/underscore.js' , // register third party libraries to be loaded via RequireJS { pattern : 'node_modules/backbone/backbone.js' , included : false } , { pattern : 'node_modules/backbone.paginator/lib/backbone.paginator.js' , included : false } , { pattern : 'node_modules/requirejs-text/text.js' , included : false } , { pattern : 'node_modules/sinon/**/*.js' , included : false } , { pattern : 'node_modules/urijs/src/*.js' , included : false } , // register all the UI Toolkit source and Underscore templates { pattern : 'src/js/**/*.js' , included : false } , { pattern : 'src/js/**/*.underscore' , included : false }", "del_tokens": "frameworks : [ 'jasmine-jquery' , 'jasmine' , 'requirejs' , 'sinon' ] , // node_modules/**/*.js contains a LOT of javascript, and // karma runs out of file handles, hence we have to be a // bit more specific: { pattern : 'node_modules/*/*.js' , included : false } , { pattern : 'node_modules/*/lib/**/*.js' , included : false } , { pattern : 'node_modules/*/src/*.js' , included : false } , { pattern : 'src/js/**/*.js' , included : false } , { pattern : 'src/js/**/*.underscore' , included : false } , { pattern : 'test/require-config.js' , included : true } , { pattern : 'test/spec-runner.js' , included : true }", "commit_type": "fix"}
{"commit_tokens": ["Improve", "support", "for", "builtin", "classes", "and", "primitives"], "add_tokens": "\"Random\" , describe ( \"Arguments\" , ( ) => { const args = ( function ( ) { return arguments ; } ( \"A\" , \"B\" , { a : \"C\" } ) ) ; it ( \"Prints argument lists\" , ( ) => { expect ( args ) . to . print ( ` Arguments [ \"A\" \"B\" { a : \"C\" } @ @ Symbol . iterator : function ( ) { length : 0 name : \"values\" } ] ` ) ; } ) ; it ( \"Shows custom properties\" , ( ) => { args . customValue = \"Something important\" ; expect ( args ) . to . print ( ` Arguments [ \"A\" \"B\" { a : \"C\" } customValue : \"Something important\" @ @ Symbol . iterator : function ( ) { length : 0 name : \"values\" } ] ` ) ; } ) ; } ) ; ] ` ) ;", "del_tokens": "\"Random\" ] ` )", "commit_type": "improve"}
{"commit_tokens": ["Adding", "following", "properties", "to", "the", "service"], "add_tokens": "service . api = Object . keys ( api ) service . resources = this . objectsToResources ( config ) ; objectsToResources ( config ) { return Object . keys ( config . objects ) . map ( name => { return pluralize ( name . toLowerCase ( ) ) ; } ) ; } var api = { } ; var route = resource ; route += '/' + id ; else //l('Calling:', data, verb, route, options); self [ verb ] . call ( self , route , options )", "del_tokens": "var api = { resources : [ ] } ; api . resources . push ( pluralize ( name . toLowerCase ( ) ) ) ; resource += '/' + id ; else //l('Calling:', verb, resource, options); self [ verb ] . call ( self , resource , options )", "commit_type": "add"}
{"commit_tokens": ["Fixed", "privateKeyPrefix", "for", "alt", "-", "currencies"], "add_tokens": "lib . Bitcoin . Address . networkVersion = parseInt ( version ) ; lib . Bitcoin . ECKey . privateKeyPrefix = parseInt ( version ) + 128 ;", "del_tokens": "lib . Bitcoin . Address . networkVersion = version ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "the", "CoffeeScript", "and", "TOML", "dependency", "injection"], "add_tokens": "var YAML = require ( 'js-yaml' ) , coffee , toml ; if ( ! coffee ) { coffee = require ( 'coffee-script' ) ; } if ( ! toml ) { toml = require ( 'toml' ) ; }", "del_tokens": "var YAML = require ( 'js-yaml' ) ; var coffee = require ( 'coffee-script' ) ; var toml = require ( 'toml' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Move", "from", "assert", "to", "better", "assert", "because", "it", "s", "well", "better"], "add_tokens": "assert = require ( 'better-assert' ) ,", "del_tokens": "assert = require ( 'assert' ) ,", "commit_type": "move"}
{"commit_tokens": ["use", "the", "dom", "-", "patch", "library"], "add_tokens": "var patch = require ( \"dom-patch\" ) ; // Listen for changes in the document and call postMessage // with the patches that will be applied on the other side. patch ( document , function ( patches ) { postMessage ( patches ) ; } ) ;", "del_tokens": "var schedule = require ( \"./scheduler\" ) . schedule ; var domId = require ( \"can-worker/dom-id/\" ) ; var serialize = require ( \"../../node_serialization\" ) . serialize ; require ( \"./overrides/insert\" ) ; require ( \"./overrides/remove\" ) ; require ( \"./overrides/attributes\" ) ; require ( \"./overrides/prop\" ) ; require ( \"./overrides/events\" ) ;", "commit_type": "use"}
{"commit_tokens": ["fix", "all", "routes", "being", "active"], "add_tokens": "if ( _activeRoutes . indexOf ( route ) === - 1 ) return false ;", "del_tokens": "var isActive = _activeRoutes . indexOf ( route ) !== - 1 ; if ( ! params ) return isActive ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "a", "test", "for", "object"], "add_tokens": "it ( 'Objects' , function ( ) { var dummyData = { data1 : \"\" , data2 : 2 , data3 : 3.0 } ; NativeStorage . set ( \"ref_obj\" , dummyData , function ( result ) { NativeStorage . getObject ( \"ref_obj\" , function ( result ) { expect ( result ) . toEqual ( dummyData ) ; } , function ( e ) { fail ( \"Read Object Failed\" ) ; } ) ; } , function ( e ) { fail ( \"Write Object Failed\" ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["fixed", "rootScope", "+", "parentScope", "for", "custom", "components"], "add_tokens": "createComponents : function ( attributes , parentScope , rootScope ) { rootScope = rootScope || this . $rootScope ; parentScope = parentScope || this . $parentScope ; components [ c ] . $parentScope = parentScope ; components [ c ] . $rootScope = rootScope ;", "del_tokens": "createComponents : function ( attributes ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "the", "Bool", "type", "management"], "add_tokens": "'\\t\\t}\\n' + '\\t\\tif(this.constructor.logger.isDebugEnabled()) {\\n' + '\\t\\t\\tthis.constructor.logger.debug(\\'before serialization: \\', this);\\n' + '\\t};\\n' ; '\\t};\\n' ; body += ( 'Object' === typeName || 'Bool' === typeName ) ?", "del_tokens": "'\\t}\\n' ; '\\t}\\n' ; body += ( 'Object' === typeName ) ?", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "style", "extension", "to", "string", "renaming", "the", "previous", "style", "to", "parseCodes", "."], "add_tokens": "style : function ( style ) { if ( Styles [ style ] ) { var classes = ( Styles [ style ] ) ; if ( ! classes . each ) classes = [ classes ] ; var codes = '' ; classes . each ( function ( color ) { codes += ANSI . get ( color ) ; } ) ; return codes + this + ANSI . get ( 'reset' ) ; } return this ; } , parseCodes : function ( style ) {", "del_tokens": "style : function ( ) {", "commit_type": "add"}
{"commit_tokens": ["fixed", "autosize", "padding", "bug", "added", "enter", "on", "single", "line", "edit", "commits", "edit"], "add_tokens": "ctx . fillText ( addEllipsis ( val , cellWidth - style [ cellStyle + 'PaddingRight' ] - orderByArrowSize - style . autosizePadding ) , } else if ( e . key === 'Enter' ) { endEdit ( ) ; draw ( ) ;", "del_tokens": "ctx . fillText ( addEllipsis ( val , cellWidth - style [ cellStyle + 'PaddingRight' ] - orderByArrowSize ) ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "some", "utils", "functions", "for", "group", "management"], "add_tokens": "", "del_tokens": "// console.log('Added ' + new GameBit({ // player: player, // key: key, // value: value, // state: state // }));", "commit_type": "add"}
{"commit_tokens": ["add", "empty", "register", "name", "test"], "add_tokens": "if ( ! name || ! _ . isString ( name ) ) { if ( ! name || ! _ . isString ( name ) ) {", "del_tokens": "if ( ! _ . isString ( name ) ) { if ( ! _ . isString ( name ) ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "Controller", "config", "init", "bug"], "add_tokens": "const OVERWRITEABLE_METHODS = [ 'constructor' ] ;", "del_tokens": "const OVERWRITEABLE_METHODS = [ 'constructor' , 'initRoutes' , 'initConfig' ] ; initConfig ( ) { /* Will be called when initialized */ }", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "leaks", "into", "global", "space"], "add_tokens": "var NANO try { NANO = require ( '../_nano' ) } catch ( err ) { err = null NANO = require ( 'nano' ) } var crypto = require ( 'crypto' ) var user = _ci . auth . split ( ':' , 1 ) . shift ( ) var password_sha = hash . digest ( 'hex' )", "del_tokens": "var NANO = require ( 'nano' ) , crypto = require ( 'crypto' ) user = _ci . auth . split ( ':' , 1 ) . shift ( ) password_sha = hash . digest ( 'hex' )", "commit_type": "fix"}
{"commit_tokens": ["Use", "constructor", "method", "instead", "of", "init", "for", "maps"], "add_tokens": "constructor : function ( properties ) { ok . Data . apply ( this , arguments ) ;", "del_tokens": "init : function ( properties ) {", "commit_type": "use"}
{"commit_tokens": ["moved", "some", "chromium", "-", "specific", "code", "into", "chromium", ".", "js", "(", "using", "extension", ".", "navigator", "namespace", ")"], "add_tokens": "extension . navigator . tabs . create ( \"options.html\" ) ; extension . navigator . setBadgeText ( newUnreadCount ) ;", "del_tokens": "chrome . tabs . create ( { url : \"options.html\" } ) ; chrome . browserAction . setBadgeText ( { text : newUnreadCount + \"\" } ) ;", "commit_type": "move"}
{"commit_tokens": ["Create", "utility", "helper", "that", "inverts", "a", "JavaScript", "object"], "add_tokens": "/ ** * Swap key with value in an object . * * @ param { Object } obj - The object . * @ return { Object } - The inverted object . * / function invertObject ( obj ) { if ( typeof obj !== 'object' || ! obj ) { // null is an object throw new Error ( '`invert`: First argument must be an object.' ) ; } var result = { } ; var key ; var value ; for ( key in obj ) { value = obj [ key ] ; if ( typeof value === 'object' ) { throw new Error ( '`invert`: Object must be flat.' ) ; } result [ value ] = key ; } return result ; } camelCase : camelCase , invertObject : invertObject", "del_tokens": "camelCase : camelCase", "commit_type": "create"}
{"commit_tokens": ["Add", "full", "Deed", "object", "to", "Entry", "object", "returned", "by", "getEntry"], "add_tokens": "// TODO: Calling this 'invalid' is confusing, it's not the same as 'invalidated' / ** * Constructs a Deed object * / function Deed ( address , balance , creationDate , owner ) { this . address = address ; this . balance = balance ; this . creationDate = creationDate ; this . owner = owner ; } Registrar . prototype . getDeed = function getDeed ( address ) { const d = this . web3 . eth . contract ( interfaces . deedInterface ) . at ( address ) ; const balance = this . web3 . eth . getBalance ( address ) ; return new Deed ( d . address , balance , d . creationDate ( ) , d . owner ( ) ) ; } ; // Accept either a name or a hash let deed ; if ( e [ 1 ] !== '0x0000000000000000000000000000000000000000' ) { // deed = this . getDeed ( e [ 1 ] ) ; } else { // construct a deed object with all props null except for the 0 address deed = new Deed ( e [ 1 ] , null , null , null ) ; } const entry = new Entry ( name , deed , e [ 4 ] . toNumber ( ) ) ;", "del_tokens": "// accept either a name or a hash const entry = new Entry ( name , e [ 1 ] , e [ 4 ] . toNumber ( ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "table", "name", "in", "references", "to", "match", "case", "of", "tables", "not", "models"], "add_tokens": "/*__each__ uniqueReferences */ this . __foreignKey__ = { tableName : '__primaryTableName__' , primaryKey : '__primaryKey__' , foreignKey : '__foreignKey__' , as : __associationNameQuoted__ } ;", "del_tokens": "/*__each__ uniqueReferences */ this . __foreignKey__ = { tableName : '__primaryTableNameModel__' , primaryKey : '__primaryKey__' , foreignKey : '__foreignKey__' , as : __associationNameQuoted__ } ;", "commit_type": "change"}
{"commit_tokens": ["added", "crop", "support", "fixed", "images", "to", "not", "crop", "by", "default"], "add_tokens": "let crop = ! ! ( 'undefined' !== typeof req . query . crop && req . query . crop == 1 ) ; let w = crop ? ` ${ width } ` : width ; let h = crop ? ` ${ height } ` : height ; . out ( '-background' , 'white' ) . resize ( w , h )", "del_tokens": ". out ( '-background' , 'transparent' ) . resize ( ` ${ width } ` , ` ${ height } ` )", "commit_type": "add"}
{"commit_tokens": ["Fixed", "an", "issue", "with", "setting", "up", "the", "callback", "option", "when", "define", "is", "called", "multiple", "times", "."], "add_tokens": "const requiresCallback = options . callback !== undefined ? options . callback : methodInfo . callback ; methodInfo . callback = requiresCallback !== undefined ? requiresCallback : true ;", "del_tokens": "methodInfo . callback = options . callback !== undefined ? options . callback : true ;", "commit_type": "fix"}
{"commit_tokens": ["Implementing", "glossary", "simple", "chunking", "and", "word", "phrasing", "(", "linking", "copulae", "negations", "..", "etc", ")"], "add_tokens": "return this . hmm . viterbi ( tokens ) . y ;", "del_tokens": "callback ( null , this . hmm . viterbi ( tokens ) . y ) ;", "commit_type": "implement"}
{"commit_tokens": ["Change", "toVisualizerMolfile", "to", "by", "default", "put", "as", "highlight", "the", "atom", "number", "."], "add_tokens": "var molfile = molecule . toVisualizerMolfile ( { diastereotopic : true } ) ; heavyAtomHydrogen : true , diastereotopic : true", "del_tokens": "var molfile = molecule . toVisualizerMolfile ( ) ; heavyAtomHydrogen : true", "commit_type": "change"}
{"commit_tokens": ["Improve", "JSDoc", "descriptions", "for", "public", "methods"], "add_tokens": "* Override default gulp - task - maker configuration * For each key in tasksConfig , load the corresponding script from taskDir * and create a set of gulp tasks * @ param { string } taskDir - task directory path * Create a set of gulp tasks from a single script or function", "del_tokens": "* Allows users to override default configuration * Resolve the provided tasks directory path and return the createTasks function * @ param { string } taskDir - task directory path or fully - fledged config * Create a single task ( public method , defers to createTask )", "commit_type": "improve"}
{"commit_tokens": ["Moving", "to", "urlPattern", "for", "newrelic", "transactions"], "add_tokens": "newrelic . setTransactionName ( routeInfo . appName + '||' + routeInfo . lang + '||' + routeInfo . urlPattern ) ;", "del_tokens": "newrelic . setTransactionName ( routeInfo . appName + '||' + routeInfo . lang + '||' + routeInfo . url ) ;", "commit_type": "move"}
{"commit_tokens": ["fix", "hiding", "buttons", "after", "deleting", "paragraph"], "add_tokens": "if ( $p . length && $p . text ( ) . trim ( ) === '' ) {", "del_tokens": "if ( $p . text ( ) . trim ( ) === '' ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "reading", "EXIF", "metadata", "(", "error", "spawn", "EMFILE", ")"], "add_tokens": "async . mapLimit ( toProcess , 100 , function ( fileInfo , next ) {", "del_tokens": "async . map ( toProcess , function ( fileInfo , next ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "copyright", "notice", "in", "LICENSE", "and", "source", "files"], "add_tokens": "/ *!", "del_tokens": "/ *", "commit_type": "add"}
{"commit_tokens": ["Add", "all", "sources", "(", "html", "css", "etc", ")"], "add_tokens": "sourceGlobs . push ( { cwd : cwd + path . sep + p . src , src : '**/*.*' } ) ;", "del_tokens": "sourceGlobs . push ( { cwd : cwd + path . sep + p . src , src : '**/*.js' } ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "unused", "variable", "(", "thx", "ray", ")"], "add_tokens": "var contentLength , childViews , childViewsLength ,", "del_tokens": "var itemViewClass , contentLength , childViews , childViewsLength , itemViewClass = get ( this , 'itemViewClass' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Changing", "Host", "header", "in", "proxy", "is", "now", "optional", "(", "changeOrigin", "parameter", ")"], "add_tokens": "changeOrigin : params . changeOrigin || false", "del_tokens": "changeOrigin : true", "commit_type": "change"}
{"commit_tokens": ["Add", "start", "and", "stop", "method", "to", "Poller", "class", "."], "add_tokens": "Poller . prototype . start = function ( ) { this . _initialize ( ) ; } ; Poller . prototype . stop = function ( ) { clearInterval ( this . _interval ) ; } ; Poller . prototype . _initialize = function ( ) { GithubPoller . prototype . _initialize = function ( ) { Poller . prototype . _initialize . call ( this ) ; BuildbotPoller . prototype . _initialize = function ( ) { Poller . prototype . _initialize . call ( this ) ;", "del_tokens": "Poller . prototype . initialize = function ( ) { GithubPoller . prototype . initialize = function ( ) { Poller . prototype . initialize . call ( this ) ; BuildbotPoller . prototype . initialize = function ( ) { Poller . prototype . initialize . call ( this ) ;", "commit_type": "add"}
{"commit_tokens": ["upgrade", "command", "-", "line", "-", "args", "..", "usage", "updated", "."], "add_tokens": "{ name : \"width\" , type : String , multiple : true , alias : \"w\" , typeLabel : \"<widths>\" , { name : \"padding-left\" , type : String , alias : \"l\" , description : \"One or more characters to pad the left of each column. Defaults to ' '.\" } , { name : \"padding-right\" , type : String , alias : \"r\" , description : \"One or more characters to pad the right of each column. Defaults to ' '.\" }", "del_tokens": "{ name : \"width\" , type : String , multiple : true , alias : \"w\" , { name : \"padding-left\" , type : String , alias : \"l\" } , { name : \"padding-right\" , type : String , alias : \"r\" }", "commit_type": "upgrade"}
{"commit_tokens": ["add", "send", "and", "pipe", "helpers"], "add_tokens": "var send = require ( './send' ) ; var pipe = require ( './pipe' ) ; Service . prototype . pipe = function ( ) { var args = norma ( '{path:s?, options:.*}' , arguments ) ; args . handler = pipe ; this . middleware . push ( args ) ; return this ; } ; Service . prototype . send = function ( ) { var args = norma ( '{path:s?, options:.*}' , arguments ) ; args . handler = send ; this . middleware . push ( args ) ; return this ; } ; 'request' , 'listen' , 'use' , 'send' , 'pipe' , 'start' , 'stop' , 'on' ,", "del_tokens": "'request' , 'listen' , 'use' , 'start' , 'stop' , 'on'", "commit_type": "add"}
{"commit_tokens": ["Add", "getRoutingID", "and", "getProcessID", "for", "window", "API", "."], "add_tokens": "// Echo every message back.", "del_tokens": "console . log ( 'message from' , process_id , routing_id ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "FiberPool", "to", "be", "restricted", "to", "a", "target", "size", "."], "add_tokens": "function FiberPool ( Promise , targetFiberCount ) { assert . strictEqual ( typeof targetFiberCount , \"number\" ) ; if ( fiberStack . length < targetFiberCount ) { fiberStack . push ( fiber ) ; } else { // If the pool has already reached the target maximum number of // Fibers, don't bother recycling this Fiber. break ; } // Limit the maximum number of idle Fibers that may be kept in the // pool. Note that the run method will never refuse to create a new // Fiber if the pool is empty; it's just that excess Fibers might be // thrown away upon completion, if the pool is full. this . setTargetFiberCount = function ( limit ) { assert . strictEqual ( typeof limit , \"number\" ) ; targetFiberCount = Math . max ( limit , 0 ) ; if ( targetFiberCount < fiberStack . length ) { // If the requested target count is less than the current length of // the stack, truncate the stack and terminate any surplus Fibers. fiberStack . splice ( targetFiberCount ) . forEach ( function ( fiber ) { fiber . reset ( ) ; } ) ; } return this ; } ; exports . makePool = function ( Promise , targetFiberCount ) { return new FiberPool ( Promise , targetFiberCount || 20 ) ;", "del_tokens": "function FiberPool ( Promise ) { fiberStack . push ( fiber ) ; exports . makePool = function ( Promise ) { return new FiberPool ( Promise ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "passing", "options", "to", "bundler"], "add_tokens": "var output = pipes ( b . bundle ( ) ) ; extensions : options . extensions , debug : options . debug", "del_tokens": "var output = pipes ( b . bundle ( options ) ) ; extensions : options . extensions", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "zoomX", "and", "zoomY", "values"], "add_tokens": "$self . data ( { \"zoomLevel\" : newLevel , \"panX\" : panX , \"panY\" : panY , \"zoomX\" : panX + paper . _viewBox [ 2 ] / 2 , \"zoomY\" : panY + paper . _viewBox [ 3 ] / 2 } ) ; $parentContainer . data ( { \"panX\" : panX , \"panY\" : panY , \"zoomX\" : panX + paper . _viewBox [ 2 ] / 2 , \"zoomY\" : panY + paper . _viewBox [ 3 ] / 2 } ) ;", "del_tokens": "$self . data ( { \"zoomLevel\" : newLevel , \"panX\" : panX , \"panY\" : panY , \"zoomX\" : zoomOptions . x , \"zoomY\" : zoomOptions . y } ) ; $parentContainer . data ( { \"panX\" : panX , \"panY\" : panY } ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "second", "argument", "to", "event", "listener", "callback"], "add_tokens": "var listeners = { } return function ( node , value , previousValue , path ) { node . removeEventListener ( key , listeners [ key ] , useCapture ) for ( key in events ) { listeners [ key ] = function eventListener ( event ) { return events [ key ] ( event , path ) } node . addEventListener ( key , listeners [ key ] , useCapture ) }", "del_tokens": "return function ( node , value , previousValue ) { node . removeEventListener ( key , events [ key ] , useCapture ) for ( key in events ) node . addEventListener ( key , events [ key ] , useCapture )", "commit_type": "add"}
{"commit_tokens": ["moved", "SPARQL", "proxy", "to", "separate", "package"], "add_tokens": "var sparqlProxy = require ( 'sparql-proxy' )", "del_tokens": "var sparqlProxy = require ( './lib/sparql-proxy' )", "commit_type": "move"}
{"commit_tokens": ["Add", "tests", "for", "promise", "-", "support"], "add_tokens": "var request = require ( './rp' ) ; requester : sinon . match . func , body : '' response : { statusCode : template . error ? 500 : 200 } // Freeze the fake result and it's properties for more reliable tests. Object . freeze ( fake ) ; Object . keys ( fake ) . forEach ( function ( key ) { if ( ! Object . isFrozen ( fake [ key ] ) && ! Buffer . isBuffer ( fake [ key ] ) ) { Object . freeze ( fake [ key ] ) ; } } ) ; // The promise returned by request-promise won't resolve until // it's callback is called. The problem is that we need to callback // after the constructor returns to simulate a real request/response. var instance = request ( params ) ; // This is the callback that cloudscraper should replace. var callback = instance . callback ; // We don't want to callback with the fake result until // after the constructor returns thus define a property getter/setter // and wait for cloudscraper to set it's own callback. Object . defineProperty ( instance , 'callback' , { // Returns request-promise's callback. return callback ; // This won't callback unless cloudscraper replaces the callback. return instance ;", "del_tokens": "var request = require ( 'request-promise' ) ; requester : request , // noinspection JSUnresolvedVariable body : '' , response : { statusCode : template . error ? 500 : 200 } , return Object . defineProperty ( { } , 'callback' , { // Return the callback function that is to be replaced. return params . callback ; // Don't callback until after cloudscraper replaces the callback function.", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "way", "to", "import", "the", "module", "from", "Cube", ".", "default", "to", "Cube"], "add_tokens": "libraryTarget : 'umd' , libraryExport : \"default\"", "del_tokens": "libraryTarget : 'umd'", "commit_type": "change"}
{"commit_tokens": ["fix", "event", "handler", "for", "IE", "and", "fix", "the", "preventDefault", "function", "too"], "add_tokens": "e . returnValue = false ; return handler . call ( elm , e ) ;", "del_tokens": "e . returnValue = true ; return handler . apply ( elm , e ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allowed", "negated", "flags", "with", "a", "short", "name", "."], "add_tokens": "o . value = o . short && o . opt && o . opt . negate ? false : ! o . negate ;", "del_tokens": "o . value = ! o . negate ;", "commit_type": "allow"}
{"commit_tokens": ["Changed", "SVGElement", "reference", "to", "window", ".", "SVGElement", "."], "add_tokens": "return typeof window . SVGElement !== 'undefined' && element [ 0 ] instanceof window . SVGElement ;", "del_tokens": "return typeof SVGElement !== 'undefined' && element [ 0 ] instanceof SVGElement ;", "commit_type": "change"}
{"commit_tokens": ["Implement", "and", "assert", "on", "recursive", "replacement", "."], "add_tokens": "var merge = utils . merge , walk = utils . walk ; var native = require ( 'cli-native' ) ; * @ param str The target string value . / ** * Performs recursive substitution of environment variables within * complex objects . * * @ param root The root object . * @ param env An object containing environment variables * default is process . env . * @ param escaping Whether escaped dollars indicate replacement * should be ignored . * / function env ( root , env , escaping ) { walk ( root , function visit ( props ) { return ( props . value instanceof String ) || typeof props . value === 'string' ; } , function transform ( props ) { props . parent [ props . name ] = replace ( props . value , env , escaping ) ; } ) } module . exports . env = env ;", "del_tokens": "var merge = require ( 'cli-util' ) . merge ; var native = require ( 'cli-native' ) ; * @ param str The target sring value .", "commit_type": "implement"}
{"commit_tokens": ["Update", "with", "better", "option", "of", "plugin", "."], "add_tokens": "nameSpace : ''", "del_tokens": "nameSpace : '' , outputDimensions : true", "commit_type": "update"}
{"commit_tokens": ["Made", "resolve", "()", "a", "Collection", "method", "and", "added", "some", "shortcuts", "to", "site"], "add_tokens": "return processor ( memo , _ . defaults ( attributes , content . attributes ) , content . site ) ; , layout = ( this . attributes . layout && this . site . layouts . resolve ( this . attributes . layout ) )", "del_tokens": "return processor ( memo , ( _ . defaults ( attributes , content . attributes ) ) , content . site ) ; , layout = ( this . attributes . layout && this . site . folder . templates . folder . layouts . folder [ this . attributes . layout ] )", "commit_type": "make"}
{"commit_tokens": ["make", "sure", "html", "renderer", "is", "not", "overridden"], "add_tokens": "if ( ! renderSettings . noFontFallback && el . nodeName . toLowerCase ( ) === 'img' && App . setup . supportsCanvas && renderSettings . renderer === 'svg' ) { 'alt' : ( theme . text ? ( theme . text . length > 16 ? theme . text . substring ( 0 , 16 ) + '…' : t eme.t e xt) + ' ['+d i mensionsCaption+' ] ': d mensionsCaption)", "del_tokens": "if ( ! renderSettings . noFontFallback && el . nodeName . toLowerCase ( ) === 'img' && App . setup . supportsCanvas ) { 'alt' : ( theme . text ? theme . text + ' [' + dimensionsCaption + ']' : dimensionsCaption )", "commit_type": "make"}
{"commit_tokens": ["Fix", "error", "handling", "on", "order", "()"], "add_tokens": "if ( ! response ) { if ( callback ) callback ( error , response ) ; else console . error ( 'Order() error:' , error ) ; return ; }", "del_tokens": "/ * Breaking change : Spread operator is unsupported by Electron Move this to a future release v0 .4 .0 trades : function ( symbol , callback , options ) { signedRequest ( base + 'v3/myTrades' , { symbol : symbol , ... options } , function ( data ) { if ( callback ) return callback . call ( this , data , symbol ) ; } ) ; } , * /", "commit_type": "fix"}
{"commit_tokens": ["Add", "simple", "mode", "which", "doesn", "t", "use", "mermaid", ".", "cli"], "add_tokens": "/ ** * Given the contents , returns a MDAST representation of a HTML node . * * @ param { string } contents * @ return { object } * / function createMermaidDiv ( contents ) { return { type : 'html' , value : ` < div class = \"mermaid\" > $ { contents } < / div > `, } ; } createMermaidDiv , getDestinationDir ,", "del_tokens": "getDestinationDir ,", "commit_type": "add"}
{"commit_tokens": ["Added", "lseek", "and", "tests", "."], "add_tokens": "FileSystem . prototype . lseek = function lseek ( fd , offset , whence , callback ) { var transaction = that . db . transaction ( [ FILE_STORE_NAME ] , IDB_RW ) ; var files = transaction . objectStore ( FILE_STORE_NAME ) ; function update_descriptor_position ( error , stats ) { if ( error ) { deferred . reject ( error ) ; } else { if ( stats . size + offset < 0 ) { deferred . reject ( new EInvalid ( 'resulting file offset would be negative' ) ) ; } else { ofd . position = stats . size + offset ; deferred . resolve ( ofd . position ) ; } } } ; fstat_file ( files , ofd , update_descriptor_position ) ;", "del_tokens": "FileSystem . prototype . seek = function seek ( fd , offset , whence , callback ) { var transaction = that . db . transaction ( [ FILE_STORE_NAME ] , IDB_RW ) ; var files = transaction . objectStore ( FILE_STORE_NAME ) ; // do fstat", "commit_type": "add"}
{"commit_tokens": ["Added", "queue", "()", "-", "function"], "add_tokens": "/ ** * Returns the current queue as standalone function . * * @ returns { Function } * / replace . queue = function ( ) { var currentQueue = queue ; queue = [ ] ; / ** * @ param { String } str * / return function ( str ) { return replace ( str , currentQueue ) ; } ; } ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "typo", "-", "copied", "line", "break"], "add_tokens": "this . lastmod += [ ut . lpad ( parseInt ( dt . getTimezoneOffset ( ) / 60 , 10 ) , 2 ) , ut . lpad ( dt . getTimezoneOffset ( ) % 60 , 2 ) ] . join ( ':' ) ;", "del_tokens": "this . lastmod += [ ut . lpad ( parseInt ( dt . getTimezoneOffset ( ) / 60 , 10 ) , 2 ) , ut . lpad ( dt . getTimezoneOffset ( ) % 60 , 2 ) ] . join ( ':' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "uncaught", "reference", "error", "when", "scrolling"], "add_tokens": "if ( ! up && ( els . innerContent . height ( ) - els . content . height ( ) == scrollTop ) ) {", "del_tokens": "if ( ! up && ( innerContent . height ( ) - content . height ( ) == scrollTop ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "for", "sentry", "and", "removing", "token", "logging", "in", "staging"], "add_tokens": "log . debug ( 'Problem verifying token: ' + token ) ;", "del_tokens": "log . error ( 'Problem verifying token: ' + token ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixes", "a", "context", "bug", "with", "relations"], "add_tokens": "return this . __chained_model ? this . __chained_model . getInternal ( 'context' ) : this . __context ; } ; exports . definition = { mixinCallback : function ( ) { var self = this ; this . on ( 'relation_record_added' , function ( parent , options , record ) { if ( parent . context ) { record . __context = parent . context ; } } ) ; }", "del_tokens": "return this . __chained_model ? this . __chained_model . getInternal ( 'context' ) : null ;", "commit_type": "fix"}
{"commit_tokens": ["added", "subfolder", "functionality", "for", "pages", "and", "special", "layouts", "for", "subfolders"], "add_tokens": "* * tests : [ 'test/dist' ] , grunt . registerTask ( 'test' , [ 'clean' , 'mustache_hogan_html' , 'nodeunit' ] ) ;", "del_tokens": "* * tests : [ 'tmp' , 'dist' ] , grunt . registerTask ( 'test' , [ 'clean' , 'mustache_hogan_html' , 'nodeunit' , 'clean' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "key", "to", "head", "and", "emit", "head", "with", "request", "event"], "add_tokens": "proto . proxyReq = function proxyReq ( opts ) { var key = opts . key ; var dest = opts . dest ; var req = opts . req ; var res = opts . res ; var timeout = opts . timeout ? checksum : ringpop . membership . checksum , ringpopKey : key ringpop . emit ( 'request' , httpRequest , httpResponse , head ) ;", "del_tokens": "proto . proxyReq = function proxyReq ( dest , req , res , opts ) { var timeout = opts && opts . timeout ? checksum : ringpop . membership . checksum ringpop . emit ( 'request' , httpRequest , httpResponse ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "unittest", "for", "circular", "dependency", "path", "."], "add_tokens": "madge ( [ __dirname + '/files/amd/circular' ] , { format : 'amd' } ) . circular ( ) . getArray ( ) . should . eql ( [ [ 'a' , 'c' ] , [ 'f' , 'g' , 'h' ] ] ) ;", "del_tokens": "madge ( [ __dirname + '/files/amd/circular' ] , { format : 'amd' } ) . circular ( ) . getArray ( ) . should . eql ( [ [ 'a' , 'c' ] , [ 'e' , 'f' , 'g' ] ] ) ;", "commit_type": "update"}
{"commit_tokens": ["fix", "statusCode", "handling", "for", "remote", "readstreams"], "add_tokens": "if ( res . statusCode !== 200 ) return reject ( res . statusMessage ) ;", "del_tokens": "if ( res . code !== 200 ) return reject ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "1MB", "in", "memory", "before", "backpressure"], "add_tokens": "var MAX_BUFFERED_AMOUNT = 1000 * 1000 if ( self . _channel . bufferedAmount > MAX_BUFFERED_AMOUNT ) { if ( ! self . _cb || ! self . _channel || self . _channel . bufferedAmount > MAX_BUFFERED_AMOUNT ) return", "del_tokens": "if ( self . _channel . bufferedAmount ) { if ( ! self . _cb || ! self . _channel || self . _channel . bufferedAmount ) return", "commit_type": "allow"}
{"commit_tokens": ["Add", "global", "config", "object", "AWS", ".", "configuration"], "add_tokens": "} AWS . configuration = new AWS . Config ( ) ;", "del_tokens": "} ,", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "environment", "variable", "alias"], "add_tokens": "function LoadEnvConfigStrategy ( prefix , aliases ) { this . aliases = aliases || } ; var prefix = this . prefix ; var aliases = this . aliases ; var envKey = prefix + delimiter + key . toUpperCase ( ) ; if ( envKey in aliases ) { envKey = aliases [ envKey ] ; }", "del_tokens": "function LoadEnvConfigStrategy ( prefix ) { var outerScope = this ; var envKey = outerScope . prefix + delimiter + key . toUpperCase ( ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "one", "key", "get", "format", "problem"], "add_tokens": "/ * * eg key is \":a-b-c\" \".a-b-c\" * then p is \"a-b-c\" \"a-b-c\" * * / var formatKey = function ( p ) { if ( validateName ( p ) === p && isNaN ( p ) ) return p ; else return ( \"\\\"\" + p + \"\\\"\" ) ; } var k = formatKey ( key . slice ( 1 ) ) ; o += ( k + \": \" ) ; var k = formatKey ( l . rest . first . slice ( 1 ) ) ; return ( need_return_string ? \"return \" : \"\" ) + compiler ( l . rest . rest . first ) + ( k [ 0 ] === \"\\\"\" ? \"[\" + k + \"]\" : \".\" + k ) ;", "del_tokens": "var k = key . slice ( 1 ) ; if ( validateName ( k ) === k && isNaN ( k ) ) o += ( k + \": \" ) ; else o += ( \"\\\"\" + k + \"\\\": \" ) ; return ( need_return_string ? \"return \" : \"\" ) + compiler ( l . rest . rest . first ) + compiler ( l . rest . first ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changing", "name", ";", "Spy", "-", ">", "Stub", ";", "More", "docs"], "add_tokens": "this . create = sinon . stub ( ) ; this . update = sinon . stub ( ) ; this . remove = sinon . stub ( ) ; this . removeAll = sinon . stub ( ) ;", "del_tokens": "this . create = sinon . spy ( function ( createProperties , callback ) { if ( typeof callback === 'function' ) { callback ( ) ; } } ) ; this . update = sinon . spy ( function ( id , updateProperties , callback ) { if ( typeof callback === 'function' ) { callback ( ) ; } } ) ; this . remove = sinon . spy ( function ( menuItemId , callback ) { if ( typeof callback === 'function' ) { callback ( ) ; } } ) ; this . removeAll = sinon . spy ( function ( callback ) { if ( typeof callback === 'function' ) { callback ( ) ; } } ) ;", "commit_type": "change"}
{"commit_tokens": ["Adds", "metaprogramming", "tricks", "for", "guarded", "functions", "."], "add_tokens": "Vec2 = require ( 'vec2' ) , should = require ( 'should' ) , factory ; factory = function factory ( ) { return new Quadtree2 ( new Vec2 ( 2 , 3 ) , 4 ) ; } ; it ( 'should throw with inproper arguments' , function ( ) { ( function ( ) { Quadtree2 ( new Vec2 ( 2 , 3 ) , 4 ) ; } ) . should . not . throw ( ) ; var qt = factory ( ) ; qt . addObject ( 1 ) ; describe ( '#getSize' , function ( ) { it ( 'returns just a clone of the size' , function ( ) { var qt = factory ( ) , size = qt . getSize ( ) ; size . x = 5 ; qt . getSize ( ) . x . should . not . eql ( 5 ) ; qt . getSize ( ) . x . should . eql ( 2 ) ; } ) ; } ) ; } ) ;", "del_tokens": "should = require ( 'should' ) ; it ( 'should throw without proper arguments' , function ( ) { ( function ( ) { Quadtree2 ( new Vec2 ( 2 , 3 ) , 4 ) ; } ) . should . throw ( ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "argument", "to", "set", "Authorization", "header"], "add_tokens": "- a -- auth set Authorization header for graphql server $ graphqlviz https : //www.mypublicautheddomain.com/graphql -a \"Bearer xxxxx\" | dot -Tpng -o graph.png } , auth : { type : 'string' , alias : 'a' var headers = { Accept : 'application/json' , 'Content-Type' : 'application/json' } ; if ( cli . flags . auth ) { headers . Authorization = cli . flags . auth ; } headers : headers , if ( ! res . ok && cli . flags . verbose ) { console . log ( 'Request for schema failed w/ ' + res . status + ' (' + res . statusText + ')' ) ; } return res . text ( ) ; } ) ;", "del_tokens": "headers : { Accept : 'application/json' , 'Content-Type' : 'application/json' } , return res . text ( ) } )", "commit_type": "add"}
{"commit_tokens": ["make", "sure", "to", "use", "the", "right", "document"], "add_tokens": "var renderAndAddRangeNode = function ( render , context , args , document ) { var ownerDocument = this . range . start . ownerDocument , frag = ownerDocument . createDocumentFragment ( ) , itemFrag = renderAndAddRangeNode ( render , context , [ itemCompute , itemIndex ] , ownerDocument ) ; var falseyFrag = renderAndAddRangeNode ( this . falseyRender , this . currentList , [ this . currentList ] , this . range . start . ownerDocument ) ;", "del_tokens": "var renderAndAddRangeNode = function ( render , context , args ) { var frag = this . range . start . ownerDocument . createDocumentFragment ( ) , itemFrag = renderAndAddRangeNode ( render , context , [ itemCompute , itemIndex ] ) ; var falseyFrag = renderAndAddRangeNode ( this . falseyRender , this . currentList , [ this . currentList ] ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "issue", "with", "method", "toObject"], "add_tokens": "if ( ! ret . transactions ) { ret . transactions = [ ] ; } for ( var i = ret . transactions . length - 1 ; i >= 0 ; i -- ) { if ( ! ret . transfers ) { ret . transfers = [ ] ; } for ( var i = ret . transfers . length - 1 ; i >= 0 ; i -- ) {", "del_tokens": "if ( ret . transactions ) for ( var i = ret . transactions . length - 1 ; i >= 0 ; i -- ) { if ( ret . transfers ) for ( var i = ret . transfers . length - 1 ; i >= 0 ; i -- ) {", "commit_type": "fix"}
{"commit_tokens": ["update", "core", "models", "and", "controllers"], "add_tokens": "/ ** * Index page route / * / index : function ( req , res ) { var we = req . getWe ( ) ; var context = req . context ; we . log . info ( 'rodou o main.index' , context ) ; res . locals . template = 'home/index' ; res . view ( { title : 'Express' } ) ; } , getConfigsJS : function ( req , res ) { if ( sails . config . clientside . publicVars ) { if ( ! req . isAuthenticated ( ) ) { if ( req . session . authToken ) {", "del_tokens": "getConfigsJS : function ( req , res ) { if ( sails . config . clientside . publicVars ) { if ( ! req . isAuthenticated ( ) ) { if ( req . session . authToken ) {", "commit_type": "update"}
{"commit_tokens": ["adding", "a", "second", "parameter", "to", "each", "()", "a", "context", "parameter", "for", "setting", "this"], "add_tokens": "each : function ( fn , ctx ) { util . each ( Stapes . _attributes [ this . _guid ] , util . bind ( fn , ctx || this ) ) ;", "del_tokens": "each : function ( fn ) { util . each ( Stapes . _attributes [ this . _guid ] , util . bind ( fn , this ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "name", "of", "Error", "and", "use", "new", "when", "building", "Error"], "add_tokens": "this . name = 'ConnectionTimeoutError' ;", "del_tokens": "this . name = 'BaseURLNotSetError' ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "configuration", "options", "to", "change", "default", "extend", "/", "retract", "keys"], "add_tokens": "options . keys = options . keys || [ '+' , 'space' ] ; this . rows . key ( options . keys , function ( ) {", "del_tokens": "this . rows . key ( [ '+' , 'space' ] , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Adding", "support", "for", "paged", "results", "."], "add_tokens": "var compiledData = [ ] ; // Recursive call to paginate function qGCall ( pageLink ) { var methodCall ; // Callback function callback ( error , data ) { compiledData = compiledData . concat ( data ) ; if ( github . hasNextPage ( data ) ) { qGCall ( data ) ; } else { defer . resolve ( compiledData ) ; } // If the call is a link to another page, use that. if ( pageLink ) { method = github . getNextPage ( pageLink , callback ) ; } else { githubAuth ( ) [ options . obj ] [ options . method ] ( options , callback ) ; } } qGCall ( ) ; collection [ u ] = data [ 0 ] ; getObjects ( data [ 0 ] ) . done ( function ( objData ) {", "del_tokens": "githubAuth ( ) [ options . obj ] [ options . method ] ( options , function ( error , data ) { defer . resolve ( data ) ; ) ; collection [ u ] = data ; getObjects ( data ) . done ( function ( objData ) {", "commit_type": "add"}
{"commit_tokens": ["Remove", "the", "limit", "on", "event", "listeners", "for", "the", "HTTP", "server", "object", "in", "the", "http", "transport", ".", "Adding", "many", "services", "to", "the", "same", "http", "server", "causes", "the", "default", "limit", "of", "10", "to", "be", "quickly", "exhausted", "."], "add_tokens": "* @ param { Boolean } [ options . callback ] Flag which specifies if a callback function should be given to this method . * If false , a value can be sent back to clients by returning a value , a Promise , or using a generator function . * True by default . methodInfo . callback = options . callback !== undefined ? options . callback : true ; } ; } else if ( cowrap && internals . isGeneratorFunction ( remappedFn ) ) { return cowrap ( remappedFn ) . bind ( self ) ; } else if ( cowrap && internals . isGeneratorFunction ( fn ) ) { methodInfo . fn = cowrap ( fn ) . bind ( methodInfo [ \"this\" ] ) ;", "del_tokens": "} } else if ( cowrap ) { return ( internals . isGeneratorFunction ( remappedFn ) ? cowrap ( remappedFn ) : remappedFn ) . bind ( self ) ; } else if ( cowrap ) { methodInfo . fn = ( internals . isGeneratorFunction ( fn ) ? cowrap ( fn ) : fn ) . bind ( methodInfo [ \"this\" ] ) ; // TODO throw error up // self.trace.error('Type importer', null, typeInfoParseError);", "commit_type": "remove"}
{"commit_tokens": ["Added", "method", "for", "updating", "inventory", "on", "bptf"], "add_tokens": "this . steamid64 = options . steamid64 ; if ( ! this . steamid64 || typeof this . steamid64 == \"string\" || ! this . steamid64 . startsWith ( '76561198' ) ) { callback ( new Error ( \"Either missing, or the given steamid64 is not valid\" ) ) ; return ; } self . _heartbeatTimer = setInterval ( Listings . prototype . sendHeartbeat . bind ( self ) , 90 * 1000 ) ; self . updateInventory ( ) ; self . _inventoryTimer = setInterval ( Listings . prototype . updateInventory . bind ( self ) , 2 * 60 * 1000 ) ;", "del_tokens": "self . _timer = setInterval ( Listings . prototype . sendHeartbeat . bind ( self ) , 90 * 1000 ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "init", "call", "as", "well"], "add_tokens": "// start! _addEvent ( document , 'keydown' , _handleKeyDown ) ; _addEvent ( document , 'keyup' , _handleKeyUp ) ;", "del_tokens": "} , / ** * starts the event listeners * * @ returns void * / init : function ( ) { _addEvent ( document , 'keydown' , _handleKeyDown ) ; _addEvent ( document , 'keyup' , _handleKeyUp ) ; // start! Mousetrap . init ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Updated", "EventDispatcher", "and", "NEXT", "lib", "."], "add_tokens": "* * * eventObj . target = target || this ; if ( o . handleEvent ) { ret = ret || o . handleEvent ( eventObj ) ; } else { ret = ret || o ( eventObj ) ; }", "del_tokens": "* * * eventObj . target = target || this ; if ( o instanceof Function ) { ret = ret || o . apply ( null , [ eventObj ] ) ; } else if ( o . handleEvent ) { ret = ret || o . handleEvent ( eventObj ) ; }", "commit_type": "update"}
{"commit_tokens": ["Removes", "race", "condition", "for", "placed", "class"], "add_tokens": "if ( this . lastPlacedSource && this . lastPlacedContainer ) { clearTimeout ( this . placedTimeoutID ) ; this . lastPlacedSource . classList . remove ( this . getClassNameFor ( 'source:placed' ) ) ; this . lastPlacedContainer . classList . remove ( this . getClassNameFor ( 'container:placed' ) ) ; } this . lastPlacedSource = this . originalSource ; this . lastPlacedContainer = this . sourceContainer ; this . placedTimeoutID = setTimeout ( ( ) => { if ( this . lastPlacedSource ) { this . lastPlacedSource . classList . remove ( this . getClassNameFor ( 'source:placed' ) ) ; if ( this . lastPlacedContainer ) { this . lastPlacedContainer . classList . remove ( this . getClassNameFor ( 'container:placed' ) ) ; this . lastPlacedSource = null ; this . lastPlacedContainer = null ;", "del_tokens": "const lastSource = this . originalSource ; const lastSourceContainer = this . sourceContainer ; setTimeout ( ( ) => { if ( lastSource ) { lastSource . classList . remove ( this . getClassNameFor ( 'source:placed' ) ) ; if ( lastSourceContainer ) { lastSourceContainer . classList . remove ( this . getClassNameFor ( 'container:placed' ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["add", "space", "between", "combined", "text", "blocks", "in", "list", "item"], "add_tokens": "item 1 continues text : \"- List item 1 item 1 continues\" ,", "del_tokens": "text : \"- List item 1\" ,", "commit_type": "add"}
{"commit_tokens": ["allow", "custom", "link", "handler", "in", "ios"], "add_tokens": "INSTALL_VIEWER_APP : \"install\" , OPEN_LINK : \"openLink\" var linkHandlers = [ ] ; document . addEventListener ( \"sdvlinkopened\" , function ( e ) { var handled = ( linkHandlers [ e . handlerId ] || function ( ) { return false ; } ) ( e . link ) ; if ( ! handled ) { exec ( null , null , CDV_HANDLE , CDV_HANDLE_ACTIONS . OPEN_LINK , [ e . occurrenceId ] ) ; } } ) ; viewDocument : function ( url , contentType , options , onShow , onClose , onMissingApp , onError , onLink ) linkHandlers . push ( onLink ) ; var linkHandlerId = linkHandlers . length - 1 ; options : options , linkHandlerId : linkHandlerId", "del_tokens": "INSTALL_VIEWER_APP : \"install\" viewDocument : function ( url , contentType , options , onShow , onClose , onMissingApp , onError ) options : options", "commit_type": "allow"}
{"commit_tokens": ["Fix", "directories", "listing", "in", "memory", "driver"], "add_tokens": "if ( ! p ) return true ; return ( filepath != p && filepath . indexOf ( p + '/' ) === 0 ) ; var prepended = p ; if ( p ) prepended = p + '/' ; file . path . indexOf ( prepended ) === 0 && _ . compact ( file . path . slice ( prepended . length ) . split ( '/' ) ) . length == 1", "del_tokens": "return ( filepath != p && filepath . indexOf ( p ) === 0 ) ; file . path . indexOf ( p ) === 0 && _ . compact ( file . path . slice ( p . length ) . split ( '/' ) ) . length == 1", "commit_type": "fix"}
{"commit_tokens": ["Add", "custom", "AMD", "path", "options"], "add_tokens": "* Copyright ( c ) 2014 Tim Branyen , contributors amd_compile_string_path : { options : { amd : 'lib/handlebars' , namespace : false } , files : { 'tmp/amd_compile_string_path.js' : [ 'test/fixtures/amd.html' ] } } , amd_compile_string_deps : { options : { amd : 'handlebars\\', \\'handlebars.helpers' , namespace : false } , files : { 'tmp/amd_compile_string_deps.js' : [ 'test/fixtures/amd.html' ] } } ,", "del_tokens": "* Copyright ( c ) 2014 Tim Branyen , contributors", "commit_type": "add"}
{"commit_tokens": ["Implemented", "UMD", "pattern", "on", "view", "files"], "add_tokens": "( function ( factory , ok , $ ) { // amd if ( typeof define === 'function' && define . amd ) { define ( 'ok.dollarview' , [ 'ok' , 'jquery' ] , factory ) ; } // commonjs else if ( typeof module !== 'undefined' && typeof require === 'function' ) { ok = require ( 'ok' ) ; $ = require ( 'jquery' ) ; factory ( ok , $ ) ; module . exports = ok ; } // globals else { ok = window . okaylib ; $ = window . jQuery ; factory ( ok , $ ) ; } } ) ( function ( ok , $ ) { } ) ;", "del_tokens": "( function ( ok , $ ) { } ) ( okaylib , jQuery || Zepto || ender || $ ) ;", "commit_type": "implement"}
{"commit_tokens": ["Add", "verbose", "/", "quiet", "arg", "to", "execWrap", "()", ";"], "add_tokens": "// Args: // - command: the shell command // - verbose: show output on the cli, defaults to true function execWrap ( command , verbose ) { verbose = typeof verbose === 'undefined' ? true : verbose ; if ( verbose ) { grunt . log . write ( shellResult . output ) ; } execWrap ( 'git reset' , false ) ; execWrap ( 'git fetch ' + remoteName , false ) ;", "del_tokens": "function execWrap ( command ) { grunt . log . write ( shellResult . output ) ; execWrap ( 'git reset' ) ; execWrap ( 'git fetch ' + remoteName ) ;", "commit_type": "add"}
{"commit_tokens": ["Create", "only", "the", "column", "from", "the", "first", "<tr", ">"], "add_tokens": "angular . forEach ( element . find ( \"tr\" ) . eq ( 0 ) . find ( \"td\" ) , function ( item ) {", "del_tokens": "angular . forEach ( element . find ( \"td\" ) , function ( item ) {", "commit_type": "create"}
{"commit_tokens": ["Fixed", "a", "bug", "that", "caused", "an", "erroneous", "validation", "error", "for", "some", "array", "parameters"], "add_tokens": "var validTypes , schema ; schema = param . schema ; schema = param ; schema = param ; if ( validTypes . indexOf ( schema . type ) === - 1 ) { throw util . newSyntaxError ( '%s has an invalid %s parameter type (%s)' , operationId , param . in , schema . type ) ; if ( schema . type === 'file' ) { else if ( schema . type === 'array' && ! schema . items ) {", "del_tokens": "var validTypes , type ; type = param . schema . type ; type = param . type ; type = param . type ; if ( validTypes . indexOf ( type ) === - 1 ) { throw util . newSyntaxError ( '%s has an invalid %s parameter type (%s)' , operationId , param . in , type ) ; if ( type === 'file' ) { else if ( type === 'array' && ! param . items ) {", "commit_type": "fix"}
{"commit_tokens": ["Move", "log", "levels", "to", "the", "root", "object"], "add_tokens": "levels : [ 'error' , 'warn' , 'info' , 'verbose' , 'debug' , 'silly' ] , module . exports . levels . forEach ( function ( level ) {", "del_tokens": "log . LEVELS . forEach ( function ( level ) {", "commit_type": "move"}
{"commit_tokens": ["Added", "ability", "to", "use", "custom", "machine", "ID", "hash", "format"], "add_tokens": "this . options . machineIdFormat [ 0 ] . replace ( / \\{account_name\\} / g , this . _logOnDetails . account_name ) , this . options . machineIdFormat [ 1 ] . replace ( / \\{account_name\\} / g , this . _logOnDetails . account_name ) , this . options . machineIdFormat [ 2 ] . replace ( / \\{account_name\\} / g , this . _logOnDetails . account_name )", "del_tokens": "\"SteamUser Hash BB3 \" + this . _logOnDetails . account_name , \"SteamUser Hash FF2 \" + this . _logOnDetails . account_name , \"SteamUser Hash 3B3 \" + this . _logOnDetails . account_name", "commit_type": "add"}
{"commit_tokens": ["allow", "navigation", "upon", "predrawn", "waveform"], "add_tokens": "this . cc = this . canvas . getContext ( '2d' ) ;", "del_tokens": "this . cc = this . canvas . getContext ( '2d' ) ; bindClick : function ( callback ) { var my = this ; this . canvas . addEventListener ( 'click' , function ( e ) { var canvasPosition = my . canvas . getBoundingClientRect ( ) ; var relX = e . pageX - canvasPosition . left ; var percents = relX / my . width ; callback ( percents ) ; } , false ) ; } ,", "commit_type": "allow"}
{"commit_tokens": ["implement", "new", "template", "in", "format", "tools"], "add_tokens": "var referenceType = require ( '../templates/fieldReferenceType' ) ; \"string\" : String , \"number\" : Number , \"date\" : Date , \"boolean\" : Boolean , \"array\" : Array , \"objectId\" : referenceType if ( field . reference ) { modelFields = modelFields . replace ( / {ref} / , field . reference ) ; }", "del_tokens": "\"string\" : String , \"number\" : Number , \"date\" : Date , \"boolean\" : Boolean , \"array\" : Array", "commit_type": "implement"}
{"commit_tokens": ["Fixed", "a", "bug", "when", "middleware", "is", "this", "instead", "of", "desired", "exported", "object"], "add_tokens": "attachTemplatesToRequest : function ( ) { return function ( req , res , next ) { req . templates = self . templates ; if ( ! req . locals ) { req . locals = { } ; } req . locals . templates = self . templates ; if ( ! res . locals ) { res . locals = { } ; } res . locals . templates = self . templates ; return next ( ) ; } ;", "del_tokens": "attachTemplatesToRequest : function ( req , res , next ) { req . templates = self . templates ; if ( ! req . locals ) { req . locals = { } ; } req . locals . templates = self . templates ; if ( ! res . locals ) { res . locals = { } ; } res . locals . templates = self . templates ; return next ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "use", "of", "Object", ".", "values"], "add_tokens": "Object . keys ( this . nodes ) . map ( id => this . nodes [ id ] ) Object . keys ( this . nodes ) . forEach ( id => this . _computeNextCWEdges ( this . nodes [ id ] ) ) ;", "del_tokens": "Object . values ( this . nodes ) Object . values ( this . nodes ) . forEach ( node => this . _computeNextCWEdges ( node ) ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "support", "for", "empty", "entries", "and", "default", "dest"], "add_tokens": "bundle . entries = ( bundle . entries || [ ] ) . map ( function ( file ) { bundle . dest = path . join ( config . dest , variation . id , ( bundle . dest || bundleName + '.js' ) ) ;", "del_tokens": "bundle . entries = bundle . entries . map ( function ( file ) { bundle . dest = path . join ( config . dest , variation . id , bundle . dest ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "callback", "to", "function", "signature", "in", "case", "of", "message", "object"], "add_tokens": "var _emit = function ( message , payload , callback ) { emit : function ( topic , category , dataType , payload , callback ) { if ( ! msngr . utils . exists ( callback ) && msngr . utils . exists ( dataType ) && msngr . utils . isFunction ( dataType ) ) { callback = dataType ; } return _emit ( message , payload , callback ) ;", "del_tokens": "var _emit = function ( message , payload ) { emit : function ( topic , category , dataType , payload ) { return _emit ( message , payload ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "withCredentials", "flag", "for", "fetch", "implementation"], "add_tokens": "credentials : opts . withCredentials ? 'include' : 'omit'", "del_tokens": "credentials : opts . credentials ? 'include' : 'omit'", "commit_type": "fix"}
{"commit_tokens": ["Make", "it", "test", "-", "able", "in", "Windows"], "add_tokens": "var vkontakte = require ( '../' ) ;", "del_tokens": "var vkontakte = require ( 'passport-vkontakte' ) ;", "commit_type": "make"}
{"commit_tokens": ["add", "support", "for", "outputting", "ES5"], "add_tokens": ". option ( '-e, --es5' , 'Output ES5 (which is not quite as pretty)' ) program . help ( ) es5 : program . es5 ,", "del_tokens": "console . error ( 'You must specify exactly one input file.' )", "commit_type": "add"}
{"commit_tokens": ["add", "test", "for", "missing", "handler", "in", "config"], "add_tokens": "var handler = options . handlers && options . handlers [ name ] ; var errStr = util . format ( 'Handler \"%s\" is not defined in config' , name ) ;", "del_tokens": "var handler = options . handlers [ name ] ; var errStr = util . format ( 'Handler \"%s\" is not defined in config.' , name ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "webrtc", "final", "actions", "tests"], "add_tokens": "var subscribers ; var subscriberId ; subscriberId = message . data [ 0 ] ; } else if ( this . _callInitiatiorRegistry . hasSubscribers ( message . data [ 1 ] ) ) { subscriberId = message . data [ 1 ] ; if ( subscriberId ) { subscribers = this . _callInitiatiorRegistry . getSubscribers ( subscriberId ) ; this . _callInitiatiorRegistry . unsubscribe ( subscriberId , subscribers [ 0 ] ) ; / ** * Reply with whether the client is still connected . Useful for determining * if the remoteCaller is no longer available . * * @ param { SocketWrapper } socketWrapper * @ param { Object } message parsed and validated deepstream message * * @ private * @ returns { void } * /", "del_tokens": "this . _callInitiatiorRegistry . unsubscribe ( message . data [ 0 ] , socketWrapper ) ; if ( this . _callInitiatiorRegistry . hasSubscribers ( message . data [ 1 ] ) ) { this . _callInitiatiorRegistry . unsubscribe ( message . data [ 1 ] , socketWrapper ) ;", "commit_type": "fix"}
{"commit_tokens": ["move", "schema", "out", "of", "data", "in", "an", "own", "object"], "add_tokens": "name : 'income' , } , { } , { selector : true , show : true } } , { id : 6 , name : 'Type Selector' , description : 'The type selector allows the user to choose the chart type.' , options : { rows : [ { name : 'sales' } ] , typeSelector : true , xAxis : { name : 'income' } } } ] ;", "del_tokens": "} , { name : 'income' name : 'day' , } , { } , { selector : true , show : true } } ] ;", "commit_type": "move"}
{"commit_tokens": ["update", "tests", "for", "method", "rename"], "add_tokens": "expect ( this . re . asString ( ) ) . to . equal ( '(foo)' ) ; expect ( this . re . asString ( ) ) . to . equal ( '(foo)' ) ; expect ( this . re . asString ( ) ) . to . equal ( '(foo)|(bar)' ) ;", "del_tokens": "expect ( this . re . toString ( ) ) . to . equal ( '(foo)' ) ; expect ( this . re . toString ( ) ) . to . equal ( '(foo)' ) ; expect ( this . re . toString ( ) ) . to . equal ( '(foo)|(bar)' ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "double", "-", "play", "of", "looping", "sounds", "."], "add_tokens": "that . play ( that . firstPlay , that . firstPlayLoop ) ; this . firstPlayLoop = loop ;", "del_tokens": "that . play ( that . firstPlay ) ;", "commit_type": "fix"}
{"commit_tokens": ["using", "__proto__", "instead", "of", "util", ".", "inherits"], "add_tokens": "* * * Args . prototype . __proto__ = Expectation . prototype ; * * * throw new Error ( this . error ( 'main' , { * module . exports = Args ;", "del_tokens": "* / ** * Module dependencies . * / var util = require ( 'util' ) ; * * util . inherits ( Args , Expectation ) ; * * * throw new Error ( this . error ( 'main' , { * module . exports = Args ;", "commit_type": "use"}
{"commit_tokens": ["update", "isDronePeripheral", "method", "in", "drone", ".", "js", ".", "support", "for", "parrot", "new", "Drone", "airborne", "-", "night", "-", "drone", "-", "maclane", "."], "add_tokens": "var localNameMatch = localName && ( localName . indexOf ( 'RS_' ) === 0 || localName . indexOf ( 'Maclan_' ) === 0 ) ; var manufacturerMatch = manufacturer && ( manufacturer . toString ( 'hex' ) === '4300cf1900090100' || manufacturer . toString ( 'hex' ) === '4300cf1907090100' ) ;", "del_tokens": "var localNameMatch = localName && localName . indexOf ( 'RS_' ) === 0 ; var manufacturerMatch = manufacturer && manufacturer . toString ( 'hex' ) === '4300cf1900090100' ;", "commit_type": "update"}
{"commit_tokens": ["CHANGED", "minimal", "patches", "to", "work", "with", "io", ".", "js"], "add_tokens": "const protocol = options . protocol || ( options . _defaultAgent && options . _defaultAgent . protocol ) || 'http:' ;", "del_tokens": "const protocol = options . protocol || 'http:' ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "bug", "where", "files", "path", "were", "being", "printed", "incorrectly", "in", "the", "spec", "file"], "add_tokens": "var dest = path . join ( file . dest , srcFile ) ; files . push ( dest ) ; fsx . copySync ( srcFile , path . join ( buildRoot , dest ) ) ;", "del_tokens": "var dest = path . join ( buildRoot , file . dest , srcFile ) ; files . push ( dest ) fsx . copySync ( srcFile , dest ) ;", "commit_type": "fix"}
{"commit_tokens": ["make", "get", "()", "isomorphic", "(", "uses", "fs", "in", "node", ")"], "add_tokens": "// AMD environment if ( typeof define === 'function' && define . amd ) { define ( [ 'ractive' ] , factory ) ; // Common JS (i.e. node/browserify) else if ( typeof module !== 'undefined' && module . exports && typeof require === 'function' ) { module . exports = factory ( require ( 'ractive' ) , require ( 'fs' ) , require ( 'path' ) ) ; } ( typeof window !== 'undefined' ? window : this , function ( Ractive , fs , path ) {", "del_tokens": "// Common JS (i.e. browserify) environment if ( typeof module !== 'undefined' && module . exports && typeof require === 'function' ) { factory ( require ( 'Ractive' ) ) ; // AMD? else if ( typeof define === 'function' && define . amd ) { define ( [ 'Ractive' ] , factory ) ; } ( typeof window !== 'undefined' ? window : this , function ( Ractive ) {", "commit_type": "make"}
{"commit_tokens": ["made", "usage", "easier", "by", "downloading", "files", "into", "nodes_modules", "of", "the", "unjar", "-", "from", "-", "url", "module"], "add_tokens": "// mkdir -p fileDirectory fileDirectory . split ( '/' ) . forEach ( ( dir , index , splits ) => { const parent = splits . slice ( 0 , index ) . join ( '/' ) ; const dirPath = path . resolve ( parent , dir ) ; if ( ! fs . existsSync ( dirPath ) ) { fs . mkdirSync ( dirPath ) ; } } ) ;", "del_tokens": "fs . mkdirSync ( fileDirectory ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "Category", "for", "ascendBy", "and", "descendBy"], "add_tokens": "* @ category Function", "del_tokens": "* @ category Array", "commit_type": "fix"}
{"commit_tokens": ["add", "test", "for", "nested", "dir"], "add_tokens": "return resolve ( fixture , 'dir-rec' )", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "with", "<C", "-", "PageUp", ">", "/", "<C", "-", "PageDown", ">", "in", "latest", "change"], "add_tokens": "mainWindow = null", "del_tokens": "mainWindow = null", "commit_type": "fix"}
{"commit_tokens": ["use", "midi", "note", "for", "note", "comparisation"], "add_tokens": "* @ param { Array } notes - an array of required notes // convert the notes to midi number var notesMidi = notes . map ( function ( note ) { return midi ( note ) ; } ) if ( notesMidi . indexOf ( midi ( note ) ) !== - 1 ) {", "del_tokens": "if ( notes . indexOf ( note ) !== - 1 ) {", "commit_type": "use"}
{"commit_tokens": ["Added", "structure", "and", "list", "member", "names", "."], "add_tokens": "} ;", "del_tokens": "} ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "default", "value", "of", "successMessage"], "add_tokens": "successMessage : / ^[Ss]erver listening / ,", "del_tokens": "successMessage : / ^server listening$ / ,", "commit_type": "change"}
{"commit_tokens": ["Remove", "unnecessary", "spaces", "in", "file", "/", "folder", "name"], "add_tokens": "var BlinkDiff = require ( 'blink-diff' ) ; * Blink - Diff comparison object browserId = this . getDriver ( ) . browserId ( ) . trim ( ) . replace ( / \\s\\s+ / g , ' ' ) ; return utils . fileNameSafe ( title . trim ( ) . replace ( / \\s\\s+ / g , ' ' ) ) + '_' + id ; var diffPath , buildPath , approvedPath ,", "del_tokens": "* Device - Pixel - Ratio object / ** * Loads the Blink - Diff library , creating output instructing user to install the module * * @ method _loadBlinkDiff * @ return { BlinkDiff } * @ private * / BlinkDiffComparison . prototype . _loadBlinkDiff = function ( ) { var BlinkDiff ; try { BlinkDiff = require ( 'blink-diff' ) ; } catch ( err ) { console . error ( 'Cannot find package \"blink-diff\". Please install it with \"npm install --save blink-diff\" to use image comparison.' ) ; } return BlinkDiff ; } ; browserId = this . getDriver ( ) . browserId ( ) ; return utils . fileNameSafe ( title ) + '_' + id ; var BlinkDiff , diffPath , buildPath , approvedPath , BlinkDiff = this . _loadBlinkDiff ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["update", "error", "message", "in", "test"], "add_tokens": "assert . equal ( err . message , 'engine-cache \"mergeHelpers\" expected \"options\" to be an object.' ) ;", "del_tokens": "assert ( err . message . indexOf ( 'Cannot' ) !== - 1 ) ;", "commit_type": "update"}
{"commit_tokens": ["Use", "v8", "symbols", "for", "thread", "locals", "on", "musl"], "add_tokens": "'Please make sure you are using a supported platform and node version. If you\\n' + 'would like to compile fibers on this machine please make sure you have setup your\\n' + 'build environment--\\n' + 'Windows + OS X instructions here: https://github.com/nodejs/node-gyp\\n' + 'Ubuntu users please run: `sudo apt-get install g++`\\n' + 'Alpine users please run: `sudo apk add python make g++`' 'node-gyp not found! Please ensure node-gyp is in your PATH--\\n' + 'Try running: `sudo npm install -g node-gyp`'", "del_tokens": "'Please make sure you are using a supported platform and node version. If you would like\\n' + 'to compile fibers on this machine please make sure you have setup your build environment--\\n' + 'Windows + OS X instructions here:\\n' + 'https://github.com/nodejs/node-gyp\\n' + 'Ubuntu users please run: `sudo apt-get install g++`' 'node-gyp not found! Please ensure node-gyp is in your PATH.'", "commit_type": "use"}
{"commit_tokens": ["Updating", "stand", "-", "alone", "builds"], "add_tokens": ". pipe ( gulp . dest ( 'dist' ) ) ; . pipe ( gulp . dest ( 'dist' ) ) ;", "del_tokens": ". pipe ( gulp . dest ( 'dist/jbb-profile-three' ) ) ; . pipe ( gulp . dest ( 'dist/jbb-profile-three' ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "debugReplace", "method", "to", "JScrewIt"], "add_tokens": "// BEGIN: JScrewIt ///////////////// var encoder = getEncoder ( compatibility ) ; var output = encoder . encode ( input , wrapWithEval ) ; return output ; } function fixCompatibility ( compatibility ) { if ( compatibility != null ) { compatibility += '' ; if ( compatibility === 'NO_IE' || compatibility === 'NO_NODE' ) { return compatibility ; } } return 'DEFAULT' ; } function getEncoder ( compatibility ) { compatibility = fixCompatibility ( compatibility ) ; return encoder ; var encoders = { } ; var JScrewIt = { encode : encode } ; self . JSFuck = self . JScrewIt = JScrewIt ; // END: JScrewIt /////////////////// // BEGIN: Debug only /////////////// function debugReplace ( input , compatibility ) var encoder = getEncoder ( compatibility ) ; var output = encoder . replace ( input ) ; return output ; } JScrewIt . debugReplace = debugReplace ; // END: Debug only /////////////////", "del_tokens": "var encoders = { } ; compatibility = compatibility === undefined ? 'DEFAULT' : compatibility + '' ; var output = encoder . encode ( input , wrapWithEval ) ; return output ; self . JSFuck = self . JScrewIt = encode : encode } ;", "commit_type": "add"}
{"commit_tokens": ["Add", "Grunt", "task", "to", "check", "types", "."], "add_tokens": "grunt . registerTask ( 'test' , [ 'jshint' , 'unit' , 'check-types' ] ) grunt . registerTask ( 'check-types' , 'Checks the types of Impromptu using Closure Compiler.' , function ( ) { var done = this . async ( ) var checkTypes = exec ( './node_modules/.bin/closure-npc' , function ( err , stdout , stderr ) { var results = stderr . trim ( ) . split ( '\\n' ) . pop ( ) var errorMatch = / (\\d+) error\\(s\\) / . exec ( results ) var succeeded = errorMatch && parseInt ( errorMatch [ 1 ] , 10 ) === 0 done ( succeeded ) } ) checkTypes . stdout . pipe ( process . stdout ) checkTypes . stderr . pipe ( process . stderr ) } )", "del_tokens": "grunt . registerTask ( 'test' , [ 'jshint' , 'unit' ] )", "commit_type": "add"}
{"commit_tokens": ["Implemented", "Terminal", ".", "prototype", ".", "fit"], "add_tokens": "term = new Terminal ( ) ; term . open ( terminalContainer ) ; term . fit ( ) ;", "del_tokens": "term = new Terminal ( { geometry : [ 95 , 37 ] } ) ; term . open ( terminalContainer ) ;", "commit_type": "implement"}
{"commit_tokens": ["Use", "Grunt", "src", "and", "dest", "convention"], "add_tokens": "src : 'test/src/*.svg' , dest : 'test/tmp' , options : { hashes : false } src : 'test/src/*.svg' , dest : 'test/tmp/fonts' , options : { destCss : 'test/tmp' , font : 'myfont' , types : 'woff,svg' , stylesheet : 'bootstrap' } all : [ 'Gruntfile.js' , 'tasks/*.js' , 'test/*.js' ] , grunt . loadNpmTasks ( 'grunt-contrib-jshint' ) ; grunt . loadNpmTasks ( 'grunt-contrib-nodeunit' ) ;", "del_tokens": "files : 'test/src/*.svg' , destCss : 'test/tmp' , destFonts : 'test/tmp' , hashes : false files : 'test/src/*.svg' , destCss : 'test/tmp' , destFonts : 'test/tmp/fonts' , font : 'myfont' , types : 'woff,svg' , stylesheet : 'bootstrap' all : [ 'Gruntfile.js' , 'tasks/*.js' , 'test/*.js' ] , grunt . loadNpmTasks ( 'grunt-contrib-jshint' ) ; grunt . loadNpmTasks ( 'grunt-contrib-nodeunit' ) ;", "commit_type": "use"}
{"commit_tokens": ["adding", "a", "note", "in", "the", "docs", "about", "how", "to", "build", "the", "parser", "and", "install", "the", "gem"], "add_tokens": "return ( new_num = 3 ) ;", "del_tokens": "return ( new_num = 3 ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "support", "for", "multiple", "sort", "-", "by", "criteria"], "add_tokens": "var Q = require ( 'q' ) , normalize = require ( '../utils/normalize' ) ; // Normalize criteria criteria = normalize . criteria ( { where : criteria } ) ; if ( ! criteria . where ) return this ; Object . keys ( criteria . where ) . forEach ( function ( key ) { where [ key ] = criteria . where [ key ] ; Deferred . prototype . sort = function ( criteria ) { // Normalize criteria criteria = normalize . criteria ( { sort : criteria } ) ; var sort = this . _criteria . sort || { } ; Object . keys ( criteria . sort ) . forEach ( function ( key ) { sort [ key ] = criteria . sort [ key ] ; } ) ;", "del_tokens": "var Q = require ( 'q' ) ; Object . keys ( criteria ) . forEach ( function ( key ) { where [ key ] = criteria [ key ] ; Deferred . prototype . sort = function ( sort ) {", "commit_type": "add"}
{"commit_tokens": ["use", "the", "requests", "json", "option"], "add_tokens": "form : settings , json : true } ; privates . get ( client ) . accessToken = body . access_token ;", "del_tokens": "form : settings } , jsonParsedBody ; jsonParsedBody = JSON . parse ( body ) ; privates . get ( client ) . accessToken = jsonParsedBody . access_token ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "possible", "conflict", "between", "multiple", "observers"], "add_tokens": "// Minimum delay before invoking the update of observers. const REFRESH_DELAY = 20 ; // Delay before the next iteration of the continuous cycle. const CONTINUOUS_DELAY = 80 ; typeof MutationObserver == 'function' && typeof navigator == 'object' && mutationsObserver_ = null ; this . continuousUpdateHandler_ = throttle ( this . refresh , CONTINUOUS_DELAY ) ; // Collect observers that have active entries. const active = this . observers_ . filter ( observer => { return observer . gatherActive ( ) , observer . hasActive ( ) ; } ) ; // Deliver notifications in a separate cycle in order to avoid any // collisions between observers. E.g. when multiple instances of // ResizeObserer are tracking the same element and the callback of one // of them changes content dimensions of the observed target. Sometimes // this may result in notifications being blocked for the rest of observers. active . forEach ( observer => observer . broadcastActive ( ) ) ; return active . length > 0 ;", "del_tokens": "typeof MutationObserver === 'function' && typeof navigator === 'object' && // Minimum delay before invoking the update of observers. const REFRESH_DELAY = 20 ; // Delay before iteration of the continuous cycle. const CONTINUOUS_HANDLER_DELAY = 80 ; mutationsObserver_ ; this . continuousUpdateHandler_ = throttle ( this . refresh , CONTINUOUS_HANDLER_DELAY ) ; let hasChanges = false ; for ( const observer of this . observers_ ) { // Collect active observations. observer . gatherActive ( ) ; // Broadcast active observations and set the flag that changes have // been detected. if ( observer . hasActive ( ) ) { hasChanges = true ; observer . broadcastActive ( ) ; } } return hasChanges ;", "commit_type": "fix"}
{"commit_tokens": ["removing", "accidentally", "checked", "-", "in", "test", "token", "(", "token", "is", "invalid", "so", "-", "dont", "bother", ")"], "add_tokens": "process . env . NODE_LOGGER_LOGGLY_TOKEN = CONF . test . auth_token ; process . env . NODE_LOGGER_LOGGLY_SUBDOMAIN = 'pmp' ;", "del_tokens": "process . env . NODE_LOGGER_LOGGLY_TOKEN = '30e9c505-d9c5-405c-869a-e891fce33583' ; process . env . NODE_LOGGER_LOGGLY_SUBDOMAIN = 'irakli' ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "map", "()", "to", "collection", "methods"], "add_tokens": "; [ 'forEach' , 'map' , 'reduce' , 'push' , 'sort' , 'indexOf' , 'concat' ] . forEach ( function ( method ) {", "del_tokens": "; [ 'forEach' , 'reduce' , 'push' , 'sort' , 'indexOf' , 'concat' ] . forEach ( function ( method ) {", "commit_type": "add"}
{"commit_tokens": ["added", "a", "working", "unit", "test"], "add_tokens": "var elm , scope , filter , ngDateFilter ; beforeEach ( inject ( function ( $rootScope , $compile , timeAgoFilter , dateFilter ) { filter = timeAgoFilter ; ngDateFilter = dateFilter ; it ( 'test filter' , function ( ) { var hourAgoIso8601 = ngDateFilter ( new Date ( Date . now ( ) - 3600 * 1000 ) , 'yyyy-MM-dd HH:mm' ) ; expect ( filter ( hourAgoIso8601 ) ) . to . equal ( 'about an hour ago' ) ; } ) ;", "del_tokens": "var elm , scope ; beforeEach ( inject ( function ( $rootScope , $compile ) {", "commit_type": "add"}
{"commit_tokens": ["Removed", "a", "couple", "global", "variables"], "add_tokens": "for ( var validator in validation ) { if ( validator !== 'msg' && validation . hasOwnProperty ( validator ) ) { fn : Backbone . Validation . validators [ validator ] , val : validation [ validator ] , msg : validation . msg validator , result ; for ( var changedAttr in attrs ) { for ( var validatedAttr in model . validation ) { if ( _ . isUndefined ( attrs [ validatedAttr ] ) && validateAttr ( model , validatedAttr , model . get ( validatedAttr ) ) ) {", "del_tokens": "for ( attr in validation ) { if ( attr !== 'msg' && validation . hasOwnProperty ( attr ) ) { fn : Backbone . Validation . validators [ attr ] , val : validation [ attr ] , msg : validation [ 'msg' ] validator , result ; for ( changedAttr in attrs ) { for ( attr in model . validation ) { if ( _ . isUndefined ( attrs [ attr ] ) && validateAttr ( model , attr , model . get ( attr ) ) ) {", "commit_type": "remove"}
{"commit_tokens": ["fixed", "keyboard", "nav", "in", "multiple", "slider"], "add_tokens": "// handle TAB key in slider with multiple handles if ( e . which === 9 && this . handleCount > 1 ) { if ( e . shiftKey && this . activeDragHandleIndex > 0 ) { this . activeDragHandleIndex -- ; } else if ( ! e . shiftKey && this . activeDragHandleIndex < this . handleCount - 1 ) { this . activeDragHandleIndex ++ ; } else { return ; }", "del_tokens": "// handle TAB key for slider with \"multiple\" attribute if ( e . which === 9 && this . handleCount > 1 && this . activeDragHandleIndex < this . handleCount - 1 ) { this . activeDragHandleIndex ++ ; // console.log(this.values);", "commit_type": "fix"}
{"commit_tokens": ["Remove", "knox", "dependency", "pass", "in", "knox", "client"], "add_tokens": "var uuid = require ( 'uuid' ) pipe . s3 = function pipes3 ( s3 , opts ) { opts . streamer = s3streamer ( s3 , opts ) function s3streamer ( s3 , opts ) { var headers = ( opts || { } ) . headers || { 'x-amz-acl' : 'public-read' }", "del_tokens": "var uuid = require ( 'uuid' ) , knox = require ( 'knox' ) pipe . s3 = function pipes3 ( s3opts , opts ) { opts . streamer = s3streamer ( s3opts ) function s3streamer ( opts ) { var s3 = knox . createClient ( opts ) , headers = opts . headers || { 'x-amz-acl' : 'public-read' }", "commit_type": "remove"}
{"commit_tokens": ["changed", "logic", "again", "because", "the", "old", "logic", "was", "buggy"], "add_tokens": "console . log ( \"http://localhost:\" + argv . port + \"/webpack-dev-server/\" ) ;", "del_tokens": "console . log ( \"http://localhost:\" + argv . port + \"/\" ) ;", "commit_type": "change"}
{"commit_tokens": ["Allow", "for", "compile", "to", "take", "an", "optional", "base", "path"], "add_tokens": "function compile ( codeOrPath , level , basePath , callback ) { if ( ! callback ) { callback = basePath basePath = null } _compile ( code . toString ( ) , level , basePath || path . dirname ( codeOrPath ) , callback ) _compile ( codeOrPath , level , basePath || process . cwd ( ) , callback )", "del_tokens": "function compile ( codeOrPath , level , callback ) { _compile ( code . toString ( ) , level , path . dirname ( codeOrPath ) , callback ) _compile ( codeOrPath , level , process . cwd ( ) , callback ) pathBase = pathBase || process . cwd ( )", "commit_type": "allow"}
{"commit_tokens": ["Add", "link", "target", "option", "."], "add_tokens": "// set uri // set default result target, if specified if ( options . target ) { result . target = options . target + '' ; } // return", "del_tokens": "// set uri and return", "commit_type": "add"}
{"commit_tokens": ["Added", "encoding", "for", "filenames", "."], "add_tokens": "formData . append ( fileProperty , model . file , $window . encodeURIComponent ( model . file . name ) ) ;", "del_tokens": "formData . append ( fileProperty , model . file ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "navigation", "for", "component", "pages"], "add_tokens": ". pipe ( gulp . dest ( './docs/_includes/usage/' ) ) ;", "del_tokens": "const gulpRename = require ( 'gulp-rename' ) ; . pipe ( gulpRename ( path => { path . basename = 'index' ; } ) ) . pipe ( gulp . dest ( './docs/components/' ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "info", "about", "corresponding", "view", "on", "RouteInfo"], "add_tokens": "const path = require ( 'path' ) * @ property { Object } target Instance containing the method ( property ) * @ param { String } name controller name path with prefix / function RouteInfo ( target , name , prop , ctrMethod ) { this . controllerPath = name this . view = parseView ( this ) // DON'T change the assignment order!!!! / ** * @ param { String } name controller name path with prefix / * @ property { String } prop Property name * / function parseView ( info ) { const parts = info . path . split ( '/' ) ; const actionPath = parts . reduce ( ( prev , curr ) => { if ( ! curr . startsWith ( ':' ) ) prev += '/' + curr return prev } , '' ) return path . join ( process . cwd ( ) , '/views' , info . controllerPath , actionPath )", "del_tokens": "* @ property { Object } target Instance containing the method ( property ) function RouteInfo ( target , prop , ctrMethod ) { this . view = parseView ( prop ) function parseView ( name ) {", "commit_type": "add"}
{"commit_tokens": ["Make", "cards", "have", "h2s", "not", "h1s"], "add_tokens": "< h2 > { text } < / h2 >", "del_tokens": "< h1 > { text } < / h1 >", "commit_type": "make"}
{"commit_tokens": ["Add", "optional", "param", "to", "constructor", "to", "delineate", "if", "called", "from", "CLI", "executable", "."], "add_tokens": "new ( require ( './mustache-wax' ) ) ( optimist . argv , true ) . renderOutput ( ) ;", "del_tokens": "new ( require ( './mustache-wax' ) ) ( optimist . argv ) . renderOutput ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "test", "for", "readPolicy", "value"], "add_tokens": "readPolicy : 'invalid' should ( err ) . be . an . instanceof ( RangeError ) . and . match ( { message : / \\boptions\\.readPolicy\\b / } ) ;", "del_tokens": "readPolicy : true should ( err ) . match ( { message : / \\boptions\\.readPolicy\\b / } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "container", "-", "less", "with", "binding", ".", "Also", "fixed", "inline", "with", "binding", "when", "value", "is", "empty", "string", "false", "or", "0", "."], "add_tokens": "foreach : new RegExp ( \"((?:ko|hz)[ ]+foreach):(.+)\" ) , \"with\" : new RegExp ( \"((?:ko|hz)[ ]+with):(.+)\" ) , } else if ( ( match = stmt . match ( syntaxRegex [ 'with' ] ) ) ) { stack . unshift ( { key : 'with' , start : node } ) ; if ( tempFrag . firstChild && val !== null && val !== undefined ) { } else if ( ( match = stmt . match ( syntaxRegex [ 'with' ] ) ) ) { val = saferEval ( match [ 2 ] , context , data , node ) ; block = this . findBlockFromStartNode ( blocks , node ) ; blockNodes = this . getImmediateNodes ( frag , block . start , block . end ) ; tempFrag = this . moveToNewFragment ( blockNodes ) ; toRemove . push ( node ) ; toRemove . push ( block . end ) ; if ( tempFrag . firstChild && val !== null && val !== undefined ) { var newContext = this . getNewContext ( context , val ) ; node . parentNode . insertBefore ( ( new Htmlizer ( tempFrag , this . cfg ) ) . toDocumentFragment ( val , newContext ) , node ) ; }", "del_tokens": "foreach : new RegExp ( \"((?:ko|hz)[ ]+foreach):(.+)\" ) if ( tempFrag . firstChild && val ) {", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "casing", "of", "the", "x", "-", "powered", "header"], "add_tokens": "res . setHeader ( \"x-powered-by\" , \"Crafity\" ) ;", "del_tokens": "res . setHeader ( \"X-Powered-By\" , \"Crafity\" ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "support", "for", "environment", "variables"], "add_tokens": "this . envs = { } ; / ** * Set environemnt variable . * * @ param { String } key * @ param { String } val * @ api public * / Command . prototype . env = function ( key , val ) { this . envs [ key ] = val ; } ; var options = { cwd : this . dir , timeout : this . ms , env : this . envs } ;", "del_tokens": "var options = { cwd : this . dir , timeout : this . ms } ;", "commit_type": "add"}
{"commit_tokens": ["fixing", "issues", "with", "colorstring", "api", "changes"], "add_tokens": "// we have an RGB array value pixelcolor = color ; } else { pixelcolor = ColorString . get . rgb ( color ) || null ; r = pixelcolor . value [ 0 ] ; g = pixelcolor . value [ 1 ] ; b = pixelcolor . value [ 2 ] ; hexcode = ColorString . to . hex ( pixelcolor . value ) ; color = ColorString . to . keyword ( pixelcolor . value ) ; rgb = pixelcolor . value ; this . pixel_color ( color . value ) ;", "del_tokens": "// we have RGB array value color = ColorString . to . hex ( color ) ; pixelcolor = ColorString . get . rgb ( color ) || null ; r = pixelcolor [ 0 ] ; g = pixelcolor [ 1 ] ; b = pixelcolor [ 2 ] ; hexcode = ColorString . to . hex ( pixelcolor ) ; color = ColorString . to . keyword ( pixelcolor ) ; rgb = pixelcolor ; this . pixel_color ( color ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "multiple", "component", "-", "tag", "addition"], "add_tokens": "var myTerminal = { header : [ \">brand\" , \"%symbolProgress\" , \"?info\" ] , / *,brandi:\" █████╗ ██╗ ██╗██████╗ ██████╗ ███████╗██╗ ██╗ ██████╗ \\n\" , info : \" .__ \\n\" + \" ._| \" brandi : chalk . green . bold , footer : [ \"&copyright\" ] , //audrey.feed(\"W05\", \"Does it have to be human?\", \"Feed me!\"); //audrey.feed(\"W05\", \"Does it have to be mine?\", \"Feed me!\");", "del_tokens": "var myTerminal = { header : [ \"brand\" , \"symbolProgress\" ] , / * \" █████╗ ██╗ ██╗██████╗ ██████╗ ███████╗██╗ ██╗ ██████╗ \\n\" //,info: / * \" .__ \\n\" + \" ._| \" * / footer : [ \"copyright\" ] , audrey . feed ( \"W05\" , \"Does it have to be human?\" , \"Feed me!\" ) ; audrey . feed ( \"W05\" , \"Does it have to be mine?\" , \"Feed me!\" ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "detaching", "of", "removed", "entities"], "add_tokens": "return entityManager . find ( entityClass , primaryKey ) . then ( ( entity ) => { entityManager . detach ( entity ) } )", "del_tokens": "let entity = entityManager . find ( entityClass , primaryKey ) entityManager . detach ( entity )", "commit_type": "fix"}
{"commit_tokens": ["Fix", "style", "test", "describe", "block", "title"], "add_tokens": "describe ( \"the style prop\" , ( ) => {", "del_tokens": "describe ( \"a hierarchy three levels deep\" , ( ) => {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "little", "error", "in", "a", "test", "description"], "add_tokens": "'A HSL color (H=0; S=0.25; L=0.25)' : {", "del_tokens": "'A HSL color (H=900; S=0.3; L=0.3)' : {", "commit_type": "fix"}
{"commit_tokens": ["Improving", "logginig", "of", "assert", ".", "fail", "calls", "."], "add_tokens": "if ( 'string' === typeof options ) options = { message : options } if ( 'operator' in options ) this . operator = options . operator", "del_tokens": "if ( 'string' === typeof options ) options = { message : options } this . operator = options . operator , operator : { value : undefined }", "commit_type": "improve"}
{"commit_tokens": ["allow", "footer", "to", "be", "defined"], "add_tokens": "* The paginator keeps track of a position index in a list this . footer = this . options . footer || '(Move up and down to reveal more choices)' ; this . position = 0 ; // Move the position when a down keypress is entered, and limit // position the middle of the visible list if ( this . position < middle && this . lastIndex < selected && selected - this . lastIndex < limit ) { this . position = Math . min ( middle , this . position + selected - this . lastIndex ) ; var topIndex = Math . max ( 0 , selected + lines . length - this . position ) ; visible += log . dim ( this . footer ) ;", "del_tokens": "* The paginator keeps track of a pointer index in a list this . pointer = 0 ; // Move the pointer when a down keypress is entered, and limit // pointer the middle of the visible list if ( this . pointer < middle && this . lastIndex < selected && selected - this . lastIndex < limit ) { this . pointer = Math . min ( middle , this . pointer + selected - this . lastIndex ) ; var topIndex = Math . max ( 0 , selected + lines . length - this . pointer ) ; visible += log . dim ( '(Move up and down to reveal more choices)' ) ;", "commit_type": "allow"}
{"commit_tokens": ["Updating", "docs", "to", "simpler", "json", "format"], "add_tokens": "} , { \"type\" : \"heading\" , \"data\" : { \"level\" : 2 , \"title\" : \"oj.CollectionView\" , \"slug\" : \"ojcollectionview\" } , \"depth\" : 2 \"title\" : \"oj.ModelKeyView\" , \"slug\" : \"ojmodelkeyview\" } , { \"type\" : \"heading\" , \"data\" : { \"level\" : 2 , \"title\" : \"oj.Table\" , \"slug\" : \"ojtable\" } , \"depth\" : 2", "del_tokens": "\"title\" : \"oj.FormView\" , \"slug\" : \"ojformview\"", "commit_type": "update"}
{"commit_tokens": ["fixes", "scope", "leaks", "in", "tests"], "add_tokens": "var immutable = Immutable ( array ) ; var mutable = immutable . toMutable ( ) ; var immutable = Immutable ( array ) ; var mutable = immutable . toMutable ( { deep : true } ) ;", "del_tokens": "immutable = Immutable ( array ) ; mutable = immutable . toMutable ( ) ; immutable = Immutable ( array ) ; mutable = immutable . toMutable ( { deep : true } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "problem", "with", "regexp", "parameters"], "add_tokens": "item [ field ] = new RegExp ( '^' + v + '.*' ) ; item [ field ] = new RegExp ( '.*' + v + '.*' ) ; item [ field ] = new RegExp ( '.*' + v + '$' ) ;", "del_tokens": "item [ field ] = { $regex : new RegExp ( '^' + v + '.*' ) } ; item [ field ] = { $regex : new RegExp ( '.*' + v + '.*' ) } ; item [ field ] = { $regex : new RegExp ( '.*' + v + '$' ) } ;", "commit_type": "fix"}
{"commit_tokens": ["add", "Zowi", "board", "to", "UNO", "productIds"], "add_tokens": "productId : [ '0x0043' , '0x7523' , '0x0001' , '0xea60' ] ,", "del_tokens": "productId : [ '0x0043' , '0x7523' , '0x0001' ] ,", "commit_type": "add"}
{"commit_tokens": ["Added", "all", "tests", "for", "Extending", "."], "add_tokens": "/*! this - v0.0.1 - 2013-02-12 */", "del_tokens": "/*! this - v0.0.1 - 2013-02-10 */", "commit_type": "add"}
{"commit_tokens": ["Added", "actions", "to", "get", "a", "single", "user", "by", "id", "or", "username"], "add_tokens": "case UserTypes . RECEIVED_ME : case UserTypes . RECEIVED_PROFILE : {", "del_tokens": "case UserTypes . RECEIVED_ME : {", "commit_type": "add"}
{"commit_tokens": ["Fix", "handle", "post", "WS", "event", "for", "DM", "/", "GM", "reply"], "add_tokens": "const { currentTeamId } = state . entities . teams ; const teamId = msg . data . team_id || currentTeamId ;", "del_tokens": "const teamId = msg . data . team_id ;", "commit_type": "fix"}
{"commit_tokens": ["moves", "mount", "code", "into", "constructor"], "add_tokens": "import React , { Component } from \"react\" ; class Viz extends Component { constructor ( props ) { super ( props ) ; const { type : Constructor } = props ; this . state = { viz : new Constructor ( ) } ; } / ** @ memberof Viz @ desc Initializes the specific visualization ' @ private * / componentDidMount ( ) { const { viz } = this . state ; viz . select ( this . container ) ; this . componentDidUpdate . bind ( this ) ( ) ; else { viz . config ( assign ( { } , d3plus || { } , config ) ) ; }", "del_tokens": "import React from \"react\" ; class Viz extends React . Component { componentDidMount ( ) { const { type } = this . props ; const Constructor = type ; const viz = new Constructor ( ) . select ( this . container ) ; this . setState ( { viz } ) ; else viz . config ( assign ( { } , d3plus || { } , config ) ) ;", "commit_type": "move"}
{"commit_tokens": ["Allow", "for", "multiple", "subreddits", "via", "the", "CLI"], "add_tokens": "const { fetchSubreddit } = require ( '../index' ) ; const argv = yargs . usage ( '$0 {subreddit} [{subreddit}]' ) const subreddits = argv . _ . map ( fetchSubreddit ) ; Promise . all ( subreddits ) . then ( flatten ) . then ( ( data ) => console . log ( pretty ( data ) ) ) function flatten ( data ) { return data . reduce ( ( prev , curr ) => { Object . keys ( curr ) . forEach ( ( key ) => prev [ key ] = curr [ key ] ) ; return prev ; } , { } ) ; }", "del_tokens": "const { fetchMetadata , fetchSubreddit } = require ( '../index' ) ; const argv = yargs . usage ( '$0 {subreddit}' ) const subreddit = argv . _ [ 0 ] ; fetchSubreddit ( subreddit ) . then ( ( { urls } ) => fetchMetadata ( urls ) ) . then ( ( urls ) => console . log ( pretty ( urls ) ) )", "commit_type": "allow"}
{"commit_tokens": ["Added", "heap", "size", "and", "heap", "used", "defaultMetrics"], "add_tokens": "var heapSizeAndUsed = require ( './metrics/heapSizeAndUsed' ) ; processRequests : processRequests , heapSizeAndUsed : heapSizeAndUsed", "del_tokens": "processRequests : processRequests", "commit_type": "add"}
{"commit_tokens": ["Add", "Configuration", "jsdoc", "update", "docs", ".", "md"], "add_tokens": "* @ property id * @ property name * @ property locationId * @ property businessUnitId * @ property deviceIdentifier * @ property serialNumber * @ property modelNumber * @ property tagNumber * @ property purchaseDate * @ property installationDate * @ property installedBy * @ property warrantyExpirationDate * @ property vendorNotes * @ property notes * @ property macAddress * @ property lastLoginName * @ property billFlag * @ property backupSuccesses * @ property backupIncomplete * @ property backupFailed * @ property backupRestores * @ property lastBackupDate * @ property backupServerName * @ property backupBillableSpaceGb * @ property backupProtectedDeviceList * @ property backupYear * @ property backupMonth * @ property ipAddress * @ property defaultGateway * @ property osType * @ property osInfo * @ property cpuSpeed * @ property ram * @ property localHardDrives * @ property parentConfigurationId * @ property vendor * @ property manufacturer * @ property activeFlag * @ property managementLink * @ property remoteLink * @ returns { promise | Configuration }", "del_tokens": "* @ property * @ returns { promise | }", "commit_type": "add"}
{"commit_tokens": ["added", "getAllEvents", "function", "with", "pagination"], "add_tokens": "// `eventStore.getEventRange(match, amount, callback)` // __getEvents:__ loads the events from _minRev_ to _maxRev_. // // `eventStore.getAllEvents(from, amount, callback)` // // - __from:__ from entry index [optional, default 0] // - __amount:__ amount of results (hint: -1 = to end) [optional] // - __callback:__ `function(err, events){}` getAllEvents : function ( from , amount , callback ) { if ( this . hasConfigurationErrors ( callback ) ) return ; if ( typeof amount === 'function' ) { callback = amount ; amount = - 1 ; } if ( typeof from === 'function' ) { callback = from ; from = 0 ; amount = - 1 ; } var self = this ; this . storage . getAllEvents ( from , amount , function ( err , events ) { events . next = function ( callback ) { from += amount ; self . getAllEvents ( from , amount , callback ) ; } ; if ( typeof callback === 'function' ) { callback ( err , events ) ; } } ) ; } ,", "del_tokens": "// `storage.getEventRange(match, amount, callback)`", "commit_type": "add"}
{"commit_tokens": ["Adding", "in", "critical", "log", "level"], "add_tokens": "'trace' , 'critical'", "del_tokens": "'trace'", "commit_type": "add"}
{"commit_tokens": ["Fixed", "a", "stupid", "bug", "creating", "globals"], "add_tokens": "re_videos = / http =\\/\\/(www\\.)?(vimeo|youtube|yahoo|flickr)\\.com / i , re_skipFootnoteLink = / ^\\s*(\\[?[a-z0-9]{1,2}\\]?|^|edit|citation needed)\\s*$ / i , re_nextLink = / (next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/ i , re_prevLink = / (prev|earl|old|new|<|«)/ i , re_extraneous = / print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single / i , re_positive = / article|body|content|entry|hentry|main|page|pagination|post|text|blog|story / , re_negative = / combx|comment|com-|contact|foot|footer|footnote|masthead|media|meta|outbrain|promo|related|scroll|shoutbox|sidebar|sponsor|shopping|tags|tool|widget / , re_unlikelyCandidates = / combx|comment|community|disqus|extra|foot|header|menu|remark|rss|shoutbox|sidebar|sponsor|ad-break|agegate|pagination|pager|popup|tweet|twitter|entry-unrelated / , re_okMaybeItsACandidate = / and|article|body|column|main|shadow / , re_badStart = / \\.( |$) / , re_pageInURL = / ((_|-)?p[a-z]*|(_|-))[0-9]{1,2}$ / i , re_noLetters = / [^a-z] / i , re_justDigits = / ^\\d{1,2}$ / , re_headers = / h[1-3] / , re_commas = / ,[\\s\\,]{0,} / g ,", "del_tokens": "re_videos = / http =\\/\\/(www\\.)?(vimeo|youtube|yahoo|flickr)\\.com / i ; re_skipFootnoteLink = / ^\\s*(\\[?[a-z0-9]{1;2}\\]?|^|edit|citation needed)\\s*$ / i ; re_nextLink = / (next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/ i ; re_prevLink = / (prev|earl|old|new|<|«)/ i ; re_extraneous = / print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single / i ; re_positive = / article|body|content|entry|hentry|main|page|pagination|post|text|blog|story / ; re_negative = / combx|comment|com-|contact|foot|footer|footnote|masthead|media|meta|outbrain|promo|related|scroll|shoutbox|sidebar|sponsor|shopping|tags|tool|widget / ; re_unlikelyCandidates = / combx|comment|community|disqus|extra|foot|header|menu|remark|rss|shoutbox|sidebar|sponsor|ad-break|agegate|pagination|pager|popup|tweet|twitter|entry-unrelated / ; re_okMaybeItsACandidate = / and|article|body|column|main|shadow / ; re_badStart = / \\.( |$) / ; re_pageInURL = / ((_|-)?p[a-z]*|(_|-))[0-9]{1;2}$ / i ; re_noLetters = / [^a-z] / i ; re_justDigits = / ^\\d{1;2}$ / ; re_headers = / h[1-3] / ; re_commas = / ;[\\s\\;]{0;} / g ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "silly", "mistake", "in", "the", "polyfill", "for", "Object", ".", "assign", "."], "add_tokens": "var key = keys [ k ] ; obj [ key ] = arg [ key ] ;", "del_tokens": "obj [ k ] = arg [ k ] ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "html5mode", "config", "for", "docs"], "add_tokens": "html5Mode : false ,", "del_tokens": "html5mode : false ,", "commit_type": "fix"}
{"commit_tokens": ["add", "support", "of", "path", "in", "fed", "server", "to", "docs"], "add_tokens": "* - path - specifies the path within the server to accept federation connections on this . fedServer . listen ( ) ;", "del_tokens": "* - port - the port that the server should listen on . ignored if server is not provided . this . fedServer . listen ( this . options . federate . port ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "mixed", "tabs&spaces", "in", "same", "file", "."], "add_tokens": "reporters . push ( 'coverage' ) ; preprocessors = { '**/src/*.js' : 'coverage' } ; coverageReporter = { type : 'html' , dir : 'coverage/' } ;", "del_tokens": "reporters . push ( 'coverage' ) ; preprocessors = { '**/src/*.js' : 'coverage' } ; coverageReporter = { type : 'html' , dir : 'coverage/' } ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "more", "error", "-", "handling", "to", "adapter", "creation", "and", "remove", "test", "data", "file"], "add_tokens": "// Don't double-dip on adapters if ( this . _adapters [ name ] ) { throw new Error ( '\"' + name + '\" is already a Supercollider adapter.' ) ; } // Don't use one of the built-in meta terms var reserved = [ 'title' , 'description' , 'fileName' ] ; for ( var i in reserved ) { if ( name === reserved [ i ] ) { throw new Error ( '\"' + name + '\" is a reserved keyword, and can\\'t be used as the name of a Supercollider adapter.' ) ; } } // Try to import one of the built-in adapters", "del_tokens": "console . log ( e ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "line", ".", "div", "/", "line", ".", "selDiv", "hack", "slightly", "less", "error", "-", "prone"], "add_tokens": "function lineElt ( line ) { return line . selDiv || line . div ; } removeElement ( lineElt ( removed [ i ] ) ) ; var linediv = lineElt ( this . lines [ sel . from . line ] ) ; var ypos = lineElt ( this . lines [ sel . from . line ] ) . offsetTop , line = this . lineHeight ( ) , return lineElt ( firstline ) . offsetHeight ; var off = eltOffset ( lineElt ( this . lines [ 0 ] ) ) ,", "del_tokens": "removeElement ( removed [ i ] . selDiv || removed [ i ] . div ) ; var linediv = this . lines [ sel . from . line ] . div ; var ypos = this . lines [ sel . from . line ] . div . offsetTop , line = this . lineHeight ( ) , return ( firstline . selDiv || firstline . div ) . offsetHeight ; var off = eltOffset ( this . lines [ 0 ] . div ) ,", "commit_type": "make"}
{"commit_tokens": ["improve", "services", "/", "components", "finding", "templates"], "add_tokens": "/ ** * Load a component ' * * Should only occur once per name ! * * NOTE : This includes local components as well as npm components * * @ param { string } name * @ returns { object | false } * / function getComponentPackage ( name ) { var componentPath = exports . getComponentPath ( name ) ; return componentPath && tryRequireEach ( [ componentPath + '/package.json' ] ) ; } exports . getComponentPath = _ . memoize ( getComponentPath ) ; exports . getComponentModule = _ . memoize ( getComponentModule ) ; exports . getComponentPackage = _ . memoize ( getComponentPackage ) ;", "del_tokens": "exports . getComponentPath = _ . memoize ( getComponentPath ) ; // memoize by _first_ parameter only (default) exports . getComponentModule = _ . memoize ( getComponentModule ) ; // memoize by _first_ parameter only (default)", "commit_type": "improve"}
{"commit_tokens": ["fixed", "double", "zipped", "lang", "model", "error"], "add_tokens": "while ( value [ 0 ] == 0x1f && value [ 1 ] == 0x8b ) { value = pako . ungzip ( value ) } // console.log(best)", "del_tokens": "value = pako . inflate ( value )", "commit_type": "fix"}
{"commit_tokens": ["Use", "patch", "to", "drop", "the", "pre", "-", "release"], "add_tokens": "if ( this . prerelease . length === 0 ) this . patch ++ ;", "del_tokens": "this . patch ++ ;", "commit_type": "use"}
{"commit_tokens": ["Make", "GME", "Examples", "and", "Sample", "GeoData", "work", "."], "add_tokens": "var layerViewModel = komapping . fromJS ( data , categoryMapping ) ; // TODO: handle hierarchy better if ( defined ( layers [ i ] . Layer ) ) { var subLayers = layers [ i ] . Layer ( ) ; for ( var j = 0 ; j < subLayers . length ; ++ j ) { layer . push ( subLayers [ j ] ) ; } } else { layer . push ( layers [ i ] ) ; }", "del_tokens": "var layerViewModel = komapping . fromJS ( data ) ; layer . push ( layers [ i ] ) ;", "commit_type": "make"}
{"commit_tokens": ["removed", "console", ".", "logs", "+++", "ensure", "that", "object", "[", "parentkey", "]", "is", "an", "object"], "add_tokens": "if ( typeof object === 'string' ) { return object . replace ( ' !important' , '' ) } object [ parentkey ] = object [ parentkey ] || { }", "del_tokens": "if ( typeof object === 'string' ) return object . replace ( ' !important' , '' ) ; console . log ( 'old key' , key ) ; console . log ( 'new key' , key ) ;", "commit_type": "remove"}
{"commit_tokens": ["Remove", "rootUrl", "and", "switch", "to", "relative", "paths", "for", "schema", "id"], "add_tokens": "let SchemaSet = require ( '../' ) ; const schemaset = new SchemaSet ( { await schemaset . validator ( libUrls . testRootUrl ( ) ) ; const schemaset = new SchemaSet ( { await schemaset . validator ( libUrls . testRootUrl ( ) ) ;", "del_tokens": "let validator = require ( '../' ) ; await validator ( { rootUrl : libUrls . testRootUrl ( ) , await validator ( { rootUrl : libUrls . testRootUrl ( ) ,", "commit_type": "remove"}
{"commit_tokens": ["add", "error", "check", "for", "rule", "-", "max_value", "test"], "add_tokens": "verr : { rule : 'max_value' , params : 3 , index : null } verr : { rule : 'max_value' , params : 3 , index : null } verr : { rule : 'max_value' , params : 3 , index : null } verr : { rule : 'max_value' , params : 3 , index : null } verr : { rule : 'max_value' , params : 333 , index : null } verr : { rule : 'max_value' , params : 333 , index : null } verr : { rule : 'max_value' , params : 333 , index : null }", "del_tokens": "expect : false expect : false expect : false expect : false expect : false expect : false expect : false", "commit_type": "add"}
{"commit_tokens": ["Allow", "to", "tbForm", "retrieve", "a", "Model", "in", "NewMode", "(", "useful", "to", "retrieve", "default", "model", "from", "REST", "Service", ")"], "add_tokens": "* @ param { string } optionLabel Set the property to get the labels . * @ param { string } optionKey Set the property to get the keys . * @ param { string } defaultValue Set the default value . scope : angular . extend ( { options : '=?' , optionsUrl : '@' , optionsMethod : '@?' , optionLabel : '@?' , optionKey : '@?' , defaultValue : '@?' } , tubularEditorService . defaultScope ) , $scope . value = value || $scope . defaultValue || possibleValue ; * @ param { string } css Set the CSS classes for the input .", "del_tokens": "* @ param { string } optionLabel Set the property to get the labels * @ param { string } optionKey Set the property to get the keys scope : angular . extend ( { options : '=?' , optionsUrl : '@' , optionsMethod : '@?' , optionLabel : '@?' , optionKey : '@?' } , tubularEditorService . defaultScope ) , $scope . value = value || possibleValue ; * @ param { string } css Set the CSS classes for the input", "commit_type": "allow"}
{"commit_tokens": ["Fixed", "not", "found", "status", "fixed", "error", "handler", "and", "bumped", "version"], "add_tokens": "statusCode : 404 ,", "del_tokens": "statusCode : 406 ,", "commit_type": "fix"}
{"commit_tokens": ["fix", "zero", "-", "nums", "and", "empty", "-", "string", "values"], "add_tokens": "var maskedObj = { } , key , value , ret , retKey if ( ( null !== ret ) && ( 'undefined' !== typeof ret ) ) { maskedObj [ key ] = ret }", "del_tokens": "var maskedObj = { } , key , value , ret , retKey if ( ret ) maskedObj [ key ] = ret", "commit_type": "fix"}
{"commit_tokens": ["Added", "ability", "to", "recognise", "arguments", "within", "commands"], "add_tokens": "* noCallback is executed with the original args input string . You can also use '$' for wildcard positions . These * positions will be returned as arguments for the yesCallback before the remainder arguments . * Some examples : var additionalArgs = [ ] ; if ( next . trim ( ) === '$' && argsplit [ 0 ] . trim ( ) . length > 0 ) { additionalArgs . push ( argsplit [ 0 ] . trim ( ) ) ; args = argsplit [ 1 ] ; } else if ( argsplit [ 0 ] . trim ( ) === next . trim ( ) ) { additionalArgs . push ( args ) ; yesCallback . apply ( this , additionalArgs ) ;", "del_tokens": "* noCallback is executed with the original args input string . Some examples : if ( argsplit [ 0 ] . trim ( ) === next . trim ( ) ) { yesCallback . call ( this , args ) ;", "commit_type": "add"}
{"commit_tokens": ["improved", "compatibility", "with", "exported", "classes"], "add_tokens": "[ 'doc:clear' , 'doc:preprocess' , 'doc:generate' , 'doc:clean' ] , gulp . task ( 'doc:preprocess' , [ 'doc:clear' ] , ( ) => gulp . task ( 'doc:clear' , ( ) => del ( [ './doc-src' , './doc' ] ) ) ; } , { pattern : / export default / g , replace : ''", "del_tokens": "[ 'doc:preprocess' , 'doc:generate' , 'doc:clean' ] , gulp . task ( 'doc:preprocess' , ( ) =>", "commit_type": "improve"}
{"commit_tokens": ["Fix", "bad", "event", "name", "."], "add_tokens": "eventPrefix = prefix + metric + '.' ;", "del_tokens": "eventPrefix = prefix + metric ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "options", ".", "paginate", "to", "disable", "pagination"], "add_tokens": "this . footer = this . options . footer ; if ( typeof this . footer !== 'string' ) { this . footer = '(Move up and down to reveal more choices)' ; } if ( lines . length <= limit || opts . paginate === false ) { if ( opts . filterList !== false ) { infinite = infinite . filter ( Boolean ) ; } var visible = infinite . splice ( topIndex , limit ) . join ( '\\n' ) ;", "del_tokens": "this . footer = this . options . footer || '(Move up and down to reveal more choices)' ; if ( lines . length <= limit ) { if ( opts . filterList === true ) { lines = lines . filter ( Boolean ) ; } var visible = infinite . splice ( topIndex , limit ) ; visible = visible . join ( '\\n' ) ;", "commit_type": "allow"}
{"commit_tokens": ["Fixing", "the", "imports", "stored", "for", "cache", "invalidation", "to", "have", "the", "path", "and", "mtime", "again", "."], "add_tokens": "// Determine the imports used and check modified times. var imports = [ ] ; output . imports . forEach ( function ( imported ) { var currentImport = { path : imported , mtime : null } ; imports . push ( currentImport ) ; // Update the mtime of the import async. fs . stat ( imported , function ( err , lessStats ) { if ( err ) { return error ( err ) ; } currentImport . mtime = lessStats . mtime ; } ) ; } ) ; imports : imports", "del_tokens": "imports : output . imports", "commit_type": "fix"}
{"commit_tokens": ["Fix", "promise", "resolve", "/", "reject", "logic"], "add_tokens": "* @ param { Function = } callback if ( value ( model ) . notTypeOf ( Object ) ) { if ( ! this . validators ) { runValidation ( self . validators [ key ] , model [ key ] , model , function ( failedFields ) { if ( failedFields . length > 0 ) { result . failedFields [ key ] = failedFields ; //was final call if ( result . result === false ) { return ; if ( ! callback || typeof callback !== \"function\" ) { promise . then ( callback , callback ) ;", "del_tokens": "* @ param { Function } callback if ( value ( model ) . notTypeOf ( Object ) ) { if ( ! this . validators ) { runValidation ( self . validators [ key ] , model [ key ] , model , function ( res ) { if ( res . length > 0 ) { result . failedFields [ key ] = res ; if ( result === false ) { if ( typeof callback === \"function\" ) { promise . then ( function ( res ) { callback ( res ) ; } ) . catch ( function ( err ) { callback ( err ) ; } ) ; } else {", "commit_type": "fix"}
{"commit_tokens": ["Make", "Reduce", "more", "flexable", "(", "3", "or", "2", "args", "are", "acceptable", ")"], "add_tokens": "var reduce = curry ( function ( f , init , ... second ) { console . log ( arguments ) ; var list ; if ( arguments . length < 3 ) { if ( Array . isArray ( init ) ) { // Simple reduce return init . reduce ( f ) ; } else { // Pass this round, currying it (manual currying) return function ( list ) { return reduce ( f , init , list ) } } } else { list = second [ 0 ] ; } ; return list . reduce ( f , init ) } ) ; var foldl = curry ( function ( f , init , list ) { return reduce ( f , init , list ) } ) ;", "del_tokens": "var reduce = curry ( function ( f , init , list ) { return list . reduce ( f , init ) } ) ; var foldl = reduce ;", "commit_type": "make"}
{"commit_tokens": ["Remove", "unnecessary", "copy", "of", ".", "proxy", "()"], "add_tokens": ": EventEmitter . prototype . proxy . call ( this , event_id )", "del_tokens": "DOMEventEmitter . prototype . _proxy = EventEmitter . prototype . proxy : this . _proxy ( event_id )", "commit_type": "remove"}
{"commit_tokens": ["fixed", "a", "test", "that", "was", "throwing", "an", "unhanded", "error"], "add_tokens": "var returnVal = server . start ( sinon . spy ( ) ) ;", "del_tokens": "var returnVal = server . start ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "publish", "filter", "out", "missing", "scripts", "add", "website", "(", "boilerplate", "html5", "+", "bootstrap", ")"], "add_tokens": "result . region = config . options . region ; console . log ( 'ok, done - amiId = ' + amiId + ' in region ' + result . region ) ; if ( path . existsSync ( path . resolve ( currentFileResolved , 'user-data.sh' ) ) ) { results . push ( result ) ; walkPathSync ( root , result , results ) ; }", "del_tokens": "console . log ( 'ok, done - amiId = ' + amiId ) ; results . push ( result ) ; walkPathSync ( root , result , results ) ;", "commit_type": "add"}
{"commit_tokens": ["Making", "polymer", "controls", "better", "."], "add_tokens": "let control = module . ID + '.html' ; let script ; script = 'beyond.polymer.register({\"' + config . polymer . id + '\": \"' + control + '\"});' ;", "del_tokens": "let script ; let id = config . polymer . id ; let path = '' ; if ( id && typeof id === 'string' ) { script = 'beyond.polymer.register({\"' + id + '\": \"' + path + '\"});' ; }", "commit_type": "make"}
{"commit_tokens": ["add", "a", "test", "when", "global", "locale", "is", "not", "equal", "object", "locale"], "add_tokens": "function normalizeUnits ( units , momentObj ) { if ( isJalali ( momentObj ) ) { units = normalizeUnits ( units , this ) ; units = normalizeUnits ( units , this ) ; units = normalizeUnits ( units , this ) ; units = normalizeUnits ( units , this ) ; units = normalizeUnits ( units , this ) ; units = normalizeUnits ( units , this ) ; units = normalizeUnits ( units , this ) ;", "del_tokens": "function normalizeUnits ( units ) { if ( isJalali ( this ) ) { units = normalizeUnits ( units ) ; units = normalizeUnits ( units ) ; units = normalizeUnits ( units ) ; units = normalizeUnits ( units ) ; units = normalizeUnits ( units ) ; units = normalizeUnits ( units ) ; units = normalizeUnits ( units ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "@fileoverview", "to", "decorategeolocation", ".", "js"], "add_tokens": "/ ** * @ fileoverview Provides a function that adds a \"tracking\" property ( using * ` ` ) to the ` ` instance , making it * possible to activate / deactivate the tracking mode . * * Example : * < input type = \"checkbox\" ngModel = \"geolocation.tracking\" / > * /", "del_tokens": "* This service provides a function that adds a \"tracking\" property ( using * ` ` ) to the ` ` instance , making it * possible to activate / deactivate the tracking mode . * * Example : * < input type = \"checkbox\" ngModel = \"geolocation.tracking\" / > *", "commit_type": "add"}
{"commit_tokens": ["improve", "connection", "status", "bar", "example", "screen"], "add_tokens": "import { View , Text , StyleSheet } from 'react-native' ; import { ConnectionStatusBar , Typography , Colors } from 'react-native-ui-lib' ; //eslint-disable-line < View style = { styles . container } > < Text style = { { textAlign : 'center' , marginBottom : 10 , ... Typography . text60 , color : Colors . dark40 } } > Turn your wifi on / off to see the component in action < / Text > < Text style = { { ... Typography . text40 } } > } const styles = StyleSheet . create ( { container : { flex : 1 , alignItems : 'center' , justifyContent : 'center' , paddingHorizontal : 25 , } , } ) ;", "del_tokens": "import { View , Text } from 'react-native' ; import { ConnectionStatusBar } from 'react-native-ui-lib' ; //eslint-disable-line < View style = { { flex : 1 , alignItems : 'center' , justifyContent : 'center' } } > < Text > }", "commit_type": "improve"}
{"commit_tokens": ["use", "_", ".", "d", ".", "set", "rather", "than", "[]"], "add_tokens": "const ops = d . inputs . map ( ( input , index ) => inner_done => { const counter = { } if ( d . index ) { counter [ d . index ] = index } Q ( Object . assign ( { } , next_self , input , counter ) ) const _ = { d : require ( \"./d\" ) . d , } _ . d . set ( sd , d . to , d . value ) ; // self[d.to] = d.value; _ . d . delete ( sd , d . to ) // delete sd[d.to]; _ . d . set ( self , d . to , d . value ) ; // self[d.to] = d.value; _ . d . delete ( self , d . to ) // delete self[d.to];", "del_tokens": "const ops = d . inputs . map ( input => inner_done => { Q ( Object . assign ( { } , next_self , input ) ) sd [ d . to ] = d . value ; delete sd [ d . to ] ; self [ d . to ] = d . value ; delete self [ d . to ] ;", "commit_type": "use"}
{"commit_tokens": ["Fix", "ci", ".", "js", "flakiness"], "add_tokens": "\"elm-community/elm-test\" : \"3.0.0 <= v < 4.0.0\" , \"elm-lang/core\" : \"5.0.0 <= v < 6.0.0\"", "del_tokens": "\"elm-lang/core\" : \"5.0.0 <= v < 6.0.0\" , \"elm-community/elm-test\" : \"3.0.0 <= v < 4.0.0\"", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "file", "and", "require", "directives", "."], "add_tokens": "'use strict' ; var errors = require ( '../errors' ) , ContentLoader = require ( './content-loader' ) ; function HttpContentLoader ( strategy ) { ContentLoader . call ( this , strategy || 'http' ) ; } HttpContentLoader . prototype = Object . create ( ContentLoader . prototype ) ; HttpContentLoader . prototype . constructor = HttpContentLoader ; * Load the content at the given path . * @ param path { String } path * @ param callback { Function } HttpContentLoader . prototype . load = function ( path , callback ) { throw new errors . NotImplementedError ( 'directive-http' ) ; } ; module . exports = HttpContentLoader ;", "del_tokens": "* Created by rclayton on 4 / 24 / 16.", "commit_type": "implement"}
{"commit_tokens": ["Fix", "lodash", ".", "assign", "dependency"], "add_tokens": "assign = require ( 'lodash.assign' ) ;", "del_tokens": "assign = require ( 'lodash/assign' ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "new", "mock", "method", "execute"], "add_tokens": ". given . apiLoaded ( grecaptchaMock = jasmine . createSpyObj ( 'grecaptcha' , [ 'render' , 'getResponse' , 'reset' , 'execute' ] ) )", "del_tokens": ". given . apiLoaded ( grecaptchaMock = jasmine . createSpyObj ( 'grecaptcha' , [ 'render' , 'getResponse' , 'reset' ] ) )", "commit_type": "add"}
{"commit_tokens": ["Changed", "timeout", "to", "25", "seconds"], "add_tokens": "request ( { uri : getNodeURI , json : true , timeout : 25000 } , ( err , response , body ) => {", "del_tokens": "request ( { uri : getNodeURI , json : true , timeout : 5000 } , ( err , response , body ) => {", "commit_type": "change"}
{"commit_tokens": ["added", "appcache", "an", "update", "package", "info"], "add_tokens": "'index.hbs' : 'index.hbs' , 'manifest.appcache' : 'manifest.appcache' var pkgPath = path . join ( __dirname , '..' , 'templates' , 'package.json' ) ;", "del_tokens": "'index.hbs' : 'index.hbs' var pkgPath = path . join ( __dirname , '..' , 'templates' , 'package.template' ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "PageAction", "RecordAction", "options", "to", "JS", "also", "added", "REcord", "Count", "web", "resource", "example", "using", "PageAction"], "add_tokens": "if ( ( QueryOptions != null ) && ( QueryOptions . RecordAction != null ) ) { response . List . forEach ( function ( record ) { QueryOptions . RecordAction ( record ) ; } ) ; response . List = [ ] ; } if ( ( QueryOptions != null ) && ( QueryOptions . PageAction != null ) ) { QueryOptions . PageAction ( response . List ) ; response . List = [ ] ; } nextLink = data [ '@odata.nextLink' ] ; if ( ( QueryOptions != null ) && ( QueryOptions . RecordAction != null ) ) { response . List . forEach ( function ( record ) { QueryOptions . RecordAction ( record ) ; } ) ; response . List = [ ] ; } if ( ( QueryOptions != null ) && ( QueryOptions . PageAction != null ) ) { QueryOptions . PageAction ( response . List ) ; response . List = [ ] ; }", "del_tokens": "nextLink = data [ '@odata.nextLink' ] ;", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "more", "watcher", "tests"], "add_tokens": "describe ( 'Consul' , function ( ) { it ( 'should work' , function ( ) { var msg = 'test message' ; var err = errors . Consul ( msg ) ; err . should . have . property ( 'isConsul' , true ) ; err . should . have . property ( 'message' , msg ) ; var test = new Error ( msg ) ; test . isTest = true ; err = errors . Consul ( test ) ; err . should . have . property ( 'message' , msg ) ; err . should . have . property ( 'isConsul' , true ) ; err . should . have . property ( 'isTest' , true ) ; err = errors . Consul ( null ) ; err . should . not . have . property ( 'message' , undefined ) ; err . should . have . property ( 'isConsul' , true ) ; err = errors . Consul ( '' ) ; err . should . not . have . property ( 'message' , undefined ) ; err . should . have . property ( 'isConsul' , true ) ; } ) ; } ) ; it ( 'should work' , function ( ) {", "del_tokens": "it ( 'should workd' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["added", "support", "for", ".", "*", "[", "...", "]", "syntax"], "add_tokens": "if ( symbolPath . node . computed ) { parentPath . replaceWith ( parentPath . node . object ) ; const prop = symbolPath . node . property ;", "del_tokens": "assert ( symbolParent . computed === false ) ; const prop = symbolPath . node . property ; if ( prop . type !== 'Identifier' ) { TODO ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "copy", "task", "to", "automatic", "build"], "add_tokens": "} , reporterOutput : \"\" copy : { main : { expand : true , cwd : 'dist/' , src : 'sticky-sidebar.pkgd.js' , dest : 'docs/js' } , } , tasks : [ 'concat' , 'jshint' , 'uglify' , 'copy' ] grunt . loadNpmTasks ( 'grunt-contrib-copy' ) ;", "del_tokens": "} tasks : [ 'jshint' , 'uglify' ]", "commit_type": "add"}
{"commit_tokens": ["removed", "option", "to", "access", "vraiable", "by", "regex"], "add_tokens": "grpIdx = _ . indexOf ( s , '*' ) , codes = this . codes ( grpIdx ) , datacol = this . datacol ( s ) ;", "del_tokens": "grpIdx = _ . indexOf ( s , '*' ) , codes = this . codes ( grpIdx ) , datacol = this . datacol ( s ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixing", "the", "PR", "review", "comments"], "add_tokens": "module . exports = function ( tag ) { if ( ! tag || typeof tag !== 'string' || tag . length < 3 ) { throw new Error ( \"All logging must have a tag that is at least 3 characters long!\" ) ; } var logger = new ( winston . Logger ) ( { transports : [ new ( winston . transports . Console ) ( { timestamp : function ( ) { return Date . now ( ) ; } , formatter : function ( options ) { return options . timestamp ( ) + ' ' + options . level . toUpperCase ( ) + ' ' + options . meta . tag + ' =>' + ( undefined !== options . message ? options . message : '' ) ; } } ) ] } ) ; logger . addRewriter ( function ( level , msg , meta ) { if ( ! meta . tag ) { meta . tag = tag ; } return meta ; } ) ; return logger ;", "del_tokens": "module . exports = function ( ) { return winston ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", ":", "jws", ".", "decode", "is", "not", "a", "function", "error", "while", "performing", "sendAttestationRequest"], "add_tokens": "const jwtDecode = require ( 'jwt-decode' ) ; const decodedResult = jwtDecode ( result ) ; const decodedResponse = response ;", "del_tokens": "const jws = require ( 'jwt-decode' ) ; const decodedResult = jws . decode ( result ) ; const decodedResponse = JSON . parse ( response . payload ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "bug", "with", "persist", "property"], "add_tokens": "if ( typeof this . _settings . persist === 'undefined' ) { this . _settings . persist = true ; }", "del_tokens": "this . _settings . persist = this . _settings . persist || true ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "containerless", "with", "binding", "."], "add_tokens": "/ *", "del_tokens": "/ *", "commit_type": "add"}
{"commit_tokens": ["add", "es6", "module", "build", "for", "rollup", "and", "webpack"], "add_tokens": "format : [ \"umd\" , \"umd-min\" , \"es\" ] ,", "del_tokens": "format : [ \"umd\" , \"umd-min\" ] ,", "commit_type": "add"}
{"commit_tokens": ["Remove", "useless", "callback", "in", "_processServerResponse"], "add_tokens": "sinon . stub ( client , '_processServerResponse' , ( response ) => { sinon . stub ( client , '_processServerResponse' , ( response ) => { } ) ; } ) ; } ) ; } ) ;", "del_tokens": "sinon . stub ( client , '_processServerResponse' , ( response , callback ) => { return callback ( ) ; sinon . stub ( client , '_processServerResponse' , ( response , callback ) => { return callback ( ) ; } , ( ) => { } ) ; } , ( ) => { } ) ; } , ( ) => { } ) ; } , ( ) => { } ) ;", "commit_type": "remove"}
{"commit_tokens": ["use", "FileSaver", ".", "js", "for", "local", "downloads"], "add_tokens": "var graphTitle = 'diagram' function doDownload ( e ) { saveAs ( new Blob ( [ svg ] , { type : 'image/svg+xml' } ) , graphTitle + '.svg' ) e . preventDefault ( ) function doDownload ( e ) { var src = currentText ( ) saveAs ( new Blob ( [ src ] , { type : 'text/txt' } ) , graphTitle + '.nomnoml' ) e . preventDefault ( ) graphTitle = model . config . title", "del_tokens": "function doDownload ( ) { link . href = 'data:image/svg+xml,' + svg ; function doDownload ( ) { var src = btoa ( currentText ( ) ) link . href = 'data:text/txt;base64,' + src ;", "commit_type": "use"}
{"commit_tokens": ["Added", "DELETE", "and", "USING", "support"], "add_tokens": "sql . delete = function del ( tbl ) { var stmt = new Statement ( 'delete' ) ; if ( tbl ) stmt . tbls = [ expandAlias ( tbl ) ] ; return stmt ; } ; // DELETE proto . using = function using ( ) { return this . add ( argsToArray ( arguments ) . map ( expandAlias ) , '_using' ) ; } ; case ' delete ' sql = this . deleteToString ( opts ) ; break ; proto . deleteToString = function deleteToString ( opts ) { var sql = 'DELETE FROM ' + this . tbls [ 0 ] + ' ' ; if ( this . _using ) sql += 'USING ' + this . _using . join ( ', ' ) + ' ' ; if ( this . _where ) sql += this . whereToString ( opts ) ; return sql ; } ; if ( typeof args [ 0 ] != 'object' && ( typeof args [ 1 ] != 'object' || args [ 1 ] instanceof sql ) ) {", "del_tokens": "if ( typeof args [ 0 ] != 'object' && typeof args [ 1 ] != 'object' ) {", "commit_type": "add"}
{"commit_tokens": ["Use", "git", "submodule", "instead", "of", "npm", "package"], "add_tokens": ", Pouch = require ( './pouchdb' )", "del_tokens": ", Pouch = require ( 'pouchdb' )", "commit_type": "use"}
{"commit_tokens": ["use", "less", "memory", "in", "paging"], "add_tokens": "// console.log(\"HERE:A.start\") // console.log(\"HERE:A.run\", pager) // console.log(\"HERE:B\", sd.cursor) sd [ d . outputs ] . forEach ( o => accumulator . push ( o ) ) // console.log(\"HERE:D\", sd.cursor)", "del_tokens": "// console.log(\"A.start\") // console.log(\"A.run\", pager) // console.log(\"B\", sd.cursor) // console.log(\"C\", d.outputs ? true : false, d.outputs ? sd[d.outputs].length : null) accumulator = accumulator . concat ( sd [ d . outputs ] )", "commit_type": "use"}
{"commit_tokens": ["Added", "passing", "of", "config", "object", "around"], "add_tokens": "const config = this . config return utils . commitChanges ( config ) return utils . getSha ( this . config ) return utils . getSha ( this . config )", "del_tokens": "return utils . commitChanges ( ) return utils . getSha ( ) return utils . getSha ( )", "commit_type": "add"}
{"commit_tokens": ["use", "lower", "-", "case", "filenames", "only"], "add_tokens": "var blendFuncs = require ( './constants/blendfuncs.json' ) var blendEquations_base = require ( './constants/blendequations.json' )", "del_tokens": "var blendFuncs = require ( './constants/blendFuncs.json' ) var blendEquations_base = require ( './constants/blendEquations.json' )", "commit_type": "use"}
{"commit_tokens": ["Add", "r", ".", "random", "()"], "add_tokens": "ARGS : true , RANDOM : true ARGS : \"args\" , RANDOM : \"random\"", "del_tokens": "ARGS : true ARGS : \"args\"", "commit_type": "add"}
{"commit_tokens": ["Added", "ability", "to", "title", "multicontainer", "pages", "before", "multicontainer", "display", "()"], "add_tokens": "var accordian = this . containers [ page_index ] if ( accordian != undefined ) { accordian . find ( '.accordion-heading' ) . find ( '.accordion-toggle' ) . html ( titles [ page_index ] ) ; } this . update ( ) ;", "del_tokens": "var accordian_toggle = this . containers [ page_index ] . find ( '.accordion-heading' ) . find ( '.accordion-toggle' ) ; accordian_toggle . html ( titles [ page_index ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "the", "ability", "to", "poll", "behind", "an", "http", "proxy"], "add_tokens": "m = monitor . createMonitor ( config . monitor . pollingInterval , config . monitor . updateInterval , config . monitor . timeout ) ; if ( config . monitor . http_proxy ) { m . proxy = config . monitor . http_proxy ; }", "del_tokens": "m = monitor . createMonitor ( ) ;", "commit_type": "add"}
{"commit_tokens": ["make", "cons", ".", "legalize", "a", "quick", "legalprop", "constructor", "if", "prop", "is", "string"], "add_tokens": "* * // quick constructor of a legal prop * cons . legalize ( 'A' ) * // { name: 'A', * // hash_by: 'name', * // hash: 'A', * // updated_by: 'bot', * // updated_when: '2016-02-01T20:34:02.582Z' } * * cons . legalize ( 'A' , 'updated_when' ) * // { name: 'A', * // hash_by: 'updated_when', * // hash: '2016-02-01T20:34:02.603Z', * // updated_by: 'bot', * // updated_when: '2016-02-01T20:34:02.603Z' } if ( _ . isString ( prop ) ) { prop = { name : prop , hash_by : 'name' } } ; var hash_key = _ . find ( [ msg , hash_by ] , _ . isString )", "del_tokens": "var hash_key = _ . find ( arguments , _ . isString )", "commit_type": "make"}
{"commit_tokens": ["Fix", "call", "indentation", "for", "chained", "functions"], "add_tokens": "startLine = node . callee . property ? node . callee . property . loc . start . line : node . callee . loc . start . line , allArgsNewLine = startLine !== firstArg . loc . start . line ,", "del_tokens": "allArgsNewLine = node . loc . start . line !== firstArg . loc . start . line ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "mock", "module", "when", "available"], "add_tokens": "} // Angular 2+ lacks addMockModule, but hybrid apps still need this if ( typeof browser . addMockModule === 'function' ) { browser . addMockModule ( 'ngApimock' , ProtractorMock , { ngapimockid : ngapimockid } ) ;", "del_tokens": "} else { browser . addMockModule ( 'ngApimock' , ProtractorMock , { 'ngapimockid' : ngapimockid } )", "commit_type": "add"}
{"commit_tokens": ["Added", "no", "-", "op", "function", "to", "fix", "problem", "with", "fresh", "databases"], "add_tokens": "return db . query ( // This function will be replaced later with a real implementation. 'CREATE FUNCTION plv8_init() RETURNS boolean LANGUAGE plv8 VOLATILE AS $$ return true; $$;' ) . query ( [", "del_tokens": "return db . query ( [", "commit_type": "add"}
{"commit_tokens": ["Made", "heads", "/", "sectors", "per", "track", "BlockDevice", "options"], "add_tokens": "this . headsPerTrack = options . headsPerTrack || - 1 this . sectorsPerTrack = options . sectorsPerTrack || - 1", "del_tokens": "this . headsPerTrack = - 1 this . sectorsPerTrack = - 1", "commit_type": "make"}
{"commit_tokens": ["Added", "at", "least", "one", "test", "for", "new", "assertions"], "add_tokens": "describe ( 'Skip/Take' , function ( ) { it ( 'Both should throw an error if called with non-numeric parameter' , function ( ) { expect ( function ( ) { [ 1 , 2 , 3 ] . Take ( 'foo' ) } ) . to . throw ( Error ) } )", "del_tokens": "describe ( 'Skip/Take are complementary' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "handling", "of", "keyUp", "and", "keyPress", "events", "too"], "add_tokens": "9 : 'tab' ,", "del_tokens": "9 : 'tab'", "commit_type": "add"}
{"commit_tokens": ["Remove", "dependency", "on", "bx", "wsk", "+", "lots", "of", "bug", "fixes"], "add_tokens": "fs . mkdirsSync ( '.workdir' ) ; ctx . cacheDir = await fs . mkdtemp ( '.workdir/test' ) ; if ( ! process . env . LOCALWSK || process . env . LOCALWSK === 'FALSE' ) await wskd . bx . initWsk ( config , { home : '.' , space : process . env . BLUEMIX_SPACE || 'openwhisk-wskp-test' } ) ;", "del_tokens": "fs . mkdirsSync ( 'test-results' ) ; ctx . cacheDir = await fs . mkdtemp ( 'test-results/test' ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "force", "argument", "to", "the", "_freshToken", "method", "and", "update", "affected", "code", "+", "tests", "."], "add_tokens": "client . getTenantInfo ( 'inexistent' , { } , function ( err , data ) { client . getTenantInfo ( '7777' , { } , function ( err , data ) { client . getServiceCatalog ( { } , function ( err , data ) { client . getTenantIdAndToken ( { } , function ( err , data ) {", "del_tokens": "client . getTenantInfo ( 'inexistent' , function ( err , data ) { client . getTenantInfo ( '7777' , function ( err , data ) { client . getServiceCatalog ( function ( err , data ) { client . getTenantIdAndToken ( function ( err , data ) {", "commit_type": "add"}
{"commit_tokens": ["allow", "-", "in", "feed", "ids", "to", "support", "mongo", "uuids"], "add_tokens": "var validRe = / ^[\\w-]+$ / ;", "del_tokens": "var validRe = / ^\\w+$ / ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "JSONLess", ".", "addHandler", "method"], "add_tokens": "before ( ( ) => { JSONLess . addHandler ( mongodb . ObjectID , ( cls , value ) => { return value . toString ( ) ; } , ( cls , value ) => { return new cls ( value ) ; } ) ; } ) ; console . log ( replaced ) ;", "del_tokens": "//console.log(replaced);", "commit_type": "add"}
{"commit_tokens": ["Add", "missing", "--", "dev", "argument"], "add_tokens": "console . log ( ' ' + chalk . cyan ( 'yarn' ) + ' add --dev gh-pages' ) ;", "del_tokens": "console . log ( ' ' + chalk . cyan ( 'yarn' ) + ' add gh-pages' ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "jsdom", "and", "fix", "undefined", "error"], "add_tokens": "function ( ) { callback ( null , window . document . documentElement . innerHTML , warnings || [ ] ) ;", "del_tokens": "function ( html ) { callback ( null , window . document . innerHTML , warnings || [ ] ) ;", "commit_type": "update"}
{"commit_tokens": ["update", "superagent", "version", "and", "fetch", "superagent", "from", "npm"], "add_tokens": "var superagent = require ( 'superagent' ) ;", "del_tokens": "var superagent = require ( '../third-party/superagent' ) ;", "commit_type": "update"}
{"commit_tokens": ["Make", "automatic", "page", "load", "instrumentation", "false", "by", "default"], "add_tokens": "tracerImp . addOption ( 'instrument_page_load' , { type : 'bool' , defaultValue : false } ) ;", "del_tokens": "tracerImp . addOption ( 'instrument_page_load' , { type : 'bool' , defaultValue : true } ) ;", "commit_type": "make"}
{"commit_tokens": ["improved", "schema", "a", "little", "but", "got", "lost", "on", "implementation", "logic"], "add_tokens": "schema : { multiple : true , object : true , type : { object : { doc : \"If multiple is true object is true, will force values to be \" + \"stored in an object - appending will not work. If multiple is \" + \"true and object is false, the key will be ignored and the \" + \"values will be stored in an array\" , type : 'boolean' } , } ,", "del_tokens": "schema : [ { ] ,", "commit_type": "improve"}
{"commit_tokens": ["add", "processOptions", "allowing", "for", "even", "cleaner", "code"], "add_tokens": "'process' , 'processOptions' ] ; const allowedProcessOptions = [ 'dispatchReturn' , 'successType' , 'failType' @ param { object } logicOptions . processOptions options influencing process hook , default { } @ param { boolean } logicOptions . processOptions . dispatchReturn dispatch the return value or resolved / next promise / observable , default false @ param { string | function } logicOptions . processOptions . successType action type or action creator fn , use value as payload @ param { string | function } logicOptions . processOptions . failType action type or action creator fn , use value as payload validate , transform , process = emptyProcess , processOptions = { } } = logicOptions ; const invalidProcessOptions = Object . keys ( processOptions ) . filter ( k => allowedProcessOptions . indexOf ( k ) === - 1 ) ; if ( invalidProcessOptions . length ) { throw new Error ( ` ${ invalidProcessOptions } ` ) ; } process , processOptions", "del_tokens": "'process' validate , transform , process = emptyProcess } = logicOptions ; process", "commit_type": "add"}
{"commit_tokens": ["Adds", "hooks", "kills", "level", "-", "updown", "approach", "with", "fire"], "add_tokens": "test ( 'precommit hooks' , dbWrap ( function ( t , base ) { test ( 'precommit hooks, chained batches' , dbWrap ( function ( t , base ) {", "del_tokens": "test . skip ( 'precommit hooks' , dbWrap ( function ( t , base ) { test . skip ( 'precommit hooks, chained batches' , dbWrap ( function ( t , base ) {", "commit_type": "add"}
{"commit_tokens": ["update", "collection", "&", "model", "tests"], "add_tokens": "todo . once ( 'changed.*' , callback ) todo . once ( 'changed.isDone' , callback ) todo . once ( 'destroy' , function callback ( ) {", "del_tokens": "todo . on ( 'changed' , callback ) todo . on ( 'changed:isDone' , callback ) todo . removeListener ( 'changed' , callback ) todo . removeListener ( 'changed:role' , callback ) todo . on ( 'destroy' , function callback ( ) { todo . removeListener ( 'destroy' , callback )", "commit_type": "update"}
{"commit_tokens": ["Fix", "broken", "tests", "and", "remove", "syntax", "unsupported", "by", "Node", "6"], "add_tokens": "} ] ) assert . deepEqual ( getOpts ( input , optdef , Object . assign ( { } , config , { terminator } ) ) , expected ) ;", "del_tokens": "} ] ) assert . deepEqual ( getOpts ( input , optdef , { ... config , terminator } ) , expected ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "issues", "template", ".", "add", "support", "and", "checks", "for", "null", "values", ".", "relax", "file", "path", "check"], "add_tokens": "if ( ! _ . isNull ( node ) && ! _ . isUndefined ( null ) && typeof node . $ref === 'string' ) { if ( ! _ . isNull ( node ) && ! _ . isUndefined ( null ) && typeof node . $ref === 'string' ) {", "del_tokens": "if ( node && typeof node . $ref === 'string' ) { if ( node && typeof node . $ref === 'string' ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "bugs", "from", "previous", "commit", "."], "add_tokens": "clientShell . onContextSave ( function ( context ) {", "del_tokens": "clientShell . onSaveContext ( function ( context ) {", "commit_type": "fix"}
{"commit_tokens": ["improve", "logging", "in", "ack", "-", "processor"], "add_tokens": "var datasetId = acknowledgement . datasetId ; if ( ! datasetId || ! acknowledgement . cuid || ! acknowledgement . hash ) { syncUtil . doLog ( datasetId , 'verbose' , 'processAcknowledge :: processing update ' + util . inspect ( acknowledgement ) ) ; syncStorage . findAndDeleteUpdate ( datasetId , acknowledgement , function ( err ) { syncUtil . doLog ( datasetId , 'info' , 'END processAcknowledge - err=' + util . inspect ( err ) ) ; syncUtil . doLog ( datasetId , 'info' , 'acknowledgement processed successfully. hash = ' + acknowledgement . hash ) ;", "del_tokens": "var dataset_id = acknowledgement . datasetId ; if ( ! dataset_id || ! acknowledgement . cuid || ! acknowledgement . hash ) { syncUtil . doLog ( dataset_id , 'verbose' , 'processAcknowledge :: processing update ' + util . inspect ( acknowledgement ) ) ; syncStorage . findAndDeleteUpdate ( dataset_id , acknowledgement , function ( err ) { syncUtil . doLog ( dataset_id , 'info' , 'END processAcknowledge - err=' + util . inspect ( err ) ) ;", "commit_type": "improve"}
{"commit_tokens": ["Make", "browserify", "test", "/", "test", ".", "js", "work", "."], "add_tokens": "// Make browserify ignore node-only modules. var requireNodeOnly = require ; var mocha = global . mocha || requireNodeOnly ( \"mocha\" ) ; var domain = requireNodeOnly ( \"domain\" ) ;", "del_tokens": "var mocha = require ( \"mocha\" ) ; // Make browserify ignore the domain module. var domain = ( 1 , require ) ( \"domain\" ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "an", "active", "index", "state", "function", "."], "add_tokens": "/ *-------------------------------------------------------------------------- Gets the active index with respect to the state of the player whether it is shuffled or not . Public Accessor : Amplitude . getActiveIndexState ( ) -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- * / function getActiveIndexState ( ) { if ( config . shuffle_on ) { return parseInt ( config . shuffle_active_index ) ; } else { return parseInt ( config . active_index ) ; } } getActiveIndex : getActiveIndex , getActiveIndexState : getActiveIndexState", "del_tokens": "getActiveIndex : getActiveIndex", "commit_type": "add"}
{"commit_tokens": ["make", "path", "to", "sinon", ".", "js", "absolute"], "add_tokens": "var fs = require ( 'fs' ) ; inject = initPage . injectJs ( options . libraryRoot ? ( fs . absolute ( options . libraryRoot ) + 'sinon.js' ) : './node_modules/phantomxhr/sinon.js' ) ;", "del_tokens": "inject = initPage . injectJs ( options . libraryRoot ? ( options . libraryRoot + 'sinon.js' ) : './node_modules/phantomxhr/sinon.js' ) ;", "commit_type": "make"}
{"commit_tokens": ["add", "example", "to", ".", "collection", "method"], "add_tokens": "* filesaver . collection ( 'documents' , './path/to/folder' , function ( ) { * // do something * } ) ;", "del_tokens": "* filesaver . collection ( 'documents' , )", "commit_type": "add"}
{"commit_tokens": ["Making", "layout", "structure", "more", "AngularJS", "friendly", "by", "making", "rows", "and", "columns", "an", "array", "instead", "of", "a", "hash", "object", "."], "add_tokens": "if ( layout ) { response . payload . layout = layout ; }", "del_tokens": "response . payload . layout = { name : value , layout : layout } ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "app", "-", "worker", "on", "Mac", "OS", "X"], "add_tokens": "appSpec . runAs , this . $proc = child_process . spawn ( 'su' , args , {", "del_tokens": "appSpec . runAs , this . $proc = child_process . spawn ( '/bin/su' , args , {", "commit_type": "fix"}
{"commit_tokens": ["Using", "test", "utils", "for", "named", "."], "add_tokens": "var test = require ( \"../../utils\" ) . test ;", "del_tokens": "var assign = require ( \"object-assign\" ) ; var path = require ( \"path\" ) ; var FILENAME = path . join ( process . cwd ( ) , \"./files\" , \"foo.js\" ) ; function test ( t ) { return assign ( { filename : FILENAME , ecmaFeatures : { modules : true } } , t ) ; }", "commit_type": "use"}
{"commit_tokens": ["allow", "model", "to", "update", "with", "both", "route", "and", "component"], "add_tokens": "newRecords . then ( records => { this . afterInfiniteQuery ( records . toArray ( ) ) ; return newRecords . then ( records => records . toArray ( ) ) ; model . addObjects ( newRecords ) ;", "del_tokens": "newRecords . then ( records => { this . afterInfiniteQuery ( records ) ; return newRecords ; model . addObjects ( newRecords . get ( 'content' ) ) ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "support", "for", "ignoring", "missing", "Entities", "when", "deleting", "..."], "add_tokens": "Entity . remove = function ( properties , ignoreIfNotExists ) { } ) . catch ( function ( err ) { // Re-throw error if we're not supposed to ignore it if ( ! ignoreIfNotExists || ! err || err . code !== 'ResourceNotFound' ) { throw err ; } Entity . prototype . remove = function ( ignoreChanges , ignoreIfNotExists ) { } ) . catch ( function ( err ) { // Re-throw error if we're not supposed to ignore it if ( ! ignoreIfNotExists || ! err || err . code !== 'ResourceNotFound' ) { throw err ; }", "del_tokens": "Entity . remove = function ( properties ) { Entity . prototype . remove = function ( ignoreChanges ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "more", "content", "to", "the", "readme", "fixed", "comment", "in", "example", "increased", "code", "linting", "strictness"], "add_tokens": "// need default values for arguments which may be left out?", "del_tokens": "// need default values for arguments which are left out?", "commit_type": "add"}
{"commit_tokens": ["remove", "default", "port", "setting", "of", "8086"], "add_tokens": "port : parsed . port ,", "del_tokens": "port : parsed . port || 8086 ,", "commit_type": "remove"}
{"commit_tokens": ["added", "build", "of", "last", "new", "feature"], "add_tokens": "var _endpoint = options . endpoint || \"js.logentries.com/v1\" ; endpoint : null ,", "del_tokens": "* @ const var _endpoint = \"js.logentries.com/v1\" ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "routability", "now", "that", "we", "don", "t", "chop", "off", "a", "step"], "add_tokens": "if ( r . route . split ( ',' ) [ 0 ] === util . format ( 'w%d' , i ) ) {", "del_tokens": "if ( r . route === util . format ( 'w%d' , i ) ) {", "commit_type": "fix"}
{"commit_tokens": ["made", "it", "work", "with", "node", "from", "the", "commandline"], "add_tokens": "( function ( self ) { self . JSFuck = { } ) ( exports || window ) ;", "del_tokens": "( function ( ) { this . JSFuck = { } ) ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Allow", "setting", "default", "connection", "string", "through", "environment", "variable"], "add_tokens": "opts . mongoUrl = opts . mongoUrl || ` ${ process . env . GULP_MONGODB_DATA_DEFAULT_CONNECTIONSTRING } ` || 'mongodb://localhost/nope'", "del_tokens": "opts . mongoUrl = opts . mongoUrl || 'mongodb://localhost/nope'", "commit_type": "allow"}
{"commit_tokens": ["use", "typeRoots", "and", "types", "instead", "of", "path"], "add_tokens": "rootDir : path . resolve ( location , \"src\" )", "del_tokens": "rootDir : path . resolve ( location , \"src\" ) , typeRoots : [ \"./node_modules/@vericus/typescript-typings/types\" , \"./node_modules/@types\" ]", "commit_type": "use"}
{"commit_tokens": ["Use", "path", ".", "normalize", "instead", "of", "path", ".", "join"], "add_tokens": "templateFile = path . normalize ( templateFile ) ;", "del_tokens": "templateFile = path . join ( templateFile ) ;", "commit_type": "use"}
{"commit_tokens": ["Added", "htcondor", ".", "submit", "prototype"], "add_tokens": "//var fs = require('fs'); //var xml2js = require('xml2js'); var adparser = require ( './lib' ) . adparser ; var tail ; var props = adparser . parse ( lines ) ; } , unwatch : function ( ) { tail . unwatch ( ) ;", "del_tokens": "var fs = require ( 'fs' ) ; var xml2js = require ( 'xml2js' ) ; lines . forEach ( function ( line ) { if ( line == \"\" ) return ; var kv = line . split ( \" = \" ) ; if ( kv . length == 2 ) { //remove double quote from value if it's quoted if ( kv [ 1 ] . indexOf ( \"\\\"\" ) == 0 ) { kv [ 1 ] = kv [ 1 ] . substring ( 1 , kv [ 1 ] . length - 1 ) ; } //convert to int if its int var i = parseInt ( kv [ 1 ] ) ; if ( i == kv [ 1 ] ) { kv [ 1 ] = i ; } props [ kv [ 0 ] ] = kv [ 1 ] ; } else { //malformed value.. let's ignore for now. //This occurs when a string contains newline like following sample //CurrentTime = time() //ReceivedBytes = 9647680.000000 //Message = \"Error from glidein_3592@hansen-a005.rcac.purdue.edu: dprintf hit fatal errors //\" } } ) ;", "commit_type": "add"}
{"commit_tokens": ["remove", "default", "timeout", "refactor", "when", "race", "occurs", "test", "tweak", "documentation", "tweak"], "add_tokens": "timeout : 10 , if ( err === 'The queries to the service(s) are not responding within the designated timeout period.' ) {", "del_tokens": "timeout : 1 , if ( err === 'timeout' ) {", "commit_type": "remove"}
{"commit_tokens": ["Remove", "unnecessary", "else", "clauses", "."], "add_tokens": "if ( lockRelease ) return lockRelease ( onUnlocked , err ) onUnlocked ( err ) done ( null , seq , release ) done ( null , nodes , batch )", "del_tokens": "if ( lockRelease ) { return lockRelease ( onUnlocked , err ) } else { onUnlocked ( err ) } else { done ( null , seq , release ) } else done ( null , nodes , batch )", "commit_type": "remove"}
{"commit_tokens": ["fixed", "babel", "build", "to", "run", "whole", "directory"], "add_tokens": "}", "del_tokens": "}", "commit_type": "fix"}
{"commit_tokens": ["Move", "codec", "creation", "to", "main", "fn"], "add_tokens": "var Codec = require ( 'level-codec' ) // TODO: remove ns from signature to align w/ sublevel ns . codec = new Codec ( opts ) // TODO: can we remove this?", "del_tokens": "ns . createCodec ( opts )", "commit_type": "move"}
{"commit_tokens": ["Update", "cordial", "/", "gulpfile", "flow"], "add_tokens": "gulp . task ( 'publish' , cordial . npm . publish ) gulp . task ( 'post-flow-release-start' , [ 'test' , 'reset' , 'write' ] , cordial . flow . release . start ) gulp . task ( 'post-flow-release-finish' , [ 'publish' , 'backup' ] )", "del_tokens": "gulp . task ( 'publish' , [ 'test' ] , cordial . npm . publish ) gulp . task ( 'post-flow-release-start' , [ 'reset' , 'write' ] , cordial . flow . release . start ) gulp . task ( 'post-flow-release-finish' , [ 'publish' , 'push' ] )", "commit_type": "update"}
{"commit_tokens": ["Fixing", "device", "selection", "for", "xcode", "7"], "add_tokens": "// For xcode major version 7 let CONFIG_FIX__XCODE_7 = { 'iPad Simulator (8.1)' : 'iPad 2 (8.1)' , 'iPad Simulator (8.2)' : 'iPad 2 (8.2)' , 'iPad Simulator (8.3)' : 'iPad 2 (8.3)' , 'iPad Simulator (8.4)' : 'iPad 2 (8.4)' , 'iPhone Simulator (8.1)' : 'iPhone 6 (8.1)' , 'iPhone Simulator (8.2)' : 'iPhone 6 (8.2)' , 'iPhone Simulator (8.3)' : 'iPhone 6 (8.3)' , 'iPhone Simulator (8.4)' : 'iPhone 6 (8.4)' , 'iPad Simulator (9.0)' : 'iPad 2 (9.0)' , 'iPad Simulator (9.1)' : 'iPad 2 (9.1)' , // Fixing ambiguous device name by adding '[' at the end so intruments // correctly starts iPhone 6 [udid] and not the iPhone 6 (9.0) + Apple Watch // for ios9.0 and above; see #5619 'iPhone Simulator (9.0)' : 'iPhone 6 (9.0) [' , 'iPhone Simulator (9.1)' : 'iPhone 6 (9.1) [' , 'iPhone 6 (9.0)' : 'iPhone 6 (9.0) [' , 'iPhone 6 (9.1)' : 'iPhone 6 (9.1) [' } ; let configFix = xcodeVersion [ 0 ] === 7 ? CONFIG_FIX__XCODE_7 : CONFIG_FIX ; if ( configFix [ iosDeviceString ] ) { iosDeviceString = configFix [ iosDeviceString ] ;", "del_tokens": "'iPad Simulator (9.0 Simulator)' : 'iPad 2 (9.0 Simulator)' , 'iPhone Simulator (9.0 Simulator)' : 'iPhone 6 (9.0 Simulator)' , if ( CONFIG_FIX [ iosDeviceString ] ) { iosDeviceString = CONFIG_FIX [ iosDeviceString ] ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "some", "minor", "issues", "."], "add_tokens": "return env [ name ] ; 'GAE_LONG_APP_ID' : 'my-test-app' , 'GAE_MODULE_NAME' : 'foo' , 'GAE_MODULE_VERSION' : 'bar' , 'GAE_MODULE_INSTANCE' : '0' , 'GAE_MINOR_VERSION' : '1234567890' return env [ name ] ; 'GAE_LONG_APP_ID' : 'my-test-app' , 'GAE_MODULE_NAME' : 'foo' , 'GAE_MODULE_VERSION' : 'bar' , 'GAE_MINOR_VERSION' : '1234567890' return env [ name ] ;", "del_tokens": "return env [ name ] 'GAE_LONG_APP_ID' : 'my-test-app' , 'GAE_MODULE_NAME' : 'foo' , 'GAE_MODULE_VERSION' : 'bar' , 'GAE_MODULE_INSTANCE' : '0' , 'GAE_MINOR_VERSION' : '1234567890' return env [ name ] 'GAE_LONG_APP_ID' : 'my-test-app' , 'GAE_MODULE_NAME' : 'foo' , 'GAE_MODULE_VERSION' : 'bar' , 'GAE_MINOR_VERSION' : '1234567890' return env [ name ]", "commit_type": "fix"}
{"commit_tokens": ["updated", "calls", "that", "are", "using", "the", "path", "module", "to", "use", "path", ".", "posix"], "add_tokens": "basepath = path . posix . normalize ( options . dest ) ;", "del_tokens": "basepath = path . normalize ( options . dest ) ;", "commit_type": "update"}
{"commit_tokens": ["removes", "un", "-", "needed", "catch", "s", "errors", "should", "naturally", "flow", "to", "user", "catch", "statements", "if", "needed"], "add_tokens": "} ) } )", "del_tokens": "} ) . catch ( reject ) } ) . catch ( reject )", "commit_type": "remove"}
{"commit_tokens": ["fixed", "the", "inheritdoc", "jsdoc", "tag", "letter", "case"], "add_tokens": "pattern : / \\/[*][*]((?:a|[^a])*?)(?: |\\t)*[*]\\s*@(?:override|inheritdoc|abstract)\\n((a|[^a])*)[*]\\/ / g ,", "del_tokens": "pattern : / \\/[*][*]((?:a|[^a])*?)(?: |\\t)*[*]\\s*@(?:override|inheritDoc|abstract)\\n((a|[^a])*)[*]\\/ / g ,", "commit_type": "fix"}
{"commit_tokens": ["fix", "a", "syntax", "error", "of", "KM", ".", "toQueryString", "method"], "add_tokens": "! K . isObject ( value = obj [ key ] ) && ! K . isArray ( value ) && ret . push ( key + '=' + encode ( value ) ) ;", "del_tokens": "! K . isObject ( value = obj [ key ] ; ) && ! K . isArray ( value ) && ret . push ( key + '=' + encode ( value ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "strategies", "property", "to", "a", "getter"], "add_tokens": "var GitRepo = require ( '../utils/git' ) ; var fs = require ( 'fs' ) ; var path = require ( 'path' ) ; var chalk = require ( 'chalk' ) ; var merge = require ( 'merge' ) ; var nopt = require ( 'nopt' ) ; var requireDir = require ( 'require-dir' ) ; var RSVP = require ( 'rsvp' ) ; var strategies = this . strategies ( ) ; strategies : function ( ) { if ( this . _strategies ) { return this . _strategies ; } return this . _strategies = requireDir ( '../strategies' ) ; } ,", "del_tokens": "var GitRepo = require ( '../utils/git' ) ; var fs = require ( 'fs' ) ; var path = require ( 'path' ) ; var chalk = require ( 'chalk' ) ; var merge = require ( 'merge' ) ; var nopt = require ( 'nopt' ) ; var RSVP = require ( 'rsvp' ) ; strategies : { semver : require ( '../strategies/semver' ) , date : require ( '../strategies/date' ) } , var strategies = this . strategies ;", "commit_type": "change"}
{"commit_tokens": ["Add", "write", "()", "method", "."], "add_tokens": "return record ; } / ** * Write the log record to stream ( s ) or dispatch * the write event if there are listeners for the write * event . * * @ api private * * @ param level The log level . * @ param record The log record . * / Logger . prototype . write = function ( level , record ) { this . write ( level , this . getLogRecord . apply ( this , arguments ) ) ;", "del_tokens": "var record = this . getLogRecord . apply ( this , arguments ) ; //console.log('logging message...%s', message);", "commit_type": "add"}
{"commit_tokens": ["fixed", "sandbox", ".", "js", "imports"], "add_tokens": "'lib/expression-api/core.js' ,", "del_tokens": "'lib/expression-api/init.js' ,", "commit_type": "fix"}
{"commit_tokens": ["Move", "config", "to", "lib", "/"], "add_tokens": "var config = require ( './lib/config' ) ( ) ;", "del_tokens": "var config = require ( './config' ) ( ) ;", "commit_type": "move"}
{"commit_tokens": ["Remove", "position", "property", "from", "Player"], "add_tokens": "return this . player . getPosition ( ) ; this . player . emit ( 'seek' , offset ) ;", "del_tokens": "_Position = 0 ; return this . _Position ; let e = { delta : offset , position : ( this . player . position || 0 ) + offset } ; this . player . emit ( 'seek' , e ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fix", "failing", "build", "(", "karma", "-", "phantomjs", "-", "launcher", "upgrade", ")"], "add_tokens": "var JsonRefs = require ( 'json-refs' ) ; function validateErrors ( actual , expected ) { assert . equal ( actual . length , expected . length ) ; _ . each ( actual , function ( aErr ) { assert . deepEqual ( aErr , _ . find ( expected , function ( vErr ) { return JsonRefs . pathToPtr ( aErr . path ) === JsonRefs . pathToPtr ( vErr . path ) ; } ) ) ; } ) ; } validateErrors ( results . errors , [ validateErrors ( results . errors , [", "del_tokens": "assert . deepEqual ( results . errors , [ assert . deepEqual ( results . errors , [", "commit_type": "fix"}
{"commit_tokens": ["implement", "and", "test", "race", "condition", "for", "wallet", "transaction", "and", "transfer"], "add_tokens": "} , 10 ) ; } , 0 ) ; } , 0 ) ; } , 0 ) ; } , 0 ) ;", "del_tokens": "} , 0 ) ; } ) . then ( undefined , function ( e ) { console . log ( '-------------' , e ) } ) ; } ) ; } ) ; } ) ;", "commit_type": "implement"}
{"commit_tokens": ["added", "test", "cases", "for", "products", "and", "orders"], "add_tokens": "function feedRequest ( ) { var FeedSubmissionId = '10101010XXX' ; feedRequest ( ) ;", "del_tokens": "function feedRequest ( FeedSubmissionId ) { feedRequest ( '10101010XXX' ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "context", "s", "resource", "private"], "add_tokens": "// Context is a top-level resource that imports other resources. The only // difference is that a regular resource is a file, and the EOF marks the // moment when the resource no longer accepts new imports. For the // context's meta resource we need the `freeze` method to simulate this // behavior. var meta = new Resource ( ) ; meta . isReady = function Meta_isReady ( ) { meta . ast = meta . resources . reduce ( function ( prev , curr ) { L20n . Compiler . compile ( meta . ast , entries , globals ) ; console . log ( 'fired' , self ) meta . loadResource ( uri , _ifReady ( meta , compile ) ) ; _ifReady ( meta , compile ) ;", "del_tokens": "Resource . call ( this ) ; this . isReady = function isReady ( ) { this . ast = this . resources . reduce ( function ( prev , curr ) { L20n . Compiler . compile ( this . ast , entries , globals ) ; console . log ( 'fired' , { ast : self . ast , entries : entries } ) ; this . loadResource ( uri , _ifReady ( this , compile ) ) ; _ifReady ( this , compile ) ;", "commit_type": "make"}
{"commit_tokens": ["Add", "deprecation", "warning", "for", "synchronous", "compilation"], "add_tokens": "var util = require ( \"util\" ) ; WebpackFileManager . prototype . loadFileSync = util . deprecate ( function ( filename , currentDirectory , options , environment ) { } , \"We are planing to remove enhanced-require support with the next major release of the less-loader: https://github.com/webpack/less-loader/issues/84\" ) ;", "del_tokens": "var parsedMap ; WebpackFileManager . prototype . loadFileSync = function ( filename , currentDirectory , options , environment ) { } ;", "commit_type": "add"}
{"commit_tokens": ["Change", "spec", "from", "url", "to", "image"], "add_tokens": "< img src = { props . image } alt = { props . text } / > image : PropTypes . string . isRequired ,", "del_tokens": "< img src = { props . url } alt = { props . text } / > url : PropTypes . string . isRequired ,", "commit_type": "change"}
{"commit_tokens": ["add", "is", "flag", "for", "allowing", "instance", "check", "to", "be", "customized"], "add_tokens": "it ( 'should use the `is` flag on the options to check the instance name' , function ( ) { app . use ( config ( { is : 'isApp' } ) ) ; assert ( ! app . config ) ;", "del_tokens": "it ( 'should process an object passed to config' , function ( cb ) { app . use ( config ( { option : { a : 'b' } } ) ) ; app . on ( 'option' , function ( key , val ) { assert ( key ) ; assert ( key === 'a' ) ; assert ( val === 'b' ) ; cb ( ) ; } ) ; app . config . process ( ) ; } ) ; it ( 'should process an array passed to config' , function ( cb ) { app = base ( ) ; app . use ( plugins ( ) ) ; app . use ( options ( ) ) ; app . use ( store ( 'base-config-tests' ) ) ; app . use ( config ( [ { option : { a : 'b' } } ] ) ) ; app . on ( 'option' , function ( key , val ) { assert ( key ) ; assert ( key === 'a' ) ; assert ( val === 'b' ) ; cb ( ) ; } ) ; app . config . process ( ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "filter", "to", "strip", "relative", "parts", "from", "remote", "filename"], "add_tokens": "var remoteFile = options . remotename ? options . remotename : ( options . keeppath ? localFile : _path . basename ( localFile ) ) ; // normalize the remote filename (strip relative parts) remoteFile = remoteFile . replace ( / \\.\\.\\/ / g , '' ) . replace ( / \\.\\. / g , '' ) ; // display filenames logStatus ( 'NodeMCU-Tool' , 'Uploading \"' + localFile + '\" >> \"' + remoteFile + '\"...' ) ; // start the file transfer", "del_tokens": "logStatus ( 'NodeMCU-Tool' , 'Uploading \"' + localFile + '\" ...' ) ; var remoteFile = options . remotename ? options . remotename : options . keeppath ? localFile : _path . basename ( localFile ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "attributes", "-", ">", "attr", "calls", "easier", "to", "follow"], "add_tokens": "let name = null ; if ( name ) { calls . push ( toFunctionCall ( t , iDOMMethod ( file , \"attr\" ) , [ name , attr ] ) ) ; name = null ; } else { name = attr ;", "del_tokens": "let current = [ ] ; current . push ( attr ) ; if ( current . length === 2 ) { calls . push ( toFunctionCall ( t , iDOMMethod ( file , \"attr\" ) , current ) ) ; current = [ ] ;", "commit_type": "make"}
{"commit_tokens": ["fixed", "display", "when", "restarting", "a", "graph"], "add_tokens": "this . hasDuration = hasDuration ; this . previousFrame = null ; this . currentTime = this . hasDuration ? this . params . get ( 'referenceTime' ) : null ; const floatFrameWidth = ( frameDuration / canvasDuration ) * canvasWidth ; const frameWidth = Math . floor ( floatFrameWidth + 0.5 ) ;", "del_tokens": "const fFrameWidth = ( frameDuration / canvasDuration ) * canvasWidth ; const frameWidth = Math . floor ( fFrameWidth + 0.5 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "correct", "port", "for", "connect", "task"], "add_tokens": "urls : [ 'http://localhost:' + ( port + 1 ) + '/example/test/test2.html' ] ,", "del_tokens": "urls : [ 'http://localhost:' + port + '/example/test/test2.html' ] ,", "commit_type": "use"}
{"commit_tokens": ["add", "failing", "test", "for", "no", "-", "minify", "+", "this", "property"], "add_tokens": "console . log ( 'testing' ) const keys = key . split ( ',' ) keys . forEach ( k => tests [ k ] ( ) )", "del_tokens": "const { cyan } = require ( 'chalk' ) tests [ key ] ( )", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "multiple", "cookies", "set", "in", "header"], "add_tokens": "var pendingCookiesArray = res . getHeader ( 'Set-Cookie' ) || [ ] ; var newCookiesArray = pendingCookiesArray . concat ( cookieStr ) ; res . setHeader ( 'Set-Cookie' , newCookiesArray ) ;", "del_tokens": "res . setHeader ( 'Set-Cookie' , cookieStr ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "lax", "assertions", "in", "test"], "add_tokens": "assert . strictEqual ( false , process . env . hasOwnProperty ( 'NOTSET' ) ) ; assert . strictEqual ( true , process . env . hasOwnProperty ( 'ALSO_SET' ) ) ; assert . strictEqual ( true , res . hasOwnProperty ( 'this_is_the_result' ) ) ; assert . strictEqual ( false , res . ALSO_SET_exists ) ;", "del_tokens": "assert . equal ( false , process . env . hasOwnProperty ( 'NOTSET' ) ) ; assert . equal ( true , process . env . hasOwnProperty ( 'ALSO_SET' ) ) ; assert . ok ( ! ! res . hasOwnProperty ( 'this_is_the_result' ) ) ; assert . equal ( false , res . ALSO_SET_exists ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "buffer", "corruption", "after", "resizing", "rows"], "add_tokens": "/ ** * The scroll position of the y cursor , ie . ybase + y = the y position within the entire * / / ** * The scroll position of the viewport * / / ** * The cursor ' * / / ** * The cursor ' * / / ** * An array of all lines in the entire buffer , including the prompt . The lines are array of * characters which are 2 - length arrays where [ 0 ] is an attribute and [ 1 ] is the character . * / if ( this . y + this . ybase < j ) { // The line is after the cursor, remove it this . lines . pop ( ) ; } else { // The line is the cursor, push the viewport down this . ybase ++ ; this . ydisp ++ ; }", "del_tokens": "this . lines . shift ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "more", "test", "files", "and", "only", "output", "one", "version", "to", "std", "out", "so", "you", "can", "redirect", "the", "output", "if", "you", "want", ".."], "add_tokens": "// decide how we want to process this, if we are outputting data to std-out // you don't really want to write both the minified version and a regular // version as you output 2 versions of your data, dev and minified // stdout shouldn't receive dev shizzle if ( ! this . stdout ) this . write ( content , 'dev' , extension ) ;", "del_tokens": "self . write ( content , 'dev' , extension ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "init", "function", "and", "more", "examples"], "add_tokens": "this . init ( ) ; init : { value : function ( ) { this . update ( ) ; this . loaded ( ) ; } } ,", "del_tokens": "this . update ( ) ; this . loaded ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "padding", "long", "error", "diffs", "with", "line", "number"], "add_tokens": "return self . pad ( ++ i , width ) + ' |' + ' ' + str / ** * Pads the string with length number of spaces * * @ param { * } str The string to pad * @ param { Number } length The number of spaces to add * * @ returns { string } The padded string * / BaseReporter . prototype . pad = function ( str , length ) { var arr = new Array ( length - String ( str ) . length + 1 ) return arr . join ( ' ' ) + str }", "del_tokens": "return pad ( ++ i , width ) + ' |' + ' ' + str", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "typo", "on", "english", "translation"], "add_tokens": "or : 'or'", "del_tokens": "or : 'ou'", "commit_type": "fix"}
{"commit_tokens": ["change", "default", "font", "to", "12px"], "add_tokens": "fontSize : '12px' ,", "del_tokens": "fontSize : '20px' ,", "commit_type": "change"}
{"commit_tokens": ["Changing", "source", "/", "target", "to", "use", "nulls", "instead", "of", "empty", "lists", "for", "multiple", "symbol", "fields", ".", "Also", "altering", "to", "use", "new", "utility", "method", "for", "setting", "defaults", "."], "add_tokens": "M = require ( '../lib/types/message' ) , var msg = new M . Message ( ) ; msg . body . push ( 10 ) ; session . sendMessage ( link , msg , { deliveryId : 1 , deliveryTag : tu . newBuf ( [ 1 ] ) } ) ; setTimeout ( function ( ) { session . detachLink ( link ) ; } , 500 ) ;", "del_tokens": "session . detachLink ( link ) ;", "commit_type": "change"}
{"commit_tokens": ["Create", "and", "test", "eol", "-", "no", "-", "whitespace"], "add_tokens": "const { value , char , insideFunction , outsideFunction } = options const charToFindIsArray = Array . isArray ( char ) function charMatchesCharToFind ( charToCheck ) { if ( charToFindIsArray ) { return char . indexOf ( charToCheck ) !== - 1 } return charToCheck === char } if ( ! isInsideString && charMatchesCharToFind ( currentChar ) ) {", "del_tokens": "const { value , insideFunction , outsideFunction } = options if ( ! isInsideString && currentChar === options . char ) {", "commit_type": "create"}
{"commit_tokens": ["Fix", "temporal", "super", "sampling", "for", "temporal", "super", "sampling"], "add_tokens": "fragment : Shader . source ( 'qtek.compositor.output' ) , // TODO, alpha is premultiplied? // blendWithPrevious: true this . _outputPass . material . shader . define ( 'fragment' , 'OUTPUT_ALPHA' ) ; var viewport = renderer . viewport ; var dpr = viewport . devicePixelRatio || renderer . getDevicePixelRatio ( ) ; var width = viewport . width * dpr ; var height = viewport . height * dpr ;", "del_tokens": "fragment : Shader . source ( 'qtek.compositor.output' ) var width = renderer . getWidth ( ) ; var height = renderer . getHeight ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "Redux", "Devtools", "Extensions", "support"], "add_tokens": "/* global window */ // Optionally add the Redux DevTools Extension, if it exists. const devtools = typeof window === \"object\" && window . devToolsExtension ? window . devToolsExtension ( ) : f => f ; return applyMiddleware ( ... middleware ) ( devtools ( createStore ) ) ;", "del_tokens": "return applyMiddleware ( ... middleware ) ( createStore ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "isEmpty", "error", "when", "obj", "has", "empty", "key"], "add_tokens": "export const isDir = isDirectory ; return false && key ; // only for eslint", "del_tokens": "return ! key && ! 0 ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "requester", "-", "username", "parameter", "when", "needed", "on", "bind"], "add_tokens": "\" <input type=\\\"radio\\\" ng-model=\\\"ctrl.serviceToBind\\\" ng-value=\\\"null\\\">\\n\" + \" <input type=\\\"radio\\\" ng-model=\\\"ctrl.serviceToBind\\\" ng-value=\\\"serviceInstance\\\">\\n\" +", "del_tokens": "\" <input type=\\\"radio\\\" ng-model=\\\"ctrl.serviceToBind\\\" value=\\\"\\\">\\n\" + \" <input type=\\\"radio\\\" ng-model=\\\"ctrl.serviceToBind\\\" value=\\\"{{serviceInstance.metadata.name}}\\\">\\n\" +", "commit_type": "add"}
{"commit_tokens": ["implemented", "assert", "by", "making", "it", "throw", "exception"], "add_tokens": "throw new MjsUnitAssertionError ( descr + \": No match found for \" + expectedValue ) ; throw new MjsUnitAssertionError ( descr + \": Multiple matches found for \" + expectedValue ) ; throw new MjsUnitAssertionError ( descr + \": No match found for \" + expectedValue ) ; throw new MjsUnitAssertionError ( descr + \": Multiple matches found for \" + expectedValue ) ;", "del_tokens": "assert ( descr + \": No match found for \" + expectedValue , false ) ; assert ( descr + \": Multiple matches found for \" + expectedValue , false ) ; assert ( descr + \": No match found for \" + expectedValue , false ) ; assert ( descr + \": Multiple matches found for \" + expectedValue , false ) ;", "commit_type": "implement"}
{"commit_tokens": ["Added", "logs", "per", "user", "/", "app"], "add_tokens": "BaseModel . prototype . get = function ( filter , options , callback ) { if ( ! callback ) { callback = options ; options = { } ; } collection . find ( filter , { } , options ) . toArray ( function ( err , data ) {", "del_tokens": "BaseModel . prototype . get = function ( filter , callback ) { collection . find ( filter ) . toArray ( function ( err , data ) {", "commit_type": "add"}
{"commit_tokens": ["Allows", "an", "HTTP", "-", "Auth", "proxy", "to", "be", "specified"], "add_tokens": "* @ param { string } domain * An http proxy domain * @ param { string } port ( optional ) * Applies a port number if specified * @ param { string } username ( optional ) * @ param { string } password ( optional ) CheerioClient . prototype . setProxy = function ( domain , port , username , password ) { if ( domain ) { var uri = 'http://' ; if ( username ) { uri += username ; uri += password ? ':' + password : '' ; uri += '@' ; } uri += domain ; uri += ( port ? ':' + port : '' ) ; delete this . requestSettings . proxy ;", "del_tokens": "* @ param { string } proxy * An http proxy provided in host : domain format CheerioClient . prototype . setProxy = function ( proxy ) { if ( proxy ) { this . requestSettings . proxy = 'http://' + proxy ; delete this . requestSettings ;", "commit_type": "allow"}
{"commit_tokens": ["Make", "ViewLayout", "autosize", "object", "-", "valued", "."], "add_tokens": "( _ . autosize && _ . autosize . type === Fit ) var type = _ . autosize && _ . autosize . type , auto = _ . autosize && _ . autosize . resize , view . autosize ( viewWidth , viewHeight , width , height , [ left , top ] , auto ) ;", "del_tokens": "( _ . autosize === Fit ) var type = _ . autosize , view . autosize ( viewWidth , viewHeight , width , height , [ left , top ] , _ . resize ) ;", "commit_type": "make"}
{"commit_tokens": ["Fixed", "Verifcation", "URl", "in", "the", "email"], "add_tokens": "var options = '' ; lrv2 . authenticationApi . userRegistrationByEmail ( userprofileModel , sott , emailTemplate , fields , options , verificationUrl , welcomeEmailTemplate ) . then ( function ( response ) {", "del_tokens": "lrv2 . authenticationApi . userRegistrationByEmail ( userprofileModel , sott , emailTemplate , fields , verificationUrl , welcomeEmailTemplate ) . then ( function ( response ) {", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "some", "bugs", "created", "for", "testing", "."], "add_tokens": "var devices = [ ] ; devices . push ( currentDevice ) ;", "del_tokens": "var devices ; //devices.push(currentDevice);", "commit_type": "fix"}
{"commit_tokens": ["add", "some", "more", "tile", "processing", "metrics"], "add_tokens": "tile . debug = { } ; tile . debug . network = + new Date ( ) ; tile . debug . network = + new Date ( ) - tile . debug . network ; // network/JSON parsing tile . debug . rendering = + new Date ( ) - timer ; // rendering/geometry prep \"debug for \" + tile . key + ': [ ' + Object . keys ( tile . debug ) . map ( function ( t ) { return t + ': ' + tile . debug [ t ] ; } ) . join ( ', ' ) + ' ]' tile . debug . projection = + new Date ( ) - timer ;", "del_tokens": "tile . timers = { } ; tile . timers . network = + new Date ( ) ; tile . timers . network = + new Date ( ) - tile . timers . network ; // network/JSON parsing tile . timers . rendering = + new Date ( ) - timer ; // rendering/geometry prep \"timers for \" + tile . key + ': [ ' + Object . keys ( tile . timers ) . map ( function ( t ) { return t + ': ' + tile . timers [ t ] ; } ) . join ( ', ' ) + ' ]' tile . timers . projection = + new Date ( ) - timer ;", "commit_type": "add"}
{"commit_tokens": ["Use", "simple", "for", "cycle", "instead", "of", "do", "..", "while", "loop"], "add_tokens": "for ( var state = $state . $current . self ; state && state . name !== '' ; state = $$breadcrumbParentState ( state ) ) { $$addStateInChain ( chain , state ) ;", "del_tokens": "var state = $state . $current . self ; do { $$addStateInChain ( chain , state ) ; state = $$breadcrumbParentState ( state ) ; while ( state && state . name !== '' ) ; //", "commit_type": "use"}
{"commit_tokens": ["updated", "var", "names", "for", "caching", "to", "generic", "names", "instead", "of", "cordova", "specific", "names"], "add_tokens": "var moduleCache ; // Path to module cache if ( newCfg . moduleCache ) { setCachePath ( joinAndCreatePath ( path . resolve ( newCfg . moduleCache ) ) ) ; // Version of node module to use if ( newCfg . moduleVersion ) currentCfg . moduleVersion = newCfg . moduleVersion ; if ( newCfg . nodePackageName ) currentCfg . nodePackageName = newCfg . nodePackageName ; moduleCache = joinAndCreatePath ( newPath . split ( path . sep ) ) ; process . env [ \"CORDOVA_HOME\" ] = path . join ( moduleCache , \"_cordova\" ) ; // Set platforms to cache in cache locaiton to avoid unexpected results process . env [ \"PLUGMAN_HOME\" ] = path . join ( moduleCache , \"_plugman\" ) ; // Set plugin cache in cache locaiton to avoid unexpected results return moduleCache ;", "del_tokens": "var cordovaCache ; // Path to cordova cache if ( newCfg . cordovaCache ) { setCachePath ( joinAndCreatePath ( path . resolve ( newCfg . cordovaCache ) ) ) ; // Version of cordova based node module to use if ( newCfg . cordovaVersion ) currentCfg . cordovaVersion = newCfg . cordovaVersion ; if ( newCfg . cordovaPackageName ) currentCfg . cordovaPackageName = newCfg . cordovaPackageName ; cordovaCache = joinAndCreatePath ( newPath . split ( path . sep ) ) ; process . env [ \"CORDOVA_HOME\" ] = path . join ( cordovaCache , \"_cordova\" ) ; // Set platforms to cache in cache locaiton to avoid unexpected results process . env [ \"PLUGMAN_HOME\" ] = path . join ( cordovaCache , \"_plugman\" ) ; // Set plugin cache in cache locaiton to avoid unexpected results return cordovaCache ;", "commit_type": "update"}
{"commit_tokens": ["Improve", "data", "-", "table", "component"], "add_tokens": "name : 'Column' , sorter : [ Boolean , Function , String ] , visible : { type : Boolean , default : true , } , const isShowIcon = this . visible ? 'check' : 'remove' ; visible : this . visible , isShowIcon , this . column . renderCell = ( h , { row , column } ) => { // eslint-disable-line if ( this . $scopedSlots . default ) { return row [ column . field ] ; return null ;", "del_tokens": "name : 'TableColumn' , sorter : [ Boolean , Function ] , this . column . renderCell = ( h , { row , column } ) => { console . log ( column ) ; if ( this . scopedSlots . default ) { // const defaultRender = (h, { row, column }) => { // const field = column.field; // return row[field]; // }; // // this.customRender = this.$options.render; // this.$options.render = (h) => {// eslint-disable-line // return (<div>{ this._t('default') }</div>); // }; // // const _self = this; // this.column.renderCell = (h, data) => { // if (_self.$vnode.data.inlineTemplate || _self.$scopedSlots.default) { // console.log(_self.inlineTemplate); // data._self = _self.context || data._self; // if (Object.prototype.toString.call(data._self) === '[object Object]') { // Object.assign(data, data._self); // data._staticTrees = _self._staticTrees; // data.$options.staticRenderFns = _self.$options.staticRenderFns; // // return _self.customRender.call(data); // // return _self.$scopedSlots.default; // console.log(''); // } // } // return defaultRender(h, data); // }; console . log ( this ) ; return ( < span > < / span > ) ;", "commit_type": "improve"}
{"commit_tokens": ["Add", "option", "for", "configuring", "tokenizer", "regexps"], "add_tokens": "var test = require ( 'tape-catch' ) ;", "del_tokens": "var test = require ( 'tape' ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "a", "critical", "/", "crashing", "csp", "bug"], "add_tokens": "// This currently throws an error, occasionally, if not in a try catch b/c // sometimes this.cometResponse is undefined... try { this . sendHeaders ( this . cometResponse , body . length ) this . cometResponse . sendBody ( body ) ; this . cometResponse . finish ( ) ; } catch ( e ) { }", "del_tokens": "this . sendHeaders ( this . cometResponse , body . length ) this . cometResponse . sendBody ( body ) ; this . cometResponse . finish ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "regression", "in", "mqlight", ".", "js", "parsing", "of", "send", "()", "arguments"], "add_tokens": "throw new TypeError ( 'options must be an object type not a ' + ( typeof options ) + ')' ) ; } if ( callback ) { if ( callbackOption ) { throw new TypeError ( 'Invalid forth argument, callback already matched' + 'for third argument' ) ; } if ( callback instanceof Function ) { callbackOption = callback ; } else { throw new TypeError ( 'callback must be a function type' ) ; if ( arguments . length === 0 ) {", "del_tokens": "throw new TypeError ( 'options must be an object type' ) ; if ( callback ) { if ( callbackOption ) { throw new TypeError ( 'Invalid forth argument, callback already matched' + 'for third argument' ) ; } if ( callback instanceof Function ) { callbackOption = callback ; } else { throw new TypeError ( 'callback must be a function type' ) ; } if ( arguments . length == 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["use", "crc", "instead", "of", "buffer", "-", "crc32"], "add_tokens": "var crc32 = require ( 'crc' ) . crc32 ;", "del_tokens": "var crc32 = require ( 'buffer-crc32' ) ;", "commit_type": "use"}
{"commit_tokens": ["fix", "69", ":", "when", "simulate", "7", "in", "ie11", "console", "will", "not", "be", "detected", "as", "ie"], "add_tokens": "} else if ( ~ ua . indexOf ( 'trident' ) || ~ ua . indexOf ( 'msie' ) ) {", "del_tokens": "} else if ( ~ ua . indexOf ( 'trident' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "meridiem", "in", "lieu", "of", "meridian", "to", "satisfy", "the", "grammarians", "of", "the", "world"], "add_tokens": "* @ return { object } { hour , meridiem } ( meridian is also returned for backwards compatibility ) var meridiem = hour < 12 ? 'am' : 'pm' ; meridiem : meridiem , meridian : meridiem * @ param { string } time . meridiem Hour meridiem ( am / pm ) . 'time.meridian' is * supported for backwards compatibility . var meridiem = time . meridiem || time . meridian ; return ( meridiem === 'am' ? 0 : 12 ) + ( time . hour % 12 ) ;", "del_tokens": "* @ return { object } { hour , meridian } meridian : hour < 12 ? 'am' : 'pm' * @ param { string } time . meridian Hour meridian ( am / pm ) return ( time . meridian === 'am' ? 0 : 12 ) + ( time . hour % 12 ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "history", "branch", "compression", "to", "combine", "deletion", "steps"], "add_tokens": "if ( from == to ) return } else if ( pos < to ) {", "del_tokens": "} else {", "commit_type": "allow"}
{"commit_tokens": ["Added", "ability", "to", "stop", "entity", "iteration", "with", "world", ".", "every"], "add_tokens": "let status = callback ( ... comps , ent , ... args ) // Stop the iteration when the callback returns false if ( status === false ) { break }", "del_tokens": "callback ( ... comps , ent , ... args )", "commit_type": "add"}
{"commit_tokens": ["fixing", "a", "problem", "with", "the", "amd", "-", "cjs", "transpiler"], "add_tokens": "var foo = require ( 'foo/foo' ) ; var bar = require ( 'bar/bar' ) ;", "del_tokens": "var foo = require ( 'foo/foo' ) , bar = require ( 'bar/bar' ) ;", "commit_type": "fix"}
{"commit_tokens": ["moved", "generation", "of", "Worksheet", "XML", "to", "Worksheet", ".", "js", "script"], "add_tokens": "this . cols . push ( colObj ) ;", "del_tokens": "this . sheet . cols . push ( colObj ) ;", "commit_type": "move"}
{"commit_tokens": ["added", "comments", "regarding", "the", "Vary", "Header", "changes"], "add_tokens": "//test if any compression is available //as long as there is any compression available for this file, add the Vary Header (used for caching proxies) //use the first matching compression to serve a compresed file", "del_tokens": "//check if the requested file is available in at least one of the supported encodings", "commit_type": "add"}
{"commit_tokens": ["add", "Uri", "-", "Query", "support"], "add_tokens": "// all good // all good if ( delta < 13 ) { /* all good */ if ( length < 13 ) { /* all good */ UriQuery : ( query ) => optionConstructors [ \"Uri-Query\" ] ( Buffer . from ( query ) ) ,", "del_tokens": "if ( delta < 13 ) { if ( length < 13 ) {", "commit_type": "add"}
{"commit_tokens": ["make", "extra", "trailing", "slash", "in", "path", "irrelevant"], "add_tokens": "var dirName = corePath . normalize ( input ) if ( dirName [ dirName . length - 1 ] !== corePath . sep ) dirName += corePath . sep", "del_tokens": "var dirName = corePath . normalize ( input ) + corePath . sep", "commit_type": "make"}
{"commit_tokens": ["Fix", "incorrect", "var", "in", "generateTraceURL"], "add_tokens": "micros = this . _tracer . _platform . nowMicros ( ) ;", "del_tokens": "micros = tracer . _platform . nowMicros ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "unused", "function", "and", "setup"], "add_tokens": "import { registerMacro } from \"htmlbars/macros\" ; module ( \"HTML Macros\" ) ; return hydrate ( spec , { } ) ;", "del_tokens": "import { registerMacro , removeMacro } from \"htmlbars/macros\" ; var macros ; module ( \"HTML Macros\" , { setup : function ( ) { macros = { } ; } } ) ; function registerMacro ( name , test , macro ) { macros [ name ] = { test : test , mutate : mutate } ; ; } return hydrate ( spec , { macros : macros } ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "options", "to", "load", "user", "groups", "and", "check", "for", "membership"], "add_tokens": "portalUrl : 'https://www.arcgis.com' , loadGroups : true", "del_tokens": "portalUrl : 'https://www.arcgis.com'", "commit_type": "add"}
{"commit_tokens": ["Add", "twig", "and", "vash", "render", "functions"], "add_tokens": "function jade ( engine , str , locals , engineOptions ) { function twig ( engine , str , locals ) { var template = engine . twig ( { data : str } ) return template . render ( locals ) } function vash ( engine , str , locals ) { var template = engine . compile ( str ) return template ( locals ) } jade : jade , 'jade-legacy' : jade , pug : jade , twig : twig , vash : vash", "del_tokens": "function pug ( engine , str , locals , engineOptions ) { jade : pug , 'jade-legacy' : pug , pug : pug", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "requiring", "*", ".", "ios", ".", "js", "modules"], "add_tokens": "mod = mod . replace ( / (\\.android|\\.ios)?\\.js$ / , '' ) ; // FIXME(mj): // This is a temporary hack until we move to getting the dependencies // from the RN packager. // See: https://github.com/mjohnston/react-native-webpack-server/issues/23 if ( mod === 'StaticContainer' ) { mod = 'StaticContainer.react' ; } module . exports = getReactNativeExternals ;", "del_tokens": "mod = mod . replace ( / \\.js$ / , '' ) ; module . exports = getReactNativeExternals ;", "commit_type": "fix"}
{"commit_tokens": ["add", "#ready", "method", "that", "got", "called", "once", "alle", "models", "are", "ready"], "add_tokens": "exports . Array = Observable . Array var utils = require ( './utils' ) exports . ready = utils . ready", "del_tokens": "exports . Array = Observable . Array", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "task", "fail", "on", "errors"], "add_tokens": "console . log ( content ) return cb ( new gutil . PluginError ( 'gulp-jscs-custom' , 'JSCS validation failed' , { showStack : false } ) )", "del_tokens": "console . log ( content ) ; //console.log(results);", "commit_type": "make"}
{"commit_tokens": ["Add", "check", "for", "in", "audio", "/", "video", "blobs", "exist"], "add_tokens": "if ( blob . audio && blob . video ) { getDataURL ( blob . audio , function ( _audioDataURL ) { getDataURL ( blob . video , function ( _videoDataURL ) { callback ( { audio : _audioDataURL , video : _videoDataURL } ) ; } else if ( blob . audio ) { getDataURL ( blob . audio , function ( _audioDataURL ) { callback ( { audio : _audioDataURL } ) ; } ) ; } else if ( blob . video ) { getDataURL ( blob . video , function ( _videoDataURL ) { callback ( { video : _videoDataURL } ) ; } ) ; }", "del_tokens": "getDataURL ( blob . audio , function ( _audioDataURL ) { getDataURL ( blob . video , function ( _videoDataURL ) { callback ( { audio : _audioDataURL , video : _videoDataURL } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "profile", "/", "template", "loading", "paths"], "add_tokens": "configuration . get ( 'baseDirectory' ) + \"/lib/profiles/*\"", "del_tokens": "configuration . get ( 'baseDirectory' ) + \"/extensions/**/profiles/**/*\"", "commit_type": "fix"}
{"commit_tokens": ["use", "enum", "for", "allowed", "tags"], "add_tokens": "\"enum\" : [ \"input\" , \"button\" , \"div\" , \"span\" /*TODO some more*/ ] , \"default\" : \"input\"", "del_tokens": "\"type\" : \"string\"", "commit_type": "use"}
{"commit_tokens": ["allows", "for", "updating", "promises", "on", "prop", "changes", "with", "shouldBrokerUpdate", "prop", "/", "opt"], "add_tokens": "loadAll , WAITING , LOADING , RESOLVED , REJECTED", "del_tokens": "loadAll", "commit_type": "allow"}
{"commit_tokens": ["Adding", "SuccssCount", ".", "startTime", "to", "get", "the", "command", "start", "time", "in", "diff", "directories"], "add_tokens": "startTime : 0 , var date = new Date ( ) ; SuccssCount . startTime = date . getTime ( ) ; var imgDiffPath = './imagediff/' + SuccssCount . startTime + '/' + this . basePath . replace ( / ^\\.?\\/ / , '' ) ;", "del_tokens": "var imgDiffPath = options . diffDir + date . getTime ( ) . toString ( ) + '/' + this . filePath ;", "commit_type": "add"}
{"commit_tokens": ["add", "option", "to", "color", "multiline", "strings"], "add_tokens": "var colorMultilineString = function ( options , line ) { if ( options . multilineStringColor === null || options . noColor ) { return line ; } else { return colors [ options . multilineStringColor ] ( line ) ; } } ; var indentLines = function ( string , spaces , options ) { return Utils . indent ( spaces ) + colorMultilineString ( options , line ) ; Utils . indent ( indentation ) + colorMultilineString ( options , '\"\"\"' ) , indentLines ( data , indentation + options . defaultIndentation , options ) , Utils . indent ( indentation ) + colorMultilineString ( options , '\"\"\"' ) // emptyArrayMsg: '(empty)', // Rendered message on empty strings // keysColor: 'blue', // Color for keys in hashes // dashColor: 'red', // Color for the dashes in arrays // stringColor: 'grey', // Color for strings // multilineStringColor: 'cyan' // Color for multiline strings // defaultIndentation: 2 // Indentation on nested objects options . multilineStringColor = options . multilineStringColor || null ;", "del_tokens": "var indentLines = function ( string , spaces ) { return Utils . indent ( spaces ) + line ; Utils . indent ( indentation ) + '\"\"\"' , indentLines ( data , indentation + options . defaultIndentation ) , Utils . indent ( indentation ) + '\"\"\"' // emptyArrayMsg: '(empty)', // Rendered message on empty strings // keysColor: 'blue', // Color for keys in hashes // dashColor: 'red', // Color for the dashes in arrays // stringColor: 'grey', // Color for strings // defaultIndentation: 2 // Indentation on nested objects", "commit_type": "add"}
{"commit_tokens": ["Fix", "absolute", "file", "path", "for", "dependency", "resolution"], "add_tokens": "let dependencyDirectory = path . dirname ( file . path ) ;", "del_tokens": "let dependencyDirectory = file . dirname ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "console", "to", "be", "called", "directly", "on", "cli", "and", "docs"], "add_tokens": "let cli = require ( '..' ) ;", "del_tokens": "let cli = require ( '../' ) ;", "commit_type": "allow"}
{"commit_tokens": ["added", "Date", "Input", "to", "component", "."], "add_tokens": "export { default as DateInput } from \"inputs/DateInput\" ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Create", "a", "new", "instance", "of", ".", "raw"], "add_tokens": "let args = { } , Object . assign ( args , this . raw ) return this . getOptions ( )", "del_tokens": "let args = this . raw , return Object . assign ( this . getOptions ( ) , this . raw )", "commit_type": "create"}
{"commit_tokens": ["Use", "rimraf", "as", "it", "handles", "edge", "cases"], "add_tokens": "var rimrafSync = require ( 'rimraf' ) . sync ; rimrafSync ( relative + '/build' ) ;", "del_tokens": "var spawnSync = require ( 'child_process' ) . spawnSync ; spawnSync ( 'rm' , [ '-rf' , relative + '/build' ] ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "context", ".", "@initialValue", "feature"], "add_tokens": "test ( ` ` , ( ) => { let context = new Context ( { \"@initialValue\" : { \"@type\" : \"Thing\" } } ) ; let data = { } ; expect ( context ) . toHaveProperty ( \"initialValue\" , { \"@type\" : \"Thing\" } ) ; expect ( context . map ( data ) ) . toHaveProperty ( \"@type\" , \"Thing\" ) ; expect ( context . map ( data , { } ) ) . toHaveProperty ( \"@type\" , \"Thing\" ) ; expect ( context . map ( data , { \"@type\" : \"Organization\" } ) ) . toHaveProperty ( \"@type\" , \"Organization\" ) ; expect ( context . map ( [ { \"name\" : \"bob\" } ] ) [ 0 ] ) . toMatchObject ( { \"@type\" : \"Thing\" , \"name\" : \"bob\" } ) ; } ) ; key : 1 , key : 2 , id : 1 , id : 2 , a : \"foo\" , b : { c : \"foo\" } , a : \"foo\" , b : \"foo\" ,", "del_tokens": "key : 1 , key : 2 , id : 1 , id : 2 , a : \"foo\" , b : { c : \"foo\" } , a : \"foo\" , b : \"foo\" ,", "commit_type": "add"}
{"commit_tokens": ["allow", "for", "beforeUpdate", "hook", "in", "updateStack"], "add_tokens": "options . beforeUpdate = options . beforeUpdate || function ( next ) { next ( ) ; } ; options . beforeUpdate ( function ( err , res ) { var templateName = path . basename ( options . template ) ; getTemplateUrl ( templateName , configDetails . template , options . region , function ( err , url ) { if ( err ) return callback ( err ) ; options . templateUrl = url ; cfn . updateStack ( cfnParams ( options , configDetails ) , callback ) ; } ) ;", "del_tokens": "var templateName = path . basename ( options . template ) ; getTemplateUrl ( templateName , configDetails . template , options . region , function ( err , url ) { options . templateUrl = url ; cfn . updateStack ( cfnParams ( options , configDetails ) , callback ) ;", "commit_type": "allow"}
{"commit_tokens": ["added", "amd", "to", "cjs", "test"], "add_tokens": "describe ( 'amd - cjs' , function ( ) { it ( 'should work' , function ( done ) { convert ( \"amd.js\" , amd2cjs , \"amd_cjs.js\" , done ) } ) ; } ) ;", "del_tokens": "cjs2global = require ( \"../lib/cjs_global\" ) , / * fs . readFile ( __dirname + \"/es6_module.js\" , function ( err , data ) { var res = es62cjs ( { source : \"\" + data , address : __dirname + \"/es6_module.js\" } ) ; console . log ( \"\\n\\n\" , res ) res = cjs2steal ( { source : res } ) console . log ( \"\\n\\n\" , res ) } ) ; * / / * fs . readFile ( __dirname + \"/cjs_module.js\" , function ( err , data ) { cjs2global ( { source : \"\" + data , address : __dirname + \"/cjs_module.js\" } ) ; } ) ; * / / * fs . readFile ( __dirname + \"/amd_module.js\" , function ( err , data ) { var res = amd2cjs ( { source : \"\" + data , address : __dirname + \"/amd_module.js\" } ) ; console . log ( res ) ; } ) ; * /", "commit_type": "add"}
{"commit_tokens": ["make", "games", "list", "only", "games", "that", "have", "a", "client", "ie", "a", "game", "running"], "add_tokens": "Game . prototype . hasClient = function ( ) { return this . client !== undefined ; } ; if ( game . hasClient ( ) ) { gameList . push ( { gameId : id , numPlayers : game . getNumPlayers ( ) , } ) ; }", "del_tokens": "gameList . push ( { gameId : id , numPlayers : game . getNumPlayers ( ) , } ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "console", ".", "log", "and", "try", "/", "catch", "for", "loading", "tracking"], "add_tokens": "console . log ( 'corge' ) ; var epsilon , pepsilon try { epsilon = require ( './doesnt-exist' ) ; pepsilon = require ( 'test-local-deps/also/doesnt-exist' ) ; } catch ( e ) { console . log ( 'don\\'t exist' ) ; }", "del_tokens": "var epsilon = require ( './doesnt-exist' ) , pepsilon = require ( 'test-local-deps/also/doesnt-exist' )", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "global", "typedef", "to", "the", "namespaced", "src", "to", "test", "with", "."], "add_tokens": "/ ** * @ summary This is a test instance method of the global test class to check that global type definitions are documented . * @ memberof GlobalClass # * @ function testMethod * @ param { SomeType } type - The parameter which is of type SomeType * / GlobalClass . prototype . testTypeDefMethod = function ( type ) { } ; window . GlobalClass = GlobalClass ; / ** * Some global type . * @ global * @ typedef { Object } SomeType * @ property { string } someProp * /", "del_tokens": "window . GlobalClass = GlobalClass ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "multiple", "event", "support", "in", "EE"], "add_tokens": "var _method = EventEmitter . prototype [ method ] EventEmitter . prototype [ method ] = function ( event ) { var args = _slice . call ( arguments , 0 ) , self = this if ( / \\s / . test ( event ) ) { event . replace ( / \\S+ / g , function ( event ) { args [ 0 ] = event _method . apply ( self , args ) } ) _method . apply ( self , args ) // Alias due to public demand EventEmitter . prototype . on = EventEmitter . prototype . addListener", "del_tokens": "// Alias due to public demand EventEmitter . prototype . on = EventEmitter . prototype . addListener var method = EventEmitter . prototype [ method ] EventEmitter . prototype . method = function ( event ) { var args = _slice . call ( arguments , 1 ) if ( / \\S / . test ( event ) ) { event . replace ( / \\S+ / g , util . applier ( method , this , args ) ) method . apply ( this , args )", "commit_type": "fix"}
{"commit_tokens": ["Use", "latest", "Docker", "image", "version"], "add_tokens": "exec ( ` ${ rootFolder } \\ exec ( ` ${ rootFolder } \\", "del_tokens": "exec ( ` ${ rootFolder } \\ exec ( ` ${ rootFolder } \\", "commit_type": "use"}
{"commit_tokens": ["Moved", "back", "to", "strict", "mode"], "add_tokens": "'use strict' ; //eslint-disable-line", "del_tokens": "", "commit_type": "move"}
{"commit_tokens": ["Added", "handler", "name", "to", "the", "protocol", "-", "in", "event"], "add_tokens": "this . emit ( 'protocol-in' , { handler : handlerName , type : Messages . nameById [ type ] , message : msg } ) ;", "del_tokens": "this . emit ( 'protocol-in' , { type : Messages . nameById [ type ] , message : msg } ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "try", "catch", "for", "top", "-", "level"], "add_tokens": "try { _TOKEN_ ( ) ; } catch ( err ) { err . stack = filterInternalFrames ( err . stack ) ; catchFn ( err ) ; }", "del_tokens": "_TOKEN_ ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "self", "-", "references", "in", "testUtils", "/", "pings", ".", "js"], "add_tokens": "return module . exports . pings . getTelemetryPings ( driver , { throw new module . exports . pings . SearchError ( condition ) ;", "del_tokens": "return getTelemetryPings ( driver , { throw new this . SearchError ( condition ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "api", ".", "js", "to", "look", "for", "the", "script", "key", "/", "value", "in", "the", "app", "s", "configuration", "before", "looking", "in", "the", "app", "s", "package", ".", "json", "for", "main", "key", "/", "value", "."], "add_tokens": "if ( globalConfig . apps [ appname ] . script ) { } else if ( pkg && pkg . main ) { main = pkg . main", "del_tokens": "if ( pkg && pkg . main ) { main = pkg . main } else if ( globalConfig . apps [ appname ] . script ) {", "commit_type": "update"}
{"commit_tokens": ["Add", "spec", "for", "unbinding", "events"], "add_tokens": "it ( \"unbinds events when removed\" , function ( ) { location . hash = '' ; var hash = L . PolarMap . Util . hash ( map , { getBaseLayer : function ( ) { return map . options . baseLayer . options . name ; } , setBaseLayer : function ( name ) { map . loadTileProjection ( baseLayer ) ; } } ) ; map . removeControl ( hash ) ; map . setView ( [ 51.505 , - 0.09 ] , 13 ) ; expect ( location . hash ) . to . be ( '' ) ; } ) ;", "del_tokens": "it ( \"unbinds events when removed\" ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "body", "content", "comparison", "."], "add_tokens": "function getBodyContent ( req ) { if ( req && req . body ) { return req . body . trim ( ) ; } return null ; } var reqBody = getBodyContent ( httpReq ) ; var specBody = getBodyContent ( specReq ) ; if ( reqBody === specBody ) { var jsonEncodedSpecBody = JSON . parse ( specBody ) ; return urlParser . jsonToFormEncodedString ( jsonEncodedSpecBody ) === reqBody ; return lodash . isEqual ( JSON . parse ( reqBody ) , JSON . parse ( specBody ) ) ;", "del_tokens": "if ( httpReq . body === specReq . body ) { var jsonEncodedSpecBody = JSON . parse ( specReq . body ) ; return urlParser . jsonToFormEncodedString ( jsonEncodedSpecBody ) === httpReq . body ; return lodash . isEqual ( JSON . parse ( httpReq . body ) , JSON . parse ( specReq . body ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "docs", "and", "bug", "fixes", "for", "responsive", "rendering"], "add_tokens": "var include = jQuery ( element ) ; jQuery . getJSON ( src , function ( data ) { jQuery ( 'esi\\\\:include, csi\\\\:include' ) . each ( timbits . processCSI ) ; jQuery ( function ( ) {", "del_tokens": "var include = $ ( element ) ; $ . getJSON ( src , function ( data ) { $ ( 'esi\\\\:include, csi\\\\:include' ) . each ( timbits . processCSI ) ; $ ( function ( ) {", "commit_type": "update"}
{"commit_tokens": ["changed", "close", "anchor", "to", "a", "button"], "add_tokens": "const close = document . createElement ( 'button' ) ; const closeSpan = document . createElement ( 'span' ) ; const internalText = ( 'textContent' in titleText ) ? 'textContent' : 'innerText' ; if ( opts . title ) titleText [ internalText ] = opts . title ; close . setAttribute ( 'type' , 'button' ) ; close . setAttribute ( 'aria-label' , 'close' ) ; closeSpan [ internalText ] = '✕'; closeSpan . setAttribute ( 'aria-hidden' , 'true' ) ; close . appendChild ( closeSpan ) ; paragraph [ internalText ] = opts . text ;", "del_tokens": "const close = document . createElement ( 'a' ) ; if ( opts . title ) titleText . innerText = opts . title ; close . innerText = '✕'; close . href = '#' ; paragraph . innerText = opts . text ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "missing", "fs", ".", "readFileSync"], "add_tokens": "var fs = require ( 'fs' ) ; exports . version = JSON . parse ( fs . readFileSync ( './package.json' ) ) . version ;", "del_tokens": "exports . version = JSON . parse ( './package.json' ) . version ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "in", "row", "configuration", "example"], "add_tokens": "import ExampleRowClassName from '../components/ExampleRowClassName' ; import exampleRowClassName from '!raw!../components/ExampleRowClassName' ; previewCodeStart : 36 , } , { id : 'example-row-class-name' , label : 'Row highlighting' , description : ` This example shows how to add class names to rows based on the data . Here all rows with MLL3 equal to MUT are colored . ` , component : ExampleRowClassName , code : exampleRowClassName , github : ` ${ githubRoot } ` , previewCodeStart : 48 , < CodeExample language = \"javascript\" code = { example . code } previewStart = { example . previewCodeStart } / >", "del_tokens": "< CodeExample language = \"javascript\" code = { example . code } / >", "commit_type": "add"}
{"commit_tokens": ["add", "eslint", "and", "conform", "to", "the", "style"], "add_tokens": "child . completePath = this . props . path . replace ( / \\/$ / , '' ) + child . props . path update ( props ) {", "del_tokens": "child . completePath = this . props . path . replace ( / \\/$ / , \"\" ) + child . props . path update ( props , children ) {", "commit_type": "add"}
{"commit_tokens": ["Allow", "entire", "directories", "to", "be", "selected", "for", "upload", "(", "chrome", "only", ")"], "add_tokens": "var relativePath = file . webkitRelativePath || file . fileName || file . name ; // Some confusion in different versions of Firefox return ( size + '-' + relativePath . replace ( / [^0-9a-zA-Z_-] / img , '' ) ) ; // directories have size == 0 if ( file . size > 0 && ! $ . getFromUniqueIdentifier ( $h . generateUniqueIdentifier ( file ) ) ) { $ . relativePath = file . webkitRelativePath || $ . fileName ; params . push ( [ 'resumableRelativePath' , encodeURIComponent ( $ . fileObj . relativePath ) ] . join ( '=' ) ) ; formData . append ( 'resumableRelativePath' , $ . fileObj . relativePath ) ; $ . assignBrowse = function ( domNodes , isDirectory ) { if ( isDirectory ) { input . setAttribute ( 'webkitdirectory' , 'webkitdirectory' ) ; } debugger ; appendFilesFromFileList ( e . target . files ) ; e . target . value = '' ;", "del_tokens": "var fileName = file . fileName || file . name ; // Some confusion in different versions of Firefox return ( size + '-' + fileName . replace ( / [^0-9a-zA-Z_-] / img , '' ) ) ; if ( ! $ . getFromUniqueIdentifier ( $h . generateUniqueIdentifier ( file ) ) ) { $ . assignBrowse = function ( domNodes ) { appendFilesFromFileList ( input . files ) ; input . value = '' ;", "commit_type": "allow"}
{"commit_tokens": ["Added", "support", "for", "entityAspect", ".", "isNavigationPropertyLoaded", "function"], "add_tokens": "", "del_tokens": "// Uncomment when we implement entityAspect.isNavigationPropertyLoaded method // targetEntity.entityAspect.markNavigationPropertyAsLoaded(navigationProperty); // Uncomment when we implement entityAspect.isNavigationPropertyLoaded method // targetEntity.entityAspect.markNavigationPropertyAsLoaded(navigationProperty); // Uncomment when we implement entityAspect.isNavigationPropertyLoaded method // relatedEntity.entityAspect.markNavigationPropertyAsLoaded(inverseProperty); // can't call _markAsLoaded here because this may be only a partial load. // Uncomment when we implement entityAspect.isNavigationPropertyLoaded method // relatedEntity.entityAspect.markNavigationPropertyAsLoaded(inverseProperty);", "commit_type": "add"}
{"commit_tokens": ["fix", "zero", "delay", "&", "ie", "restore", "invisible", "focus"], "add_tokens": "//IE8 will throw if element for setting focus is invisible try { self . _restoreFocus . focus ( ) ; } catch ( e1 ) { ( function ( ) { var elementToFocus = self . _restoreFocus ; $timeout ( function ( ) { if ( elementToFocus ) { try { elementToFocus . focus ( ) ; } catch ( e2 ) { } } } , 100 ) ; } ) ( ) ; }", "del_tokens": "self . _restoreFocus . focus ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "proper", "var", "name", "in", "quicksort", "docs"], "add_tokens": "* @ param { number } right The index to sort to . * @ param { number } right The index to sort to . * @ param { number } right The index to sort to .", "del_tokens": "* @ param { number } left The index to sort to . * @ param { number } left The index to sort to . * @ param { number } left The index to sort to .", "commit_type": "use"}
{"commit_tokens": ["Add", "CAG", "to", "compat", "file", ".", "Fixes", "Hexagon", "in", "jscad", "-", "hardware", "file"], "add_tokens": "var jsCadCSG = { CSG , CAG } ;", "del_tokens": "var jsCadCSG = { CSG } ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "alternative", "iOS", "fullscreen", "simulation"], "add_tokens": "// Set various callback overrides in iOS. if ( Util . isIOS ( ) ) { this . manager . setFullscreenCallback ( function ( ) { Util . sendParentMessage ( { type : 'enter-fullscreen' } ) ; } ) ; this . manager . setExitFullscreenCallback ( function ( ) { Util . sendParentMessage ( { type : 'exit-fullscreen' } ) ; } ) ; this . manager . setVRCallback ( function ( ) { Util . sendParentMessage ( { type : 'enter-vr' } ) ; } ) ; } // On IE 11, if an 'image' param is provided, load it instead of showing // an error. // When exiting VR mode, make sure we emit back an exit-fullscreen event. if ( ! isVR && Util . isIOS ( ) ) { Util . sendParentMessage ( { type : 'exit-fullscreen' } ) ; }", "del_tokens": "// On iOS and IE 11, if an 'image' param is provided, load it instead of // showing an error.", "commit_type": "add"}
{"commit_tokens": ["Fix", "missing", "-", "in", "negative", "margin", "helper"], "add_tokens": "[ ` ${ modifier } ` ] : {", "del_tokens": "[ ` ${ modifier } ` ] : {", "commit_type": "fix"}
{"commit_tokens": ["remove", "var", "path", "simplify", "path", "to", "functions", "lib", "discard", "old", "test", "files"], "add_tokens": "expand ( [ 'functions/*.js' ] , { cwd : __dirname } ) . map ( function ( filepath ) {", "del_tokens": "var cwd = path . join ( __dirname , '../' ) ; expand ( [ 'lib/functions/*.js' ] , { cwd : cwd } ) . map ( function ( filepath ) {", "commit_type": "remove"}
{"commit_tokens": ["Add", "fs", ".", "type", "(", "github", "or", "local", ")"], "add_tokens": "Driver . id = \"local\" ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Make", "install", "callback", "into", "Error"], "add_tokens": "callBack ( new Error ( 'Could not locate JXCore folder. Exiting the thali plugin installation..' ) , null ) ;", "del_tokens": "callBack ( 'Could not locate JXCore folder. Exiting the thali plugin installation..' , null ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "element", "()", ".", "isVisible", "()"], "add_tokens": "beforeEach ( function ( ) { elt . innerHTML = 'test' ; afterEach ( function ( ) { describe ( \"isVisible()\" , function ( ) { it ( \"should return true if the element is visible\" , function ( ) { assert . ok ( element ( '#foo' ) . isVisible ( ) ) ; } ) ; it ( \"should return false if the element's visibility is set to hidden\" , function ( ) { document . getElementById ( 'foo' ) . setAttribute ( 'style' , 'visibility: hidden' ) ; assert . notOk ( element ( '#foo' ) . isVisible ( ) ) ; } ) ; } ) ; } ) ;", "del_tokens": "before ( function ( ) { after ( function ( ) { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "the", "engine", "to", "support", "code", "generation", "end", "-", "to", "-", "end", "."], "add_tokens": "module . exports = { } ;", "del_tokens": "module . exports = ( { rasterize : ( pState , fCallback ) => { pState . Behaviors . stateLog ( pState , 'This is really rasterizey...' ) ; fCallback ( false , pState ) ; } } ) ;", "commit_type": "update"}
{"commit_tokens": ["changed", "statSync", "in", "a", "transform", "test"], "add_tokens": "const oldSize = fs . statSync ( path . join ( 'src' , 'images' , 'bigimage.jpg' ) ) . size ; const newSize = fs . statSync ( path . join ( tempFolder , 'images' , 'bigimage.jpg' ) ) . size ; t . truthy ( newSize < oldSize ) ;", "del_tokens": "const oldStat = stat ( path . join ( 'src' , 'images' , 'bigimage.jpg' ) ) ; const newStat = stat ( path . join ( tempFolder , 'images' , 'bigimage.jpg' ) ) ; return Promise . all ( [ oldStat , newStat ] ) ; } ) . then ( ( results ) => { return t . truthy ( results [ 0 ] . size > results [ 1 ] . size ) ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "an", "issue", "in", "the", "previous", "prerelease"], "add_tokens": "_ . each ( bodyParameters , ( bodyParameter , index ) => { this . pushSchemaAsset ( bodyParameter . schema , request , this . path . concat ( [ 'parameters' , index , 'schema' ] ) ) ; this . pushSchemaAsset ( schema , response , this . path ) ; pushSchemaAsset ( schema , payload , path ) { this . createSourceMap ( schemaAsset , path ) ;", "del_tokens": "_ . each ( bodyParameters , ( bodyParameter ) => { this . pushSchemaAsset ( bodyParameter . schema , request ) ; this . pushSchemaAsset ( schema , response ) ; pushSchemaAsset ( schema , payload ) { this . createSourceMap ( schemaAsset , this . path ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "body", "size", "limiter", "middleware", "."], "add_tokens": "[ 'access_logger' , 'transaction_id' , 'body_size_limiter' ] . forEach ( function ( module ) {", "del_tokens": "[ 'access_logger' , 'transaction_id' ] . forEach ( function ( module ) {", "commit_type": "add"}
{"commit_tokens": ["Fixing", "all", "events", ".", "What", "is", "going", "on", "with", "this", "library?!"], "add_tokens": "this . page . sendEvent . apply ( self . page , arguments ) ;", "del_tokens": "this . page . sendEvent . apply ( self . page , [ 'mousedown' ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "standalone", "-", "html", ".", "js"], "add_tokens": "var escapeChar = ( commandLine . escape === undefined ) ? '[]' : commandLine . escape ;", "del_tokens": "var escapeChar = ( commandLine . escape === undefined ) ? '' : commandLine . escape ;", "commit_type": "update"}
{"commit_tokens": ["Made", "callable", "it", "s", "own", "thing", "."], "add_tokens": "var callable = require ( './callable' ) ; / ** * Documentation forthcoming . * * @ private * @ method * / Meta . prototype . __call__ = function ( ) { return this . create . apply ( this , arguments ) ; } ; / ** * Documentation forthcoming . * * @ private * @ method * / Meta . prototype . _init = function ( ) { this . prototype = this . __class__ . prototype ; } ; var ChildMeta = callable ( function ( ) { return this . _init ( ) ; } ) ;", "del_tokens": "var setPrototypeOf = require ( './set-prototype-of' ) ; var ChildMeta = function ( ) { var callable = function ( ) { return construct ( ChildClass , arguments ) ; } ; setPrototypeOf ( callable , ChildMeta . prototype ) ; callable . prototype = ChildClass . prototype ; return callable ; } ;", "commit_type": "make"}
{"commit_tokens": ["update", "peliasStreet", "to", "make", "use", "of", "the", "new", "synonyms", "added", "by", "@stephenkhess"], "add_tokens": "// note: more descriptive tokens must come before less descriptive ones // eg: 'southwest' must come before 'west' else 'southwest foo' -> 'southw foo' \"northeast => ne\" , \"north => n\" , \"south => s\" , \"east => e\" , \"west => w\"", "del_tokens": "\"north => n\" , \"south => s\" , \"east => e\" , \"west => w\" , \"northeast => ne\"", "commit_type": "update"}
{"commit_tokens": ["Updated", "lib", "/", "mbr", ":", "Fixed", "base", "format", "init"], "add_tokens": "if ( ! ( this instanceof MBR ) || this . format === 'MBR' ) return MBR . parse ( buffer , start , end ) this . partitions . push ( new MBR . Partition ( ) ) this . parse ( buffer , start , end ) MBR . parse = function ( value , start , end ) { var buffer = value . slice ( start , end )", "del_tokens": "if ( ! ( this instanceof MBR ) ) return MBR . parse ( buffer ) this . partitions . push ( new MBR . Partition ( ) ) this . buffer = buffer . slice ( start , end ) MBR . parse = function ( buffer ) {", "commit_type": "update"}
{"commit_tokens": ["remove", "all", "randomness", "from", "model", ".", "js"], "add_tokens": "var key = keys [ ~ ~ ( random * keys . length ) ]", "del_tokens": "var key = keys [ ~ ~ ( Math . random ( ) * keys . length ) ]", "commit_type": "remove"}
{"commit_tokens": ["Fix", "a", "bug", "with", "messages", "looping", "forever"], "add_tokens": "if ( config . prompt ) { if ( config . prompt ) {", "del_tokens": "if ( data . prompt ) { if ( data . prompt ) {", "commit_type": "fix"}
{"commit_tokens": ["Allowing", "for", "stdin", "source", "."], "add_tokens": "return ! input ? undefined : input . toString ( ) . toLowerCase ( )", "del_tokens": "return input . toString ( ) . toLowerCase ( )", "commit_type": "allow"}
{"commit_tokens": ["adding", "encoding", "to", "exports", "for", "utf8", "chars"], "add_tokens": "var cmd = [ 'ogr2ogr' , '-f' , ogrFormats [ format ] , ( format == 'zip' ) ? outFile . replace ( 'zip' , 'shp' ) : outFile , inFile , '-lco' , 'ENCODING=UTF-8' ] ;", "del_tokens": "var cmd = [ 'ogr2ogr' , '-f' , ogrFormats [ format ] , ( format == 'zip' ) ? outFile . replace ( 'zip' , 'shp' ) : outFile , inFile , '-lco' , 'GEOMETRY=AS_XY' ] ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "legacy", "issues", "around", "keyChecking"], "add_tokens": "// console.log(\"--------------------------------------- QUERY\") // console.dir(options)", "del_tokens": "console . log ( \"--------------------------------------- QUERY\" ) console . dir ( options )", "commit_type": "fix"}
{"commit_tokens": ["Making", "polymer", "controls", "better", "."], "add_tokens": "var holder ; var execute = Delegate ( this , function ( error ) { if ( error ) { executing = false ; console . error ( 'Holder error' , error ) ; return ; } if ( typeof this . onError === 'function' ) this . onError ( 'timedout' , 'Acknowledge timeout.' ) ; if ( ! executing ) return ; if ( typeof this . onError === 'function' ) this . onError ( 'timedout' , 'Response not received in time.' ) ; if ( ! executing ) return ; holder . cancel ( ) ; if ( typeof this . onError === 'function' ) this . onError ( 'timedout' , 'At least one RPC holder did not release the implementation of the action.' ) ; holder = new Holder ( request , events , execute ) ; if ( ! executing ) return ;", "del_tokens": "var execute = Delegate ( this , function ( ) { if ( typeof this . onError === 'function' ) this . onError ( 'timedout' , 'Acknowledge timeout' ) ; if ( timedout ) return ; if ( typeof this . onError === 'function' ) this . onError ( 'timedout' , 'Response not received in time' ) ; if ( timedout ) return ; if ( typeof this . onError === 'function' ) this . onError ( 'timedout' , 'RPC holders did not freed' ) ; var holder = new Holder ( request , events , execute ) ; if ( timedout ) return ;", "commit_type": "make"}
{"commit_tokens": ["Made", "the", "action", "type", "slightly", "taller"], "add_tokens": "paddingTop : 6 ,", "del_tokens": "paddingTop : 4 ,", "commit_type": "make"}
{"commit_tokens": ["Add", "possibility", "to", "add", "a", "SVG", "in", "toDaistereotopicSVG", "to", "allow", "testing"], "add_tokens": "var svg = options . svg ; if ( ! svg ) svg = this . toSVG ( width , height , prefix ) ;", "del_tokens": "var svg = this . toSVG ( width , height , prefix ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "profiling", "/", "list", "table", "margins"], "add_tokens": "table = $ ( '<table style=\"margin:1em 2em;\"><thead style=\"font-weight: bold;\"><tr><td>Channel Name</td><td>Members</td><td style=\"padding-left: 2em;\">Topic</td></tr></thead><tbody style=\"vertical-align: top;\"></tbody>' ) ;", "del_tokens": "console . log ( '/list start' ) ; console . profile ( 'list' ) ; table = $ ( '<table><thead style=\"font-weight: bold;\"><tr><td>Channel Name</td><td>Members</td><td style=\"padding-left: 2em;\">Topic</td></tr></thead><tbody style=\"vertical-align: top;\"></tbody>' ) ; console . profileEnd ( ) ; console . log ( '/list end.' ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "some", "logging", "to", "tests"], "add_tokens": "var parsed = templates . parse ( raw [ key ] , data ) ; if ( parsed !== expected [ key ] ) { fs . writeFile ( path . join ( TEMPLATES_DIRECTORY , key + '.log' ) , parsed ) ; } else { fs . unlink ( path . join ( TEMPLATES_DIRECTORY , key + '.log' ) ) ; } assert . equal ( parsed , expected [ key ] ) ;", "del_tokens": "assert . equal ( templates . parse ( raw [ key ] , data ) , expected [ key ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "positioning", "of", "page", "-", "margin", "boxes", "along", "the", "fixed", "dimension", "of", "the", "page"], "add_tokens": "var marginInside = adapt . pm . toExprZeroAuto ( scope , style [ \"margin-\" + insideName ] , pageMargin ) ; var marginOutside = adapt . pm . toExprZeroAuto ( scope , style [ \"margin-\" + outsideName ] , pageMargin ) ;", "del_tokens": "var marginInside = adapt . pm . toExprAuto ( scope , style [ \"margin-\" + insideName ] , pageMargin ) ; var marginOutside = adapt . pm . toExprAuto ( scope , style [ \"margin-\" + outsideName ] , pageMargin ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "strange", "behaviour", "of", "using", "get", "path", "instead", "of", "default", "path", "for", "delete", "when", "no", "explicit", "delete", "path", "was", "set", "."], "add_tokens": "this . deletePath = paths [ 'delete' ] || paths . default ; } if ( options . forAccountPath !== undefined ) { if ( object . _id !== undefined || this . options . saveMethod === 'PUT' ) { } ) ;", "del_tokens": "this . deletePath = paths [ 'delete' ] || paths . get || paths . default ; } ; if ( options . forAccountPath != null ) { if ( object . _id != null || this . options . saveMethod == 'PUT' ) { } )", "commit_type": "remove"}
{"commit_tokens": ["Fix", "producer", "instance", "bootstrap", "clean", "up"], "add_tokens": "BOOTSTRAPPING : 4 , if ( dispatcherInstance . isConsumer ( ) ) instance . emit ( events . MESSAGE_NEXT ) ;", "del_tokens": "CONSUMING_MESSAGE : 4 , BOOTSTRAPPING : 5 , instance . emit ( events . MESSAGE_NEXT ) ; state = states . CONSUMING_MESSAGE ; state = states . UP ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "base", "structure", "for", "api"], "add_tokens": "var Q = require ( 'q' ) ; var path = require ( 'path' ) ; root : path . resolve ( __dirname , './fixtures' ) return fs . read ( 'README.md' ) ; } ) ; it ( 'should fail for file out of the repo' , function ( ) { return fs . read ( '../../local.js' ) . then ( function ( ) { throw \"Should have failed\" ; } , function ( ) { return Q ( ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "old", "-", "IE", "forEach", "again", ".", "Hrm", "..."], "add_tokens": "callback ( attr . name , store . deserialize ( storage . getAttribute ( attr . name ) ) )", "del_tokens": "callback ( attr . name , store . deserialize ( storage . getAttribute ( key ) ) )", "commit_type": "fix"}
{"commit_tokens": ["add", "rinfo", "field", "to", "the", "service", "object"], "add_tokens": "this . _onresponse = function ( packet , rinfo ) { var matches = buildServicesFor ( name , packet , rinfo ) function buildServicesFor ( name , packet , rinfo ) { service . rinfo = rinfo ;", "del_tokens": "this . _onresponse = function ( packet ) { var matches = buildServicesFor ( name , packet ) function buildServicesFor ( name , packet ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "dynamic", "volume", "option", "."], "add_tokens": "* Same as GainNode in web - audio - api as a generic function . * stream in stream . js , pull - stream in pull . js , element in element . js var noop = function ( ) { } ; * Create pcm volume controller . if ( ! options ) options = 1 ; if ( typeof options === 'number' || typeof options . volume === 'number' ) { // adjust gain(Number) || gain({ volume: Number }) var volume = options . volume || options ; options = { volume : function ( x ) { return x * volume } } ; } else if ( typeof options === 'function' ) { // adjust gain(Function); write . end = noop ; // Write volume to buffer // Apply volume function on buffer util . fill ( buf , volume ) ; // Sync return buffer.", "del_tokens": "* Same as GainNode in web - audio - api , but for streams . * Create pcm stream volume controller . if ( typeof options === 'number' ) { } else if ( ! options ) { options = { volume : 1 } ; write . end = function ( ) { } ; util . fill ( buf , function ( x ) { return x * volume ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "mapbox", "-", "gl", "-", "layer", "to", "TilePane"], "add_tokens": "map . getPanes ( ) . tilePane . appendChild ( this . _container ) ; map . getPanes ( ) . tilePane . removeChild ( this . _container ) ;", "del_tokens": "this . getPane ( ) . appendChild ( this . _container ) ; this . getPane ( ) . removeChild ( this . _container ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "ability", "to", "run", "JSHint", "test", "from", "file", ":", "///", "protocol", "."], "add_tokens": "( this . status === 0 || this . status === 200 ) ? onLoad ( null , name , this . responseText ) : onLoad ( this . statusText , name ) ;", "del_tokens": "this . status === 200 ? onLoad ( null , name , this . responseText ) : onLoad ( this . statusText , name ) ;", "commit_type": "add"}
{"commit_tokens": ["Change", "helper", "import", "in", "the", "test", "to", "play", "nice", "with", "the", "latest", "ember"], "add_tokens": "} from '../../../helpers/linkify' ;", "del_tokens": "} from 'ember-linkify/helpers/linkify' ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "validation", "of", "arrays", "of", "pojos"], "add_tokens": "if ( expectedType . length > 3 && expectedType . substr ( expectedType . length - 2 , 2 ) === '[]' ) { var asserter = asserters [ individualPojoType ] ;", "del_tokens": "if ( expectedType . length > 3 && expectedType . substr ( expectedType . length - 3 , 2 ) === '[]' ) { var asserter = this [ 'assertValid' + individualPojoType ] ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "undefined", "values", "and", "simplify", "code"], "add_tokens": "let obj = { a : 1 , c : undefined , b : 'hello' } let expected = JSON . stringify ( obj ) let actual = stringify ( obj ) assert . is ( actual , expected ) obj = { b : 'hello' , a : undefined , c : 1 } assert . end ( ) } ) test ( 'undefined values and indented' , function ( assert ) { let obj = { a : 1 , c : undefined , b : 'hello' } let expected = JSON . stringify ( obj , null , 2 ) let actual = stringify ( obj , null , 2 ) assert . is ( actual , expected )", "del_tokens": "let obj , expected , actual obj = { a : 1 , c : undefined , b : 'hello' }", "commit_type": "fix"}
{"commit_tokens": ["Added", "functionality", "updated", "docs", "."], "add_tokens": "* @ property { Complex } I The imaginary number .", "del_tokens": "* The imaginary number . * @ property I", "commit_type": "add"}
{"commit_tokens": ["Add", "recognition", "of", "asynchronous", "functions"], "add_tokens": "} ; case \"AsyncGeneratorFunction\" : typeName = \"async function*()\" ; break ; case \"AsyncFunction\" : typeName = \"async function()\" ; break ;", "del_tokens": "} let floored ;", "commit_type": "add"}
{"commit_tokens": ["fix", "safari", "private", "browsing", "mode"], "add_tokens": "/ ** * Use ` ` to detect private browsing mode * / const TEST_KEY = '!!storage-emitter-key-test' const isLocalStorageAvailable = ! isPrivateBrowsingMode ( ) const cmd = JSON . parse ( e . newValue ) if ( isLocalStorageAvailable ) { const cmd = JSON . stringify ( { event , args } ) localStorage . setItem ( KEY , cmd ) localStorage . removeItem ( KEY ) } / ** * Check browser is in private browsing mode or not * * @ return { Boolean } * / function isPrivateBrowsingMode ( ) { try { localStorage . setItem ( TEST_KEY , '1' ) localStorage . removeItem ( TEST_KEY ) return false } catch ( error ) { return true } }", "del_tokens": "var cmd = JSON . parse ( e . newValue ) var cmd = JSON . stringify ( { event : event , args : args } ) localStorage . setItem ( KEY , cmd ) localStorage . removeItem ( KEY )", "commit_type": "fix"}
{"commit_tokens": ["fix", "host", "+", "port", "serialization"], "add_tokens": "var url = require ( 'url' ) ; var urlObject = url . parse ( 'http://' + this . request . header . host ) ; var httpsHost = hostname || urlObject . hostname ; var redirectTo = 'https://' + httpsHost + ':' + httpsPort ; this . response . redirect ( redirectTo ) ;", "del_tokens": "var redirectTo = 'https://' ; redirectTo += hostname || this . request . hostname ; this . response . redirect ( redirectTo + ':' + httpsPort ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "more", "presets", "and", "reordering", "properties"], "add_tokens": "esc : [ '\\\\' ] toQuote : [ ',' , '\\r\\n' , '\\n' , '\\r' ] , toEsc : [ '\"' ] var tsvQuotOpts = { sep : [ '\\t' ] , linesep : [ '\\r\\n' , '\\n' , '\\r' ] , quote : [ '\"' ] , toQuote : [ '\\t' , '\\r\\n' , '\\n' , '\\r' ] esc : [ '\"' ] , toEsc : [ '\"' ] } ;", "del_tokens": "esc : [ '\\\\' ] , toQuote : [ ] toEsc : [ '\"' ] , toQuote : [ ',' , '\\r\\n' , '\\n' , '\\r' ] options . charsEncoding = options . charsEncoding || csvOpts . charsEncoding ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "conversion", "to", "pass", "all", "the", "tests"], "add_tokens": "var name , root ; root = typeof global !== \"undefined\" && global !== null ? global : this ; root [ name ] = obj [ name ] ;", "del_tokens": "var name ; this [ name ] = obj [ name ] ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "with", "some", "new", "patches", "that", "should", "resolve", "7", "&", "9"], "add_tokens": "'use strict' ; grunt . registerTask ( 'test' , [ 'ftp_push' ] ) ;", "del_tokens": "'use strict' ; } , test : { options : { authKey : \"serverB\" , host : \"server.sample.com\" , dest : \"test/html\" , port : 21 } , files : [ // Enable Dynamic Expansion, Src matches are relative to this path, Actual Pattern(s) to match { expand : true , cwd : '.' , src : [ 'README.md' ] } ] grunt . registerTask ( 'test' , [ 'ftp_push:test' ] ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "schema", "analyzation", "for", "post", "/", "put", "data"], "add_tokens": "db . putData ( 'tmp' , 5 , { name : 'String' , birth : 'Date' , age : 1 } ) ; // db.postTable('user', {name: 'String', birth: 'Date', age: 1}); schema = this . getSchema ( table ) ; var label = table . label ; if ( dataSize ( schema . columns ) == 0 ) { if ( label ) { var tableOBJ = { \"name\" : table , \"label\" : label } ; this . setSchema ( tableOBJ , getValueSchema ( data ) ) ; } else { this . setSchema ( table , getValueSchema ( data ) ) ; } schema = this . getSchema ( table ) ; }", "del_tokens": "db . postTable ( 'user' , { name : 'String' , birth : 'Date' , age : 1 } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", ";", "improved", "htmlfile", "framing", "size", "."], "add_tokens": "req . res . write ( '<html><body>' + '<script>var _ = function (msg) { parent.s._(msg, document); };</script>' + new Array ( 174 ) . join ( ' ' ) ) ; data = '<script>_(' + JSON . stringify ( data ) + ');</script>' ;", "del_tokens": "req . res . write ( '<html><body>' + new Array ( 245 ) . join ( ' ' ) ) ; data = '<script>parent.s._(' + JSON . stringify ( message ) + ', document);</script>' ;", "commit_type": "change"}
{"commit_tokens": ["fixed", "style", "building", "but", "there", "s", "still", "a", "loop", "."], "add_tokens": "var pickFiles = require ( 'broccoli-static-compiler' ) ; var compiledCss = scssCompile ( [ 'styles-addon' ] , 'main.scss' , 'ember-cli-ember-dvc.css' ) ; var exportedCss = exportTree ( compiledCss , { destDir : 'vendor-addon/ember-cli-ember-dvc' , clobber : true } ) ; vendor : mergeTrees ( [ 'vendor' , 'vendor-addon' ] ) , app . import ( 'vendor/ember-cli-ember-dvc/ember-cli-ember-dvc.css' ) ; module . exports = mergeTrees ( [ exportedCss , app . toTree ( ) ] ) ;", "del_tokens": "var vendorTree = mergeTrees ( [ 'vendor' , 'vendor-addon' ] ) ; vendor : vendorTree , var cssTree = scssCompile ( [ 'styles-addon' ] , 'main.scss' , 'ember-cli-ember-dvc.css' ) ; // var outputCss = (cssTree, { // destDir: '/' // }); app . import ( 'vendor-addon/ember-cli-ember-dvc/ember-cli-ember-dvc.css' ) ; // Use `app.import` to add additional libraries to the generated // output files. // // If you need to use different assets in different // environments, specify an object as the first parameter. That // object's keys should be the environment name and the values // should be the asset to use in that environment. // // If the library that you are including contains AMD or ES6 // modules that you would like to import into your application // please specify an object with the list of modules as keys // along with the exports of each module as its value. var wat = exportTree ( cssTree , { destDir : 'vendor-addon/ember-cli-ember-dvc' , clobber : true } ) ; module . exports = mergeTrees ( [ app . toTree ( ) , wat ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "phantom", "exited", "logger", "statement"], "add_tokens": "phantomProc . on ( 'close' , function ( ) { grunt . log . writeln ( 'Phantom exited.' ) ; next ( err ) ; } ) ;", "del_tokens": "phantomProc . on ( 'close' , function ( ) { next ( err ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "that", "generated", "xpi", "is", "always", "removed", "."], "add_tokens": "var fs = require ( \"fs-promise\" ) ; function extendWith ( source , field ) { return function ( value ) { source [ field ] = value ; return source ; } } function removeXPI ( options ) { return fs . unlink ( options . xpi ) . then ( function ( ) { return options ; } ) ; } return xpi ( manifest , options ) . then ( extendWith ( options , \"xpi\" ) ) . then ( function ( options ) { return options . profile || createProfile ( options ) ; } ) . then ( extendWith ( options , \"profile\" ) ) . then ( removeXPI ) . then ( runFirefox )", "del_tokens": "return xpi ( manifest , options ) . then ( function ( xpiPath ) { return runFirefox ( _ . extend ( { } , options , { xpi : xpiPath } ) ) ; } ) ;", "commit_type": "make"}
{"commit_tokens": ["Change", "default", "partials", "rendering", "the", "commit", "messages"], "add_tokens": "feature : ' - {{{this}}}\\n' , fix : ' - {{{this}}}\\n' ,", "del_tokens": "feature : ' - {{this}}\\n' , fix : ' - {{this}}\\n' ,", "commit_type": "change"}
{"commit_tokens": ["Fixed", "Windows", "issue", "with", "path", ".", "sep", "in", "RegExp"], "add_tokens": "btoaPathSepRegExp = new RegExp ( path . sep . replace ( '\\\\' , '\\\\\\\\' ) , 'g' ) ,", "del_tokens": "btoaPathSepRegExp = new RegExp ( path . sep , 'g' ) ,", "commit_type": "fix"}
{"commit_tokens": ["Changed", "file", "command", "tests", "to", "work", "with", "window", ".", "opener", "(", "so", "they", "ll", "only", "work", "when", "run", "from", "the", "main", "app", ")", "added", "open", "file", "test"], "add_tokens": "var myContent = \"This is awesome!\" ;", "del_tokens": "var myContent = \"This is awesome!\" ;", "commit_type": "change"}
{"commit_tokens": ["fix", "a", "sb", "literal", "bug"], "add_tokens": "var mSeriesItemData = magicOption . series [ seriesIdx ] . data ;", "del_tokens": "var mSeriesItemData = magicOption . series [ seriesIdx ] . Data ;", "commit_type": "fix"}
{"commit_tokens": ["Making", "a", "few", "semantic", "changes", "to", "internal", "variable", "names"], "add_tokens": "location : location , return function ( context , dispatch ) { var params = parseParams ( path , context . uri ) ; context = Object . assign ( { } , context , { params } ) ; handler ( context , dispatch ) ;", "del_tokens": "// location: location, return function ( ctx , dispatch ) { var params = parseParams ( path , ctx . uri ) ; ctx = Object . assign ( ctx , { params } ) ; handler ( ctx , dispatch ) ;", "commit_type": "make"}
{"commit_tokens": ["changed", "to", "class", "instances", "for", "store", "and", "storage"], "add_tokens": "var EventStream = function ( store , streamId , events ) { this . streamId = streamId ;", "del_tokens": "var EventStream = function ( store , events ) {", "commit_type": "change"}
{"commit_tokens": ["Adds", "micro", "-", "benchmark", "performance", "tests", "."], "add_tokens": "specs : [ 'perf/macro/**/*.spec.js' ] ,", "del_tokens": "specs : [ 'perf/**/*.spec.js' ] ,", "commit_type": "add"}
{"commit_tokens": ["add", "global", "client", "for", "polyIO"], "add_tokens": "module . exports = { server : require ( path . join ( __dirname , 'src' , 'start-io' ) ) , gClient : require ( path . join ( __dirname , 'src' , 'global-client' ) ) }", "del_tokens": "module . exports = require ( path . join ( __dirname , 'src' , 'start-io' ) )", "commit_type": "add"}
{"commit_tokens": ["Added", "logging", "fixed", "remove", "command", "name"], "add_tokens": "cordova . events . on ( 'verbose' , require ( 'debug' ) ( 'rncp:cordova:verbose' ) ) ; cordova . events . on ( 'log' , require ( 'debug' ) ( 'rncp:cordova:log' ) ) ; mkdirp . sync ( path . resolve ( PLATFORM_DIR , 'assets/www' ) ) ; platformVersion : '4.0.0' } ) . then ( function ( ) { console . log ( 'Plugin %s added' , plugin ) ; } ) ; console . log ( 'If you still have trouble adding/removing plugins, delete all the plugin from node_modules' ) ;", "del_tokens": "platformVersion : '4.0.0' , } ) ; console . log ( 'If you still have trouble adding/removing plugins, delete each plugin from node_modules' ) ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "duplication", "where", "findIndex", "was", "better"], "add_tokens": "var toRemove = this . timers . findIndex ( function ( analysed ) { return analysed . uid > timer . uid ; } ; assert ( toRemove !== - 1 ) ; this . timers . splice ( toRemove , 1 ) ;", "del_tokens": "var i ; for ( i = 0 ; i < this . timers . length ; ++ i ) { if ( this . timers [ i ] . uid === timer . uid ) { break ; } } this . timers . splice ( i , 1 ) ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", "all", "tests", "about", "middlewares"], "add_tokens": "var request = this . _createRequest ( method , params , payload ) ; if ( ! middleware ) { return ; } } else { this . _callMiddlewares ( middlewares , method , request , response_middlewares , callback ) ;", "del_tokens": "var request = this . _createRequest ( method , params , payload ) ; if ( ! middleware )", "commit_type": "fix"}
{"commit_tokens": ["Remove", "babel", "-", "runtime", "dep"], "add_tokens": "var babel = 'babel?stage=0'", "del_tokens": "var babel = 'babel?optional[]=runtime&stage=0'", "commit_type": "remove"}
{"commit_tokens": ["fixed", "bug", "where", "updateImage", "would", "crash", "if", "the", "image", "hadn", "t", "been", "loaded", "yet"], "add_tokens": "// only draw the image if it has loaded if ( image !== undefined ) { csc . drawImage ( ee , image ) ; }", "del_tokens": "csc . drawImage ( ee , image ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "sure", "that", "(", "SyncItTestServ", "/", "TestServer", ")", ".", "getQueueitem", "()", "does", "not", "fail", "when", "there", "is", "no", "query", "key", "in", "the", "req", "parameter"], "add_tokens": "req . hasOwnProperty ( 'query' ) ? req . query . hasOwnProperty ( 'from' ) ? req . query . from : null : null ,", "del_tokens": "var filter = { } ; req . query . hasOwnProperty ( 'from' ) ? req . query . from : null , var datakey = '' , dataset = '' ;", "commit_type": "make"}
{"commit_tokens": ["Improve", "circular", "reference", "error", "message"], "add_tokens": "throw new Error ( 'Circular chain found: ' + id + ' must be before ' + afterID + ' due to a direct order specification, but ' + afterID + ' must be before ' + id + ' based on other specifications.' ) ;", "del_tokens": "throw new Error ( 'Circular chain found: ' + afterID + ' is in ' + id ) ;", "commit_type": "improve"}
{"commit_tokens": ["Add", "unit", "tests", "for", "readFile", "compareTemplates"], "add_tokens": "config . AWS = AWS ; var cfn = new config . AWS . CloudFormation ( _ ( env ) . extend ( { config . readFile = readFile ; var s3 = new config . AWS . S3 ( _ ( env ) . extend ( { region : region } ) ) ; var s3 = new config . AWS . S3 ( _ ( env ) . extend ( { region : region } ) ) ; var iam = new config . AWS . IAM ( _ ( env ) . extend ( { region : region } ) ) ;", "del_tokens": "var cfn = new AWS . CloudFormation ( _ ( env ) . extend ( { var s3 = new AWS . S3 ( _ ( env ) . extend ( { region : region } ) ) ; var s3 = new AWS . S3 ( _ ( env ) . extend ( { region : region } ) ) ; var iam = new AWS . IAM ( _ ( env ) . extend ( { region : region } ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "makefile", "target", "for", "reporting", "coverage", "."], "add_tokens": "// Lazy initialization of nock, as it otherwise interferes with the // regular tests nock = require ( 'nock' ) ; nock . restore ( ) ; request . setHeader ( 'X-Awesome-Signature' , 'ken sent me' ) ; nock ( 'http://127.0.0.1' , { allowUnmocked : true } ) assert . equal ( this . req . headers [ 'x-awesome-signature' ] , 'ken sent me' , 'signature header was missing from the request' ) ;", "del_tokens": "///--- Globals var PORT = process . env . UNIT_TEST_PORT || 0 ; // Lazy initialization of nock, as it otherwise interferes with the regular tests nock = require ( 'nock' ) ; nock . restore ( ) ; request . setHeader ( 'X-Awesome-Signature' , 'ken sent me' ) ; var nockContext = nock ( 'http://127.0.0.1' , { allowUnmocked : true } ) assert . equal ( this . req . headers [ 'x-awesome-signature' ] , 'ken sent me' , 'signature header was missing from the request' ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "tests", ".", "missing", "service", "name"], "add_tokens": "this . instance = Service . createInstance ( 'test-service' ) ;", "del_tokens": "this . instance = Service . createInstance ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "right", "axis", "label", "distance"], "add_tokens": ". attr ( 'y' , rotateYLabel ? ( - Math . max ( margin . right , width ) + axisLabelDistance ) : - 10 ) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart", "del_tokens": ". attr ( 'y' , rotateYLabel ? ( - Math . max ( margin . right , width ) + 12 ) : - 10 ) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart", "commit_type": "fix"}
{"commit_tokens": ["change", "css", "rules", "handling", "to", "support", "firefox", "..."], "add_tokens": "delimiter : \"\" , if ( document . styleSheets [ i ] . rules != undefined ) { chartStyle = document . styleSheets [ i ] . rules } else { chartStyle = document . styleSheets [ i ] . cssRules }", "del_tokens": "delimiter : \"\\\"\" , chartStyle = document . styleSheets [ i ] . rules", "commit_type": "change"}
{"commit_tokens": ["Fix", "bug", "when", "columnGroups", "is", "not", "defined"], "add_tokens": "if ( ! columnGroups || ! columnGroups . some ( columnGroup => columnGroup . header ) ) {", "del_tokens": "if ( ! columnGroups . some ( columnGroup => columnGroup . header ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Allow", ".", "env", "to", "override", "API_URL"], "add_tokens": "let apiURL ; let apiHostname ; apiURL = process . env . API_URL || 'https://api.vapid.com' ; apiHostname = url . parse ( apiURL ) . hostname ;", "del_tokens": "const apiURL = process . env . API_URL || 'https://api.vapid.com' ; const apiHostname = url . parse ( apiURL ) . hostname ;", "commit_type": "allow"}
{"commit_tokens": ["Made", "it", "all", "async", "-", "y", "to", "fit", "with", "the", "rest", "of", "node", ".", "js", ":", ")"], "add_tokens": "var authorize = function ( user , pass , callback ) { var result = ( user == 'foo' && pass == 'bar' ) callback ( null , result ) ; } use ( Cookie ) use ( Auth , { onAuthorize : authorize } ) var self = this ; self . isAuthorized ( function ( error , authorized ) { if ( authorized ) { if ( ! self . session . counter ) self . session . counter = 0 ; self . status ( 200 ) self . respond ( \"<h1>Hello!\" + self . REMOTE_USER + \"</h1>\" + \"<p>\" + ( self . session . counter ++ ) + \"</p>\" ) } } ) ;", "del_tokens": "use ( Cookie ) use ( Auth ) if ( this . isAuthorized ( ) ) { if ( ! this . session . counter ) this . session . counter = 0 ; return \"<h1>Hello!\" + this . REMOTE_USER + \"</h1>\" + \"<p>\" + ( this . session . counter ++ ) + \"</p>\" }", "commit_type": "make"}
{"commit_tokens": ["improved", "the", "idle", "transaction", "observer", "API", "and", "protocol", "added", "some", "tests", "updated", "the", "documentation"], "add_tokens": "* @ param { { idleTransactions : { ttl : number , warningDelay : number , observer : function ( TransactionRunner , boolean ) } } } options * @ type { { idleTransactions : { ttl : number , warningDelay : number , observer : function ( TransactionRunner , boolean ) } } }", "del_tokens": "* @ param { { idleTransactions : { ttl : number , warningDelay : number , observer : function ( Transaction , boolean ) } } } options * @ type { { idleTransactions : { ttl : number , warningDelay : number , observer : function ( Transaction , boolean ) } } }", "commit_type": "improve"}
{"commit_tokens": ["Fix", "for", "SingleRequest", "namespace", "."], "add_tokens": "var SingleRequest ; ( function ( SingleRequest ) { SingleRequest . idle = idle ; SingleRequest . tryRequest = tryRequest ; SingleRequest . success = success ; SingleRequest . failed = failed ; } ) ( SingleRequest = exports . SingleRequest || ( exports . SingleRequest = { } ) ) ;", "del_tokens": "var SingleMessage ; ( function ( SingleMessage ) { SingleMessage . idle = idle ; SingleMessage . tryRequest = tryRequest ; SingleMessage . success = success ; SingleMessage . failed = failed ; } ) ( SingleMessage = exports . SingleMessage || ( exports . SingleMessage = { } ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "unicode", "extension", "handling", "when", "variant", "is", "null"], "add_tokens": "sep = Cldr . localeSep , unicodeLocaleExtensionsRaw = \"\" ; if ( subtags . length === 5 ) { unicodeLocaleExtensions = subtags . pop ( ) ; unicodeLocaleExtensionsRaw = sep + \"u\" + sep + unicodeLocaleExtensions ; // Remove trailing null when there is unicodeLocaleExtensions but no variants. if ( ! subtags [ 3 ] ) { subtags . pop ( ) ; } } minLanguageId : minLanguageId + unicodeLocaleExtensionsRaw , maxLanguageId : maxLanguageId . join ( sep ) + unicodeLocaleExtensionsRaw ,", "del_tokens": "sep = Cldr . localeSep ; unicodeLocaleExtensions = subtags [ 4 ] ; minLanguageId : minLanguageId , maxLanguageId : maxLanguageId . join ( sep ) ,", "commit_type": "fix"}
{"commit_tokens": ["fixing", "webhub", "to", "declare", "platform", "as", "this", "github", "project"], "add_tokens": "model . platform = \"https://github.com/draggett/arena-webhub\" ;", "del_tokens": "model . platform = \"https://example.org/wot/webhub\" ;", "commit_type": "fix"}
{"commit_tokens": ["use", "path", "to", "join", "file", "paths"], "add_tokens": "* Handle your project environment properties from a simple . json file . var path = require ( \"path\" ) , envy = exports , * Deep copies the properties of the source object into the destination * Loads the configuration . json file with the provided filename and returns an var configFile = require ( path . join ( process . cwd ( ) , filename || \"config\" ) ) , * envy . config can be replaced with envy . load ( ) . Therefore it will", "del_tokens": "* Handle your project environment properties from a simple . json file . var envy = exports , * Deep copies the properties of the source object into the destination * Loads the configuration . json file with the provided filename and returns an var configFile = require ( process . cwd ( ) + \"/\" + ( filename || \"config\" ) ) , * envy . config can be replaced with envy . load ( ) . Therefore it will", "commit_type": "use"}
{"commit_tokens": ["Updating", "client", "examples", "in", "/", "test", "folder", "to", "pass", "single", "subprotocol", "as", "a", "string", "instead", "of", "an", "array", "."], "add_tokens": "client . connect ( args . protocol + '//' + args . host + ':' + args . port + '/' , 'fragmentation-test' ) ;", "del_tokens": "client . connect ( args . protocol + '//' + args . host + ':' + args . port + '/' , [ 'fragmentation-test' ] ) ;", "commit_type": "update"}
{"commit_tokens": ["Allow", "makeFixer", "to", "take", "a", "boolean"], "add_tokens": "/ ** * Creates a fixing function or boolean that can be provided as eslint ' * option . * * @ param { Object | boolean } options Either an options object , or a boolean * @ return { Function | boolean } ` ` option for eslint * / if ( ! options ) { if ( typeof options === 'boolean' ) { return options ; } if ( rulesToFix ) { return function ( eslintMessage ) { if ( rulesToFix . includes ( eslintMessage . ruleId ) ) { return true ; } return false ; } ; } // Fallback return false ;", "del_tokens": "if ( ! options || ! Array . isArray ( options . rules ) || ! options . rules . length ) { return function ( eslintMessage ) { if ( rulesToFix . includes ( eslintMessage . ruleId ) ) { return true ; } return false ; } ;", "commit_type": "allow"}
{"commit_tokens": ["Make", "codeclimate", "a", "bit", "more", "happy"], "add_tokens": "let fields = [ \"username\" , \"password\" ] ; for ( var i = 0 , len = fields . length ; i < len ; i ++ ) { let toTest = fields [ i ] ; it ( ` ${ toTest } ` , ( done ) => { let hash = { username : \"berti\" , password : \"soSecre7\" } ; delete hash [ toTest ] ; let user = new User ( hash ) ; user . validate ( function ( err ) { expect ( err . errors [ toTest ] ) . toBeDefined ( ) ; done ( ) ; } ) ; }", "del_tokens": "it ( \"is invalid without a username\" , ( done ) => { let user = new User ( { password : \"soSecre7\" } ) ; user . validate ( function ( err ) { expect ( err . errors . username ) . toBeDefined ( ) ; done ( ) ; } ) ; } ) ; it ( \"is invalid without a password\" , ( done ) => { let user = new User ( { username : \"berti\" } ) ; user . validate ( function ( err ) { expect ( err . errors . password ) . toBeDefined ( ) ; done ( ) ; } ) ;", "commit_type": "make"}
{"commit_tokens": ["moved", "default", "queries", "to", "configuration", "file"], "add_tokens": "this . existsQuery = options . existsQuery this . graphQuery = options . graphQuery", "del_tokens": "this . existsQuery = options . existsQuery || SparqlHandler . defaults . existsQuery this . graphQuery = options . graphQuery || SparqlHandler . defaults . graphQuery SparqlHandler . defaults = { existsQuery : 'ASK { <${iri}> ?p ?o }' , // eslint-disable-line no-template-curly-in-string graphQuery : 'DESCRIBE <${iri}>' // eslint-disable-line no-template-curly-in-string }", "commit_type": "move"}
{"commit_tokens": ["Make", "preview", "rendering", "be", "customizable"], "add_tokens": "editor . options . preview_render ( editor , preview ) ; editor . options . preview_render ( editor , preview ) ; editor . options . preview_render ( editor , preview ) ; if ( ! options . preview_render ) { options . preview_render = function ( editor , preview ) { var text = editor . codemirror . getValue ( ) ; preview . innerHTML = editor . markdown ( text ) ; } } SimpleMDE . prototype . markdown = function ( text ) {", "del_tokens": "var parse = editor . constructor . markdown ; preview . innerHTML = parse ( cm . getValue ( ) ) ; preview . innerHTML = parse ( cm . getValue ( ) ) ; var parse = editor . constructor . markdown ; var text = cm . getValue ( ) ; preview . innerHTML = parse ( text ) ; SimpleMDE . markdown = function ( text ) {", "commit_type": "make"}
{"commit_tokens": ["make", "colorPicker", "instances", "wait", "for", "the", "document", "to", "load"], "add_tokens": "// Quick reference to the document object and some strings since we usethem more than once const doc = document , READYSTATE_COMPLETE = \"complete\" , READYSTATE_CHANGE = \"readystatechange\" ; / ** * @ desc call callback when the page document is ready * @ param { Function } callback callback function to be called * / whenReady : function ( callback ) { var _this = this ; if ( doc . readyState == READYSTATE_COMPLETE ) { callback ( ) ; } else { _this . listen ( doc , READYSTATE_CHANGE , function stateChange ( e ) { if ( doc . readyState == READYSTATE_COMPLETE ) { callback ( ) ; _this . unlisten ( doc , READYSTATE_CHANGE , stateChange ) ; } } ) ; } } ,", "del_tokens": "// Quick reference to the document object since we use it more than once const doc = document ;", "commit_type": "make"}
{"commit_tokens": ["Use", "negociateLocale", "in", "the", "app", "sample"], "add_tokens": "import url ; import { createTranslator , negociateLocale , provideTranslate } from 'gandi.translate' ; const defaultLocale = 'en' ; // It's up to you to detect the locale of your user // (by url param, cookie, X-Accept-Language header, user pref etc) const queryParamLocale = url . parse ( redirectTo , true ) . query . lang ; const userBrowserLocales = window . navigator . languages || [ ( window . navigator . language || window . navigator . userLanguage ) ] ; const locale = negociateLocale ( [ queryParamLocale , ... userBrowserLocales , ] , availableLocales , defaultLocale ) ; // It's up to you to define a strategy of how to retrieve your translations // Define your translations params // Create translator // Provide the translator to your whole app", "del_tokens": "import { provideTranslate , createTranslator } from '@gandi/react-translate' ; // it's up to you to detect the locale of your user // (by url, cookie, header X-Accept-Language, etc) const matches = document . location . search . match ( / lang=(.*) / ) ; let locale = ( Array . isArray ( matches ) && matches . pop ( ) ) || 'en' ; if ( ! availableLocales . includes ( locale ) ) { locale = 'en' ; } // it's up to you to define a strategy of how to retrieve your translations // define your translations params // create translator // provide the translator to your whole app", "commit_type": "use"}
{"commit_tokens": ["Allow", "specifying", "the", "full", "path", "of", "the", "page"], "add_tokens": "if ( / https?:\\/\\/.+ / . test ( options . openPage ) ) { opener ( options . openPage ) } else { opener ( url + options . openPage ) }", "del_tokens": "opener ( url + options . openPage )", "commit_type": "allow"}
{"commit_tokens": ["Remove", "parse", "return", "value", "and", "add", "some", "comments"], "add_tokens": "/ ** * bitwise mask of different request types * / / ** * Maps element types to type mask . * / / ** * Finds the first separator character in the input string * / / ** * Parses the set of filter rules and fills in parserData * @ param input filter rules * @ param parserData out parameter which will be filled * with the filters , exceptionFilters and htmlRuleFilters . * / / ** * Obtains the domain index of the input filter line * / / ** * Similar to str1 . indexOf ( filter , startingPos ) but with * extra consideration to some ABP filter rules like ^ . * / / ** * Given an individual parsed filter data determines if the input url should block . * / / ** * Using the parserData rules will try to see if the input URL should be blocked or not * @ param parserData The filter data obtained from a call to parse * @ param input The input URL * @ return true if the URL should be blocked * /", "del_tokens": "return parserData ; // Similar to str1.indexOf(filter, startingPos) but with // extra consideration to some ABP filter rules like ^", "commit_type": "remove"}
{"commit_tokens": ["add", "lat", "lon", "to", "feedback", "function"], "add_tokens": "setImmediate ( function ( ) { RED . nodes . registerType ( \"ui_worldmap\" , UIWorldMap ) } ) ;", "del_tokens": "RED . nodes . registerType ( \"ui_worldmap\" , UIWorldMap ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "bug", "where", "listeners", "are", "assigned", "the", "wrong", "id"], "add_tokens": "//if(this.id === 39) { debugger; } if ( node . id === 51 ) { //console.log(demanding_var.id, node.id, node.ood); } listener_id ++ ; return listener . id ;", "del_tokens": "listener_id ++ ; return listener_id ;", "commit_type": "fix"}
{"commit_tokens": ["added", "correct", "float", "css", "syntax", "for", "navigator", "in", "firefox", "and", "older", "IE"], "add_tokens": "style . float = 'left' ; //Webkit style . cssFloat = 'left' ; //Firefox style . floatStyle = 'left' ; //IE", "del_tokens": "style . float = 'left' ;", "commit_type": "add"}
{"commit_tokens": ["change", "uid", "-", ">", "id"], "add_tokens": "uid = uid . id || uid ;", "del_tokens": "uid = uid . uid || uid ;", "commit_type": "change"}
{"commit_tokens": ["Improve", "the", "README", ".", "md", "file"], "add_tokens": "Transaction : builder . Openchain . Transaction", "del_tokens": "Transaction : builder . Openchain . Transaction , ByteBuffer : ByteBuffer", "commit_type": "improve"}
{"commit_tokens": ["Fix", "test", "for", "branch", "tracking"], "add_tokens": "if ( shelljs . exec ( 'git config branch.' + options . branch + '.remote' , { silent : true } ) . output . replace ( / \\n / g , '' ) !== remoteName ) {", "del_tokens": "if ( shelljs . exec ( 'git config branch.' + options . branch + '.remote' !== remoteName ) ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "Promise", "not", "constructed", "using", "new"], "add_tokens": "var promise = new promiseFactory ( function ( resolve , reject ) {", "del_tokens": "var promise = promiseFactory ( function ( resolve , reject ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "example", "to", "work", "with", "new", "constructor", "callback"], "add_tokens": "} , function ( err ) { if ( err ) { e . details = err ;", "del_tokens": "port : 8081 , } , function ( err , error ) { if ( err || error ) { e . details = err || error ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "worker", "process", "listeners", "to", "prevent", "Error", ":", "IPC", "channel", "is", "already", "disconnected"], "add_tokens": "worker . process . removeAllListeners ( 'message' ) ; // remove worker process listeners to prevent \"Error: IPC channel is already disconnected\"", "del_tokens": "worker . disconnect ( ) ; // should disconnect to prevent \"Error: IPC channel is already disconnected\"", "commit_type": "remove"}
{"commit_tokens": ["Update", "README", "with", "lesson", "04", "(", "label", "map", ")"], "add_tokens": "updateLayer1 ( ) ; updateLayerMix ( ) ;", "del_tokens": "updateLayerMix ( ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "a", "bug", "with", "snapshotting", "where", "callback", "was", "not", "used", "for", "hashing"], "add_tokens": "name = name . replace ( / [^a-zA-Z0-9._-] / g , '-' ) ; fileName = './test/snapshots/' + code . children [ 0 ] . tagName + '-' + ( name && name + '-' || '' ) + sha1 ( html + JSON . stringify ( props ) + callback . toString ( ) ) . substr ( 0 , 5 ) ;", "del_tokens": "fileName = './test/snapshots/' + code . children [ 0 ] . tagName + '-' + ( name && name + '-' || '' ) + sha1 ( html + JSON . stringify ( props ) ) . substr ( 0 , 5 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "cross", "-", "spawn", "-", "async", "."], "add_tokens": "// Any required modules must be available // at run-time when the SDK is used as part // of a service. This means they need to be // either node core modules, or included // in the `dependencies` map in the SDK's // `package.json`. var spawn = require ( 'cross-spawn-async' ) ;", "del_tokens": "// Be careful to only use the node core modules here, // as by nature, the SDK's dependencies may not // be available yet. var spawn = require ( 'cross-spawn' ) ;", "commit_type": "use"}
{"commit_tokens": ["Use", "dev", "-", "specific", "dbDir", "and", "configFile", "when", "NODE_ENV", "=", "development"], "add_tokens": "/ ** * The Hub is like the root DNS server for Postvox nicknames . Setting -- hubUrl * lets you point to a different Hub authority . * / exports . hubUrl ; / ** * The default interchange URL is used during the ` ` command . * / exports . defaultInterchangeUrl ; exports . configFile ; exports . dbDir ; exports . dbDir = commandLineArgs . dbDir || path . join ( homeDir , '.voxhistory-dev' ) ; exports . configFile = commandLineArgs . configFile || path . join ( homeDir , '.voxconfig-dev.json' ) ; exports . dbDir = commandLineArgs . dbDir || path . join ( homeDir , '.voxhistory' ) ; exports . configFile = commandLineArgs . configFile || path . join ( homeDir , '.voxconfig.json' ) ;", "del_tokens": "exports . configFile = commandLineArgs . configFile || path . join ( homeDir , '.voxconfig.json' ) ; exports . dbDir = commandLineArgs . dbDir || path . join ( homeDir , '.voxhistory' ) ; / ** * The Hub is like the root DNS server for Postvox nicknames . Setting -- hubUrl * lets you point to a different Hub authority . * / / ** * The default interchange URL is used during the ` ` command . * /", "commit_type": "use"}
{"commit_tokens": ["Adding", "tenant", "()", "helper", "to", "the", "database", "object", "to", "abstract", "away", "multi", "-", "tenancy", "."], "add_tokens": "beforeEach ( function ( ) { mongo . db ( \"test key\" , undefined ) ; } ) ; afterEach ( function ( ) { mongo . db ( \"test key\" , undefined ) ; } ) ; var db = mongo . db ( \"test key\" ) ; var db = mongo . db ( \"test key\" , \"mongojs-hooks-tdd\" ) ; var dbFirst = mongo . db ( \"test key\" , \"mongojs-hooks-tdd\" ) ; var db = mongo . db ( \"test key\" ) ;", "del_tokens": "var db = mongo . db ( \"test\" ) ; var db = mongo . db ( \"test\" , \"mongojs-hooks-tdd\" ) ; mongo . db ( \"test\" , undefined ) ; var dbFirst = mongo . db ( \"test\" , \"mongojs-hooks-tdd\" ) ; var db = mongo . db ( \"test\" ) ; mongo . db ( \"test\" , undefined ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", ":", "packager", ".", "js", "version", "revise"], "add_tokens": "// version revise if ( '.map' !== path . extname ( fileName ) ) { let versionLine = code . match ( / ( \\* [\\S].+)([0-9]+.[0-9]+.[A-Za-z0-9_-]+)(\\n) / ) ; if ( versionLine ) { let newLine = versionLine [ 0 ] . replace ( / ([0-9]+.[0-9]+.[A-Za-z0-9_-]+) / , config . pkg . version ) ; code = code . replace ( / ( \\* [\\S].+)([0-9]+.[0-9]+.[A-Za-z0-9_-]+)(\\n) / , newLine ) ; } }", "del_tokens": "// TODO: version", "commit_type": "fix"}
{"commit_tokens": ["Improve", "extension", "logging", "when", "mounting"], "add_tokens": "console . error ( '[lib/bundles/parser.js] Couldn\\'t load extension' , bundle . extension . path , 'for' , bundle . name , 'Skipping.' ) ;", "del_tokens": "console . error ( '[lib/bundles/parser.js] Couldn\\'t load bundle.main' , bundle . extension . path , 'for' , bundle . name , 'Skipping.' ) ;", "commit_type": "improve"}
{"commit_tokens": ["Updated", "tests", ";", "better", "handling", "of", "skippable", "data"], "add_tokens": "// Handle skippable data if ( this . skippableSize > 0 ) { this . skippableSize -= data . length if ( this . skippableSize > 0 ) { // More to skip done ( ) return } data = data . slice ( - this . skippableSize ) this . skippableSize = 0 this . state = STATES . MAGIC }", "del_tokens": "Decoder . prototype . read_SkippableData = function ( ) { if ( this . check_Size ( this . skippableSize ) ) return true this . state = STATES . DATABLOCK_SIZE this . skippableSize = 0 } if ( this . state === STATES . SKIP_DATA ) notEnoughData = this . read_SkippableData ( )", "commit_type": "update"}
{"commit_tokens": ["Added", "to", "the", "Advanced", "chapter", "of", "the", "documentation", "all", "the", "details", "about", "options", ".", "pgFormatting", "."], "add_tokens": "// - Redirects query formatting into PG library;", "del_tokens": "// - Redirect all query formatting to PG library;", "commit_type": "add"}
{"commit_tokens": ["fixed", "one", "-", "letter", "variable"], "add_tokens": "var index = configHelpers . watchers . indexOf ( newWatcher ) ; if ( index == - 1 ) { configHelpers . watchers . push ( newWatcher ) ; } var index = configHelpers . watchers . indexOf ( newWatcher ) ; if ( index > - 1 ) { configHelpers . watchers . splice ( index , 1 ) ; }", "del_tokens": "var isSet = false ; configHelpers . watchers . forEach ( function ( watcher ) { if ( watcher === newWatcher ) { isSet = true ; } } ) ; if ( ! isSet ) { configHelpers . watchers . push ( newWatcher ) ; } var index = false ; configHelpers . watchers . forEach ( function ( watcher , k ) { if ( watcher === newWatcher ) { index = k ; } } ) ; if ( index !== false ) { configHelpers . watchers . splice ( index , 1 ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Use", "join", "()", "in", "examples"], "add_tokens": "var carrier = { } ; Tracer . inject ( span , Tracer . FORMAT_TEXT_MAP , carrier ) ; for ( var key in carrier ) { options . headers [ key ] = carrier [ key ] ; }", "del_tokens": "// Optional: convey the trace context to the proxy server 'LightStep-Trace-GUID' : span . imp ( ) . traceGUID ( ) , 'LightStep-Parent-GUID' : span . imp ( ) . guid ( ) ,", "commit_type": "use"}
{"commit_tokens": ["Fix", "issue", "where", "finding", "a", "particuar", "non", "-", "cql", "key", "that", "has", "been", "chained", "on", "fails"], "add_tokens": "var hasKey = ( searchKey in allMetas [ i ] ) ; if ( found || hasKey ) { } else if ( hasKey ) {", "del_tokens": "if ( found || ( searchKey in allMetas [ i ] ) ) { } else {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "typo", "in", "failure", "message"], "add_tokens": "grunt . fail . warn ( 'Invalid argument : options.use should be equal to date or hash' ) ;", "del_tokens": "grunt . fail . warn ( 'Invalid argument : options.use should be equal to date or hase' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "chalk", "for", "support", "for", "terminal", "colors"], "add_tokens": "var chalk = require ( 'chalk' ) ; console . log ( chalk . cyan ( 'Building HTML files..' ) ) ; console . log ( chalk . green ( 'Done' ) ) ;", "del_tokens": "console . log ( 'Building HTML files..' ) ; console . log ( 'Done' ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "log", "&", "add", "repository"], "add_tokens": "", "del_tokens": "//console.log(lcov);", "commit_type": "remove"}
{"commit_tokens": ["Fix", "job", "command", "description", "tests", "."], "add_tokens": "checks . bag_parse_commands . build . desc . should . equal ( 'Trigger a build with optional parameters' ) ; checks . bag_parse_commands . build . desc . should . equal ( 'Trigger a build with optional parameters' ) ;", "del_tokens": "checks . bag_parse_commands . build . desc . should . equal ( 'Trigger build with optional parameters' ) ; checks . bag_parse_commands . build . desc . should . equal ( 'Trigger build with optional parameters' ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "d", ".", "ts", "file"], "add_tokens": ", moment = require ( './moment-jalaali.d' )", "del_tokens": ", moment = require ( './index' )", "commit_type": "add"}
{"commit_tokens": ["Add", "sub", "-", "context", "expression", "this", "support", "."], "add_tokens": "if ( functions ) { this . functions = functions ; this . functions . context = this ; } this . functions = ctx . functions ; if ( ctx . functions ) { this . functions = Object . create ( ctx . functions ) ; this . functions . context = this ; }", "del_tokens": "this . functions = functions ;", "commit_type": "add"}
{"commit_tokens": ["Added", "ability", "to", "enable", "auto", "key", "generation", "by", "adding", "a", "trailing", "^", "to", "the", "specString", ".", "Removed", "auto", "key", "generation", "entirely", "from", "custom", "components", ".", "Left", "in", "ability", "to", "trigger", "auto", "key", "generation", "for", "all", "specString", "declared", "components", "at", "construction", "-", "time", "to", "ease", "migration", "."], "add_tokens": "var autoKeyGenRegex = / \\^$ / // matches 'anything^' function parseTagSpec ( specString , autoKeyGen ) { var props = { } if ( autoKeyGen || specString . match ( autoKeyGenRegex ) ) { props . key = specString } if ( typeof componentType !== 'function' ) { var spec = parseTagSpec ( componentType , autoKeyGen )", "del_tokens": "function parseTagSpec ( specString ) { // Provide the specString as a default key, which can always be overridden // by the props hash (for when two siblings have the same specString) var props = { key : specString } if ( typeof componentType === 'function' ) { // For custom components, attempt to provide a default \"key\" prop. // This can prevent the \"Each child in an array should have a // unique key prop\" warning when the element doesn't have any // siblings of the same type. Provide a displayName for your custom // components to make this more useful (and help with debugging). var fakeKey = componentType . displayName || 'customElement' props = props || { } if ( ! props . key ) props . key = fakeKey } else { var spec = parseTagSpec ( componentType )", "commit_type": "add"}
{"commit_tokens": ["fixed", "bark", "scale", "variable", "scope", "issue", "added", "node_modules", "to", "gitignore"], "add_tokens": "for ( var i = 0 ; i < self . barkScale . length ; i ++ ) {", "del_tokens": "for ( var i = 0 ; i < barkScale . length ; i ++ ) {", "commit_type": "fix"}
{"commit_tokens": ["Updating", "example", "to", "match", "newer", "API"], "add_tokens": "miio . device ( { } ) . then ( device => { console . log ( 'power is now' , device . power ) ; return device . setPower ( ! device . power ) ; } ) . catch ( console . error ) ;", "del_tokens": "const device = miio . createDevice ( { } ) ; // Call any method via call device . call ( 'set_mode' , [ 'silent' ] ) . then ( console . log ) . catch ( console . error ) ; // Or use some of the built-in methods device . setPower ( false ) ; device . getProperties ( [ 'power' , 'mode' , 'aqi' , 'temp_dec' , 'humidity' ] ) . then ( console . log ) . catch ( console . error ) ;", "commit_type": "update"}
{"commit_tokens": ["fixed", "REPL", "to", "log", "error", "and", "continue", "rather", "than", "throw", ";", "updated", "documentation"], "add_tokens": "var log ; if ( ! opts . log ) { opts . log = require ( 'simple-node-logger' ) . createLogger ( ) ; } log = opts . log ; log . info ( key , ':' , value ) ; if ( err ) { log . error ( err . message ) ; } else { log . info ( result ) ; }", "del_tokens": "if ( ! opts . log ) opts . log = require ( 'simple-node-logger' ) . createLogger ( ) ; opts . log . info ( key , ':' , value ) ; if ( err ) throw err ; opts . log . info ( result ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "JS", "that", "checks", "for", "poor", "contrast", "in", "our", "palettes"], "add_tokens": "config . pl_src + '/ui.js' , config . pl_src + '/color-contrast.js'", "del_tokens": "config . pl_src + '/ui.js'", "commit_type": "add"}
{"commit_tokens": ["make", "field", "inherit", "classes", "and", "spread", "props"], "add_tokens": "export default class Field extends Component { className : PropTypes . string , this . props . className , 'field' < div { ... this . props } className = { classes } >", "del_tokens": "class Field extends Component { disabled : PropTypes . bool , error : PropTypes . bool , inline : PropTypes . bool , large : PropTypes . bool , required : PropTypes . bool , small : PropTypes . bool , this . props . large && 'large' , this . props . small && 'small' , this . props . inline && 'inline' , this . props . disabled && 'disabled' , this . props . required && 'required' , 'field' , this . props . error && 'error' < div className = { classes } > export default Field ;", "commit_type": "make"}
{"commit_tokens": ["fixed", "the", "dropping", "of", "export", "default", "from", "documented", "code"], "add_tokens": "pattern : / ^\\s*export\\s+default\\s+ / gm ,", "del_tokens": "pattern : / export default / g ,", "commit_type": "fix"}
{"commit_tokens": ["implement", "form", "level", "touched", "and", "untouched", "based", "on", "child", "fields"], "add_tokens": "let fieldState = setField ( state , localPath , { return icepick . merge ( fieldState , { touched : true , untouched : false } ) ;", "del_tokens": "return setField ( state , localPath , {", "commit_type": "implement"}
{"commit_tokens": ["removed", "bug", "on", "forever", ":", "restart"], "add_tokens": "forever . stop ( index ) . on ( 'stop' , function ( ) { startRequest ( ) ; done ( ) } )", "del_tokens": "forever . restart ( index ) . on ( 'error' , function ( message ) { error ( 'Error restarting ' + index + '. [REASON] :: ' + message ) ; done ( false ) ; } ) ; done ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Remove", "pointless", "feedback", "about", "height", "calculation"], "add_tokens": "! animHeight && classList . toggle ( \"shrinking\" , totalHeight < prevHeight ) ;", "del_tokens": "if ( ! animHeight && classList . toggle ( \"shrinking\" , totalHeight < prevHeight ) ) { console . info ( \"Height difference: \" + ( prevHeight - totalHeight ) ) ; }", "commit_type": "remove"}
{"commit_tokens": ["Using", "buffer", ".", "fill", "instead", "of", "assignment"], "add_tokens": "* Fills array or arraybuffer with zeroes buffer . fill ( 0 ) ;", "del_tokens": "* Fills array or arrybuffer with zeroes for ( var i = 0 , len = buffer . length ; i < len ; i ++ ) { buffer [ i ] = 0 ; }", "commit_type": "use"}
{"commit_tokens": ["moved", "sql", "API", "to", "sql", "folder"], "add_tokens": "var dataFrame = sqlContext . read ( ) . json ( file ) ;", "del_tokens": "var dataFrame = sqlContext . read . json ( file ) ;", "commit_type": "move"}
{"commit_tokens": ["Implemented", "Styles", "generator", "with", "css", "and", "less", "support", "."], "add_tokens": "var async = require ( 'async' ) , less = require ( 'less' ) ; } ) ; // This handlers is only to allow process, but do nothing. handlersManager . add ( \"css\" , function ( context , callback ) { callback ( null , context ) ; } ) ; handlersManager . add ( \"less\" , function ( context , callback ) { less . render ( context . buffer , function ( err , css ) { if ( err ) context . buffer = \"/* [LESS: ERROR] \" + context . file . name + context . file . extname + \" not generated, cause: \\n\" + err + \"*/\" ; else context . buffer = css ; console . log ( css ) ; callback ( null , context ) ; } ) ; } ) ; // [TODO] Will be implemented handlersManager . add ( \"scss\" , function ( context , callback ) { context . buffer = \"\\n/* [SORRY] \" + context . file . name + context . file . extname + \" not generated, scss is not currently supported. */\\n\" ; callback ( null , context ) ; } ) ; // [TODO] Will be implemented handlersManager . add ( \"stylus\" , function ( context , callback ) { context . buffer = \"\\n/* [SORRY] \" + context . file . name + context . file . extname + \" not generated, stylus is not currently supported. */\\n\" ; callback ( null , context ) ;", "del_tokens": "var async = require ( 'async' ) ;", "commit_type": "implement"}
{"commit_tokens": ["use", "forEach", "instead", "of", "for", "...", "of", "and", "use", "instanceof", "instead", "of", "typeof"], "add_tokens": "this . _items . forEach ( item => { this . options . init instanceof Function && this . options . init . apply ( this , [ item , this ] ) ; } ) ; this . options . done instanceof Function && this . options . done . apply ( this , [ item , this ] ) ; mutations . forEach ( mutation => { [ ] . slice . call ( mutation . addedNodes , 0 ) . forEach ( item => { } ) ; } ) ; this . _items . forEach ( item => { } ) ;", "del_tokens": "for ( let item of this . _items ) { / ^f / . test ( typeof this . options . init ) && this . options . init . apply ( this , [ item , this ] ) ; } / ^f / . test ( typeof this . options . done ) && this . options . done . apply ( this , [ item , this ] ) ; for ( let mutation of mutations ) { for ( let item of [ ] . slice . call ( mutation . addedNodes , 0 ) ) { } } for ( let item of this . _items ) { }", "commit_type": "use"}
{"commit_tokens": ["Add", "fee", "in", "search", "for", "utxo"], "add_tokens": "TransactionBuilder . findUtxo = function ( utxo , target , fee ) { //Add fee if ( fee == undefined ) fee = Transaction . DEFAULT_FEE ; if ( target [ \"ETP\" ] ) target . ETP += fee ; else target . ETP = fee ;", "del_tokens": "TransactionBuilder . findUtxo = function ( utxo , target ) {", "commit_type": "add"}
{"commit_tokens": ["adding", "where", "...", "in", "support"], "add_tokens": "} ; var node = new BinaryNode ( { operator : operator } ) ; if ( Array . isArray ( val ) ) { node . right = val . map ( function ( v ) { return v . toNode ? v . toNode ( ) : new ParameterNode ( v ) ; } ) ; } else { node . right = val . toNode ? val . toNode ( ) : new ParameterNode ( val ) ; } return node ; } ; } ; binaryMethod ( 'in' , 'IN' ) ; binaryMethod ( 'notIn' , 'NOT IN' ) ;", "del_tokens": "} return new BinaryNode ( { operator : operator , right : val . toNode ? val . toNode ( ) : new ParameterNode ( val ) } ) } }", "commit_type": "add"}
{"commit_tokens": ["Added", "bodyBackground", "option", "+", "plus", "targetOrigin", "to", "sendMessage"], "add_tokens": "bodyBackground : null , bodyPadding : null , var } ':' + settings . heightCalculationMethod + ':' + settings . bodyBackground + ':' + settings . bodyPadding ; var } ;", "del_tokens": "var } ':' + settings . heightCalculationMethod ; var } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "issue", "with", "replacing", "/", "s", "with", ".", "for", "older", "Handlebars"], "add_tokens": "name = name . replace ( / \\/ / g , '.' ) ;", "del_tokens": "name = name . replace ( '/' , '.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "jQuery", "paths", "in", "demo", "dir"], "add_tokens": "'jquery' : '../demo/bower_demo_components/jquery/dist/jquery' ,", "del_tokens": "'jquery' : '../demo/bower_demo_components/jquery/jquery' ,", "commit_type": "update"}
{"commit_tokens": ["Removes", "div", "that", "wasn", "t", "being", "effectively", "removed", "by", "previous", "code"], "add_tokens": "$ ( descElem ) . find ( 'div' ) . remove ( ) ;", "del_tokens": "$ ( descElem ) . remove ( 'div' ) ;", "commit_type": "remove"}
{"commit_tokens": ["added", "test", "for", "collapse", "+", "data", "."], "add_tokens": "} ) ; it ( 'should infer data for collapsed arrays' , function ( ) { var result = schema_sync ( [ { a : [ 1 , 2 , 3 , 4 ] } , { a : [ 5 , 6 ] } ] , { data : true } ) ; var expected = { min : 1 , max : 6 } ; assert . deepEqual ( result . a [ '$data' ] , expected ) ; } ) ; it ( 'should merge existing text/category data correctly with new strings' , function ( ) { var result = schema_sync ( [ { a : \"foo\" } , { a : \"foo\" } , { a : \"bar\" } , { a : \"bar\" } ] , { data : true } ) ; result = schema_sync ( [ { a : \"foo\" } , { a : \"bar\" } ] , { data : true , merge : result } ) ; assert . deepEqual ( result . a [ '$type' ] , \"category\" ) ; } ) ;", "del_tokens": "} ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "databaseName", "as", "optional", "argument", "in", "dropSeries", "()"], "add_tokens": "InfluxDB . prototype . dropSeries = function ( databaseName , seriesName , callback ) { if ( 'function' === typeof seriesName ) { callback = seriesName ; seriesName = databaseName ; databaseName = this . options . database ; } url : this . url ( 'db/' + databaseName + '/series/' + seriesName ) ,", "del_tokens": "InfluxDB . prototype . dropSeries = function ( seriesName , callback ) { url : this . url ( 'db/' + this . options . database + '/series/' + seriesName ) ,", "commit_type": "add"}
{"commit_tokens": ["Using", "WorkerHandler", "in", "Pool", "now"], "add_tokens": "exports . worker = function worker ( exports ) { // TODO: implement worker", "del_tokens": "exports . worker = function worker ( ) {", "commit_type": "use"}
{"commit_tokens": ["Added", "first", "draft", "of", "_", ".", "interleave"], "add_tokens": "weave : function ( /* args */ ) { if ( ! _ . some ( arguments ) ) return [ ] ; } , interleave : _ . weave", "del_tokens": "interleave : function ( /* args */ ) { }", "commit_type": "add"}
{"commit_tokens": ["Add", "tests", "for", "both", "views", "and", "filename", "engineOptions"], "add_tokens": "} , engineOptions : { } test ( 'Renders an Ejs template with partial (views)' , async ( ) => { views : [ path . resolve ( __dirname , 'data' ) ] } } const stats = await compiler ( 'data/source-partial.ejs' , options ) const output = stats . toJson ( ) . modules [ 0 ] . source const source = helpers . value ( output ) expect ( source ) . toContain ( '<h1>Ejs Template</h1>' ) expect ( source ) . toContain ( '<h2>A template rendered by Ejs</h2>' ) } ) test ( 'Renders an Ejs template with partial (filename)' , async ( ) => { const options = { engine : 'ejs' , locals : { title : 'Ejs Template' , desc : 'A template rendered by Ejs' } , engineOptions : function ( info ) { return { filename : info . filename }", "del_tokens": "} test ( 'Renders an Ejs template with partial' , async ( ) => { views : [ path . resolve ( __dirname , 'data' ) ]", "commit_type": "add"}
{"commit_tokens": ["make", "the", "app", "name", "for", "rc", "config", "module", "configurable", "via", "env", "var"], "add_tokens": "var RC = require ( 'rc' ) var SpmConfig = function ( appType ) { var rc = new RC ( 'spmagent' , spmDefaultConfig ) util . _extend ( this , rc ) module . exports = new SpmConfig ( process . env . SPM_AGENT_APP_TYPE )", "del_tokens": "var SpmConfig = function ( ) { var rc = require ( 'rc' ) ( 'spmagent' , spmDefaultConfig ) util . _extend ( this , rc ) module . exports = new SpmConfig ( )", "commit_type": "make"}
{"commit_tokens": ["Updated", "lighter", "-", "common", "event", "emitter"], "add_tokens": "* @ version 0.0 .3 / ** * Return an array of listeners for an event type . * / listeners : function ( type ) { var self = this ; var events = self . _events ; var list = events ? events [ type ] : undefined ; return ! list ? [ ] : list instanceof Array ? list : [ list ] ; } ,", "del_tokens": "* @ version 0.0 .2", "commit_type": "update"}
{"commit_tokens": ["Added", "keyOfMin", "/", "keyOfMax", "fixed", "a", "bug", "in", "min", "and", "max", "."], "add_tokens": "var min = data . _ . min ( function ( item ) { expect ( min ) . to . eql ( { name : 'foo' , value : 1 } ) ; data = [ { name : 'foo' , value : 2 } , { name : 'bar' , value : 3 } , { name : 'baz' , value : 1 } ] ; min = data . _ . min ( function ( item ) { return item . value ; } ) ; expect ( min ) . to . eql ( { name : 'baz' , value : 1 } ) ;", "del_tokens": "var max = data . _ . min ( function ( item ) { expect ( max ) . to . eql ( { name : 'foo' , value : 1 } ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "*", "operator", "highlight", "for", "import", "a", ".", "b", ".", "*", ";"], "add_tokens": "'operator' : { pattern : / ([^\\.]|^)([-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\\|?\\||\\?|\\*|\\/|%|\\^|(&lt;){2}|($gt;){2,3}|:|~) / g , lookbehind : true } ,", "del_tokens": "'operator' : / [ - + ] { 1 , 2 } | ! |= ? & lt ; |= ? & gt ; |= { 1 , 2 } | ( & amp ; ) { 1 , 2 } | \\| ? \\| | \\? | \\* | \\/ | % | \\^ | ( & lt ; ) { 2 } | ( $gt ; ) { 2 , 3 } | : | ~ / g,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "bug", "IndexSizeError", "in", "IE11", "&", "FF"], "add_tokens": "let newAnchorOffset = anchorOffset - ( isBackward ? lastBefore - lastAfter : firstBefore - firstAfter ) ; let newFocusOffset = focusOffset - ( isBackward ? firstBefore - firstAfter : lastBefore - lastAfter ) ; focusOffset : newFocusOffset < 0 ? 0 : newFocusOffset ,", "del_tokens": "let newAnchorOffset = anchorOffset - firstBefore + firstAfter ; focusOffset : focusOffset - lastBefore + lastAfter ,", "commit_type": "fix"}
{"commit_tokens": ["add", "lambda", "function", "full", "access", "to", "the", "create", "iam", "user", "url", "deep", "link"], "add_tokens": "\"https://console.aws.amazon.com/iam/home?region=us-east-1#/users$new?step=review&accessKey&userNames=AWSMobileCLI&permissionType=policies&policies=arn:aws:iam::aws:policy%2FAWSMobileHub_FullAccess&policies=arn:aws:iam::aws:policy%2FAWSDeviceFarmFullAccess&policies=arn:aws:iam::aws:policy%2FAWSLambdaFullAccess&policies=arn:aws:iam::aws:policy%2FIAMReadOnlyAccess\"", "del_tokens": "\"https://console.aws.amazon.com/iam/home?region=us-east-1#/users$new?step=review&accessKey&userNames=AWSMobileCLI&permissionType=policies&policies=arn:aws:iam::aws:policy%2FAWSMobileHub_FullAccess&policies=arn:aws:iam::aws:policy%2FAWSDeviceFarmFullAccess&policies=arn:aws:iam::aws:policy%2FIAMReadOnlyAccess\"", "commit_type": "add"}
{"commit_tokens": ["Use", "a", "read", "-", "only", "token", "for", "reading", "PRs", "from", "API"], "add_tokens": "const headers = { } console . log ( ` ${ process . env . RO_GH_TOKEN } ` ) if ( process . env . RO_GH_TOKEN ) { headers [ 'Authorization' ] = ` ${ process . env . RO_GH_TOKEN } ` return { headers } if ( process . env . VERBOSE ) { console . log ( ` ${ url } ` ) } const url = ` ${ owner } ${ repo } ` if ( process . env . VERBOSE ) { console . log ( ` ${ url } ` ) } fetch ( url , getFetchOpts ( ) )", "del_tokens": "return { headers : { 'user-agent' : 'ciena-frost' , Authorization : ` ${ process . env . GITHUB_TOKEN } ` } fetch ( ` ${ owner } ${ repo } ` , getFetchOpts ( ) )", "commit_type": "use"}
{"commit_tokens": ["Added", "BuildArch", "tag", "and", "quote", "file", "paths", "."], "add_tokens": "if ( ( file . hasOwnProperty ( 'mode' ) && file . mode !== null ) || ( file . hasOwnProperty ( 'user' ) && file . user !== null ) || ( file . hasOwnProperty ( 'group' ) && file . group !== null ) ) { directives . push ( '\"' + file . path + '\"' ) ; . add ( 'Release: ' + spec . tags . release ) . add ( 'BuildArch: ' + spec . tags . buildArch ) ;", "del_tokens": "if ( file . hasOwnProperty ( 'mode' ) || file . hasOwnProperty ( 'user' ) || file . hasOwnProperty ( 'group' ) ) { directives . push ( file . path ) ; . add ( 'Release: ' + spec . tags . release ) ;", "commit_type": "add"}
{"commit_tokens": ["Move", "uniqueId", "to", "the", "adt", ".", "util", "namespace"], "add_tokens": "// Helper function to return a unique id adt . util . uniqueId = ( function ( ) { var id = 0 ; return function ( pre ) { return pre + ( id ++ ) ; } ; } ) ( ) ; name = adt . util . uniqueId ( 'Anonymous' ) ;", "del_tokens": "name = uniqueId ( 'Anonymous' ) ; // Helper function to return a unique id var uniqueId = ( function ( ) { var id = 0 ; return function ( pre ) { return pre + ( id ++ ) ; } ; } ) ( ) ;", "commit_type": "move"}
{"commit_tokens": ["Improves", "self", ".", "resemble", "with", "try", "catch", "imagesMatch", "boolean", "condition", "and", "casper", "test"], "add_tokens": "resemble ( imgBase . src ) . compareTo ( imgCheck . src ) . onComplete ( function ( data ) { try { var imagesMatch = ! Math . round ( data . misMatchPercentage ) ; if ( ! imagesMatch ) { var filePath = './resemble/' + SuccssCount . startTime + '/' + capture . basePath . replace ( / ^\\.?\\/ / , '' ) ; self . writeImgDiff ( imgDiff , imgBase , imgCheck , filePath ) ; } casper . test . assertTrue ( imagesMatch , 'Capture matches base screenshot (resemble).' ) ; } catch ( e ) { self . catchErrors ( e ) ; }", "del_tokens": "var diff = resemble ( imgBase . src ) . compareTo ( imgCheck . src ) . onComplete ( function ( data ) { var filePath = './resemble/' + SuccssCount . startTime + '/' + capture . basePath . replace ( / ^\\.?\\/ / , '' ) ; self . writeImgDiff ( imgDiff , imgBase , imgCheck , filePath ) ;", "commit_type": "improve"}
{"commit_tokens": ["Added", "payloadType", "support", "at", "route", "level"], "add_tokens": "responseMessages : routeOptions && routeOptions . responseMessages || [ ] , payloadType : routeOptions && routeOptions . payloadType || null // set globally or locally to route var payloadType = settings . payloadType if ( route . payloadType ) { payloadType = route . payloadType ; } if ( payloadType . toLowerCase ( ) === 'json' ) { // set as json var payloadProperty = internals . validatorToProperty ( op . nickname , route . payloadParams , swagger . models ) ; // set as form if ( arrayProperty . type === 'string' ) { property . items = { 'type' : arrayProperty . type } ; } else { property . items = { '$ref' : arrayProperty . type } ; }", "del_tokens": "responseMessages : routeOptions && routeOptions . responseMessages || [ ] if ( settings . payloadType === 'json' ) { var payloadProperty = internals . validatorToProperty ( op . nickname , route . payloadParams , swagger . models ) ; // set body type property . items = { '$ref' : arrayProperty . type } ;", "commit_type": "add"}
{"commit_tokens": ["added", "additional", "log", "events", "during", "raw", "ocr", "process"], "add_tokens": "self . emit ( 'log' , 'finished splitting pages for file at path ' + pdf_path ) ; self . emit ( 'log' , 'converted page to intermediate tiff file, page ' + index + '(0-based indexing) of ' + num_pages ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["removed", "original", "serializers", ".", "js", "and", "containers", ".", "js"], "add_tokens": "var writer = require ( '../serializers/writer' ) ;", "del_tokens": "var writer = require ( '../serializers' ) . writer ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", "logging", "error", "in", "console", "."], "add_tokens": "this . echo ( 'Screenshots for ' + vp . name + ' (' + ( vp . width || vp . viewport . width ) + 'x' + ( vp . height || vp . viewport . height ) + ')' , 'info' ) ;", "del_tokens": "this . echo ( 'Screenshots for ' + vp . name + ' (' + vp . width || vp . viewport . width + 'x' + vp . height || vp . viewport . height + ')' , 'info' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "team", "next", "games", "url", "as", "command", "line", "parameter"], "add_tokens": "var commander = require ( 'commander' ) ; var path = require ( 'path' ) ; var pkg = require ( path . join ( __dirname , 'package.json' ) ) ; commander . version ( pkg . version ) . option ( '-t, --team <team>' , 'The team url.' ) . parse ( process . argv ) ; var team = commander . team || 'http://www.fussball.de/ajax.team.next.games/-/team-id/01S7GV1URS000000VS548985VUL18RL3' ; url : team , * * @ param { String } matchTime }", "del_tokens": "url : \"http://www.fussball.de/ajax.team.next.games/-/team-id/01S7GV1URS000000VS548985VUL18RL3\" , * * @ param { String } matchTime }", "commit_type": "add"}
{"commit_tokens": ["Fix", "relative", "paths", "for", "when", "compiler", ".", "outputFileSystem", "is", "MemoryFileSystem"], "add_tokens": "self . options . path = path . resolve ( self . options . path || compiler . options . output . path || '.' )", "del_tokens": "path : '.' ,", "commit_type": "fix"}
{"commit_tokens": ["Moved", "age", "and", "alive", "into", "one", "attribute"], "add_tokens": "params : new SPE . ShaderAttribute ( 'v3' ) , // Holds (alive, age, emitterIndex) // attributes.age.typedArray.setNumber( i, i ); // index, value // attributes.alive.typedArray.setNumber( i, i ); // index, value // alive, age, emitterIndex (used for valueOverLifetimes as array start index) attributes . params . typedArray . setVec3Components ( i , 0 , 0 , 0 ) ;", "del_tokens": "alive : new SPE . ShaderAttribute ( 'f' ) , age : new SPE . ShaderAttribute ( 'f' ) , attributes . age . typedArray . setNumber ( i , i ) ; // index, value attributes . alive . typedArray . setNumber ( i , i ) ; // index, value", "commit_type": "move"}
{"commit_tokens": ["Allow", "multiple", "routes", "to", "be", "matched"], "add_tokens": "var routes = [ ] ; if ( ! ( routes = router . match ( this . method , this . path , this . params ) ) ) { // Dispatch route middlewares for ( var i = 0 ; i < routes . length ; i ++ ) { debug ( 'dispatch \"%s\" %s' , routes [ i ] . path , routes [ i ] . regexp ) ; yield routes [ i ] . middleware . call ( this , next ) ; } var matchingRoutes = [ ] ; debug ( 'match \"%s\" %s' , routes [ i ] . path , routes [ i ] . regexp ) ; matchingRoutes . push ( routes [ i ] ) ; if ( matchingRoutes . length > 0 ) { return matchingRoutes ; } else { return false ; }", "del_tokens": "var route ; if ( ! ( route = router . match ( this . method , this . path , this . params ) ) ) { // Dispatch route middleware debug ( 'dispatch \"%s\" %s' , route . path , route . regexp ) ; yield route . middleware . call ( this , next ) ; return routes [ i ] ; return false ;", "commit_type": "allow"}
{"commit_tokens": ["Use", "simple", "define", "clauses", "to", "help", "dryice"], "add_tokens": "define ( function ( require , exports , module ) {", "del_tokens": "( function ( mod ) { if ( typeof exports == \"object\" && typeof module == \"object\" ) return mod ( exports ) ; // CommonJS if ( typeof define == \"function\" && define . amd ) return define ( [ \"exports\" ] , mod ) ; // AMD mod ( this . acorn || ( this . acorn = { } ) ) ; // Plain browser env } ) ( function ( exports ) {", "commit_type": "use"}
{"commit_tokens": ["removed", "commented", "out", "line", "."], "add_tokens": "fs . unlink ( localPath , function ( ) { } ) ;", "del_tokens": "//fs.unlink(localPath, function() { //});", "commit_type": "remove"}
{"commit_tokens": ["added", "script", "to", "pool", "-", "proxy", "-", "function"], "add_tokens": "exports . pool = function pool ( script , options ) { return new Pool ( script , options ) ;", "del_tokens": "exports . pool = function pool ( options ) { return new Pool ( options ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "dependency", "on", "Node", ".", "js", "util", "module"], "add_tokens": "Error . call ( this , message ) ; FetchError . prototype = Object . create ( Error . prototype ) ; FetchError . prototype . name = 'FetchError' ;", "del_tokens": "this . name = this . constructor . name ; require ( 'util' ) . inherits ( FetchError , Error ) ;", "commit_type": "remove"}
{"commit_tokens": ["Updated", "system", "example", "in", "docs"], "add_tokens": "* world . each ( 'position' , 'velocity' , ( { position , velocity } ) => { * position . x += velocity . x * dt * position . y += velocity . y * dt * world . each ( 'controlled' , 'velocity' , ( { velocity } , entity ) => {", "del_tokens": "* world . every ( [ 'position' , 'velocity' ] , ( position , velocity ) => { * position . x += velocity . x * position . y += velocity . y * world . every ( [ 'controlled' , 'velocity' ] , ( controlled , velocity , entity ) => {", "commit_type": "update"}
{"commit_tokens": ["Updated", "drawLabels", "to", "not", "use", "Prototype", "."], "add_tokens": "html = [ ] ; html = html . join ( '' ) ; var div = D . create ( 'div' ) D . setStyles ( div , { fontSize : 'smaller' , color : options . grid . color } ) ; div . className = 'flotr-labels' ; D . insert ( this . el , div ) ; D . insert ( div , html ) ;", "del_tokens": "html = [ '<div style=\"font-size:smaller;color:' + options . grid . color + ';\" class=\"flotr-labels\">' ] ; html . push ( '</div>' ) ; this . el . insert ( html . join ( '' ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "CSS", "-", "tooltip", "upon", "validation", "fail", "."], "add_tokens": "* @ version 1.1 .0 var options = options || false , rules = rules || false ; if ( options !== false ) options . element = false ; var legend = elements [ i ] . getAttribute ( \"data-label\" ) || \"Invalid value given!\" ; var parent = elements [ i ] . parentNode ; parent . setAttribute ( \"data-hint\" , legend ) ; if ( elements [ i ] . classList . contains ( this . stylings . error ) ) { var parent = elements [ i ] . parentNode ; parent . removeAttribute ( \"data-hint\" ) ; }", "del_tokens": "* @ version 1.0 .0 options . element = false ; if ( elements [ i ] . classList . contains ( this . stylings . error ) )", "commit_type": "add"}
{"commit_tokens": ["fixed", "silent", "mode", "for", "fsinfo", "command"], "add_tokens": "SilentMode ( options . json === true || _cli . silent === true ) ;", "del_tokens": "SilentMode ( options . json === true ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "pause", "as", "an", "action", "to", "make", "record", ".", "json", "more", "hackable"], "add_tokens": "case 'pause' : fn = function ( ) { console . log ( ' Pause for %s ms' . grey , currentEvent . ms ) ; setTimeout ( _next , currentEvent . ms ) ; } ; break ; return done ( 'Unrecognized user action. Record.json might have been modified' ) ; fn ( ) ;", "del_tokens": "if ( currentEvent . waitInterval ) { console . log ( ' Pause for %s ms' . grey , currentEvent . waitInterval ) ; } return done ( 'Unrecognized user event.' ) ; setTimeout ( fn , currentEvent . waitInterval || 0 ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "silent", "option", "(", "won", "t", "output", "client", "side", "webpack", "build", "stats", "to", "console", ";", "e", ".", "g", ".", "when", "using", "webpack", "-", "dashboard", ")"], "add_tokens": "if ( ! options . silent ) { }", "del_tokens": "// if (options.development) // { // }", "commit_type": "add"}
{"commit_tokens": ["Fix", "parse", "error", "in", "form"], "add_tokens": "UI . store . fetcher . nowOrWhenFetched ( form , function ( ok , message ) { if ( ! ok ) complainIfBad ( ok , message )", "del_tokens": "UI . store . fetcher . nowOrWhenFetched ( form , function ( xhr ) {", "commit_type": "fix"}
{"commit_tokens": ["adding", "support", "for", "building", "https", "config", "from", "options", "file"], "add_tokens": "var config = new HttpsConfig ( options . config )", "del_tokens": "var config = new HttpsConfig ( options )", "commit_type": "add"}
{"commit_tokens": ["added", "checking", "for", "missing", "variables"], "add_tokens": "err = null ; for ( prop in schema ) { if ( schema . hasOwnProperty ( prop ) ) {", "del_tokens": "err ; for ( prop in input ) { if ( input . hasOwnProperty ( prop ) && schema . hasOwnProperty ( prop ) ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "missing", "coverage", "for", "the", "boolean", "data", "type"], "add_tokens": "case types . boolean : case types . number : case types . undefined : case types . boolean :", "del_tokens": "case types . number : case types . undefined : if ( x !== y ) return false ; break ;", "commit_type": "add"}
{"commit_tokens": ["fix", "linting", "and", "add", "none", "option"], "add_tokens": "// special case for start to have the right working directory", "del_tokens": "//special case for start to have the right working directory", "commit_type": "fix"}
{"commit_tokens": ["using", "npm", "-", "published", "version", "of", "pluginstall", ".", "line", "drawn", "in", "sand", "regarding", "minimum", "cordova", "version", ".", "added", "asyncblock", "for", "flow", "control", ".", "fixed", "an", "issue", "with", "express", "deprecation", "warning", "."], "add_tokens": "server = express ( ) ;", "del_tokens": "server = express . createServer ( ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "coveralls", ".", "io", "badge"], "add_tokens": "catch ( ex ) { console . log ( red + 'Could not parse file ' + file ) ; }", "del_tokens": "catch ( ex ) { }", "commit_type": "add"}
{"commit_tokens": ["Made", "exceptions", "optional", "support", "async", "calling", "and", "trivial", "optimizations"], "add_tokens": "it ( \"will not execute the next function if the previous function pops it\" , function ( ) { expect ( Sugarless ( { } ) ( function ( ) { Sugarless . next ( this ) ; } , function ( ) { return \"second\" ; } ) ) . toBeUndefined ( ) ; } ) ; Sugarless ( obj ) ( function ( ) { Sugarless . next ( this ) ; } , function ( ) { } ) ; it ( \"should throw the exception normally, if no error handler is defined\" , function ( ) {", "del_tokens": "it ( \"will not execute the next function if the previous function doesn't return\" , function ( ) { expect ( Sugarless ( { } ) ( function ( ) { result = \"first\" ; } , function ( ) { return \"second\" ; } ) ) . toBeUndefined ( ) ; } ) ; Sugarless ( obj ) ( function ( ) { /* doesn't return or calls next */ } , function ( ) { } ) ; it ( \"should throw the exception if no error handler is defined\" , function ( ) {", "commit_type": "make"}
{"commit_tokens": ["added", "options", "for", "the", "page", "object", "of", "phantomJS"], "add_tokens": "haltOnError : true , pageOptions : { } taskChannelPrefix : taskChannelPrefix , pageOptions : options . pageOptions", "del_tokens": "haltOnError : true taskChannelPrefix : taskChannelPrefix", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "list", "filtering"], "add_tokens": "function setNumberOfPages ( vm , listName , length ) { state [ listName ] . numberOfItems = length ; state [ listName ] . numberOfPages = Math . ceil ( state [ listName ] . numberOfItems / state [ listName ] . perPage ) ; // Set numberOfPages on the vm instance // so you can use it in your links section. vm . $set ( listName + 'Links' , state [ listName ] . numberOfPages ) ; } setNumberOfPages ( vm , listName , originalLists [ listName ] . length ) ; vm [ 'refresh' + helpers . capitalize ( listName ) + 'Page' ] = function ( ) { vm [ 'change' + helpers . capitalize ( listName ) + 'Page' ] ( 0 ) ; } ; // Turn on warnings back // Refresh number of pages (useful in case you're filtering the list) setNumberOfPages ( this . vm , listName , list . length ) ;", "del_tokens": "state [ listName ] . numberOfItems = originalLists [ listName ] . length ; state [ listName ] . numberOfPages = Math . ceil ( state [ listName ] . numberOfItems / state [ listName ] . perPage ) ; // Set numberOfPages on the vm instance // so you can use it in your links section. vm . $set ( listName + 'Links' , state [ listName ] . numberOfPages ) ; // Turn on warnings", "commit_type": "add"}
{"commit_tokens": ["adds", "a", "wrapper", "context", "in", "data", "source", "tests", "to", "not", "interfere", "with", "nock", "recordings", "updates", "fixtures", "all", "tests", "passing"], "add_tokens": "for ( let key in existing_obj ) { let val = existing_obj [ key ] if ( [ 'string' , 'number' ] . indexOf ( typeof val ) !== - 1 ) { expect ( object . attributes [ key ] ) . to . eq ( existing_obj [ key ] ) }", "del_tokens": "for ( var key in existing_obj ) { expect ( object . attributes [ key ] ) . to . eq ( existing_obj [ key ] )", "commit_type": "add"}
{"commit_tokens": ["Adds", "root", "to", "default", "configs", "and", "passes", "it", "into", "call", "to", "http"], "add_tokens": "root : '' export default function ( { onUnauthorized , root , ... options } ) { root return http ( ` ${ root } ${ url } ` , requestOptions )", "del_tokens": "export default function ( { onUnauthorized , ... options } ) { return http ( url , requestOptions )", "commit_type": "add"}
{"commit_tokens": ["Use", "array", "instead", "of", "object", "to", "trace", "which", "socket", "is", "opened"], "add_tokens": "var sockets = [ ] ; sockets . push ( this . id ) ; sockets . splice ( sockets . indexOf ( socket . id ) , 1 ) ; res . end ( \"\" + ( sockets . indexOf ( query . id ) != - 1 ) ) ;", "del_tokens": "var sockets = { } ; sockets [ this . id ] = true ; delete sockets [ this . id ] ; res . end ( \"\" + ( query . id in sockets ) ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixed", "end", "to", "end", "tests"], "add_tokens": "* Copyright 2015 , Google Inc .", "del_tokens": "* Copyright 2014 , Google Inc .", "commit_type": "fix"}
{"commit_tokens": ["Use", "spawnSync", "instead", "of", "execSync"], "add_tokens": "// TODO switch from spawnSync to spawn so we can start processing the // stream as it comes in. const child = childProcess . spawnSync ( command ) ; if ( child . error ) { throw child . error ; if ( child . stderr ) { throw new Error ( child . stderr ) ; } child . output . forEach ( ( f ) => {", "del_tokens": "const out = childProcess . execSync ( command ) ; const err = '' ; // TODO: catch stderr here if ( err !== '' ) { throw new Error ( err ) ; String ( out ) . split ( '\\n' ) . forEach ( ( f ) => {", "commit_type": "use"}
{"commit_tokens": ["Use", "label", "elements", "for", "advanced", "filters", "so", "users", "can", "click", "on", "labels", "and", "not", "checkboxes"], "add_tokens": "< label htmlFor = { \"filter-\" + index } className = \"no-select\" > { filter . label } < / label > < input id = { \"filter-\" + index } type = \"checkbox\" checked = { filter . checked || false } onChange = { this . handleAdvancedFilterToggle . bind ( this , filter ) } / >", "del_tokens": "< span className = \"no-select\" > { filter . label } < / span > < input type = \"checkbox\" checked = { filter . checked || false } onChange = { this . handleAdvancedFilterToggle . bind ( this , filter ) } / >", "commit_type": "use"}
{"commit_tokens": ["added", "callback", "to", "getting", "template", "string"], "add_tokens": "fs . readFile ( options . emailtemplatefilepath , 'utf8' , ( err , file ) => { if ( err ) { reject ( err ) ; } else { resolve ( file ) ; } } ) ;", "del_tokens": "fs . readFile ( options . emailtemplatefilepath , 'utf8' ) . then ( resolve ) . catch ( reject ) ;", "commit_type": "add"}
{"commit_tokens": ["Creating", "capture", "promise", "object", "."], "add_tokens": "asyncTest : macadamNative . asyncTest , capture : macadamNative . capture", "del_tokens": "asyncTest : macadamNative . asyncTest", "commit_type": "create"}
{"commit_tokens": ["changed", "to", "require", "index", "for", "runner"], "add_tokens": "moose = require ( \"index\" ) , ConnectionPool = require ( \"ConnectionPool\" ) , sql = moose . SQL , LiteralString = sql . LiteralString , assert . equal ( ds . selectSql , 'select * from xyz' ) ; assert . equal ( ds . selectSql , 'select * from xyz' ) ; suite . run ( { reporter : vows . reporter . spec } , comb . hitch ( ret , \"callback\" ) ) ;", "del_tokens": "moose = require ( \"../../lib\" ) , SQL = require ( \"../../lib/sql\" ) , ConnectionPool = require ( \"../../lib/ConnectionPool\" ) , sql = SQL . sql , LiteralString = SQL . LiteralString , assert . equal ( ds . selectSql ( ) , 'select * from xyz' ) ; assert . equal ( ds . selectSql ( ) , 'select * from xyz' ) ; suite . run ( { reporter : require ( \"vows\" ) . reporter . spec } , function ( ) { //helper.dropModels().then(comb.hitch(ret, \"callback\"), comb.hitch(ret, \"errback\")) } ) ;", "commit_type": "change"}
{"commit_tokens": ["Make", "nested", "path", "traversal", "work", "."], "add_tokens": "this . opcode ( 'pushProgram' , this . compileContents ( node . content ) ) ; var guid = this . compileContents ( program ) ; / ** * Compile an elements contents . * * @ param { Object } program * @ return { Number } * / Compiler . prototype . compileContents = function ( program ) { var guid = this . compileProgram ( program ) ; var result = this . children [ guid ] ; result . proxied = true ; // Proxy all the depth nodes between compiled programs. for ( var i = 0 ; i < result . depths . list . length ; i ++ ) { this . addDepth ( result . depths . list [ i ] ) ; } return guid ; } ;", "del_tokens": "this . opcode ( 'pushProgram' , this . compileProgram ( node . content ) ) ; var guid = BaseCompiler . compileProgram . call ( this , program ) ;", "commit_type": "make"}
{"commit_tokens": ["fix", "bug", "with", "state", "stacks", "not", "setting", "dirty", "correctly", "when", "popping"], "add_tokens": "var dirty = false var forceDirty = true if ( dirty || forceDirty ) { forceDirty = dirty = false stack . length -= n forceDirty = true", "del_tokens": "var dirty = true if ( dirty ) { dirty = false stack . length -= n dirty = true", "commit_type": "fix"}
{"commit_tokens": ["FIXED", ":", "restore", "static", "helper", "functions"], "add_tokens": "static isPriceValid = utils . isPriceValid ; static calculateValidPrice = utils . calculateValidPrice ; static calculateNextLowerPrice = utils . calculateNextLowerPrice ; static calculateNextHigherPrice = utils . calculateNextHigherPrice ; static getBaseId = utils . getBaseId ;", "del_tokens": "// Object.assign(Fut.prototype, Methods.prototype) // futapi.isPriceValid = utils.isPriceValid // futapi.calculateValidPrice = utils.calculateValidPrice // futapi.calculateNextLowerPrice = utils.calculateNextLowerPrice // futapi.calculateNextHigherPrice = utils.calculateNextHigherPrice // futapi.getBaseId = utils.getBaseId // module.exports = futapi", "commit_type": "fix"}
{"commit_tokens": ["improve", "nfa", "regex", "test", "case"], "add_tokens": "//TODO", "del_tokens": "", "commit_type": "improve"}
{"commit_tokens": ["fix", "issue", "with", "missing", "getCenter", "function"], "add_tokens": "import { intersectionArea , distance , getCenter } from \"./circleintersection\" ;", "del_tokens": "import { intersectionArea , distance } from \"./circleintersection\" ;", "commit_type": "fix"}
{"commit_tokens": ["allow", "options", "to", "be", "passed", "to", "fns"], "add_tokens": "var merge = require ( 'mixin-deep' ) ; function deepBind ( target , thisArg , options ) { options = options || { } ; target [ key ] = deepBind ( fn , thisArg ) ; // target[key] = fn.bind(thisArg); target [ key ] = bind ( thisArg , key , fn , options ) ; } function bind ( thisArg , key , fn , options ) { return function ( ) { if ( options . hasOwnProperty ( key ) ) { thisArg . options = merge ( { } , thisArg . options , options [ key ] ) ; } return fn . apply ( thisArg , arguments ) ; } } / ** * Expose ` ` * / module . exports = deepBind ;", "del_tokens": "module . exports = function bindEach ( target , thisArg ) { target [ key ] = bindEach ( fn , thisArg ) ; target [ key ] = fn . bind ( thisArg ) ; } ;", "commit_type": "allow"}
{"commit_tokens": ["add", "new", "region", "and", "machine", "types", "to", "machine", "create", "docs"], "add_tokens": "* @ param { string } params . region - Name of the region : either 'East Coast (NY2)' , 'West Coast (CA1)' , or 'Europe (AMS1)' * @ param { string } params . machineType - Machine type : either 'Air' , 'Standard' , 'Pro' , 'Advanced' , 'GPU+' , 'P4000' , 'P5000' , 'P6000' , 'V100' , 'C1' , 'C2' , 'C3' , 'C4' , 'C5' , 'C6' , 'C7' , 'C8' , 'C9' , or 'C10' < p >", "del_tokens": "* @ param { string } params . region - Name of the region : 'East Coast (NY2)' or 'West Coast (CA1)' * @ param { string } params . machineType - Machine type : either 'Air' , 'Standard' , 'Pro' , 'Advanced' , 'GPU+' , 'P5000' , 'C1' , 'C2' , 'C3' , 'C4' , 'C5' , 'C6' , 'C7' , 'C8' , 'C9' , or 'C10' < p >", "commit_type": "add"}
{"commit_tokens": ["Fix", "an", "issue", "when", "the", "delayed", "property", "name", "isnt", "set", "yet"], "add_tokens": "var value , self = this , sourceValue ; // added `__dummy__` in case there is no delayed property set, to avoid errors sourceValue = this . get ( this . get ( 'delayedPropertyName' ) || '__dummy__' ) ; var value = this . get ( this . get ( 'delayedPropertyName' ) || '__dummy__' ) ;", "del_tokens": "var value , self = this ; var sourceValue = this . get ( this . get ( 'delayedPropertyName' ) ) ; var value = this . get ( this . get ( 'delayedPropertyName' ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "public", "closeModal", "method", "."], "add_tokens": "modalInstance && modalInstance . setActive_ ( true , id , true ) ; } / ** * Closes current modal * / function closeModal ( ) { modalInstance && modalInstance . setActive_ ( false , null , true ) ; openModalById : openModalById , closeModal : closeModal", "del_tokens": "if ( ! modalInstance ) { return ; } modalInstance . setActive_ ( true , id , true ) ; openModalById : openModalById", "commit_type": "add"}
{"commit_tokens": ["adding", "apikey", "action", "to", "user"], "add_tokens": "reset : require ( './actions/reset' ) , apiKey : require ( './actions/apiKey' )", "del_tokens": "reset : require ( './actions/reset' )", "commit_type": "add"}
{"commit_tokens": ["Implemented", "off", "in", "pubsub", "."], "add_tokens": "} , // Remove a certain callback from an event chain. off : function ( obj , event , callback ) { // Use jQuery to handle DOM events. if ( _ . isElement ( obj ) && jQuery ) { return jQuery ( obj ) . off ( event , callback ) ; } // Use internal handler for pubsub if ( this . isString ( obj ) ) { event = obj ; obj = this ; } if ( this . isUndefined ( obj . __event_handlers ) ) return ; obj . __event_handlers = _ . filter ( obj . __event_handlers , function ( cb ) { return ( cb . toString ( ) === callback . toString ( ) ) ; // TODO Make this smarter } ) ; return this ;", "del_tokens": "/ * This needs to remove a specific function from the chain , not the entire chain // , // // Remove // off: function(obj, event) { // // Use jQuery to handle DOM events. // if(_.isElement(obj) && jQuery){ return jQuery(obj).off(event, callback); } // // Use internal handler for pubsub // if(this.isString(obj)) { event = obj; obj = this; } // if(this.isUndefined(obj.__event_handlers)) return; // delete obj._events[event]; // } * /", "commit_type": "implement"}
{"commit_tokens": ["fix", "purgeHotkeys", "to", "delete", "all"], "add_tokens": "var i = scope . hotkeys . length ; while ( i -- ) { var hotkey = scope . hotkeys [ i ] ; if ( hotkey && ! hotkey . persistent ) { _del ( hotkey ) ; } }", "del_tokens": "angular . forEach ( scope . hotkeys , function ( hotkey ) { if ( ! hotkey . persistent ) { _del ( hotkey ) ; } } ) ;", "commit_type": "fix"}
{"commit_tokens": ["removing", "clean", "css", "from", "task", "sequence"], "add_tokens": "gulp . task ( 'cssnano' , function ( ) {", "del_tokens": "gulp . task ( 'cssnano' , [ 'cleancss' ] , function ( ) {", "commit_type": "remove"}
{"commit_tokens": ["removed", "Date", ".", "now", "(", "already", "supported", "by", "all", "browsers", ")"], "add_tokens": "Version 0.5 ~ dev , generated on Thu Apr 4 09 : 44 : 50 CEST 2013.", "del_tokens": "Version 0.5 ~ dev , generated on Wed Apr 3 16 : 15 : 12 CEST 2013. if ( ! Date . now ) { / ** * @ returns { int } Current timestamp ( msec ) * / Date . now = function ( ) { return + ( new Date ) ; } }", "commit_type": "remove"}
{"commit_tokens": ["Added", "toString", "method", "for", "X10Commands"], "add_tokens": "command . toString ( ) . should . eql ( \"allLightsOff\" ) ; command . toString ( ) . should . eql ( \"allLightsOff\" ) ; command . toString ( ) . should . eql ( \"allLightsOff\" ) ; command = new X10Command ( { \"functionCode\" : \"allLightsOff\" } ) ; command . toString ( ) . should . eql ( \"allLightsOff\" ) ; command . toString ( ) . should . eql ( \"allLightsOff\" ) ; command . toString ( ) . should . eql ( \"allLightsOff\" ) ; command . toString ( ) . should . eql ( \"allLightsOff\" ) ;", "del_tokens": "command = new X10Command ( { \"functionCode\" : \"allLightsOff\" } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "icon", "previews", "on", "private", "media", "library"], "add_tokens": "function getUrl ( file , size , media ) { media = media || get_media ; return media ( file . location , size ) + '?version=' + version ; if ( ! object ) { return ; } , null , agneta . get_media ) ;", "del_tokens": "function getUrl ( file , size ) { return get_media ( file . location , size ) + '?version=' + version ; if ( ! object ) { return ; } ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "option", "to", "disable", "base64", "encoding"], "add_tokens": "maxBuffer : 0 maxBuffer : 0", "del_tokens": "reporter : 'dot' , maxBuffer : 10000 * 1024 maxBuffer : 10000 * 1024", "commit_type": "add"}
{"commit_tokens": ["Add", "can", "-", "util", "/", "namespace", "and", "unify", "package", ".", "json"], "add_tokens": "var ns = require ( 'can-util/namespace' ) ; module . exports = ns . compute = COMPUTE ;", "del_tokens": "module . exports = exports = COMPUTE ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "apiCall", "params", "not", "being", "set", "to", "object"], "add_tokens": "this . apiCalls [ 0 ] . params = { myParam : req . query . myParam } ; // in real life don't forget to sanitize query params!", "del_tokens": "this . apiCalls [ 0 ] . params = req . query . myParam ; // in real life don't forget to sanitize query params!", "commit_type": "fix"}
{"commit_tokens": ["implement", "addComment", "in", "blog", ".", "js"], "add_tokens": "// 4XX Error function BadRequest ( msg ) { this . name = 'BadRequest' ; Error . call ( this , msg ) ; Error . captureStackTrace ( this , arguments . callee ) ; } BadRequest . prototype . __proto__ = Error . prototype ; // 5XX Error exports . BadRequest = BadRequest ;", "del_tokens": "// Error", "commit_type": "implement"}
{"commit_tokens": ["Fix", "webpack", "css", "images", "resolving", "path"], "add_tokens": "appStylesheetsPaths , // Modules resolving paths var resolvingPaths = kitten . loadPaths . concat ( path . join ( __dirname , '..' , 'webpack' ) ) ; 'application' : './webpack/javascripts/application.js' , filename : jsFilenames , root : resolvingPaths , assets : true , new ExtractTextPlugin ( cssFilename , { allChunks : true } ) , { test : / \\.css$ / , loaders : [ 'css' ] } , { test : / \\.(svg|png|jpe?g)$ / , loaders : [ 'file?name=images/[name]-[hash].[ext]' ] } , loader : ExtractTextPlugin . extract ( 'css-loader!sass-loader' ) , } , ] , includePaths : sassLoadPaths , sourceMap : false ,", "del_tokens": "appStylesheetsPaths 'application' : './webpack/javascripts/application.js' filename : jsFilenames root : path . join ( __dirname , '..' , 'webpack' ) assets : true new ExtractTextPlugin ( cssFilename , { allChunks : true } ) { test : / \\.css$ / , loaders : [ 'css' ] , } , loader : ExtractTextPlugin . extract ( 'css-loader!sass-loader' ) } ] includePaths : sassLoadPaths sourceMap : false", "commit_type": "fix"}
{"commit_tokens": ["change", "message", "organization", "check", "for", "message", "version", "fix", "error", "with", "empty", "nodeList"], "add_tokens": "var zonar = require ( './lib/zonar' ) ; zonar . init ( { id : \"zonar-\" + ( new Date ( ) ) . getTime ( ) } ) ; module . exports = zonar ;", "del_tokens": "var mesh = require ( './lib/mesh' ) ; mesh . init ( { port : 5777 } ) ; module . exports = mesh ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "mapping", "issue", ".", "Make", "sure", "CommonJS", "module", "scope", "doesn", "t", "follow", "the", "AMD", "path", "in", "UMD", "snippets", "."], "add_tokens": "var deps = exports . dependencies ( id , js ) , params = [ ] , undef = '' ; // make sure code follows the `exports` path instead of `define` path once wrapped if ( / \\bdefine\\.amd\\b / . test ( js ) ) { undef = 'var define;' ; } '{' + undef + js + '\\n}' + filename ; filename = map [ id ] || id ; if ( 'function' === typeof filename ) { filename = filename ( id , options ) ; } filename = Path . resolve ( root , filename ) ;", "del_tokens": "var deps = exports . dependencies ( id , js ) , params = [ ] ; '{' + js + '\\n}' + filename = map [ id ] || id ; if ( 'function' === typeof filename ) { filename = filename ( id , options ) ; } filename = Path . resolve ( root , filename ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "errors", "for", "updating", "to", "mongodb", "3", ".", "x"], "add_tokens": "options . strict = false ; this . setMaxListeners ( 0 ) ; callback ( null , docs . ops [ 0 ] ) ; { tailable : true , timeout : false , sortValue : { $natural : - 1 } , numberOfRetries : Number . MAX_VALUE , tailableRetryInterval : self . options . retryInterval } ) ; . find ( latest ? { _id : latest . _id } : null , { timeout : false } ) collection . insert ( { 'dummy' : true } , { safe : true } , function ( err , docs ) { if ( err ) return cb ( err ) ; callback ( err , docs . ops [ 0 ] , collection ) ;", "del_tokens": "callback ( null , docs [ 0 ] ) ; { tailable : true , numberOfRetries : - 1 , tailableRetryInterval : self . options . retryInterval } ) . sort ( { $natural : 1 } ) ; . find ( latest ? { _id : latest . _id } : null ) . sort ( { $natural : - 1 } ) collection . insert ( { dummy : true } , { safe : true } , function ( err , docs ) { callback ( err , docs [ 0 ] , collection ) ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "XM", "suffix", "from", "XMPlayer", "calls"], "add_tokens": "if ( ! XMPlayer . load ( xmdata ) ) { XMPlayer . pause ( ) ; XMPlayer . play ( ) ; XMPlayer . stop ( ) ; XMPlayer . stop ( ) ; XMPlayer . init ( ) ;", "del_tokens": "if ( ! XMPlayer . loadXM ( xmdata ) ) { XMPlayer . pauseXM ( ) ; XMPlayer . playXM ( ) ; XMPlayer . stopXM ( ) ; XMPlayer . stopXM ( ) ; XMPlayer . initAudio ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "folderSettings", "property", "for", "application", "class", "folder", "configurations"], "add_tokens": "folderConfigs : { publicFolder : null , viewsFolder : null , controllerFolder : null , apiFolder : null , hubFolder : null } , this . app . set ( 'views' , this . folderConfigs . viewsFolder ) ; this . app . use ( express . static ( this . folderConfigs . publicFolder ) ) ; self . _loadModulesFromFolder ( self . folderConfigs . hubFolder , { io : io , socket : socket } ) ; this . _loadModulesFromFolder ( this . folderConfigs . apiFolder , { app : this . app } ) ; this . _loadModulesFromFolder ( this . folderConfigs . controllerFolder , { app : this . app } ) ;", "del_tokens": "this . app . set ( 'views' , path . join ( __dirname , '/app/views' ) ) ; this . app . use ( express . static ( path . join ( __dirname , this . publicFolder || 'public' ) ) ) ; self . _loadModulesFromFolder ( __dirname + '/app/hubs/' , { io : io , socket : socket } ) ; this . _loadModulesFromFolder ( __dirname + '/app/api/' , { app : this . app } ) ; this . _loadModulesFromFolder ( __dirname + '/app/controllers/' , { app : this . app } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "issues", "with", "no", "router", "present"], "add_tokens": "topRouteConfig ( routerName , routeConfig ) { return function ( $injector ) { var $router ; try { $router = $injector . get ( routerName ) ; } catch ( e ) { return ; } this . module . run ( [ '$injector' , this . topRouteConfig ( '$router' , topComponent . $routeConfig ) ] )", "del_tokens": "topRouteConfig ( routeConfig ) { return function ( $router ) { this . module . run ( [ '$router' , this . topRouteConfig ( topComponent . $routeConfig ) ] )", "commit_type": "fix"}
{"commit_tokens": ["Fix", "tests", "&", "update", "deps"], "add_tokens": "import { createMessageEvent } from 'mock-socket/src/event-factory'", "del_tokens": "import { createMessageEvent } from 'mock-socket/dist/event-factory'", "commit_type": "fix"}
{"commit_tokens": ["Added", "filters", "**", "and", "//"], "add_tokens": "let params = name , ret ; tools . each ( params , ( v , k , i ) => { if ( i == 0 ) { ret = v ; } return ret ;", "del_tokens": "let params = name ; tools . each ( params , ( v , k ) => { return component ;", "commit_type": "add"}
{"commit_tokens": ["Added", "promiseHelpers", ".", "allSettled", "."], "add_tokens": "const promiseHelpers = require ( \"./promiseHelpers\" ) ; const validatorPromises = thingsToCheck . map ( validate ) ; // run the function over all items. promiseHelpers . allSettled ( validatorPromises ) . each ( function ( inspection ) {", "del_tokens": "const validators = thingsToCheck . map ( validate ) ; // run the function over all items. Promise . all ( validators . map ( function ( promise ) { return promise . reflect ( ) ; } ) ) . each ( function ( inspection ) {", "commit_type": "add"}
{"commit_tokens": ["moved", "control", "-", "initialisation", "to", "end", "of", "open", "()", "0"], "add_tokens": "// save images if group param was passed or currGroup exists group = group || currGroup ; if ( group ) { currImages = getByGroup ( group ) ; if ( that . opt . controls ) { initControls ( ) ; } }", "del_tokens": "// save images if group param was passed or currGroup exists group = group || currGroup ; if ( group ) { currImages = getByGroup ( group ) ; if ( that . opt . controls ) { initControls ( ) ; } }", "commit_type": "move"}
{"commit_tokens": ["Fix", "issue", "with", "empty", "string", "in", "deepget"], "add_tokens": "// false | 0 | '' will all negate the ternary, hence we do extra checks here // to make sure none of them comes back as undefined return cursor || cursor === ! 1 || cursor === 0 || cursor === '' ? cursor : undefined ;", "del_tokens": "return cursor || cursor === ! 1 || cursor === 0 ? cursor : undefined ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "bug", "in", "which", "the", "animateLayer", "()", "method", "required", "a", "callback", "in", "some", "cases", "(", "which", "should", "be", "optional", ")"], "add_tokens": "callback = function ( ) { } ; } else if ( callback === undefined ) { callback = function ( ) { } ;", "del_tokens": "callback = function ( ) { }", "commit_type": "fix"}
{"commit_tokens": ["Move", "out", "menu", "generation", "function", "to", "prepare", "for", "new", "features"], "add_tokens": "var fs , makeDestination , path ; exports . makeDestination = makeDestination = function ( file ) { exports . makeMenu = function ( files ) { var file , key , link , menu , parts , _i , _len , _results ; menu = { } ; _results = [ ] ; for ( _i = 0 , _len = files . length ; _i < _len ; _i ++ ) { file = files [ _i ] ; link = { name : path . basename ( file , path . extname ( file ) ) , href : 'html/' + makeDestination ( file ) } ; parts = file . split ( '/' ) . splice ( 1 ) ; key = parts . length > 1 ? parts [ 0 ] : './' ; if ( menu [ key ] != null ) { _results . push ( menu [ key ] . push ( link ) ) ; } else { _results . push ( menu [ key ] = [ link ] ) ; } } return _results ; } ;", "del_tokens": "var fs , path ; exports . makeDestination = function ( file ) {", "commit_type": "move"}
{"commit_tokens": ["fix", "the", "selected", "Node", "set", "to", "null", "from", "outside"], "add_tokens": "if ( ! a || ! b )", "del_tokens": "if ( ! a || ! b )", "commit_type": "fix"}
{"commit_tokens": ["Create", "tests", "for", "node", "-", "sass", "transform", ".", "Requires", "includePaths", "option", "to", "work", "."], "add_tokens": "it ( 'should successfully build and perform built-in transforms on an SASS \"file\" asset with `@import` directive' , function ( done ) {", "del_tokens": "it ( 'should successfully build and perform built-in transforms on a simple SASS \"file\" asset' , function ( done ) {", "commit_type": "create"}
{"commit_tokens": ["Added", "some", "missing", "documentation", "on", "Conditions"], "add_tokens": "// subdivision v0.4.1 var isEnabled = true ; if ( _ . isFunction ( pathOptions . isEnabled ) ) { isEnabled = pathOptions . isEnabled ( ) ; } else { if ( _ . isBoolean ( pathOptions . isEnabled ) ) { isEnabled = pathOptions . isEnabled ; } } if ( isEnabled === false ) { return ; } delete clonedOptions [ 'isEnabled' ] ;", "del_tokens": "// subdivision v0.4.0", "commit_type": "add"}
{"commit_tokens": ["Use", "object", "-", "key", "lookup", "to", "check", "for", "compressibility", "."], "add_tokens": "var spec = compressible . specs [ type ] return spec ? spec . compressible : false", "del_tokens": "return compressible . regexp . test ( type )", "commit_type": "use"}
{"commit_tokens": ["fix", "multiple", "invocations", "namespace", "location"], "add_tokens": "function prev ( ) { _namespace . pop ( ) ; } function peek ( key ) { next ( key ) ; let value = getValue ( ) ; if ( value ) { prev ( ) ; } return value ; } return peek ( name ) || init ( target , name ) ;", "del_tokens": "next ( name ) ; return getValue ( ) || init ( target , name ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "createNode", "adding", "id", "when", "is", "empty"], "add_tokens": "if ( id ) { node . id = id ; }", "del_tokens": "node . id = id ;", "commit_type": "fix"}
{"commit_tokens": ["moved", "template", "extraction", "to", "initialize", "children"], "add_tokens": "// if is twoWay binding this . on ( 'change:' + key , function ( e ) { scope . set ( attrKey , e . $ ) ; } ) ; // throw \"Binding not found\"; _createComponentForNode : function ( node , args ) { args = args || [ ] ; var component = appDomain . createInstance ( fqClassName , args , className ) ; if ( component . constructor . name == \"js.core.Template\" ) { if ( ! component . $ . name ) { throw \"template without name\" ; } this . $templates [ component . $ . name ] = component ; } else { childrenFromDescriptor . push ( component ) ; }", "del_tokens": "if ( child . constructor . name == \"js.core.Template\" ) { if ( ! child . $ . name ) { throw \"template without name\" ; } this . $templates [ child . $ . name ] = child ; } throw \"Binding not found\" ; _createComponentForNode : function ( node ) { var component = appDomain . createInstance ( fqClassName , [ ] , className ) ; childrenFromDescriptor . push ( component ) ;", "commit_type": "move"}
{"commit_tokens": ["Updating", "the", "test", "suite", "style"], "add_tokens": "require ( [ 'augmented' , 'augmentedPresentation' , 'boot' ] , function ( Augmented , Presentation ) { \"use strict\" ; var app = new Augmented . Presentation . Application ( \"Data Push\" ) ; //app.registerStylesheet(\"styles/main.css\"); app . registerStylesheet ( \"https://fonts.googleapis.com/css?family=Roboto:100,300,400\" ) ; app . start ( ) ; var versionLine = document . getElementById ( \"augmented\" ) ; Augmented . Presentation . Dom . setValue ( versionLine , \"<span class=\\\"version\\\">Version \" + Augmented . VERSION + \" (\" + Augmented . codename + \")</span>&emsp;<span class=\\\"release\\\">Release (\" + Augmented . releasename + \")</span>\" ) ; //$(\"#augmented\").html(\"Version \" + Augmented.VERSION + \" (\" + Augmented.codename + \") Release \" + Augmented.releasename);", "del_tokens": "require ( [ 'augmented' , 'boot' ] , function ( Augmented ) { $ ( \"#augmented\" ) . html ( \"Version \" + Augmented . VERSION + \" (\" + Augmented . codename + \") Release \" + Augmented . releasename ) ;", "commit_type": "update"}
{"commit_tokens": ["Added", "more", "tests", "for", "w", "-", "extend"], "add_tokens": "if ( ! config ) { config = { } ; }", "del_tokens": "if ( ! config ) { config = { } ; }", "commit_type": "add"}
{"commit_tokens": ["Add", "the", "ability", "to", "specify", "a", "wait", "time", "in", "between", "retries"], "add_tokens": "let retrySleep = ( ) => false // Set a custom function that sets how long we should // sleep between each failed request function retryWait ( callback ) { retrySleep = callback } if ( retrySleep ( tries ) ) { await sleep ( retrySleep ( tries ) ) } module . exports = { retry , retryWait , statistics , requestStatistics , single , many }", "del_tokens": "module . exports = { retry , statistics , requestStatistics , single , many }", "commit_type": "add"}
{"commit_tokens": ["Allow", "all", "access", "in", "and", "out", "of", "the", "application", "subnet"], "add_tokens": "buildAppNetworkAcl ( stage , zones . length ) ,", "del_tokens": "buildAppNetworkAcl ( stage , subnets . get ( PUBLIC_SUBNET ) ) ,", "commit_type": "allow"}
{"commit_tokens": ["Fix", "Lock#acquire", "()", "issue", "when", "callback", "is", "called", "twice"], "add_tokens": "return exit ( result . error ) ; timedOut = true ; deleteNode ( lock , lockPath , utils . noop ) ; var client = lock . client ; client . create ( ) . creatingParentsIfNeeded ( ) . withMode ( CreateMode . EPHEMERAL_SEQUENTIAL ) . forPath ( nodePath , callback ) ;", "del_tokens": "return onerror ( result . error , true ) ; deleteNode ( lock , lockPath ) ; var zk = lock . client . zk ; zk . mkdirp ( lock . basePath , afterCreateBase ) ; function afterCreateBase ( err ) { if ( err && err . getCode ( ) !== Exception . NODE_EXISTS ) { callback ( err ) ; } else { zk . create ( nodePath , CreateMode . EPHEMERAL_SEQUENTIAL , callback ) ; } }", "commit_type": "fix"}
{"commit_tokens": ["Add", "mithril", "bindings", "for", "values"], "add_tokens": "m . e ( 'input' , attrs . cfg ) ,", "del_tokens": "m ( 'input' , attrs . cfg ) ,", "commit_type": "add"}
{"commit_tokens": ["add", "authenticate", "email", "sign", "in", "+", "tests"], "add_tokens": "export function authenticate ( opts ) { let jqPromise = Auth . validateToken ( opts ) ;", "del_tokens": "export function authenticate ( config ) { let jqPromise = Auth . configure ( config ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "null", "and", "allof", "types"], "add_tokens": "OneOfNode : require ( './lib2/oneof' ) , AllOfNode : require ( './lib2/allof' ) , NullNode : require ( './lib2/null' )", "del_tokens": "OneOfNode : require ( './lib2/oneof' )", "commit_type": "add"}
{"commit_tokens": ["add", ":", "countAll", "-", "counts", "all", "records", "in", "the", "collection", ".", "workaround", "for", "CRM", "Web", "API", "$count", "limitation"], "add_tokens": "var dwaExpandRequest = function ( ) { var dwaRequest = function ( ) { / ** * Sends an asynchronous request to count records . Returns : Number * * @ param { string } collection - The Name of the Entity Collection . * @ param { Function } successCallback - The function that will be passed through and be called by a successful response . * @ param { Function } errorCallback - The function that will be passed through and be called by a failed response . * @ param { string } [ filter ] - Use the $filter system query option to set criteria for which entities will be returned . * / this . countAll = function ( collection , successCallback , errorCallback , filter ) { return this . retrieveAllRequest ( { collection : collection , filter : filter } , function ( response ) { successCallback ( response ? ( response . value ? response . value . length : 0 ) : 0 ) ; } , errorCallback ) ; }", "del_tokens": "var dwaExpandRequest = function ( ) { var dwaRequest = function ( ) {", "commit_type": "add"}
{"commit_tokens": ["remove", "eliteDependencies", "&", "magic", "path", "detection", "behavior"], "add_tokens": "replace ( fileType . detect [ blockType ] , function ( match ) {", "del_tokens": "var filesCaught = [ ] ; filesCaught = [ ] ; replace ( fileType . detect [ blockType ] , function ( match , reference ) { filesCaught . push ( reference . replace ( / ['\"\\s] / g , '' ) ) ; filter ( function ( filePath ) { return filesCaught . indexOf ( filePath ) === - 1 ; } ) .", "commit_type": "remove"}
{"commit_tokens": ["add", "notes", "options", "to", "the", "instrument", "load"], "add_tokens": "var promise = loadBank ( ctx , this . nameToUrl ( name ) , options . notes ) . then ( function ( buffers ) {", "del_tokens": "var promise = loadBank ( ctx , this . nameToUrl ( name ) ) . then ( function ( buffers ) {", "commit_type": "add"}
{"commit_tokens": ["added", "support", "for", "specified", "column", "values", "in", "a", "column", "family"], "add_tokens": "this . columns = { } ; if ( definition . column_metadata && Array . isArray ( definition . column_metadata ) ) { var i = 0 , len = definition . column_metadata . length , col ; for ( ; i < len ; i += 1 ) { col = definition . column_metadata [ i ] ; this . columns [ col . name ] = new Marshal ( col . validation_class ) ; } } var col = new Column ( prop , value , ts , options . ttl ) , valueMarshaller = this . columns [ prop ] || this . valueMarshaller ; column : col . toThrift ( this . columnMarshaller , valueMarshaller )", "del_tokens": "var col = new Column ( prop , value , ts , options . ttl ) ; column : col . toThrift ( this . columnMarshaller , this . valueMarshaller )", "commit_type": "add"}
{"commit_tokens": ["Improve", "error", "message", "when", "using", "objects", "in", "Borrows", "that", "are", "unable", "to", "be", "defined", "as", "classes", "."], "add_tokens": "'Utils/object/forOwn' , forOwn , // Validate params as an object // Give the class a default name // Verify reserved words ( function ( params ) { var reserved = [ \"$constructor\" , \"$initializing\" ] ; forOwn ( params , function ( value , key ) { if ( reserved . indexOf ( key ) !== - 1 ) { throw new TypeError ( 'Class \"' + params . Name + '\" is using a reserved word: ' + key ) ; } } ) ; } ( params ) ) ; // Verify if the class has abstract methods but not defined as abstract //>>includeStart('checks', pragmas.checks); if ( isObject ( sources [ i ] ) ) { try { current = Classify ( mixIn ( { } , sources [ i ] ) ) . prototype ; } catch ( e ) { throw new Error ( 'Unable to define object at index ' + i + ' in Borrows of class \"' + target . prototype . Name + '\": ' + e . message ) ; } } else { current = sources [ i ] . prototype ; } //>>includeEnd('checks'); //>>excludeStart('checks', pragmas.checks); //>>excludeEnd('checks');", "del_tokens": "", "commit_type": "improve"}
{"commit_tokens": ["Add", "support", "for", "signing", "with", "P12", "certificate"], "add_tokens": "let params = [ 'sign' , '-f' , pfxFile , '-fd' , 'SHA256' , '-v' ] if ( program . certPass ) { params . push ( '-p' , program . certPass ) } params = params . concat ( program . signtoolParams || [ ] )", "del_tokens": "const params = [ 'sign' , '-f' , pfxFile , '-fd' , 'SHA256' , '-v' ] . concat ( program . signtoolParams || [ ] )", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "utility", "function", "tests"], "add_tokens": "message : 'Function name' message : 'Environment' } , { name : 'output' , message : 'Output path. Setting this will not upload function to AWS' , when : ( ) => false", "del_tokens": "message : 'Which function?' message : 'Which environment variables?'", "commit_type": "add"}
{"commit_tokens": ["Adding", "support", "for", "custom", "wrapper", "component", "for", "Field", "via", "<Field", "component", "=", "{", "...", "}", ">"], "add_tokens": "function getFieldWrapper ( props ) { if ( ! props . component ) { if ( props . className || props . children . length > 1 ) { return 'div' ; } return null ; } return props . component ; } var component = getFieldWrapper ( props ) ; if ( component ) { return _react2 . default . createElement ( component , props , _react2 . default . Children . map ( props . children , function ( child ) { return createFieldControlComponent ( child , props , options ) ; } ) ) ; parser : _react2 . default . PropTypes . func , component : _react2 . default . PropTypes . oneOfType ( [ _react2 . default . PropTypes . func , _react2 . default . PropTypes . string ] )", "del_tokens": "if ( props . children . length > 1 ) { return _react2 . default . createElement ( 'div' , props , _react2 . default . Children . map ( props . children , function ( child ) { return createFieldControlComponent ( child , props , options ) ; } ) ) ; parser : _react2 . default . PropTypes . func", "commit_type": "add"}
{"commit_tokens": ["Removed", "extra", "rp", "()", "in", "logUnkownIntent"], "add_tokens": "return err ; return err ; return err ; return err ; return err ; return err ;", "del_tokens": "rp ( data ) return false ; return false ; return false ; return false ; return false ; return false ;", "commit_type": "remove"}
{"commit_tokens": ["fixed", "situation", "like", "<script", "src", "=", "abc", "/", "abc", "/", "abc?#abc", ">", "<", "/", "script", ">"], "add_tokens": "const RE_QUERY = / \\?[^#]* / g ;", "del_tokens": "const RE_QUERY = / \\?[^#]+ / g ;", "commit_type": "fix"}
{"commit_tokens": ["removed", "support", "for", "unwanted", "tokens", "like", "=", "Del", "etc", "."], "add_tokens": "var Mexp = function ( parsed ) { if ( ex . constructor !== Array ) { //pop1 needs to be constructor ex = [ { type : 1 , value : ex } ] ; } ex = new Mexp ( ex ) ;", "del_tokens": "var Mexp = function ( parsed , error ) { if ( error ) { this . value = [ ] ; }", "commit_type": "remove"}
{"commit_tokens": ["Update", "bitdepth", "()", "doc", "string"], "add_tokens": "* Change the bit depth of samples . The input array is modified in - place .", "del_tokens": "* Change the bit depth of the data in a array . * The input array is modified in - place .", "commit_type": "update"}
{"commit_tokens": ["Fix", "suppression", "of", "encrypted", "events", "."], "add_tokens": "this . requestGenerated_ [ initDataKey ] = true ; p . catch ( shaka . util . TypedBind ( this , this . requestGenerated_ [ initDataKey ] = false ;", "del_tokens": "p . then ( shaka . util . TypedBind ( this , function ( ) { this . requestGenerated_ [ initDataKey ] = true ; } ) ) . catch ( shaka . util . TypedBind ( this ,", "commit_type": "fix"}
{"commit_tokens": ["Add", "@js", ".", "properties", "namespace", "test", "fix", "found", "bug"], "add_tokens": "const k = key === defaultKey ? prefix . slice ( 0 , - ( pathSep . length ) ) : prefix + key", "del_tokens": "const k = key === defaultKey ? prefix . substr ( 0 , - ( pathSep . length ) ) : prefix + key", "commit_type": "add"}
{"commit_tokens": ["remove", "plato", "help", "doc", "and", "clean", "plato", "interface"], "add_tokens": "var avgMaintainability = parseFloat ( JSON . parse ( platoRes ) . average . maintainability ) ; if ( avgMaintainability < 70 ) {", "del_tokens": "var maintainability = parseFloat ( JSON . parse ( platoRes ) . average . maintainability ) ; if ( maintainability < 70 ) {", "commit_type": "remove"}
{"commit_tokens": ["Fix", "async", "mounting", "issues", "when", "parent", "calls", "scrollHandler", "before", "child", "is", "mounted"], "add_tokens": "item . _node && ( item . _node . style [ prop ] = styleObject [ prop ] ) ;", "del_tokens": "item . _node . style [ prop ] = styleObject [ prop ] ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "some", "issues", "that", "came", "up", "in", "review"], "add_tokens": "this . highlighted_ = highlighted ; this . showLineNumbers_ = showLineNumbers ; var showLineNumbers , highlighted ; if ( writer . currentLine_ . length > 0 ) { __proto__ : ParseTreeVisitor . prototype , if ( tree != null && tree == this . highlighted_ ) { if ( tree != null && tree . location != null && tree . location . start != null && this . showLineNumbers_ ) { if ( tree != null && tree == this . highlighted_ ) { while ( this . currentLine_ . length < 80 ) { if ( this . currentLine_ . length == 0 ) {", "del_tokens": "this . HIGHLIGHTED = highlighted ; this . SHOW_LINE_NUMBERS = showLineNumbers ; if ( writer . currentLine_ . length ( ) > 0 ) { __proto__ : ParseTreeVisitor , if ( tree != null && tree == this . HIGHLIGHTED ) { if ( tree != null && tree . location != null && tree . location . start != null && this . SHOW_LINE_NUMBERS ) { if ( tree != null && tree == this . HIGHLIGHTED ) { while ( this . currentLine_ . length ( ) < 80 ) { if ( this . currentLine_ . length ( ) == 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["Fix", "error", "in", "the", "images", "folder", "name"], "add_tokens": "if ( fs . existsSync ( 'images' ) ) {", "del_tokens": "if ( fs . existsSync ( 'image' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "--", "rename", "option", "to", "rename", "declarations", "and", "references"], "add_tokens": ". options ( \"rename\" , { describe : \"rename declarations and annotated refernces\\n\" + \"originalName newName anotherOriginalName anotherNewName ...\" , default : \"\" } ) [ \"add\" , \"remove\" , \"o\" , \"regexp\" , \"rename\" , \"single_quotes\" , \"plugin\" , \"stats\" ] . forEach ( function ( opt ) { if ( config . rename ) { var flattenRename = config . rename . split ( \" \" ) ; var renameMap = { } ; for ( var i = 0 ; i < flattenRename . length ; i = i + 2 ) { renameMap [ flattenRename [ i ] ] = flattenRename [ i + 1 ] ; } config . rename = renameMap ; }", "del_tokens": "[ \"add\" , \"remove\" , \"o\" , \"regexp\" , \"single_quotes\" , \"plugin\" , \"stats\" ] . forEach ( function ( opt ) {", "commit_type": "add"}
{"commit_tokens": ["removed", "unnecessary", "script", "attributes", "from", "code", "bumped", "version", "number"], "add_tokens": "i = bundleIds . length , numWaiting = i , fn , bundleId , r , q ; var i = paths . length , numWaiting = i , pathsNotFound = [ ] , fn ; while ( i -- ) loadScript ( paths [ i ] , fn ) ;", "del_tokens": "numWaiting = bundleIds . length , i = numWaiting , fn , bundleId , i , r , q ; s . style = 'text/javascript' ; s . async = true ; var numWaiting = paths . length , pathsNotFound = [ ] , fn , i ; for ( i = paths . length - 1 ; i > - 1 ; i -- ) loadScript ( paths [ i ] , fn ) ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "support", "for", "wrapper", "functions", "with", "resolve", "()"], "add_tokens": "* @ param { boolean } [ options . clone = false ] Clone the tree before resolving it , this keeps the original intact but costs some time while cloning , without this the input will be mutated * @ param { function } [ options . wrapper = Promise . resolve ] Wrap the promise in this function before resolving . Called as ( nodeFunction , path , tree ) . Should return a promise or something that has 'that' compatibility wrapper : node => Promise . resolve ( node ( ) ) , var nodePath = path . concat ( [ childIndex ] ) ; ( settings . wrapper ( child , nodePath , base ) ) // Wrap the function and expect it to return a promise", "del_tokens": "* @ param { boolean } [ options . clone = false ] Clone the tree before resolving it , this keeps the original intact but costs some time while cloning Promise . resolve ( child ( ) ) var nodePath = path . concat ( [ childIndex ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "ability", "to", "change", "columnLength"], "add_tokens": "* @ param { Number } [ options . storageOptions . columnLength = 255 ] character length of the column . * For utf8mb4 charsets under InnoDB , you may need to set this <= 190 columnName : 'name' , // You may need to override this for utf8mb4 charsets columnLength : 255 type : new Sequelize . STRING ( this . options . storageOptions . columnLength ) ,", "del_tokens": "columnName : 'name' type : Sequelize . STRING ,", "commit_type": "add"}
{"commit_tokens": ["Make", "sure", "we", "always", "return", "this"], "add_tokens": "if ( ! children ) return this ;", "del_tokens": "if ( ! children ) return ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "for", "things", "getting", "double", "extended"], "add_tokens": "if ( staticKeywords . indexOf ( k ) === - 1 ) { return module ;", "del_tokens": "if ( instanceKeywords . indexOf ( k ) === - 1 ) { return module ;", "commit_type": "fix"}
{"commit_tokens": ["use", "new", "Intl", "polyfill", "capabilities"], "add_tokens": "case 'LL' : return string ( { month : '2-digit' , day : 'numeric' } , 'month' ) ; //like 01, doesn't seem to work case 'LLLL' : return string ( { month : 'long' } , 'month' ) ; //like January case 'LLLLL' : return string ( { month : 'narrow' } , 'month' ) ; //like J case 'MMMMM' : return string ( { month : 'narrow' } , 'month' ) ; //like J", "del_tokens": "case 'LL' : return string ( { month : '2-digit' , day : 'numeric' } , 'month' ) ; //like 01 case 'LLLL' : return string ( { month : 'long' , day : 'numeric' } , 'month' ) ; //like January case 'LLLLL' : return string ( { month : 'narrow' , day : 'numeric' } , 'month' ) ; //like J case 'MMMMM' : return string ( { month : 'narrow' , day : 'numeric' } , 'month' ) ; //like J", "commit_type": "use"}
{"commit_tokens": ["add", "and", "then", "rm", "works", "but", "set", "not", "working"], "add_tokens": "changes . forEach ( change => { changeQueue . add ( ( ) => { return renderChange ( change , inputs , renderFunc , ( renderedChange ) => { // console.log('outputting rendered change', renderedChange); output$ ( renderedChange ) ; } ) // .then(() => { // console.log('rendered change', change); // }); } ) // .then(() => { // console.log('resolved changes', changes); // }) } ) // .then(() => { // console.log('finished rendering add bulk', vals); // });", "del_tokens": "changeQueue . add ( function renderChanges ( ) { return batchAsyncQueue ( changes . map ( change => ( ) => { return renderChange ( change , inputs , renderFunc , output$ ) ; } ) ) ; } ) ; if ( type == 'set' ) { batchCallback ( [ { type : 'add' , index , elems : val != null ? [ renderFunc ( val , inputs ) ] : null } ] ) ; } // export function list(input$, listSelector, renderFunc) { // let output$ = stream([]); // merge$( // listChanges$(input$.map(value => value != null ? value[listSelector] : null)), // input$.map(value => { // if (value == null) { return null; } // let copiedValue = Object.assign({}, value); // delete copiedValue[listSelector]; // return copiedValue; // }) // .distinct() // ) // .map(([changes, inputs]) => { // let chunk = []; // return processLargeArrayAsync( // changes, // ({subIndex, item}) => { // chunk.push({ // subIndex, // elem: item != null ? renderFunc(item, inputs) : null // }); // }, // 200, // () => { // output$(chunk); // chunk = []; // }); // }); // output$.IS_CHANGE_STREAM = true; // return output$; // }", "commit_type": "add"}
{"commit_tokens": ["Use", "connect", ".", "session", "for", "session", "data"], "add_tokens": "var server ; server = connect . createServer ( connect . logger ( ) , connect . bodyParser ( ) , connect . static ( __dirname + '/public' ) , connect . errorHandler ( { showStack : true , dumpExceptions : true } ) , connect . query ( ) , connect . router ( ActivityPump . initApp ) , connect . session ( { secret : ( config . secret || \"activitypump\" ) } ) ) ;", "del_tokens": "server = connect . createServer ( connect . logger ( ) , connect . bodyParser ( ) , connect . static ( __dirname + '/public' ) , connect . errorHandler ( { showStack : true , dumpExceptions : true } ) , connect . query ( ) , connect . router ( ActivityPump . initApp ) ) ,", "commit_type": "use"}
{"commit_tokens": ["updating", "js", "-", "to", "-", "string"], "add_tokens": "// @ts-ignore const mergedData = Object . assign ( { } , oldData , newData ) ; const func = ` ${ jsToString ( mergedData ) } ` ; const required = requireFromString ( func ) ; return required ; script : jsToString ( cleanBundle ) , script : jsToString ( cleanBundle ) ,", "del_tokens": "this . jsToStringOptions = { execFuncs : [ \"data\" ] , } ; const mergedData = Object . assign ( { } , oldData , newData , this . data ) ; return function data ( ) { return mergedData ; } ; script : jsToString ( cleanBundle , this . jsToStringOptions ) , script : jsToString ( cleanBundle , this . jsToStringOptions ) ,", "commit_type": "update"}
{"commit_tokens": ["fixed", "json", "content", "type", "for", "server", "mode"], "add_tokens": "var headerMock = jest . genMockFn ( ) ; var reply = jest . genMockFn ( ) . mockReturnValue ( { header : headerMock } ) ; var headerMock = jest . genMockFn ( ) ; var reply = jest . genMockFn ( ) . mockReturnValue ( { header : headerMock } ) ;", "del_tokens": "var reply = jest . genMockFn ( ) ; var reply = jest . genMockFn ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "configuration", "for", "src", "/", "lib", "/", "resources", "in", "info", ".", "js", "to", "make", "it", "a", "little", "more", "relocatable", "."], "add_tokens": "exports . buildTypes = [ 'prod' , 'developer' , 'qa' , 'stage' , 'uitest' ] ;", "del_tokens": "exports . buildTypes = [ 'prod' , 'developer' , 'qa' , 'uitest' ] ;", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "of", "mostRecentCall", "on", "Spy", "API", "."], "add_tokens": "mostRecentCall : { } , } if ( prop === 'mostRecentCall' ) { return target . calls . mostRecent ( ) ; }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["Fixing", "broken", "Array", ".", "prototype", ".", "includes"], "add_tokens": "return styles . indexOf ( line_info ) < 0", "del_tokens": "return ! styles . includes ( line_info )", "commit_type": "fix"}
{"commit_tokens": ["Allowing", "to", "use", "noder", "with", "no", "configuration", "."], "add_tokens": "// if there is no src, it cannot be the right script tag anyway if ( src ) { var configContent = scriptTag . innerHTML ; if ( ! / ^\\s*$ / . test ( configContent ) ) { config = exec ( configContent ) || config ; }", "del_tokens": "if ( ! src ) { // if there is no src, it cannot be the right script tag scriptTag = null ; } else { config = exec ( scriptTag . innerHTML ) || config ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "moduleNameMapper", "to", "point", "to", "src", "/", "index", ".", "ts", "instead", "of", "lib", "/", "cjs", "/", "index", ".", "ts", "during", "testing", "time"], "add_tokens": "moduleNameMapper : { '^@cycle-robot-drivers\\\\/([^/]+)' : '<rootDir>/../$1/src' } , tsConfigFile : \"<rootDir>/tsconfig.json\" , enableTsDiagnostics : true", "del_tokens": "\"transformIgnorePatterns\" : [ \"<rootDir>/node_modules/(?!@cycle)\" , \"<rootDir>/node_modules/(?!@cycle-robot-drivers)\" ] , tsConfigFile : \"<rootDir>/tsconfig.json\"", "commit_type": "add"}
{"commit_tokens": ["adding", "max", "parameter", "for", "restricting", "the", "number", "of", "units"], "add_tokens": "empty = byId ( 'empty-label' ) . value || \"\" , max = Number ( byId ( 'max-units' ) . value ) ; byId ( 'counter' ) . innerHTML = ts . toHTML ( \"strong\" , max ) || empty ;", "del_tokens": "empty = byId ( 'empty-label' ) . value || \"\" ; byId ( 'counter' ) . innerHTML = ts . toHTML ( \"strong\" ) || empty ;", "commit_type": "add"}
{"commit_tokens": ["Use", "location", ".", "hash", "to", "remember", "active", "window"], "add_tokens": ". scrollGlue ( { speed : 400 } ) . end ( ) ; var networks = $ ( \"#networks\" ) . html ( render ( \"networks\" , { networks : data . networks } ) ) ; var target = null ; if ( location . hash ) { var id = location . hash ; target = sidebar . find ( \"button[data-target='\" + id + \"']\" ) ; } else { target = sidebar . find ( \"button\" ) . first ( ) } target . trigger ( \"click\" ) ; location . hash = target ; var window = $ ( target ) . css ( \"z-index\" , z ++ )", "del_tokens": ". scrollGlue ( { speed : 400 } ) ; $ ( \"#networks\" ) . html ( render ( \"networks\" , { networks : data . networks } ) ) . parent ( ) . find ( \"button\" ) . first ( ) . trigger ( \"click\" ) ; $ ( target ) . css ( \"z-index\" , z ++ )", "commit_type": "use"}
{"commit_tokens": ["Added", "tests", "for", "compiled", "source"], "add_tokens": "name : 'App' , exclude : [ 'coders/component/cpCoder' , 'coders/component/cpDecoder' , 'coders/placeholders/plCoder' , 'coders/placeholders/plDecoder' , 'coders/databind/bdDecoder' , 'coders/databind/bdCoder' , 'coders/style/styleCoder' , 'coders/style/styleDecoder' , 'coders/router/routerCoder' , 'coders/router/routerDecoder' , 'templating/Coder' , 'templating/Decoder' ] { name : 'template' } , grunt . registerTask ( 'test' , [ 'connect' , 'mocha_phantomjs' ] ) ; grunt . registerTask ( 'default' , [ 'clean:all' , 'exec:browserify' , 'reqTemplate' , 'copy:es6' , 'babel:dev' , 'babel:prod' , 'copy:es5' , 'basic' , 'uglify' , 'test' ] ) ;", "del_tokens": "exclude : [ 'coders/component/cpCoder' , 'coders/component/cpDecoder' , 'coders/placeholders/plCoder' , 'coders/placeholders/plDecoder' , 'coders/databind/bdDecoder' , 'coders/databind/bdCoder' , 'coders/style/styleCoder' , 'coders/style/styleDecoder' , 'coders/router/routerCoder' , 'coders/router/routerDecoder' , 'templating/Coder' , 'templating/Decoder' ] , name : 'App' grunt . registerTask ( 'default' , [ 'clean:all' , 'exec:browserify' , 'reqTemplate' , 'copy:es6' , 'babel:dev' , 'babel:prod' , 'copy:es5' , 'basic' , 'uglify' ] ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "check", "for", "ie11", "to", "login"], "add_tokens": "useIntermediateIframe = window . navigator . userAgent . indexOf ( \"MSIE\" ) >= 0 || window . navigator . userAgent . indexOf ( \"Trident\" ) >= 0 ,", "del_tokens": "useIntermediateIframe = window . navigator . userAgent . indexOf ( \"MSIE\" ) >= 0 ,", "commit_type": "add"}
{"commit_tokens": ["Make", "horizontal", "picker", "work", "fine", "with", "value"], "add_tokens": "//events on ( self . draggable , 'drag' , function ( ) { self . value = self . calcValue ( ) ; } ) ; on ( self . draggable , 'dragend' , function ( ) { self . renderValue ( ) ; } ) ; //don’t render value on each drag step // this.renderValue(); self . calcValue = function ( e ) { // calcValue: function (e) { calcValue : function ( e ) { calcValue : function ( e ) { calcValue : function ( e ) {", "del_tokens": "this . renderValue ( value ) ; self . _getValue = function ( e ) { // _getValue: function (e) { _getValue : function ( e ) { _getValue : function ( e ) { _getValue : function ( e ) {", "commit_type": "make"}
{"commit_tokens": ["Fix", "the", "validation", "of", "2", "letter", "TLDs", "in", "the", "email", "regexp"], "add_tokens": "PATTERN : / ^[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z]{2,}$ /", "del_tokens": "PATTERN : / ^[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9\\u007F-\\uffff!#$%&'*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|edu|gov|mil|biz|info|mobi|name|aero|asia|jobs|museum)$ /", "commit_type": "fix"}
{"commit_tokens": ["update", "appendFittedText", "to", "support", "data", "update"], "add_tokens": "var text = d3 . select ( this ) . data ( [ { } ] ) ; text . enter ( ) . merge ( text ) var span = d3 . select ( this ) . selectAll ( \"tspan\" ) . data ( lines ) ; span . exit ( ) . remove ( ) ; span . enter ( ) . merge ( span )", "del_tokens": "d3 . select ( this ) . data ( [ { } ] ) . enter ( ) d3 . select ( this ) . selectAll ( \"tspan\" ) . data ( lines ) . enter ( ) console . log ( d ) ;", "commit_type": "update"}
{"commit_tokens": ["made", "reverse", "work", "with", "varying", "num", "channels"], "add_tokens": "var numChannels = buffer . numberOfChannels , cloned = this . _context . createBuffer ( numChannels , buffer . length , buffer . sampleRate ) ; for ( var i = 0 ; i < numChannels ; i ++ ) { var numChannels = buffer . numberOfChannels ; for ( var i = 0 ; i < numChannels ; i ++ ) { Array . prototype . reverse . call ( buffer . getChannelData ( i ) ) ; } return buffer ;", "del_tokens": "var cloned = this . _context . createBuffer ( buffer . numberOfChannels , buffer . length , buffer . sampleRate ) ; for ( var i = 0 ; i < buffer . numberOfChannels ; i ++ ) { //cloned.getChannelData(i).set(new Float32Array(buffer.getChannelData(i))); Array . prototype . reverse . call ( buffer . getChannelData ( 0 ) ) ; Array . prototype . reverse . call ( buffer . getChannelData ( 1 ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Removing", "old", "code", "fixing", "lint", "errors", "."], "add_tokens": "/*eslint-disable global-require*/ /*eslint-enable global-require*/", "del_tokens": "const decode = require ( './decode' ) ; //todo deprecate client . decode = decode ; //todo deprecate module . exports . decode = decode ;", "commit_type": "remove"}
{"commit_tokens": ["fix", "relationship", "name", "for", "belongsTo", "polymorphic"], "add_tokens": "type : modelName ,", "del_tokens": "type : relation . modelTo . modelName ,", "commit_type": "fix"}
{"commit_tokens": ["fixed", "tests", "not", "building", ".", "added", "watch"], "add_tokens": "var testWebpackConfig = require ( './test/webpack.config' ) ; gulp . task ( 'build-test' , function ( callback ) { testWebpackConfig . plugins = testWebpackConfig . plugins . concat ( new webpack . DefinePlugin ( { 'process.env' : { 'NODE_ENV' : JSON . stringify ( 'development' ) } } ) ) ; webpackHelper ( testWebpackConfig , callback ) ; } ) ; runSequence ( 'build-test' , 'test-server-start' , 'process.env' : { 'NODE_ENV' : JSON . stringify ( 'development' ) 'process.env' : { 'NODE_ENV' : JSON . stringify ( 'production' ) gulp . task ( 'watch' , function ( ) { gulp . watch ( [ 'src/**/*' ] , [ 'build-dev' ] ) ; } ) ;", "del_tokens": "runSequence ( 'test-server-start' , \"process.env\" : { \"NODE_ENV\" : JSON . stringify ( \"development\" ) \"process.env\" : { \"NODE_ENV\" : JSON . stringify ( \"production\" )", "commit_type": "fix"}
{"commit_tokens": ["add", "more", "default", "options", "in", "broker"], "add_tokens": "nodeID : null , logger : null , transporter : null , sendHeartbeatTime : 10 , nodeHeartbeatTimeout : 30 , cacher : null , metrics : false , // ServiceFactory: null, // ContextFactory: null // Self nodeID this . nodeID = this . options . nodeID || utils . getNodeID ( ) ;", "del_tokens": "sendHeartbeatTime : 10 , nodeHeartbeatTimeout : 30 , metrics : false , // Self nodeID this . nodeID = this . options . nodeID || utils . getNodeID ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "header", "marker", "and", "add_header", "methods"], "add_tokens": "if ( err . stack ) { logger . logerror ( method + \" failed: \" + err ) ; err . stack . split ( \"\\n\" ) . forEach ( logger . logerror ) ; } else { logger . logerror ( method + \" failed: \" + err ) ; } this . transaction . add_data ( line ) ; // this.transaction.add_header('X-Haraka', 'Version ' + haraka.version);", "del_tokens": "logger . logerror ( method + \" failed: \" + err ) ; this . transaction . data_bytes += line . length ; this . transaction . data_add ( line ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "header", "to", "minified", "JavaScript"], "add_tokens": "", "del_tokens": "var average = ( minX + maxX ) / 2 ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "debug", "messages", "and", "fixed", "typo"], "add_tokens": "//console.log(__filename + ': DEBUG: _resolve(routes = '+\"'\" + routes + \"', path='\" + path + \"') called!\");", "del_tokens": "console . log ( __filename + ': DEBUG: _resolve(routes = ' + \"'\" + routes + \"', path='\" + path + \"') called!\" ) ;", "commit_type": "remove"}
{"commit_tokens": ["adds", "normalizeObject", "and", "option", "for", "name", "to", "be", "a", "function", ".", "nowhere", "near", "done"], "add_tokens": "var fixture = [ { hash : true , name : 'foo.bar.baz' , src : [ 'test/fixtures/*.{json,yml}' ] , one : { two : 'three' } } ] ; var expected = { foo : { bar : { aaa : 'bbbb' , ccc : 'dddd' , eee : 'ffff' } } , one : { two : 'three' } } ;", "del_tokens": "var fixture = [ { hash : true , name : 'foo.bar.baz' , src : [ 'test/fixtures/*.{json,yml}' ] , one : { two : 'three' } } ] ; var expected = { foo : { bar : { aaa : 'bbbb' , ccc : 'dddd' , eee : 'ffff' } } , one : { two : 'three' } } ;", "commit_type": "add"}
{"commit_tokens": ["fix", "potential", "memory", "leak", "on", "other", "platforms"], "add_tokens": "if ( device . platform === \"iOS\" ) { linkHandlers [ linkHandlerId ] = ! options . linkPattern ? onLink : function ( link ) { return options . linkPattern . test ( link ) ? onLink ( link ) : false ; } ; }", "del_tokens": "linkHandlers [ linkHandlerId ] = ! options . linkPattern ? onLink : function ( link ) { return options . linkPattern . test ( link ) ? onLink ( link ) : false ; } ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "problem", "with", "redirecting", "to", "a", "test", "page", "."], "add_tokens": "res . redirect ( url + '#testem' )", "del_tokens": "res . redirect ( url )", "commit_type": "fix"}
{"commit_tokens": ["Removed", "/", "...", "/", "from", "pattern"], "add_tokens": "privateProps . get ( this ) . pattern = pattern . trim ( ) . replace ( '/' , '' ) ;", "del_tokens": "privateProps . get ( this ) . pattern = '/' + pattern . trim ( ) . replace ( '/' , '' ) + '/' ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "partial", "-", "import", "resolver"], "add_tokens": "exports . LocalModuleProxy = require ( './resolvers/LocalModuleProxy' ) ; exports . WeaveworksPartialImport = require ( './resolvers/WeaveworksPartialImport' ) ;", "del_tokens": "exports . LocalModuleProxy = require ( './resolvers/localModuleProxy' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "paths", "and", "each", "to", "util"], "add_tokens": "function each ( obj , iter ) { if ( Array . isArray ( obj ) ) return obj . forEach ( iter ) for ( var k in obj ) iter ( obj [ k ] , k , obj ) } //this can probably be optimized to create less arrays! function paths ( object , test ) { var p = [ ] for ( var key in object ) { var value = object [ key ] if ( test ( value ) ) p . push ( key ) else if ( isObject ( value ) ) p = p . concat ( paths ( value , test ) . map ( function ( path ) { return [ key ] . concat ( path ) } ) ) } return p exports . paths = paths exports . each = each", "del_tokens": "function paths ( value , test ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "Audio", "Output", "configuration"], "add_tokens": "connection . deletePlayList ( name ) ; } , getOutputs : function ( cb , errorcb ) { if ( ! connection ) { errorHandler ( \"notconnected\" ) ; } connection . getOutputs ( cb , errorcb ) ; } , enableOutput : function ( id , cb , errorcb ) { if ( ! connection ) { errorHandler ( \"notconnected\" ) ; } connection . enableOutput ( id , cb , errorcb ) ; } , disableOutput : function ( id , cb , errorcb ) { if ( ! connection ) { errorHandler ( \"notconnected\" ) ; } connection . disableOutput ( id , cb , errorcb ) ; }", "del_tokens": "}", "commit_type": "add"}
{"commit_tokens": ["add", "require", ".", "js", "support"], "add_tokens": "( function ( angular , factory ) { if ( typeof define === 'function' && define . amd ) { define ( 'ngTable' , [ 'jquery' , 'angular' ] , function ( $ , angular ) { return factory ( angular ) ; } ) ; } else { return factory ( angular ) ; } } ( angular || null , function ( angular ) { var el , filter , filterTemplateURL , parsedTitle ; filter = el . attr ( \"filter\" ) ? $parse ( el . attr ( \"filter\" ) ) ( ) : false ; filterTemplateURL = false ; if ( filter && filter . templateURL ) { filterTemplateURL = filter . templateURL ; delete filter . templateURL ; } filter : filter , filterTemplateURL : filterTemplateURL , $templateCache . put ( 'ng-table/header.html' , '<tr><th ng-class=\"{sortable: column.sortable,\\'sort-asc\\': params.sorting[column.sortable]==\\'asc\\', \\'sort-desc\\': params.sorting[column.sortable]==\\'desc\\'}\" ng-click=\"sortBy(column)\" ng-repeat=\"column in columns\" ng-show=\"column.show(this)\" class=\"header\"><div>{{column.title}}</div></th></tr><tr ng-show=\"show_filter\"><th ng-repeat=\"column in columns\" ng-show=\"column.show(this)\" class=\"filter\"><form ng-submit=\"doFilter()\"><input type=\"submit\" style=\"position: absolute; left: -9999px; width: 1px; height: 1px;\"/><div ng-repeat=\"(name, filter) in column.filter\"><div ng-if=\"column.filterTemplateURL\"><div ng-include=\"column.filterTemplateURL\"></div></div><div ng-if=\"!column.filterTemplateURL\"><div ng-include=\"\\'ng-table/filters/\\' + filter + \\'.html\\'\"></div></div></div></form></th></tr>' ) ; } ] ) ; return angular . module ( 'ngTable' ) ; } ) ) ;", "del_tokens": "var el , parsedTitle ; filter : ( el . attr ( \"filter\" ) ? $parse ( el . attr ( \"filter\" ) ) ( ) : false ) , $templateCache . put ( 'ng-table/header.html' , '<tr><th ng-class=\"{sortable: column.sortable,\\'sort-asc\\': params.sorting[column.sortable]==\\'asc\\', \\'sort-desc\\': params.sorting[column.sortable]==\\'desc\\'}\" ng-click=\"sortBy(column)\" ng-repeat=\"column in columns\" ng-show=\"column.show(this)\" class=\"header\"><div>{{column.title}}</div></th></tr><tr ng-show=\"show_filter\"><th ng-repeat=\"column in columns\" ng-show=\"column.show(this)\" class=\"filter\"><form ng-submit=\"doFilter()\"><input type=\"submit\" style=\"position: absolute; left: -9999px; width: 1px; height: 1px;\"/><div ng-repeat=\"(name, filter) in column.filter\"><div ng-include=\"\\'ng-table/filters/\\' + filter + \\'.html\\'\"></div></div></form></th></tr>' ) ; } ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "now", "obsolete", "error", "handling", "for", "formatter", "loading"], "add_tokens": "resolveMissingFormatter . should . throw ( Error , { message : / There was a problem loading formatter / } ) ;", "del_tokens": "resolveMissingFormatter . should . throw ( TypeError , { message : 'Invalid Formatter' } ) ;", "commit_type": "remove"}
{"commit_tokens": ["Updated", "tests", "so", "they", "pass", "again", "."], "add_tokens": "return conn . model ( 'IdentityCounter' ) . collection . drop ( done ) ;", "del_tokens": "return conn . model ( 'Mongoose-Auto-Increment' ) . collection . drop ( done ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "auth", "to", "disposition", "unpack"], "add_tokens": "authDisposition = this . getAuthDisposition ( ) , auth = this . getAuthProperties ( ) , _ . union ( authDisposition , imports . required , config . required ) . concat ( authDisposition , } else if ( auth . hasOwnProperty ( attr ) ) { prop = _ . clone ( auth [ attr ] ) ; auth = this . getAuthProperties ( ) , imports : { } , auth : { } if ( auth . hasOwnProperty ( ptr . name ) ) { unpacked . auth [ ptr . name ] = value ; }", "del_tokens": "_ . union ( imports . required , config . required ) . concat ( imports : { }", "commit_type": "add"}
{"commit_tokens": ["Update", "HERE", "as", "requested", "by", "Marek"], "add_tokens": "'Map &copy; 1987-2014 <a href=\"http://developer.here.com\">HERE</a>' ,", "del_tokens": "'Map &copy; <a href=\"http://developer.here.com\">HERE</a>, Data &copy; NAVTEQ 2012' ,", "commit_type": "update"}
{"commit_tokens": ["Add", "\\", "!help", "factoids", ".", "Fix", "typo", "."], "add_tokens": "\"factoids\" : [ \"Factoids are short descriptions for phrases often used\" \"for FAQs or inside jokes.\" , \"\" , \"You can look up a factoid with `{{!}}factoid key` or\" , \"teach this bot a factoid with `{{!}}learn`. You can also\" , \"make the bot forget a factoid with `{{!}}forget key`.\" , \"Admins can make certain factoids unmodifiable.\" , \"For more information, do {{!}}help command-name.\" ] , \"{{!}}learn factoid-key = factiod-description\" ,", "del_tokens": "\"{{!}}learn factoid-key = faction-description\" ,", "commit_type": "add"}
{"commit_tokens": ["fixed", "a", "bug", "with", "dynamic", "HTML", "injection"], "add_tokens": "if ( node . match ( / <[\\w:_-]+[^>]*> / ) ) { if ( domChild . children . length === 1 ) { domChild . parentNode . innerHTML = node ; } else { let html = document . createElement ( 'span' ) ; html . innerHTML = node ; domChild . parentNode . replaceChild ( html , domChild ) ; } } else { domChild . nodeValue = node . replace ( / &quot; / g , '\"' ) . replace ( / &lt; / g , '<' ) . replace ( / &gt; / g , '>' ) . replace ( / &amp; / g , '&' ) ; }", "del_tokens": "domChild . nodeValue = node ;", "commit_type": "fix"}
{"commit_tokens": ["Adding", "mocha", "testing", "framework", "with", "tests", ".", "Cleaning", "examples", "and", "renaming", "sync", "to", "standard", "."], "add_tokens": "console . log ( hashes ) ;", "del_tokens": "console . log ( hashes ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "type", "definitions", "for", "TypeScrypt", "removed", "problematic", "base64", "-", "url", "dependency"], "add_tokens": "var decoded = JSON . parse ( decode ( parts [ 1 ] ) ) ; function unescape ( str ) { return ( str + '===' . slice ( ( str . length + 3 ) % 4 ) ) . replace ( / - / g , '+' ) . replace ( / _ / g , '/' ) ; } function decode ( str , encoding ) { return Buffer . from ( unescape ( str ) , 'base64' ) . toString ( encoding || 'utf8' ) ; }", "del_tokens": "var base64 = require ( \"base64-url\" ) ; var decoded = JSON . parse ( base64 . decode ( parts [ 1 ] ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "alerts", "success", "/", "warning"], "add_tokens": "this . onError = options . onError || this . onError ; App . alertView . success ( 'Saved' ) ; } , onError : function onError ( ) { console . log ( arguments ) App . alertView . error ( 'Invalid form' ) ;", "del_tokens": "this . onError = options . onError || noop ;", "commit_type": "add"}
{"commit_tokens": ["Implement", "and", "assert", "on", "strict", "find", "."], "add_tokens": "* @ param strict A boolean indicating that the default language * should never be returned . function find ( search , filter , strict ) { var lang , search = search || [ ] , i , k , v , re = / ^(LC_|LANG) / ; return c ( lang ) || ( ! strict ? language : null ) ;", "del_tokens": "function find ( search , filter ) { var lang , search = search || [ ] , i , k , v , re = / ^LC_ / ; return c ( lang ) || language ;", "commit_type": "implement"}
{"commit_tokens": ["added", "check", "for", "git", "command", "availability", ".", "Updated", "my", "contact", "email", "in", "the", "contributors", "list", "."], "add_tokens": "// TODO: process.exit(1) is a pretty terrible pattern because it kills // excecution immediately and prevents cleanup routines. However, // I don't want to just spew a stack trace to the user either. // verify platform is supported // verify that git command line is available if ( ! shell . which ( 'git' ) ) { console . error ( '\"git\" command not found.' ) ; process . exit ( 1 ) ; } // specify which project tag to check out. minimum tag is 2.1.0rc1", "del_tokens": "// TODO: this is really a pretty terrible pattern because it kills // excecution immediately and prevents cleanup routines. However, // I don't want to just spew a stack trace to the user either. // specify which project tag to check out. minimum tag is 2.1.0", "commit_type": "add"}
{"commit_tokens": ["Fix", "to", "make", "sure", "the", "build", "runs"], "add_tokens": "} ) . then ( function ( ) {", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["FIXED", ":", "map", "drawing", "if", "no", "window", "found"], "add_tokens": "* @ param { number } options . viewportW The width of the viewport : it is usually the same as the game width . Default = map . width * @ param { number } options . viewportH The height of the viewport : it is usually the same as the game height . Default = map . height this . viewportW = options . viewportW || this . width ; this . viewportH = options . viewportH || this . height ; debugger ; if ( window && window . displayed === false ) {", "del_tokens": "* @ param { number } options . viewportW The width of the viewport : it is usually the same as the game width * @ param { number } options . viewportH The height of the viewport : it is usually the same as the game height this . viewportW = options . viewportW || 0 ; this . viewportH = options . viewportH || 0 ; if ( window . displayed === false ) {", "commit_type": "fix"}
{"commit_tokens": ["Added", "environment", "variable", "scanning", "and", "app", "name", "caching", "per", "page"], "add_tokens": "href : content . document . location . href , html : content . document . documentElement . innerHTML , headers : [ ] , environmentVars : wappalyzer . getEnvironmentVars ( ) } , getEnvironmentVars : function ( ) { var element = content . document . createElement ( 'wappalyzerData' ) ; element . setAttribute ( 'id' , 'wappalyzer-data' ) ; element . setAttribute ( 'style' , 'display: none;' ) ; content . document . documentElement . appendChild ( element ) ; var script = content . document . createElement ( 'script' ) ; script . innerHTML = 'for ( i in window ) document.getElementById(\"wappalyzer-data\").innerHTML += i + \" \";' ; content . document . documentElement . appendChild ( script ) ; var environmentVars = content . document . getElementById ( 'wappalyzer-data' ) . innerHTML . split ( ' ' ) ; element . parentNode . removeChild ( element ) ; script . parentNode . removeChild ( script ) ; return environmentVars ;", "del_tokens": "href : content . document . location . href , html : content . document . documentElement . innerHTML , headers : [ ]", "commit_type": "add"}
{"commit_tokens": ["Added", "ability", "to", "pass", "options", "to", "bower", "command"], "add_tokens": "var bowerOptions = this . data . bowerOptions || { } ; } , includes , excludes , dependencies , bowerOptions ) ; function bowerJavaScripts ( allDone , includes , excludes , dependencies , bowerOptions ) { map : bowerList ( 'map' , bowerOptions ) , components : bowerList ( 'paths' , bowerOptions ) function bowerList ( kind , bowerOptions ) { _ . extend ( params , bowerOptions ) ;", "del_tokens": "} , includes , excludes , dependencies ) ; function bowerJavaScripts ( allDone , includes , excludes , dependencies ) { map : bowerList ( 'map' ) , components : bowerList ( 'paths' ) function bowerList ( kind ) {", "commit_type": "add"}
{"commit_tokens": ["Removing", "the", "resolve", "and", "reject", "methods", "from", "promise", ".", "done", "."], "add_tokens": "createPromise . done = done . promise ( ) ;", "del_tokens": "createPromise . done = done ;", "commit_type": "remove"}
{"commit_tokens": ["Use", "the", "Compressor", "/", "Decompressor", "contructors", "correctly", "in", "compressor", "tests"], "add_tokens": "var decompressor = new Decompressor ( 'REQUEST' ) ; var compressor = new Compressor ( 'REQUEST' ) ; var decompressor = new Decompressor ( 'REQUEST' ) ;", "del_tokens": "var decompressor = new Decompressor ( true ) ; var compressor = new Compressor ( true ) ; var decompressor = new Decompressor ( true ) ;", "commit_type": "use"}
{"commit_tokens": ["Fixed", "an", "issue", "with", "missing", "console", "method", "in", "IE", "."], "add_tokens": "/*global define,window,document*/ if ( has ( window . console ) ) { window . console . info ( message ) ; if ( has ( window . console ) ) { window . console . warn ( message ) ; if ( has ( window . console ) ) { window . console . error ( message ) ; if ( has ( window . console ) ) { if ( has ( window . console , 'debug' ) ) { window . console . debug ( message ) ; window . console . info ( message ) ;", "del_tokens": "/*global define,console,document*/ if ( has ( console ) ) { console . info ( message ) ; if ( has ( console ) ) { console . warn ( message ) ; if ( has ( console ) ) { console . error ( message ) ; if ( has ( console ) ) { if ( has ( console , 'debug' ) ) { console . debug ( message ) ; info ( message ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "a", "bug", "in", "debugger"], "add_tokens": "events : { \"click .log\" : \"logStateMachine\" } , logStateMachine : function ( event ) { event . preventDefault ( ) ; console . log ( this . model ) ; }", "del_tokens": "$ ( \".log\" , innerHtml ) . click ( _ . bind ( function ( event ) { event . preventDefault ( ) ; console . log ( this . model ) ; } , this ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["update", "how", "CS1", "IV", "works"], "add_tokens": "var seed = self . whokey ( arg . parts , false , arg . keys ) ; function whokey ( parts , key , keys ) if ( keys ) key = keys [ csid ] ; // convenience for addSeed", "del_tokens": "var seed = self . whokey ( arg . parts , arg . keys ) ; function whokey ( parts , key ) if ( typeof key == \"object\" ) key = key [ csid ] ; // convenience for addSeed", "commit_type": "update"}
{"commit_tokens": ["Added", "module", "references", "to", "index"], "add_tokens": "module . exports . impersonate = require ( './impersonate' ) ;", "del_tokens": "module . exports . impersonate = require ( './impersonate' )", "commit_type": "add"}
{"commit_tokens": ["Make", "builder", "agnostic", "about", "type", "of", "transformer"], "add_tokens": "transformer : compilerCollection", "del_tokens": "compilerCollection : compilerCollection", "commit_type": "make"}
{"commit_tokens": ["Add", "simple", "class", "-", "ruleset", "JS", "output", "for", "required", "CSS", "modules", "."], "add_tokens": "import generateRuleSetObj from \"./gen-ruleset-obj\" ; \"insert\" , \"object\" return generateRuleSetObj ( bundles ) ;", "del_tokens": "\"insert\" // TODO", "commit_type": "add"}
{"commit_tokens": ["update", "react", "-", "prop", "-", "types", "dependency"], "add_tokens": "import createChainableTypeChecker from 'react-prop-types/lib/utils/createChainableTypeChecker' ;", "del_tokens": "import { createChainableTypeChecker } from 'react-prop-types/lib/common' ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "method", "hook", "with", "api", "versioning"], "add_tokens": "type = type . replace ( builder . version , self . version ) ; var event = util . format ( '%s.%s.%s.%s' , name , self . name , self . version , arg ) ;", "del_tokens": "var event = util . format ( '%s.%s.%s' , name , self . name , arg ) ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "published", "version", "of", "deskproapps", "-", "sdk", "-", "react"], "add_tokens": "pattern : '(https?:)?//unpkg.com/@deskproapps/deskproapps-sdk-react/dist/deskproapps-sdk-react.min.js' . replace ( '.' , '\\.' ) , replacement : destination == 'dist' ? '//unpkg.com/@deskproapps/deskproapps-sdk-react@0.1.4/dist/deskproapps-sdk-react.js' : '../assets/deskproapps-sdk-react.js'", "del_tokens": "pattern : '(https?:)?//unpkg.com/deskproapps-sdk-react/dist/deskproapps-sdk-react.min.js' . replace ( '.' , '\\.' ) , replacement : destination == 'dist' ? '../assets/deskproapps-sdk-react.js' : '../assets/deskproapps-sdk-react.js'", "commit_type": "use"}
{"commit_tokens": ["Fix", "issue", "where", "default", "and", "rest", "params", "where", "dropped", "on", "the", "floor", "by", "the", "ClassTransformer", "."], "add_tokens": "var createParameterList = ParseTreeFactory . createParameterList ; createParameterList ( set . tree . parameter ) , method . tree . formalParameterList , * @ param { FormalParameterList } formalParameters methodTree . formalParameterList ,", "del_tokens": "var createParameters = ParseTreeFactory . createParameters ; createParameters ( set . tree . parameter ) , createParameters ( method . tree . formalParameterList ) , * @ param { Array . < string > } formalParameters createParameters ( methodTree . formalParameterList ) ,", "commit_type": "fix"}
{"commit_tokens": ["Use", "<Row", ">", "instead", "of", "<tr", ">", "for", "column", "indicators"], "add_tokens": "< Row > < / Row >", "del_tokens": "< tr > < / tr >", "commit_type": "use"}
{"commit_tokens": ["Fixed", "getTokenByName", "when", "multiple", "tokens", "are", "available"], "add_tokens": "* @ param { string } device_id id of the device if ( token ) break ;", "del_tokens": "* @ param { string } device_id id of the device if ( token ) return ;", "commit_type": "fix"}
{"commit_tokens": ["Remove", "support", "for", "old", "versions", "of", "Ember", "."], "add_tokens": "assert . equal ( formatMoney ( [ 123.4567 ] , { } ) , \"$123.46\" ) ; assert . equal ( formatMoney ( [ 123.4567 ] , { precision : 2 } ) , \"$123.46\" ) ; assert . equal ( formatMoney ( [ 123.4567 ] , { precision : 2 , decimal : \",\" } ) , \"$123,46\" ) ; assert . equal ( formatMoney ( [ 1234.567 ] , { precision : 2 , decimal : \",\" , thousand : \"::\" } ) , \"$1::234,57\" ) ; assert . equal ( formatMoney ( [ 1234.567 ] , { precision : 2 , symbol : \"€\", f rmat: \" v %s\"}) , \" ,234.57 €\");", "del_tokens": "import callHelper from '../../helpers/call-helper' ; assert . equal ( callHelper ( formatMoney , 123.4567 , { } ) , \"$123.46\" ) ; assert . equal ( callHelper ( formatMoney , 123.4567 , { precision : 2 } ) , \"$123.46\" ) ; assert . equal ( callHelper ( formatMoney , 123.4567 , { precision : 2 , decimal : \",\" } ) , \"$123,46\" ) ; assert . equal ( callHelper ( formatMoney , 1234.567 , { precision : 2 , decimal : \",\" , thousand : \"::\" } ) , \"$1::234,57\" ) ; assert . equal ( callHelper ( formatMoney , 1234.567 , { precision : 2 , symbol : \"€\", f rmat: \" v %s\"}) , \" ,234.57 €\");", "commit_type": "remove"}
{"commit_tokens": ["Use", "real", "logged", "user", "on", "extended", "headers"], "add_tokens": "headers [ 'X-Logged-User' ] = logged_user // logged_user", "del_tokens": "headers [ 'X-Logged-User' ] = process . env [ 'USERNAME' ] // logged_user", "commit_type": "use"}
{"commit_tokens": ["moved", "scriptinjector", ".", "js", "to", "module", "dependency"], "add_tokens": "Spins up a development server on ` ` http : //localhost:PORT`` for working with static your JavaScript changes .", "del_tokens": "Spins up a development server on ` ` http : //localhost:PORT`` for working with static your JavaScript changes . Works only with auto - generated index . html '", "commit_type": "move"}
{"commit_tokens": ["add", "support", "for", "describe", "level"], "add_tokens": "* @ param { function } dIt - The 'it' function used in this function . * @ param { function } dDescribe - The 'describe' function used in this function . * If omitted , 'describe' in global name space is used . function forEach ( parameters , dIt = global . it , dDescribe = global . describe ) { const it = makeTestCaseDefiner ( parameters , dIt ) ; it . skip = makeParameterizedSkip ( parameters , dIt ) ; it . only = makeParameterizedOnly ( parameters , dIt ) ; const describe = makeTestCaseDefiner ( parameters , dDescribe ) ; describe . skip = makeParameterizedSkip ( parameters , dDescribe ) ; describe . only = makeParameterizedOnly ( parameters , dDescribe ) ; return { it , describe } ;", "del_tokens": "* @ param { function } defaultIt - The 'it' function used in this function . function forEach ( parameters , defaultIt = global . it ) { const it = makeTestCaseDefiner ( parameters , defaultIt ) ; it . skip = makeParameterizedSkip ( parameters , defaultIt ) ; it . only = makeParameterizedOnly ( parameters , defaultIt ) ; return { it } ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "on", "socket", ".", "io", "ver", ".", "3"], "add_tokens": "this . io = require ( \"socket.io\" ) ( server , { cors : { origin : \"*\" , methods : [ \"GET\" , \"POST\" ] } } ) ;", "del_tokens": "this . io = require ( \"socket.io\" ) ( server ) ;", "commit_type": "fix"}
{"commit_tokens": ["using", "obj", "name", "instead", "of", "any", "for", "weak", "references"], "add_tokens": "hyperHTML . wire = function wire ( obj ) { wireWeakly ( obj ) ; function wireWeakly ( obj ) { return wm . get ( obj ) || ( wm . set ( obj , wireContent ( ) ) , wireWeakly ( obj ) get : function ( obj ) { return obj [ EXPANDO ] ; } , set : function ( obj , value ) { Object . defineProperty ( obj , EXPANDO , {", "del_tokens": "hyperHTML . wire = function wire ( any ) { wireWeakly ( any ) ; function wireWeakly ( any ) { return wm . get ( any ) || ( wm . set ( any , wireContent ( ) ) , wireWeakly ( any ) get : function ( any ) { return any [ EXPANDO ] ; } , set : function ( any , value ) { Object . defineProperty ( any , EXPANDO , {", "commit_type": "use"}
{"commit_tokens": ["Added", "models", "and", "refactored", "code", "to", "match"], "add_tokens": "doc . autoTable ( columns , data ) ;", "del_tokens": "doc . autoTable ( columns , data , { overflowColumns : [ ] } ) ;", "commit_type": "add"}
{"commit_tokens": ["Adding", "a", "patch", "to", "catch", "all", "uncaughtExceptions", "thrown", "."], "add_tokens": "} ; module . exports . patch_global = function patch_global ( options ) { var client = new Client ( options ) ; process . on ( 'uncaughtException' , function ( err ) { client . create_from_exception ( err , { } , function ( result ) { var util = require ( 'util' ) ; util . log ( 'uncaughtException: ' + client . get_ident ( result ) ) ; } ) ; } ) ;", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["Fix", "absolute", "value", "of", "cartesian", "(", "was", "previously", "x", "*", "x", "+", "y", "*", "y", "but", "should", "be", "Sqrt", "[", "x^2", "+", "y^2", "]", ")"], "add_tokens": "Global . sqrt . default ( ri [ 0 ] [ '^' ] ( two ) [ '+' ] ( ri [ 1 ] [ '^' ] ( two ) ) ) , var two = new Expression . Integer ( 2 ) ; return Global . sqrt . default ( ri [ 0 ] [ '^' ] ( two ) [ '+' ] ( ri [ 1 ] [ '^' ] ( two ) ) ) ;", "del_tokens": "ri [ 0 ] [ '^' ] ( two ) [ '+' ] ( ri [ 1 ] [ '^' ] ( two ) ) , return ri [ 0 ] [ '*' ] ( ri [ 0 ] ) [ '+' ] ( ri [ 1 ] [ '*' ] ( ri [ 1 ] ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["implement", "recent", "comment", "for", "public"], "add_tokens": "entries : blog . entry . getAll ( ) ,", "del_tokens": "entries : blog . entries ( ) ,", "commit_type": "implement"}
{"commit_tokens": ["Fix", "HTML", "parsing", "bug", "when", "<", "/", "script", ">", "is", "in", "the", "phantomas", "results", "json"], "add_tokens": "// Escape \"</script>\" because it can interfer with the HTML parser var phantomasResults = results . phantomasResults ; phantomasResults = phantomasResults . replace ( '</script>' , '\\\\u003c/script>' ) ; html = html . replace ( '%%RESULTS%%' , phantomasResults ) ;", "del_tokens": "html = html . replace ( '%%RESULTS%%' , results . phantomasResults ) ;", "commit_type": "fix"}
{"commit_tokens": ["make", "text", "module", "regexp", "configurable", "since", "e", ".", "g", "."], "add_tokens": "this . textPluginPattern = opts . textPluginPattern || / ^text! / ; var clone = new CommonJsProject ( { roots : this . roots , ignores : this . ignoreRequires , textPluginPattern : this . textPluginPattern } ) ; if ( this . textPluginPattern . test ( module ) ) { baseObj = findModuleAt ( baseObj , base , module . replace ( this . textPluginPattern , '' ) ) ; if ( ! baseObj ) baseObj = findModuleAt ( baseObj , base , module + '/index.js' ) ;", "del_tokens": "var clone = new CommonJsProject ( this . roots ) ; var textPluginPattern = / ^text! / ; if ( textPluginPattern . test ( module ) ) { baseObj = findModuleAt ( baseObj , base , module . replace ( textPluginPattern , '' ) ) ; baseObj = findModuleAt ( baseObj , base , module + '/index.js' ) ;", "commit_type": "make"}
{"commit_tokens": ["Removed", "overly", "nested", "source", "file", "organization", "."], "add_tokens": "'src/errors.js:errors' , 'src/utils.js:utils'", "del_tokens": "'src/errors/index.js:errors' , 'src/utils/index.js:utils'", "commit_type": "remove"}
{"commit_tokens": ["Changed", "how", "the", "application", "is", "initialized"], "add_tokens": "// Singleton application for the module. Resolve the location of the application // directory, and initialize the application to the resolved location. var app ; / ** * Get the application for the module . If the application has not been * initialized , then an exception is thrown . * / Object . defineProperty ( exports , 'app' , { get : function ( ) { if ( app ) return app ; throw new Error ( 'Application is not initialized; must all Application(appPath) first' ) ; } } ) ; / ** * Factory method for creating an Blueprint . js application . * * @ param appPath * @ constructor * / exports . Application = function ( appPath ) { if ( app ) throw new Error ( 'Application is already initialized' ) ; // Create a new application, initialize the application, and return the // application to the caller. app = new Application ( appPath ) ; app . init ( ) ; return app ; } ;", "del_tokens": "// Singleton application for the module. Resolve the location of the // application directory, and initialize the application to the resolved // location. var appPath = resolveApplicationPath ( ) ; if ( ! appPath ) throw Error ( 'Cannot resolve application path' ) ; var app = new Application ( appPath ) ; exports . app = app ; // Initialize the application. app . init ( ) ;", "commit_type": "change"}
{"commit_tokens": ["Added", "previous", "fs", "-", "extra", "default", "of", "spaces", ":", "2"], "add_tokens": "fs . writeJsonSync ( packagePath , packageJson , { spaces : 2 } ) ;", "del_tokens": "fs . writeJsonSync ( packagePath , packageJson ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "content", "headers", "being", "sent", "in", "304", "response"], "add_tokens": "'ETag' : etag ( buf ) function send ( req , res , icon ) { var headers = icon . headers ; // Set headers for ( var header in headers ) { res . setHeader ( header , headers [ header ] ) ; } if ( fresh ( req . headers , res . _headers ) ) { res . statusCode = 304 ; res . end ( ) ; return ; } res . statusCode = 200 ; res . setHeader ( 'Content-Length' , icon . body . length ) ; res . setHeader ( 'Content-Type' , 'image/x-icon' ) ; res . end ( icon . body ) ;", "del_tokens": "'Content-Type' : 'image/x-icon' , 'Content-Length' : buf . length , 'etag' : etag ( buf ) function send ( req , res , icon ) { var _fresh = fresh ( req . headers , icon . headers ) ; var buf = _fresh ? '' : icon . body ; var status = _fresh ? 304 : 200 ; res . writeHead ( status , icon . headers ) ; res . end ( buf ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "missing", "jsdoc", "for", "Select", "+", "missing", "tests"], "add_tokens": "function Select ( mapFn = x => x ) { const iter = this . y ( ) ; let index = 0 ; return new Collection ( function * ( ) { for ( let val of iter ) { yield mapFn ( val , index ) ; index ++ } } ) }", "del_tokens": "function Select ( mapFn = x => x ) { const iter = this . y ( ) ; return new Collection ( function * ( ) { for ( let val of iter ) { yield mapFn ( val ) } } ) }", "commit_type": "add"}
{"commit_tokens": ["Removed", "sourcemaps", "for", "the", "time", "being", "."], "add_tokens": "return gulp . src ( config . src . js + '/framework.js' )", "del_tokens": "sourcemaps = require ( 'gulp-sourcemaps' ) , jshintStylish = require ( 'jshint-stylish' ) , return gulp . src ( config . src . js + '/**/*.js' ) . pipe ( sourcemaps . init ( ) ) . pipe ( sourcemaps . write ( '.' ) )", "commit_type": "remove"}
{"commit_tokens": ["fixed", "$number", "on", "number", "type"], "add_tokens": "'$type expects an array of two elements with the second being a string'", "del_tokens": "'$type expects an array of two elements while the second being a string'", "commit_type": "fix"}
{"commit_tokens": ["Added", "support", "for", "TypeScript", "files", "and", "for", "custom", "index", "template", "."], "add_tokens": "var index = path . resolve ( templates , 'index.tmpl' ) ; if ( options . template && path . resolve ( options . template ) ) { index = options . template ; } content = fs . readFileSync ( index , 'utf8' ) ; fs . readFileSync ( options . navTemplate , 'utf8' ) , if ( scriptNames . indexOf ( fileName ) === - 1 ) {", "del_tokens": "content = fs . readFileSync ( path . resolve ( templates , 'index.tmpl' ) , 'utf8' ) ; fs . readFileSync ( options . navTemplate , 'utf8' ) , if ( scriptNames . indexOf ( fileName ) === - 1 ) {", "commit_type": "add"}
{"commit_tokens": ["add", "test", "cases", "and", "re", "-", "invite", "handling"], "add_tokens": "dialog . once ( 'ack' , function ( ) { cb ( null , dialog ) ; } ) ; opts . headers . contact = 'sip:' + opts . callingNumber + '@localhost' ; cb ( '' + res . status + ' ' + res . reason ) ;", "del_tokens": "cb ( null , dialog ) ; cb ( { status : res . status , reason : res . reason , msg : res . msg } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixed", "the", "babble", "module", "always", "sending", "messages", "via", "it", "s", "own", "internal", "messagebus", "instead", "of", "the", "agents", "send", "/", "receive", "function", "."], "add_tokens": "babbler . connect ( { connect : function ( params ) { } , disconnect : function ( token ) { } , send : function ( to , message ) { agent . send ( to , message ) ; } } ) ; // create a receive function for the agent var receiveOriginal = agent . _receive ;", "del_tokens": "var receiveOriginal = agent . _receive ; // attach receive function to the agent", "commit_type": "fix"}
{"commit_tokens": ["Fix", "tests", "for", "URL", "rewriting", "and", "rewriting", "itself", "."], "add_tokens": "var processed = regexpHelper ( target . href , req . hostMatch , req . pathMatch ) ; if ( req . parsedUrl . search ) processed += req . parsedUrl . search ; var newTarget = url . parse ( processed ) ; // target.query = req.parsedUrl.query; // target.query = req.parsedUrl.query;", "del_tokens": "var newTarget = url . parse ( regexpHelper ( target . href , req . hostMatch , req . pathMatch ) ) ; newTarget . withPath = true ; target . query = req . parsedUrl . query ; target . query = req . parsedUrl . query ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "support", "for", "matching", "on", "any", "search", "token"], "add_tokens": "constructor ( { indexMode , tokenizePattern , caseSensitive , matchAnyToken } = { } ) { this . _matchAnyToken = matchAnyToken caseSensitive : this . _caseSensitive , matchAnyToken : this . _matchAnyToken", "del_tokens": "constructor ( { indexMode , tokenizePattern , caseSensitive } = { } ) { caseSensitive : this . _caseSensitive", "commit_type": "add"}
{"commit_tokens": ["Removed", "unneeded", "gradient", "global", "(", "Canvas", "was", "unused", "we", "use", "that", "instead", "for", "checks", ")", "."], "add_tokens": ", Canvas", "del_tokens": ", gradient , Canvas ;", "commit_type": "remove"}
{"commit_tokens": ["Change", "writePidToFile", "to", "echoPidToFile", "in", "tests"], "add_tokens": "* echoPidToFile exports . echoPidToFile = {", "del_tokens": "* writePidToFile exports . writePidToFile = {", "commit_type": "change"}
{"commit_tokens": ["Fix", "installation", "break", "receiving", "messages"], "add_tokens": "var user = process . env . USER ; // TODO: Broken. execSync('mkfifo' + FIFO_PATH, 0755);", "del_tokens": "var mkfifo = require ( 'mkfifo' ) . mkfifoSync ; var execSync = require ( 'exec-sync' ) ; var user = execSync ( 'whoami' ) ; mkfifo ( FIFO_PATH , 0755 ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "specification", "of", "a", "timeout", "on", "flushAllExpected"], "add_tokens": "* There is a total timeout ( of 100 ms by default ) , after which the returned * promise is rejected . * @ param { Object = } opts Options object * @ param { Number = } opts . timeout Total timeout , in ms . 100 by default . flushAllExpected : function ( opts ) { opts = opts || { } ; const waitTime = opts . timeout === undefined ? 100 : opts . timeout ;", "del_tokens": "* There is a total timeout of 100 ms , after which the returned promise is * rejected . flushAllExpected : function ( ) { const waitTime = 100 ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "reset", "reset", "-", "db", "and", "reset", "-", "doc", "targets", "."], "add_tokens": "desc : 'Alias for teardown' , } , reset : { desc : 'Delete then recreate databases and documents' , options : options , action : _do ( [ 'tearDownDatabases' , 'setUpDatabases' , 'setUpDocuments' ] ) } , 'reset-db' : { desc : 'Alias for reset' , options : options , action : _do ( [ 'tearDownDatabases' , 'setUpDatabases' , 'setUpDocuments' ] ) } , 'reset-doc' : { desc : 'Delete then recreate documents only' , options : options , action : _do ( [ 'tearDownDocuments' , 'setUpDocuments' ] )", "del_tokens": "desc : 'Delete databases, including documents' ,", "commit_type": "add"}
{"commit_tokens": ["fix", "tilda", "tempfiles", "regex", "in", "fstream"], "add_tokens": "entry . match ( / ^.*~$ / ) ||", "del_tokens": "entry . match ( / ^\\..*\\~$ / ) ||", "commit_type": "fix"}
{"commit_tokens": ["Changed", "build", "process", "to", "pixify"], "add_tokens": "//Nothing to deprecate right now!", "del_tokens": "( function ( undefined ) { //Nothing to deprecate right now! } ( ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Fix", "automatic", "escaping", "of", "ampersands"], "add_tokens": "* @ preserve @ version 1.1 .3 return code . replace ( / < / g , '&lt;' ) . replace ( / > / g , '&gt;' ) . replace ( / &(?![\\w\\#]+;) / g , '&amp;' ) ;", "del_tokens": "* @ preserve @ version 1.1 .2 return code . replace ( / < / g , '&lt;' ) . replace ( / > / g , '&gt;' ) . replace ( / &(?!.*;) / g , '&amp;' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Update", "comparison", "with", "other", "projects", "."], "add_tokens": "const { parseURL , isThirdParty } = require ( './adblockpluscore/lib/url.js' ) ; const url = parseURL ( request . url ) ; const sourceURL = parseURL ( request . frameUrl ) ;", "del_tokens": "const { isThirdParty } = require ( './adblockpluscore/lib/domain.js' ) ; const url = new URL ( request . url ) ; const sourceURL = new URL ( request . frameUrl ) ;", "commit_type": "update"}
{"commit_tokens": ["add", "jsScroll", "support", "for", "lazy", "use", "and", "special", "usage"], "add_tokens": "import Vue from 'vue' import App from './App.vue' import AttachFastClick from './assets/js/fastclick' import APP_CONFIGS from './config/app-configs' import PLATFORM_CONFIGS from './config/platform-configs' // import vmGeo from 'vm-geo' // import vmLog from 'vm-log' // import vmStorage from 'vm-storage' // // Vue.use(vmGeo, { // enableHighAccuracy: true, // 是否要求高精度地理位置信息 // maximumAge: 10000, // 设置缓存时间为1s，1s后重新获取地理位置信息 // timeout: 15000, // 5s未返回信息则返回错误 // fallBack: 'aMap', // 条件允许优先使用原生获取, 如果在IOS下是使用的是HTTP获取, 则使用备选, 这里是aMap // qMap: { // key: 'OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77', // official example app key, please use geo.register() to replace // name: 'qqMapName' // }, // bMap: { // key: 'yFKaMEQnAYc1hA0AKaNyHGd4HTQgTNvO' // }, // aMap: { // key: '8d1ba642a3a3046d1ee087e0f8b490a2' // } // }) // // Vue.use(vmStorage) // Vue.use(vmLog)", "del_tokens": "import Vue from 'vue' import App from './App.vue' import AttachFastClick from './assets/js/fastclick' import APP_CONFIGS from './config/app-configs' import PLATFORM_CONFIGS from './config/platform-configs' import vmGeo from 'vm-geo' import vmLog from 'vm-log' import vmStorage from 'vm-storage' Vue . use ( vmGeo , { enableHighAccuracy : true , // 是否要求高精度地理位置信息 maximumAge : 10000 , // 设置缓存时间为1s，1s后重新获取地理位置信息 timeout : 15000 , // 5s未返回信息则返回错误 fallBack : 'aMap' , // 条件允许优先使用原生获取, 如果在IOS下是使用的是HTTP获取, 则使用备选, 这里是aMap qMap : { key : 'OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77' , // official example app key, please use geo.register() to replace name : 'qqMapName' } , bMap : { key : 'yFKaMEQnAYc1hA0AKaNyHGd4HTQgTNvO' } , aMap : { key : '8d1ba642a3a3046d1ee087e0f8b490a2' } } ) Vue . use ( vmStorage ) Vue . use ( vmLog ) // eslint-disable-next-line no-unused-vars function a ( ) { console . log ( 123 ) }", "commit_type": "add"}
{"commit_tokens": ["Improving", "m", "-", "function", "testing", "and", "adding", "cb", "functions", "."], "add_tokens": "this . cache . mset = function ( obj , cb ) { if ( cb ) cb ( ) ; this . cache . flushAll = function ( cb ) { if ( cb ) cb ( ) ;", "del_tokens": "this . cache . mset = function ( obj ) { this . cache . flushAll = function ( ) {", "commit_type": "improve"}
{"commit_tokens": ["fixed", "should", "require", "path", "error"], "add_tokens": "var should = require ( '../node_modules/should' ) ;", "del_tokens": "var should = require ( 'should' ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "all", "tests", "including", "full", "coverage"], "add_tokens": "var token = 'fake_token' ;", "del_tokens": "var token = \"fake_token\" ;", "commit_type": "fix"}
{"commit_tokens": ["Adds", "un", "-", "shimmed", "support", "for", "Require", ".", "js", "."], "add_tokens": "( function ( exports , module , define ) { else { root . validate = validate ; if ( validate . isFunction ( define ) && define . amd ) define ( \"validate\" , [ ] , function ( ) { return validate ; } ) ; } typeof module !== 'undefined' ? module : null , typeof define !== 'undefined' ? define : null ) ;", "del_tokens": "( function ( exports , module ) { else root . validate = validate ; typeof module !== 'undefined' ? module : null ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "(", "commented", "out", ")", "preserveDrawingBuffer", "flag"], "add_tokens": "gl = canvas . getContext ( 'experimental-webgl' , { /*preserveDrawingBuffer: true*/ } ) ; // preserveDrawingBuffer needed for gl.readPixels (could be used for feature selection)", "del_tokens": "gl = canvas . getContext ( 'experimental-webgl' ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "addGraph", "func", "with", "empty", "chart"], "add_tokens": "* AngularJS - nvD3 , v1 .0 .3 - dev ; MIT License ; 02 / 11 / 2015 13 : 49 if ( ! scope . chart ) return ; if ( scope . chart . resizeHandler ) scope . chart . resizeHandler . clear ( ) ; // Zoom feature", "del_tokens": "* AngularJS - nvD3 , v1 .0 .3 - dev ; MIT License ; 01 / 11 / 2015 17 : 01 if ( scope . chart && scope . chart . resizeHandler ) scope . chart . resizeHandler . clear ( ) ; //// Zoom feature - start //// Zoom feature - end", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "conditional", "statement", "in", "word", "wrap", "added", "test", "cases"], "add_tokens": "// Add buffer to result if we can't fit any more words in the buffer. if ( ( max || max === 0 ) &&", "del_tokens": "if ( ( word . indexOf ( '\\n' ) === - 1 ) && ( max || max === 0 ) &&", "commit_type": "fix"}
{"commit_tokens": ["Add", "matching", "logic", "for", "regex", "filters"], "add_tokens": "parsedFilterData . data = input . slice ( beginIndex + 1 , - 1 ) ; export function matchesFilter ( parsedFilterData , input ) { if ( parsedFilterData . isRegex ) { if ( ! parsedFilterData . regex ) { parsedFilterData . regex = new RegExp ( parsedFilterData . data ) ; } return parsedFilterData . regex . test ( input ) ; } return true ; }", "del_tokens": "parsedFilterData . regex = input . substring ( beginIndex + 1 ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "up", "paths", "and", "squash", "emitter", "leak", "warning", "(", "it", "s", "not", "a", "leak", ")"], "add_tokens": "var CoordinatorConnector = require ( './CoordinatorConnector' ) ; // We're about to add a lot of event handlers so squash the emitter leak warning Coordinator . setMaxListeners ( 0 ) ; // Add a disconnect listener //test([name], [opts], cb) module . exports = Thali_Tape ;", "del_tokens": "var CoordinatorConnector = require ( 'CoordinatorConnector' ) ; // Add a disconnect listener //test([name], [opts], cb) module . exports = Thali_Tape ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "uglify", "to", "built", "-", "in", "file", "transform"], "add_tokens": "'uglify' : require ( './transforms/uglify' ) , b . transform ( t . options , t . fn , t . args ) ; transform : [ { options : { global : true } , fn : 'uglifyify' , args : { } } ] , } . bind ( this ) , { options : { } , fn : 'uglify' , args : { } }", "del_tokens": "b . transform ( t . options , t . fn , t . fnOpts ) ; } . bind ( this )", "commit_type": "add"}
{"commit_tokens": ["Add", "translation", "commands", "for", "alerts"], "add_tokens": "import alertExtensions from './alert' ; Object . assign ( commands , contextCommands , executeExtensions , alertExtensions ,", "del_tokens": "Object . assign ( commands , contextCommands , executeExtensions ,", "commit_type": "add"}
{"commit_tokens": ["Add", "null", "check", "to", "Extent", "."], "add_tokens": "if ( v != null ) { if ( v < min ) min = v ; if ( v > max ) max = v ; }", "del_tokens": "if ( v < min ) min = v ; if ( v > max ) max = v ;", "commit_type": "add"}
{"commit_tokens": ["Add", "properties", "support", "for", "getSuggestions"], "add_tokens": "const getSuggestions = ( fields , suggestions , currentValue , suggestionProperties = [ ] ) => { const populateSuggestionsList = ( val , source ) => { const defaultOption = { let additionalKeys = { } ; if ( Array . isArray ( suggestionProperties ) && suggestionProperties . length > 0 ) { suggestionProperties . forEach ( ( prop ) => { if ( source . hasOwnProperty ( prop ) ) { additionalKeys = { ... additionalKeys , [ prop ] : source [ prop ] , } ; } } ) ; } const option = { ... defaultOption , ... additionalKeys , } ; val . forEach ( suggestion => populateSuggestionsList ( suggestion , source ) ) ; populateSuggestionsList ( val , source ) ;", "del_tokens": "const getSuggestions = ( fields , suggestions , currentValue ) => { const populateSuggestionsList = ( val ) => { const option = { val . forEach ( suggestion => populateSuggestionsList ( suggestion ) ) ; populateSuggestionsList ( val ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "group", "list", "test", "case"], "add_tokens": "list ( { offset = 0 , count = 0 , sort = undefined , fields = undefined , query = undefined } = { } , callback ) {", "del_tokens": "list ( { offset = 0 , count = 0 , sort = undefined , fields = undefined , query = undefined } , callback ) {", "commit_type": "add"}
{"commit_tokens": ["use", "class", "-", "utils", "and", "inherit", "directly", "from", "vinyl", "instead", "of", "base"], "add_tokens": "var utils = require ( './utils' ) ; utils . File . call ( this ) ; is ( this , 'VinylGroup' ) ; * Inherit ` ` utils . cu . inherit ( VinylGroup , utils . File ) ; / ** * Set the name and type of object . * / function is ( obj , name ) { if ( typeof name !== 'string' ) { throw new TypeError ( 'expected name to be a string' ) ; } utils . define ( obj , 'is' + utils . pascal ( name ) , true ) ; utils . define ( obj , '_name' , name ) ; } ;", "del_tokens": "var Base = require ( 'base' ) ; var Vinyl = require ( 'vinyl' ) ; Vinyl . call ( this ) ; Base . call ( this ) ; this . is ( 'VinylGroup' ) ; * Inherit ` ` and ` ` Base . extend ( VinylGroup ) ; Base . inherit ( VinylGroup , Vinyl ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "test", "for", "until", "dom", "dependency"], "add_tokens": "import { h , stream , if$ , merge$ , initRouter , CHILDREN_CHANGED , ADDED , REMOVED , UPDATED } from '../src' ; it ( 'should evaluate streams on dom attachment' , ( ) => { const myMock = jest . fn ( ) ; let control$ = stream ( false ) ; let trigger$ = stream ( true ) ; let my$ = stream ( 'HALLO' ) . until ( trigger$ ) ; let app = < div > { if$ ( control$ , my$ ) } < / div > ; expect ( app . outerHTML ) . toBe ( '<div></div>' ) ; control$ ( true ) ; expect ( app . outerHTML ) . toBe ( '<div></div>' ) ; trigger$ ( false ) ; expect ( app . outerHTML ) . toBe ( '<div>HALLO</div>' ) ; } )", "del_tokens": "import { h , stream , if$ , initRouter , CHILDREN_CHANGED , ADDED , REMOVED , UPDATED } from '../src' ; let outerDeleted$ = stream ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "function", "for", "check", "table", "existence", "."], "add_tokens": "/ ** * Check table existence * @ param { String } dbName - Table name * @ param { String } dbLocation - Table location path * @ return { Boolean } checking result * / function tableExists ( ) { let fName = '' ; if ( arguments . length == 2 ) { // Given the database name and location let dbName = arguments [ 0 ] ; let dbLocation = arguments [ 1 ] ; fName = path . join ( dbLocation , dbName + '.json' ) ; } else if ( arguments . length == 1 ) { let dbName = arguments [ 0 ] ; fName = path . join ( userData , dbName + '.json' ) ; } return fs . existsSync ( fName ) ; } count , tableExists", "del_tokens": "count", "commit_type": "add"}
{"commit_tokens": ["Use", "buffer", ".", "from", "-", "helper", "to", "make", "tests", "work", "on", "older", "Node", "versions"], "add_tokens": "isNode , bufferFrom it ( 'should transform string to url option' , ( ) => { const body = 'Just some plain text for you to consume' const request = requester ( [ baseUrl , debugRequest ] ) const req = request ( '/plain-text' ) return expectRequest ( req ) . to . eventually . have . property ( 'body' , body ) } ) const req = request ( { url : '/echo' , body : bufferFrom ( 'Foo bar' ) } ) . and . deep . equal ( bufferFrom ( 'Just some plain text for you to consume' ) )", "del_tokens": "isNode const req = request ( { url : '/echo' , body : Buffer . from ( 'Foo bar' , 'utf8' ) } ) . and . deep . equal ( Buffer . from ( 'Just some plain text for you to consume' , 'utf8' ) )", "commit_type": "use"}
{"commit_tokens": ["Fixing", "pages", "count", "for", "archive", "pages"], "add_tokens": "var pages = Math . ceil ( archive . posts . length / archiveConfig . paginate )", "del_tokens": "var pages = archive . posts . length / archiveConfig . paginate", "commit_type": "fix"}
{"commit_tokens": ["fixing", "comscore", "to", "properly", "init", "with", "settings"], "add_tokens": "_comscore . push ( this . settings ) ;", "del_tokens": "_comscore . push ( settings ) ;", "commit_type": "fix"}
{"commit_tokens": ["Implemented", "opening", "of", "links", "in", "new", "window"], "add_tokens": "//mainWindow.openDevTools();", "del_tokens": "mainWindow . openDevTools ( ) ;", "commit_type": "implement"}
{"commit_tokens": ["Added", "premajor", "and", "preminor", "to", "inc", "()", "(", "with", "tests", ")"], "add_tokens": "case 'premajor' : this . inc ( 'major' ) ; this . inc ( 'pre' ) ; break ; case 'preminor' : this . inc ( 'minor' ) ; this . inc ( 'pre' ) ; break ; case 'prerelease' : if ( this . prerelease . length === 0 ) this . inc ( 'patch' ) ; this . inc ( 'pre' ) ; break ; case 'pre' :", "del_tokens": "case 'prerelease' :", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "of", "exchange", "service"], "add_tokens": "exports . decode = function ( xml , schema ) { n : schema", "del_tokens": "exports . decode = function ( xml ) { n : 'http://www.betfair.com/publicapi/v3/BFGlobalService/'", "commit_type": "add"}
{"commit_tokens": ["Make", "callback", "optional", "in", "show"], "add_tokens": "if ( cb ) cb ( new Error ( data ) ) ; catch ( e ) { if ( cb ) cb ( e ) ; return ; } if ( err ) { if ( cb ) cb ( err ) ; return ; } if ( cb ) cb ( null , parsed , data ) ;", "del_tokens": "cb ( new Error ( data ) ) ; catch ( e ) { cb ( e ) ; return ; } if ( err ) { cb ( err ) ; return ; } cb ( null , parsed , data ) ;", "commit_type": "make"}
{"commit_tokens": ["added", "run", "command", "to", "move", "away", "from", "_run"], "add_tokens": "name : 'run' , } , { topic : 'run' , help : ` ` , variableArgs : true , needsAuth : true , needsApp : true , flags : [ { name : 'exit-code' , description : 'raise same exit code from dyno process' } , ] , run : run", "del_tokens": "name : '_run' ,", "commit_type": "add"}
{"commit_tokens": ["Add", "syntax", "highlighting", "for", "index", ".", "html"], "add_tokens": "var marked = require ( 'marked' ) ; // var hl = require('highlight').Highlight; var hl = require ( 'node-syntaxhighlighter' ) ; marked . setOptions ( { highlight : function ( code , lang ) { lang = lang || 'javascript' ; lang = hl . getLanguage ( lang ) ; return hl . highlight ( code , lang ) ; } , gfm : true } ) ; var readme = grunt . file . read ( 'readme.md' ) ,", "del_tokens": "var marked = require ( 'marked' ) , readme = grunt . file . read ( 'readme.md' ) , marked . setOptions ( { gfm : true } ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "issue", "with", "multibyte", "characters", "in", "node"], "add_tokens": "var responseBuffer = [ ] ; responseBuffer . push ( chunk ) ; Buffer . concat ( responseBuffer ) . toString ( 'utf8' ) , } ;", "del_tokens": "var responseText = '' ; responseText += chunk ; responseText , } ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "conf", "option", "in", "sample", "service"], "add_tokens": "\"repo\" : \"user/repository\" , \"conf\" : [ \"my-host.token\" ] // Persist credentials to service-specific option", "del_tokens": "// Remember to enable options in lib/config.js \"repo\" : \"user/repository\" // Assuming option \"my-host.token\" has been enabled in \"../config.js\"", "commit_type": "add"}
{"commit_tokens": ["Make", "the", "queue", "simpler", "and", "keep", "the", "knowledge", "about", "being", "cancelled", "inside", "the"], "add_tokens": "var action = queue . shift ( ) ; if ( action ) action ( ) ; var cancelled ; // This task will complete when we pop it off the queue. queue . push ( function ( ) { if ( ! cancelled ) { recentTimes . insert ( getTime ( ) ) ; callback ( null , null ) ; } } ) ; return function onCancel ( ) { cancelled = true ; if ( ! err ) return doSomething ( ) ;", "del_tokens": "// Look for the next non-cancelled item in the queue. while ( true ) { var item = queue . shift ( ) ; if ( ! item ) return ; if ( ! item . cancelled ) break ; } recentTimes . insert ( getTime ( ) ) ; item . callback ( null , null ) ; var item = { callback : callback , cancelled : false } ; queue . push ( item ) ; // If the task is cancelled, mark it so that the queue ignores it. return function cancel ( ) { item . cancelled = true ; if ( err ) return ; return doSomething ( ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "error", "reporting", "for", "fetching", "original", "site", "URL"], "add_tokens": "if ( ! queueItem . referrer ) { return grunt . log . error ( 'Error fetching `site` URL: ' + queueItem . url . magenta ) ; } grunt . log . error ( 'Client error fetching the following resource linked from ' + queueItem . referrer ? queueItem . referrer . cyan : site + ' to' , queueItem . url . magenta ) ;", "del_tokens": "grunt . log . error ( 'Client error fetching the following resource linked from ' + queueItem . referrer ? queueItem . referrer . cyan : site + ' to' , queueItem . url . magenta ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "find", "of", "existing", "AMI", "in", "non", "us", "-", "east", "-", "1", "region"], "add_tokens": ", endpoint : config . options . region", "del_tokens": ", region : config . options . region", "commit_type": "fix"}
{"commit_tokens": ["added", "regexp", "and", "not", "-", "exists", "support", "to", ".", "exists", "()"], "add_tokens": "var found = true , queryValue , objectValue ; var negated = prop [ 0 ] === \"!\" ; var queryValue = query [ prop ] ; var objectValue = negated ? object [ prop . slice ( 1 ) ] : object [ prop ] ; if ( queryValue instanceof RegExp ) { found = negated ? ! queryValue . test ( objectValue ) : queryValue . test ( objectValue ) ; } else { found = negated ? queryValue !== objectValue : queryValue === objectValue ; }", "del_tokens": "var found = true ; found = query [ prop ] === object [ prop ] ;", "commit_type": "add"}
{"commit_tokens": ["adds", "stream", "-", "exhaust", "to", "ensure", "files", "are", "pulled", "through", "on", "process"], "add_tokens": "var exhaust = require ( 'stream-exhaust' ) var opts = utils . merge ( { } , this . options , files . options , options ) ; this . data ( opts . data || { } ) ; . pipe ( exhaust ( this . dest ( files . dest , opts ) ) ) this . data ( config . data || config . options . data || { } ) ;", "del_tokens": "var opts = utils . extend ( { } , this . options , files . options , options ) ; . pipe ( this . dest ( files . dest , opts ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "some", "failed", "rearranging", "and", "bad", "capitalization", "in", "the", "country", "code", "list"], "add_tokens": "\"Cocos (Keeling) Islands\" : \"CC\" , \"Ecuador\" : \"EC\" , \"Monaco\" : \"MC\" , \"New Caledonia\" : \"NC\" , \"Réunion\": RE\", \"Saint Barthélemy\": BL\", \"Saint Lucia\" : \"LC\" , \"Saint Vincent And The Grenadines\" : \"VC\" , \"Seychelles\" : \"SC\" , \"Turks And Caicos Islands\" : \"TC\" ,", "del_tokens": "\"CC\" : \"Cocos (Keeling) Islands\" , \"EC\" : \"Ecuador\" , \"MC\" : \"Monaco\" , \"NC\" : \"New Caledonia\" , \"RÉUnion\": RE\", \"Saint BarthÉLemy\": BL\", \"LC\" : \"Saint Lucia\" , \"VC\" : \"Saint Vincent And The Grenadines\" , \"SC\" : \"Seychelles\" , \"TC\" : \"Turks And Caicos Islands\" ,", "commit_type": "fix"}
{"commit_tokens": ["fixed", "updateDate", "plugin", "with", "no", "modifier"], "add_tokens": "var utils = require ( '../utils' ) ; if ( utils . isModifier ( params . modifier ) ) { params . modifier . $set = params . modifier . $set || { } ; params . modifier . $set . updateDate = now ; } else { params . modifier . updateDate = now ; }", "del_tokens": "params . modifier . $set = params . modifier . $set || { } ; params . modifier . $set . updateDate = now ;", "commit_type": "fix"}
{"commit_tokens": ["Updated", "tests", "and", "module", "loading", "infrastructure"], "add_tokens": "var instance = di . resolve ( moduleName + 'Middleware' ) ;", "del_tokens": "var instance = di . resolve ( moduleName ) ;", "commit_type": "update"}
{"commit_tokens": ["Adding", "try", "catch", "block", "around", "importScripts", "of", "app", "-", "internal"], "add_tokens": "//If id is null, return self // 'status': 'string' //Status (['available', 'offline', 'away', 'idle'])", "del_tokens": "// 'status': 'string' //Status (['online', 'offline', 'away', 'idle'])", "commit_type": "add"}
{"commit_tokens": ["Adding", "in", "a", "mapControls", "action", "and", "reducer"], "add_tokens": "ReactDOM . render ( < SdkMap store = { store } showZoomSlider / > , document . getElementById ( 'map' ) ) ;", "del_tokens": "ReactDOM . render ( < SdkMap store = { store } / > , document . getElementById ( 'map' ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Make", "MenuItem", "s", "type", "default", "to", "submenu", "if", "it", "has", "submenu", "property", "."], "add_tokens": "menu . append ( new MenuItem ( { submenu : appleMenu } ) ) ; menu . append ( new MenuItem ( { label : 'Window' , submenu : windowMenu } ) ) ;", "del_tokens": "menu . append ( new MenuItem ( { type : 'submenu' , submenu : appleMenu } ) ) ; menu . append ( new MenuItem ( { label : 'Window' , type : 'submenu' , submenu : windowMenu } ) ) ;", "commit_type": "make"}
{"commit_tokens": ["updated", "JS", "-", "files", "in", "folders", "other", "than", "/", "demo"], "add_tokens": "if ( typeof ret === 'string' ) { return true ; }", "del_tokens": "if ( typeof ret != undefined ) { return true ; }", "commit_type": "update"}
{"commit_tokens": ["removed", "unused", "logs", "and", "fixed", "clearStatus"], "add_tokens": "cleanResultsStatus ( ) ;", "del_tokens": "cleanResultsStatus ( ) ;", "commit_type": "remove"}
{"commit_tokens": ["add", "no", "-", "exit", "option"], "add_tokens": "var options = { reporter : 'mochawesome' , timeout : 30000 , slow : 1 , \"no-exit\" : true } ;", "del_tokens": "var options = { reporter : 'mochawesome' , timeout : 30000 , slow : 1 } ;", "commit_type": "add"}
{"commit_tokens": ["allow", "close", "atx", "-", "style", "headers"], "add_tokens": "const result = line . match ( / ^(#{1,6})\\s*(.*?)\\s*(?:#{1,6})(?:\\n|$) / ) ;", "del_tokens": "const result = line . match ( / ^(#{1,6})\\s*(.*?)(?:\\n|$) / ) ;", "commit_type": "allow"}
{"commit_tokens": ["added", "check", "for", "existence", "of", "btns", "in", "resize", "()"], "add_tokens": "if ( this . opt . responsive && nextBtn && prevBtn ) {", "del_tokens": "if ( this . opt . responsive ) {", "commit_type": "add"}
{"commit_tokens": ["add", ".", "travis", ".", "yml", "and", "automatically", "merge", "ctx", ".", "flash"], "add_tokens": ". expect ( / <title>koa-swig.*<\\/title> / ) describe ( 'flash' , function ( ) { var app = koa ( ) ; var session = require ( 'koa-session' ) ; var flash = require ( 'koa-flash' ) ; app . keys = [ 'foo' ] ; app . use ( session ( ) ) ; app . use ( flash ( { key : 'bar' } ) ) ; render ( app , { root : path . join ( __dirname , '../example' ) } ) ; app . use ( function * ( ) { this . flash . notice = 'Success!' ; yield this . render ( 'flash' ) ; } ) ; it ( 'should success' , function ( done ) { request ( app . listen ( ) ) . get ( '/' ) . expect ( 'Success!\\n' ) . expect ( 200 , done ) ; } ) ; } ) ;", "del_tokens": ". expect ( / <title>koa-swig@v0.1.*<\\/title> / )", "commit_type": "add"}
{"commit_tokens": ["Remove", "description", "properties", "from", "responses"], "add_tokens": "var info = FlightStats . AirlineCategory [ airline . category ] airline . category = { code : ( info && info . code ) || airline . category , scheduled : info && info . scheduled , passenger : info && info . passenger , cargo : info && info . cargo , }", "del_tokens": "airline . category = FlightStats . AirlineCategory [ airline . category ] ? Object . assign ( { } , FlightStats . AirlineCategory [ airline . category ] ) : { code : airline . category }", "commit_type": "remove"}
{"commit_tokens": ["added", "logger", "option", "to", "make"], "add_tokens": "afterTimeout = options . afterTimeout , logger = options . logger ; var _logger = ( typeof logger === 'undefined' ? 'undefined' : _typeof ( logger ) ) === 'object' ? logger : { } ; // emit an error event when log-level is error which throws an error this . on ( 'log' , function ( log ) { if ( typeof _logger [ log . level ] === 'function' ) _logger [ log . level ] ( log ) ; if ( log . level === 'error' ) _this2 . emit ( 'error' , log . error ) ;", "del_tokens": "afterTimeout = options . afterTimeout ; // emit an error event when log-level is error which throws an error this . on ( 'log' , function ( _ref ) { var level = _ref . level , error = _ref . error ; if ( level === 'error' ) _this2 . emit ( 'error' , error ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "basic", "tests", "for", "the", "runner", "."], "add_tokens": "response . length . should . equal ( 2 ) ; response . indexOf ( tube ) . should . be . above ( - 1 ) ; worker . start ( [ tube , 'unused' ] ) ;", "del_tokens": "response . length . should . equal ( 1 ) ; response . indexOf ( tube ) . should . equal ( 0 ) ; worker . start ( [ tube ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "some", "tests", "and", "docs"], "add_tokens": "'test/**/test-*.js' './test/**/*.js' : [ 'browserify' ] ,", "del_tokens": "'test/test-*.js' './test/*.js' : [ 'browserify' ] ,", "commit_type": "add"}
{"commit_tokens": ["improve", "performance", "of", "log", ".", "trace", "()", "when", "enabled"], "add_tokens": "record . timestamp ; } , 'should overwrite Trace.toJSON' : function ( ) { var a = new Logger ( unique ( ) ) ; a . propagate = false ; a . setLevel ( Logger . TRACE ) ; var spyA = spy ( ) ; a . addHandler ( { handle : spyA , level : 0 } ) ; a . trace ( 'intrusion' ) ; var record = spyA . getLastArgs ( ) [ 0 ] ; assert . equal ( JSON . stringify ( record . args [ 1 ] ) , '\"[object Trace]\"' ) ;", "del_tokens": "", "commit_type": "improve"}
{"commit_tokens": ["Add", "locales", "to", "zip", "folder", "on", "build"], "add_tokens": "it ( 'should get locale from machine' , ( ) => { } ) ;", "del_tokens": "it . only ( 'should get locale from machine' , ( ) => { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "[]", ".", "indexOf", "shim", "on", "IE<", "=", "8"], "add_tokens": "// IE <= 8 doesn't implement [].indexOf. // This shim was extracted from CoffeeScript: var __indexOf = [ ] . indexOf || function ( item ) { for ( var i = 0 , l = this . length ; i < l ; i ++ ) { if ( i in this && this [ i ] === item ) { return i ; } } return - 1 ; } ; if ( __indexOf . call ( typeables , fn ) === - 1 ) { return __indexOf . call ( [ \"\" , \"true\" ] , el . getAttribute ( \"contenteditable\" ) ) !== - 1 ;", "del_tokens": "if ( typeables . indexOf ( fn ) === - 1 ) { return [ \"\" , \"true\" ] . indexOf ( el . getAttribute ( \"contenteditable\" ) ) !== - 1 ;", "commit_type": "use"}
{"commit_tokens": ["Allow", "dragging", "elements", "across", "iframes"], "add_tokens": "if ( this . _timeout != null ) { this . _oDocument . find ( 'iframe' ) . css ( 'pointer-events' , '' ) ; this . _oDocument . unbind ( 'mousemove touchmove' , this . _fMove ) ; if ( this . _bDragging === true ) { this . emit ( 'dragStop' , oEvent , this . _nOriginalX + this . _nX ) ; this . _oDocument . find ( 'iframe' ) . css ( 'pointer-events' , 'none' ) ;", "del_tokens": "if ( this . _timeout != null ) { this . _oDocument . unbind ( 'mousemove touchmove' , this . _fMove ) ; if ( this . _bDragging === true ) { this . emit ( 'dragStop' , oEvent , this . _nOriginalX + this . _nX ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "support", "for", "Node", ".", "js", "modules"], "add_tokens": "* Expose Blueprint to the Global context with support for AMD and Node Modules if ( typeof define === \"function\" && define . amd ) { define ( \"Blueprint\" , [ ] , function ( ) { return Blueprint ; } ) ; } else if ( typeof module !== 'undefined' && typeof exports !== 'undefined' && module . exports ) { module . exports = Blueprint ; } else { root . Blueprint = Blueprint ; }", "del_tokens": "* Expose Blueprint to the Global context with support for AMD Modules if ( typeof define === \"function\" && define . amd ) { define ( \"Blueprint\" , [ ] , function ( ) { return Blueprint ; } ) ; } else { root . Blueprint = Blueprint ; }", "commit_type": "add"}
{"commit_tokens": ["Fix", "lint", "errors", "in", "index", ".", "test", ".", "js"], "add_tokens": "import { expect } from 'chai' describe ( 'Request' , function ( ) { // given let request = sinon . spy ( ) } ) // when trafik . getDepartures ( 'test' ) // then // given 'fs' : fs } ) // when // then // Catch the AssertionError thrown if the expectation above is not met request . invokeCallback ( 'Test error' , undefined , '{\"status\": \"failure\"}' ) describe ( 'Sucess responses' , function ( ) { 'fs' : fs // given // when expect ( result ) . to . be . empty // Catch the AssertionError thrown if the expectation above is not met request . invokeCallback ( undefined , undefined , response ) } )", "del_tokens": "import { assert , expect } from 'chai' describe ( 'Request' , function ( ) { //given let request = sinon . spy ( ) ; } ) ; //when trafik . getDepartures ( 'test' ) ; //then //given 'fs' : fs } ) ; //when //then //Catch the AssertionError thrown if the expectation above is not met request . invokeCallback ( 'Test error' , undefined , '{\"status\": \"failure\"}' ) describe ( 'Sucess responses' , function ( ) { // var request, trafik before ( function ( ) { } ) 'fs' : fs //given //when expect ( result ) . to . be . empty ; //Catch the AssertionError thrown if the expectation above is not met request . invokeCallback ( undefined , undefined , response ) } )", "commit_type": "fix"}
{"commit_tokens": ["update", "information", "about", "draw", "function"], "add_tokens": "* @ param canvas ( Canvas ) canvas instance * @ param aspectratio ( float ) the width to height of the symbol ( excluding quiet zones ) ; default 2 * @ param devicePixelRatio ( int ) determine how much extra pixel density should be added to allow for a sharper image ; default window . devicePixelRatio if available", "del_tokens": "* @ param aspectratio ( float ) the width to height of the symbol ( excluding quiet zones ) * @ param devicePixelRatio ( int ) determine how much extra pixel density should be added to allow for a sharper image", "commit_type": "update"}
{"commit_tokens": ["Added", "pass", "through", "argument", "for", "css", "precompilers"], "add_tokens": "Language . prototype . compile = function ( filename , passthrough_args , cb ) { var args ; if ( ( passthrough_args != null ) && typeof passthrough_args === \"string\" ) { passthrough_args = [ passthrough_args ] ; } args = [ ] . concat ( this . preprocessor . args ) ; if ( passthrough_args ) args = args . concat ( passthrough_args ) ; return exec ( \"\" + this . preprocessor . cmd + \" \" + ( args . join ( ' ' ) ) + \" \" + filename , function ( err , stdout , stderr ) {", "del_tokens": "Language . prototype . compile = function ( filename , cb ) { return exec ( \"\" + this . preprocessor . cmd + \" \" + ( this . preprocessor . args . join ( ' ' ) ) + \" \" + filename , function ( err , stdout , stderr ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "options", "to", "enable", "and", "disable", "features"], "add_tokens": "console . log ( 'Usage: node ' + process . argv [ 1 ] + ' [OPTIONS] filename.js...' ) ; var args = process . argv . slice ( 2 ) ; var files = args . filter ( function ( value ) { return ! / ^-- / . test ( value ) ; } ) ; traceur . options . fromArgv ( args ) ; var success = compileFiles ( files ) ;", "del_tokens": "console . log ( 'Usage: node ' + process . argv [ 1 ] + ' filename.js...' ) ; var success = compileFiles ( process . argv . slice ( 2 ) ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "XHR", "ProgressEvent", "creation", ".", "works", "in", "IE", "/", "Edge", "Chrome", "and", "Firefox", "now"], "add_tokens": "var ProgressEventConstruntor ; try { /* global ProgressEvent */ new ProgressEvent ( '' ) ; ProgressEventConstruntor = ProgressEvent ; } catch ( error ) { ProgressEventConstruntor = function ( reason ) { const error = document . createEvent ( 'ProgressEvent' ) ; error . initEvent ( reason , false , false ) ; return error ; } ; }", "del_tokens": "var ProgressEventConstruntor ; try { /* global ProgressEvent */ new ProgressEvent ( '' ) ; ProgressEventConstruntor = ProgressEvent ; } catch ( error ) { ProgressEventConstruntor = function ( reason ) { const error = document . createEvent ( 'ProgressEvent' ) ; error . initEvent ( reason , false , false ) ; retunr error ; } ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "tests", "for", "firebase", "version", "upgrade"], "add_tokens": "* @ param { Object } config This must contain either a ` ` property ( deprecated ) or a ` ` property if ( ! config ) { throw new Error ( 'configuration is required.' ) ; } // Backwards compatibility shim var configuration ; if ( config . firebase_uri ) { configuration . databaseURL = config . firebase_uri ; } else if ( ! config . databaseURL ) { throw new Error ( 'databaseURL is required.' ) ; } else { configuration = config ; } var app = firebase . initializeApp ( config ) , database = app . database ( ) , rootRef = database . ref ( ) , cb ( null , snapshot . val ( ) ) ; } , cb ) ; } , cb ) ;", "del_tokens": "* @ param { Object } config This must contain a ` ` property var rootRef = firebase . initializeApp ( config ) . database ( ) . ref ( ) , cb ( snapshot . val ( ) ) ; } ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "url", "to", "frame", "model", "."], "add_tokens": "setTimeout ( this . parseFrame ( series , stack , response . url , 0 , volumeParser , resolve , reject ) , 0 ) ; parseFrame ( series , stack , url , i , dataParser , resolve , reject ) { frame . url = url ; setTimeout ( this . parseFrame ( series , stack , url , this . _parsed , dataParser , resolve , reject ) , 0 ) ;", "del_tokens": "setTimeout ( this . parseFrame ( series , stack , 0 , volumeParser , resolve , reject ) , 0 ) ; parseFrame ( series , stack , i , dataParser , resolve , reject ) { setTimeout ( this . parseFrame ( series , stack , this . _parsed , dataParser , resolve , reject ) , 0 ) ;", "commit_type": "add"}
{"commit_tokens": ["adding", "error", "reporting", "to", "syncStorage"], "add_tokens": "var error = false ; working : ( numConns > 0 ) , error : error error = false ; error = report . error ; reportStatus ( - 1 ) ; error = false ; error = result . error ;", "del_tokens": "working : ( numConns > 0 ) reportStatus ( - 1 ) ; //report sync error //...", "commit_type": "add"}
{"commit_tokens": ["improve", "webpack", "log", "in", "dev", "server"], "add_tokens": "watchDelay : 200 , stats : { hash : false , cached : false , cachedAssets : false , colors : true }", "del_tokens": "watchDelay : 200", "commit_type": "improve"}
{"commit_tokens": ["make", "sure", "to", "add", "before", "checking", "git", "status"], "add_tokens": "git . add ( '.' ) . then ( ( ) => { git . status ( ) . then ( ( status ) => { if ( status . modified . length ) { const fileArray = status . modified . filter ( element => element . includes ( 'package.json' ) ) ; const addArray = fileArray . map ( element => ` ${ element } ` ) git . add ( addArray ) ; git . commit ( 'corrected packages version!' ) ; } else console . log ( 'no change' ) ; } ) . catch ( err => console . error ( err ) ) ;", "del_tokens": "git . status ( ) . then ( ( status ) => { if ( status . modified . length ) { const fileArray = status . modified . filter ( element => element . includes ( 'package.json' ) ) ; const addArray = fileArray . map ( element => ` ${ element } ` ) git . add ( addArray ) ; git . commit ( 'corrected packages version!' ) ; } else console . log ( 'no change' ) ;", "commit_type": "make"}
{"commit_tokens": ["use", "jQuery", "s", "extend", "()", "method", "for", "the", "deep", "clone"], "add_tokens": "var newAttrs = this . _deepClone ( this . attributes ) , return this . _deepClone ( json ) ; } , _deepClone : function ( obj ) { 'use strict' ; return $ . extend ( true , { } , obj ) ;", "del_tokens": "var newAttrs = _ . deepClone ( this . attributes ) , return _ . deepClone ( json ) ; _ . mixin ( { deepClone : function ( obj ) { 'use strict' ; var result = _ . clone ( obj ) ; // shallow clone if ( _ . isObject ( obj ) ) { _ . each ( obj , function ( val , key ) { result [ key ] = _ . deepClone ( val ) ; } ) ; } return result ; } } ) ;", "commit_type": "use"}
{"commit_tokens": ["Add", "convenient", "method", "on", "grid", "to", "retrieve", "selected", "models"], "add_tokens": "var SelectAllHeaderCell = Backgrid . Extension . SelectAllHeaderCell = SelectRowCell . extend ( { / ** Convenient method to retrieve a list of selected models . This method only exists when the ` ` extension has been included . @ member Backgrid . Grid @ return { Array . < Backbone . Model > } * / Backgrid . Grid . prototype . getSelectedModels = function ( ) { var selectAllHeaderCell ; var headerCells = this . header . row . cells ; for ( var i = 0 , l = headerCells . length ; i < l ; i ++ ) { var headerCell = headerCells [ i ] ; if ( headerCell instanceof SelectAllHeaderCell ) { selectAllHeaderCell = headerCell ; break ; } } var result = [ ] ; if ( selectAllHeaderCell ) { for ( var modelId in selectAllHeaderCell . selectedModels ) { result . push ( this . collection . get ( modelId ) ) ; } } return result ; } ;", "del_tokens": "Backgrid . Extension . SelectAllHeaderCell = SelectRowCell . extend ( {", "commit_type": "add"}
{"commit_tokens": ["fixed", "edge", "-", "less", "graph", "drawing", "issue"], "add_tokens": "sizeMax = sizeMax || 1 ; weightMax = weightMax || 1 ;", "del_tokens": "if ( sizeMax == 0 ) { return ; } if ( weightMax == 0 ) { return ; }", "commit_type": "fix"}
{"commit_tokens": ["added", "tests", "for", "lazy", "block"], "add_tokens": "return Task . create ( function ( ) { return resolver ( this . model ) ; name : \"LazyBlock\" , return typeof Proxy !== \"undefined\" ? new Proxy ( logic , commandsProxy ) : logic ;", "del_tokens": "return Task . create ( function ( { model } ) { return resolver ( model ) ; name : \"\" , return typeof Proxy !== \"undefined\" ? new Proxy ( logic , commandsProxy ) : logic ;", "commit_type": "add"}
{"commit_tokens": ["fix", "the", "velocity", "constraint", "add", "some", "extra", "config"], "add_tokens": "//- ----------外部参数 var coolDown ; var centripetal ; var initializeSize ; var attractiveness ; //- ---------- // ----------获取外部参数 attractiveness = self . deepQuery ( [ serie ] , 'attractiveness' ) ; initSize = self . deepQuery ( [ serie ] , 'initSize' ) ; centripetal = self . deepQuery ( [ serie ] , 'centripetal' ) ; coolDown = self . deepQuery ( [ serie ] , 'coolDown' ) ; // ---------- viewportWidth / 2 , viewportHeight / 2 , initSize var forceFactor = d2 / 100 * centripetal ; velocity [ 0 ] = Math . max ( Math . min ( velocity [ 0 ] , 100 ) , - 100 ) ; velocity [ 1 ] = Math . max ( Math . min ( velocity [ 1 ] , 100 ) , - 100 ) ; temperature *= coolDown ; setTimeout ( cb , stepTime * 1000 ) ;", "del_tokens": "var attractiveness = self . deepQuery ( [ serie ] , 'attractiveness' ) ; viewportWidth / 2 , viewportHeight / 2 , 300 var forceFactor = d2 / 100 ; velocity [ 0 ] = Math . min ( velocity [ 0 ] , 100 ) ; velocity [ 1 ] = Math . min ( velocity [ 1 ] , 100 ) ; temperature *= 0.999 ; setTimeout ( cb , stepTime ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "logic", "to", "trim", "blank", "lines", "by", "default"], "add_tokens": "const input = ` { } ` ; { } ` ) ; { }", "del_tokens": "const input = ` ` ; ` ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "where", "an", "equals", "sign", "in", "a", "filter", "argument", "confuses", "the", "key", "logic"], "add_tokens": "// Specified key const keyParts = obj . param . split ( '=' ) if ( keyParts . length > 1 ) { obj . key = keyParts [ 0 ] obj . param = keyParts [ 1 ] }", "del_tokens": "// Specified key const keyParts = obj . param . split ( '=' ) if ( keyParts . length > 1 ) { obj . key = keyParts [ 0 ] obj . param = keyParts [ 1 ] }", "commit_type": "fix"}
{"commit_tokens": ["improve", "facet", "-", "edit", "layout", "after", "facet", "editting", "refactoring"], "add_tokens": "deps : [ 'type' , 'transform' , 'base_value_time_type' ] , if ( this . isDatetimeInput && this . transform == 'toduration' ) { return 'continuous' ; } if ( this . isDurationInput && this . transform == 'none' ) {", "del_tokens": "deps : [ 'type' , 'transform' ] , if ( this . model . transform == 'duration' ) {", "commit_type": "improve"}
{"commit_tokens": ["fixed", "bug", "in", "selection", "rectangle", "and", "Timer", "node"], "add_tokens": "if ( this . inputs && this . inputs . length > 1 && this . inputs [ 1 ] ) if ( this . inputs && this . inputs . length > 1 && this . inputs [ 1 ] )", "del_tokens": "if ( this . inputs [ 1 ] ) if ( this . inputs [ 1 ] )", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "problem", "with", "error", "catching"], "add_tokens": "this . server . on ( 'error' , this . handleError . bind ( this ) ) ; Prox . prototype . handleError = function ( err ) { this . log ( errMsg ) ; this . emit ( errMsg ) ; } ;", "del_tokens": "this . server . on ( 'error' , handleError . bind ( this ) ) ; function handleError ( err ) { self . log ( errMsg ) ; self . emit ( errMsg ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Added", "exactly", "modifier", "to", "make", "expect", "(", "fn", ")", ".", "to", ".", "exactly", ".", "throw", "()", "instead", "of", "using", "match", "for", "this"], "add_tokens": "exactly : true , if ( this . _modifiers . exactly ) {", "del_tokens": "if ( this . _modifiers . match ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "more", "configuration", "options", "."], "add_tokens": "var API_SANDBOX_URI = 'https://sandbox-api.uber.com/v1/' ; var API_PRODUCTION_URI = 'https://api.uber.com/v1/' ; var OAUTH_URI = 'https://login.uber.com/oauth/v2/token' ; return rest . post ( OAUTH_URI , { function getUrl ( path ) { var sandbox = nconf . get ( 'uber_api_sandbox' ) ; return ( sandbox ? API_SANDBOX_URI : API_PRODUCTION_URI ) + ( path || '' ) ; } console . log ( 'API ' + options . method + ' ' + getUrl ( path ) , options . data ) ; return rest . request ( getUrl ( path ) , options ) ; 'put' : function ( path , data ) { var options = { } ; options . method = 'PUT' ; options . headers = { 'content-type' : 'application/json' } ; options . data = JSON . stringify ( data ) ; return call ( path , options ) ; } ,", "del_tokens": "var API = 'https://sandbox-api.uber.com/v1/' ; return rest . post ( 'https://login.uber.com/oauth/v2/token' , { console . log ( 'using access token' , options . accessToken , options ) ; return rest . request ( API + path , options ) ;", "commit_type": "add"}
{"commit_tokens": ["use", "simple", "-", "sha1", "for", "tests"], "add_tokens": "var sha1 = require ( 'simple-sha1' ) t . equals ( sha1 . sync ( parsedTorrent . infoBuffer ) , 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36' ) t . equals ( sha1 . sync ( parsedTorrent . infoBuffer ) , '80562f38656b385ea78959010e51a2cc9db41ea0' ) t . equals ( sha1 . sync ( parsedTorrent . infoBuffer ) , '427887e9c03e123f9c8458b1947090edf1c75baa' ) t . equals ( sha1 . sync ( parsedTorrent . infoBuffer ) , 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36' ) var files = fs . readdirSync ( numbersPath ) . map ( function ( file ) { t . equals ( sha1 . sync ( parsedTorrent . infoBuffer ) , '80562f38656b385ea78959010e51a2cc9db41ea0' )", "del_tokens": "var crypto = require ( 'crypto' ) function sha1 ( buf ) { return crypto . createHash ( 'sha1' ) . update ( buf ) . digest ( 'hex' ) } t . equals ( sha1 ( parsedTorrent . infoBuffer ) , 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36' ) t . equals ( sha1 ( parsedTorrent . infoBuffer ) , '80562f38656b385ea78959010e51a2cc9db41ea0' ) t . equals ( sha1 ( parsedTorrent . infoBuffer ) , '427887e9c03e123f9c8458b1947090edf1c75baa' ) t . equals ( sha1 ( parsedTorrent . infoBuffer ) , 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36' ) var files = fs . readdirSync ( numbersPath ) . map ( function ( file ) { t . equals ( sha1 ( parsedTorrent . infoBuffer ) , '80562f38656b385ea78959010e51a2cc9db41ea0' )", "commit_type": "use"}
{"commit_tokens": ["Add", "ability", "to", "skip", "comments", "in", "check", "-", "coverage"], "add_tokens": "if ( ! process . env [ 'SKIP_COMMENTS' ] && config . isPr && config . prComments ) {", "del_tokens": "if ( config . isPr && config . prComments ) {", "commit_type": "add"}
{"commit_tokens": ["Update", "react", "-", "hot", "-", "loader"], "add_tokens": "// TODO :: make it work again for TypeScript //if (chain.module.rule(\"ts\")) { // chain.module.rule(\"ts\").use(\"hot\").loader(\"react-hot-loader/webpack\"); //}", "del_tokens": "if ( chain . module . rule ( \"ts\" ) ) { chain . module . rule ( \"ts\" ) . use ( \"hot\" ) . loader ( \"react-hot-loader/webpack\" ) ; } // According to react-hot-loader's documentation, this should be the very first entry. chain . entry ( \"default\" ) . prepend ( require . resolve ( \"react-hot-loader/patch\" ) ) ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "boa", "problem", "with", "non", "ascii", "characters", "in", "file", "names"], "add_tokens": "try { var b64file = btoa ( encodeURIComponent ( file ) ) ; song . b64file = b64file ; } catch ( err ) { console . log ( err ) ; } try { var b64file = btoa ( encodeURIComponent ( file ) ) ; song . b64file = b64file ; } catch ( err ) { console . log ( err ) ; }", "del_tokens": "var b64file = btoa ( file ) ; song . b64file = b64file ; var b64file = btoa ( file ) ; song . b64file = b64file ;", "commit_type": "fix"}
{"commit_tokens": ["Create", "mocksPath", "directory", "if", "DNE", ".", "Edited", "README", ".", "md"], "add_tokens": "grunt . log . warn ( 'Mocks path did not exist \\'' + mocksPath + '\\' Attempting to create...' ) ; grunt . file . mkdir ( mocksPath ) ;", "del_tokens": "grunt . log . error ( 'Prism mocksPath: \\'' + mocksPath + '\\' is invalid.' ) ; return false ;", "commit_type": "create"}
{"commit_tokens": ["Added", "back", "dislikes", "into", "recommendations"], "add_tokens": "_ . each ( leastSimilarUserIds , function ( id , key ) { setsToUnion . push ( [ CLASSNAME , 'user' , id , 'disliked' ] . join ( \":\" ) ) ; } ) ;", "del_tokens": "if ( config . factorLeastSimilarLeastLiked ) { _ . each ( leastSimilarUserIds , function ( id , key ) { setsToUnion . push ( [ CLASSNAME , 'user' , id , 'disliked' ] . join ( \":\" ) ) ; } ) ; }", "commit_type": "add"}
{"commit_tokens": ["fixed", "test", "case", "in", "the", "browser"], "add_tokens": "client . feed ( 'flat1' , '2-3' , 'token' ) ;", "del_tokens": "client . feed ( 'flat1' , '2-3' ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "method", "for", "flight", "stages", "and", "added", "tests"], "add_tokens": "flightID : null , return Url . resolve ( base , 'flights/' + this . flightID + '/flight_stages' ) } , addTeam : function ( teamID , callback ) { var url = this . urlRoot ( ) + '/' + this . id + '/add_team/' + teamID FlightStage . sync ( 'update' , null , { url : url } , callback ) } , removeTeam : function ( teamID , callback ) { var url = this . urlRoot ( ) + '/' + this . id + '/remove_team/' + teamID FlightStage . sync ( 'delete' , null , { url : url } , callback ) } ,", "del_tokens": "return Url . resolve ( base , '/flight_stages' ) }", "commit_type": "add"}
{"commit_tokens": ["allow", "changing", "socket", ".", "io", "-", "path", "via", "query", "string"], "add_tokens": "var url = require ( 'url' ) ; var urlParts = url . parse ( typeof __resourceQuery === \"string\" && __resourceQuery ? io = io . connect ( url . format ( { protocol : urlParts . protocol , auth : urlParts . auth , host : urlParts . host } ) , { path : urlParts . path === '/' ? null : urlParts . path } ) ;", "del_tokens": "io = io . connect ( typeof __resourceQuery === \"string\" && __resourceQuery ?", "commit_type": "allow"}
{"commit_tokens": ["Add", "new", "features", "to", "ViewportSizeClass"], "add_tokens": "* @ param { string } [ measurement = 'width' ] - Specifies whether to use a specific * measurement to determine the size * class ( 'width' , 'height' , 'min' or * 'max' ) . get : ( measurement ) => { if ( typeof measurement !== 'string' ) measurement = 'width' ; let t ; if ( measurement === 'height' ) { t = rect . height ; } else if ( measurement === 'max' ) { t = Math . max ( rect . width , rect . height ) ; } else if ( measurement === 'min' ) { t = Math . min ( rect . width , rect . height ) ; } else { t = rect . width ; }", "del_tokens": "* @ param { boolean } [ isLandscape = false ] - Specifies whether to verify viewport * size class in landscape orientation * ( defaults to portrait ) . get : ( isLandscape ) => { if ( typeof isLandscape !== 'boolean' ) isLandscape = false ; let t = isLandscape ? Math . max ( rect . width , rect . height ) : Math . min ( rect . width , rect . height ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "utf7", "dependency", "decode", "mailbox", "names", "to", "unicode"], "add_tokens": "\"./lib/specialUse\" , \"./bower_components/utf7/utf7\" } ( this , function ( imap , specialUse , utf7 ) { name : utf7 . imap . decode ( names [ i ] ) ,", "del_tokens": "\"./lib/specialUse\" } ( this , function ( imap , specialUse ) { name : names [ i ] , // FIXME: currently utf7 name is not converted to unicode // while mathcing is against unicode strings", "commit_type": "add"}
{"commit_tokens": ["Use", "specific", "link", "for", "iOS", "default", "to", "query", "search", "for", "Android"], "add_tokens": "url = isIOS ? ` ${ prefixes [ 'google-maps' ] } ${ lat } ${ lng } ${ encodeURIComponent ( title || 'Location' ) } ` : ` ${ prefixes [ 'google-maps' ] } ${ lat } ${ lng } `", "del_tokens": "url = prefixes [ 'google-maps' ] + '?q=' + lat + ',' + lng", "commit_type": "use"}
{"commit_tokens": ["remove", "temporary", "files", "+", "fix", "merge", "bug"], "add_tokens": "if ( this . attribute_types [ options . extend ] ) { var extend = this . attribute_types [ options . extend ] . cast ;", "del_tokens": "if ( this . field_types [ options . extend ] ) { var extend = this . field_types [ options . extend ] . cast ;", "commit_type": "remove"}
{"commit_tokens": ["Remove", "all", "uses", "of", "attributes", "from", "order", "phase"], "add_tokens": "return function ( g , orderIters , ranks ) { for ( var i = 0 ; i < orderIters ; ++ i ) {", "del_tokens": "return function ( g , ranks ) { var iters = g . attrs . orderIters ; for ( var i = 0 ; i < iters ; ++ i ) {", "commit_type": "remove"}
{"commit_tokens": ["Changed", "to", "use", "abstract", "classes", "."], "add_tokens": "import AbstractSearchRoute from 'hospitalrun/routes/abstract-search-route' ; export default AbstractSearchRoute . extend ( { moduleName : 'patients' , searchKeys : [ 'firstName' , 'lastName' ] , searchModel : 'patient'", "del_tokens": "export default Ember . Route . extend ( { actions : { allPatients : function ( ) { this . transitionTo ( 'patients' ) ; } } , searchText : null , model : function ( params ) { this . set ( 'searchText' , params . search_text ) ; var queryParams = { containsValue : { value : params . search_text , keys : [ '_id' , 'firstName' , 'lastName' ] } , } ; return this . store . find ( 'patient' , queryParams ) ; } , setupController : function ( controller , model ) { controller . set ( 'model' , model ) ; controller . set ( 'searchText' , this . get ( 'searchText' ) ) ; }", "commit_type": "change"}
{"commit_tokens": ["Change", "initializer", "to", "instance", "initializer"], "add_tokens": "name : 'ember-parachute' ,", "del_tokens": "name : 'parachute-route' ,", "commit_type": "change"}
{"commit_tokens": ["Use", "object", "-", "assign", "for", "Object", ".", "assign"], "add_tokens": "var assign = require ( 'object-assign' ) ; options = assign (", "del_tokens": "options = Object . assign (", "commit_type": "use"}
{"commit_tokens": ["Make", "sure", "the", "menu", "doesn", "t", "try", "to", "realign", "its", "button", "before", "a", "flush"], "add_tokens": "// FIXME implement collapsing", "del_tokens": "if ( options . predicate && ! options . predicate ( pm ) ) return", "commit_type": "make"}
{"commit_tokens": ["Adding", "success", "param", "to", "onResponse", "callback"], "add_tokens": "callback ( resp , ( resp . _HTTP . status < 400 ) ) ;", "del_tokens": "callback ( resp ) ;", "commit_type": "add"}
{"commit_tokens": ["Implemented", "axis", "parameter", "in", "Vector", "and", "Matrix"], "add_tokens": "* @ param { Leap . Vector } [ axis ] The axis to measure rotation around . angle = isNaN ( angle ) ? 0.0 : angle ; if ( axis ) { var rotAxis = this . rotationAxis ( sinceFrame ) ; angle *= rotAxis . dot ( axis . normalized ( ) ) ; } return angle ;", "del_tokens": "// TODO: implement axis parameter return isNaN ( angle ) ? 0.0 : angle ;", "commit_type": "implement"}
{"commit_tokens": ["fix", "setting", "window", ".", "debug", "before", "require", "(", "aframe", ")", "to", "allow", "stubbing", "of", "core", "render", "funcs"], "add_tokens": "this . sinon . stub ( AScene . prototype , 'resize' ) ; this . sinon . stub ( AScene . prototype , 'setupRenderer' ) ;", "del_tokens": "//this.sinon.stub(AScene.prototype, 'resize'); //this.sinon.stub(AScene.prototype, 'setupRenderer');", "commit_type": "fix"}
{"commit_tokens": ["Fix", "a", "type", "-", "vector", "unit", "-", "test"], "add_tokens": "try { var list = new TypeVector ( { module : 'namespace' , type : '%Message' , list : [ message1 , message2 ] } ) ; var buffer = list . serialize ( ) ; } catch ( e ) { console . log ( 'error: ' , e ) ; throw e ; }", "del_tokens": "var list = new TypeVector ( { type : '%Message' , list : [ message1 , message2 ] } ) ; var buffer = list . serialize ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "functions", "to", "the", "public", "api", "."], "add_tokens": "\"hexToHpluv\" : hsluv . Hsluv . hexToHpluv , \"lchToLuv\" : hsluv . Hsluv . lchToLuv , \"luvToXyz\" : hsluv . Hsluv . luvToXyz , \"xyzToRgb\" : hsluv . Hsluv . xyzToRgb , \"lchToRgb\" : hsluv . Hsluv . lchToRgb , \"hpluvToLch\" : hsluv . Hsluv . hpluvToLch , \"lchToHpluv\" : hsluv . Hsluv . lchToHpluv , \"lchToHsluv\" : hsluv . Hsluv . lchToHsluv , \"hsluvToLch\" : hsluv . Hsluv . hsluvToLch", "del_tokens": "\"hexToHpluv\" : hsluv . Hsluv . hexToHpluv", "commit_type": "add"}
{"commit_tokens": ["Fix", "response", "output", "for", "Detect", "Labels"], "add_tokens": "labels . forEach ( label => console . log ( label . description ) ) ; labels . forEach ( label => console . log ( label . description ) ) ;", "del_tokens": "labels . forEach ( label => console . log ( label ) ) ; labels . forEach ( label => console . log ( label ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "component", "dependencies", "got", "browser", "sample", "working"], "add_tokens": "module . exports = lodash ; var Client , Collector , EventEmitter , applyOp , find , normalizePayload , objInclude , _ , _ref , if ( typeof window !== \"undefined\" && window !== null ) { EventEmitter = require ( 'emitter' ) ; } else { EventEmitter = require ( 'events' ) . EventEmitter ; } } ) ( EventEmitter ) ;", "del_tokens": "if ( freeExports && ! freeExports . nodeType ) { freeExports . _ = lodash ; } var Client , Collector , Emitter , applyOp , find , normalizePayload , objInclude , _ , _ref , Emitter = require ( 'emitter' ) ; } ) ( Emitter ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "bug", "in", "build", ".", "js", "that", "prevents", "build", "process", "from", "exiting"], "add_tokens": "this . compileFile . $ ( ) ) } process . exit ( ) /* call explicitly, because supervisor's ipc.js prevents from auto-exiting (while listening to messages) */ } ,", "del_tokens": "this . compileFile . $ ( ) ) } } ,", "commit_type": "fix"}
{"commit_tokens": ["Allow", "an", "index", "to", "be", "specified", "in", "command", "-", "line", "options"], "add_tokens": "defaultConfig = this . _setDefaultServerConfig ( defaultConfig , argv ) ; if ( argv . ghostMode === \"false\" ) { defaultConfig . ghostMode = false ; } return defaultConfig ; } , _setDefaultServerConfig : function ( defaultConfig , argv ) { baseDir : argv . server , index : argv . index || \"index.html\" baseDir : \"./\" , index : argv . index || \"index.html\"", "del_tokens": "baseDir : argv . server baseDir : \"./\" if ( argv . ghostMode === \"false\" ) { defaultConfig . ghostMode = false ; }", "commit_type": "allow"}
{"commit_tokens": ["Changed", "the", "port", "to", "run", "tests", "through", "the", "vagrant", "port", "forwarded", "mongo", "port", "."], "add_tokens": "crypto : { secret_passphrase : \"2804c9ad-ffc8-4acb-9c9d-16337824af8c\" } , host : 'mongodb://{dbuser}:{dbpassword}@localhost:8070/grasshopper' ,", "del_tokens": "host : 'mongodb://{dbuser}:{dbpassword}@ds043348.mongolab.com:43348/grasshopper' ,", "commit_type": "change"}
{"commit_tokens": ["use", "time", "-", "constant", "compare", "for", "csrf", "token"], "add_tokens": "var scmp = require ( 'scmp' ) ; return scmp ( token , createToken ( token . slice ( 0 , 10 ) , secret ) ) ;", "del_tokens": "return token === createToken ( token . slice ( 0 , 10 ) , secret ) ;", "commit_type": "use"}
{"commit_tokens": ["Use", "he", "for", "robust", "HTML", "entity", "encoding", "/", "decoding"], "add_tokens": "var he = require ( 'he' ) ; return he . encode ( group , { useNamedReferences : true } ) ;", "del_tokens": "var ent = require ( 'ent' ) ; return ent . encode ( group , { named : true } ) ;", "commit_type": "use"}
{"commit_tokens": ["fix", "-", "non", "utf", "-", "8", "encoded", "txt", "file", "decode", "correctly"], "add_tokens": "var iconv = require ( 'iconv-lite' ) ; var jschardet = require ( 'jschardet' ) ; var encoding = jschardet . detect ( data ) . encoding . toLowerCase ( ) ; var decoded = iconv . decode ( data , encoding ) ; cb ( null , decoded ) ; } ;", "del_tokens": "cb ( null , data . toString ( ) ) ; } ;", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "some", "Input", "and", "ValidatorChain", "bug", "for", "IE", ".", "Added", "EmptyValidator", "(", "validates", "if", "value", "is", "empty", "."], "add_tokens": "continueIfEmpty : true , // Protect from adding programmatic validators, from within `isValid`, more than once this . options . isValidHasRun = false ; // Get the validator chain, value and validate validatorChain = self . getValidatorChain ( ) , // Check whether we need to add an empty validator if ( ! self . options . isValidHasRun && ! self . getContinueIfEmpty ( ) ) { validatorChain . addValidator ( new context . sjl . EmptyValidator ( ) ) ; // Protect from adding programmatic validators more than once.. if ( ! self . options . isValidHasRun ) { self . options . isValidHasRun = true ; } return this . options . continueIfEmpty ;", "del_tokens": "continueIfEmpty : false , validatorChain , if ( ! self . getContinueIfEmpty ( ) ) { // inject non empty validator // Get the validator chain, value and validate validatorChain = self . getValidatorChain ( ) ; return this . options . breakOnFailure ;", "commit_type": "fix"}
{"commit_tokens": ["Use", "$interval", "instead", "of", "$timeout"], "add_tokens": "/* ng-infinite-scroll - v1.1.2 - 2014-12-01 */ '$rootScope' , '$window' , '$interval' , 'THROTTLE_MILLISECONDS' , function ( $rootScope , $window , $interval , THROTTLE_MILLISECONDS ) { $interval . cancel ( timeout ) ; $interval . cancel ( timeout ) ; return timeout = $interval ( later , remaining , 1 ) ; return $interval ( ( function ( ) { } ) , 0 , 1 ) ;", "del_tokens": "/* ng-infinite-scroll - v1.1.2 - 2014-11-30 */ '$rootScope' , '$window' , '$timeout' , 'THROTTLE_MILLISECONDS' , function ( $rootScope , $window , $timeout , THROTTLE_MILLISECONDS ) { $timeout . cancel ( timeout ) ; $timeout . cancel ( timeout ) ; return timeout = $timeout ( later , remaining ) ; return $timeout ( ( function ( ) { } ) , 0 ) ;", "commit_type": "use"}
{"commit_tokens": ["Implement", "bright", "and", "underline", "."], "add_tokens": "console . log ( 'console.log: %s values draw attention to the eye' , ansi ( 'bright' ) . bright ( ) . white ( ) ) ; console . log ( 'console.log: %s values draw attention to the eye' , ansi ( 'bright' ) . underline ( ) . white ( ) ) ; //console.log('console.log: a %s string and a blue number %d', //ansi('white').white(), ansi(3.14).blue()); //console.info('console.info: a %s string and a green number %d', //ansi('cyan').cyan(), ansi(3.14).green()); //console.error('console.error: a %s string and a red number %d', //ansi('magenta').magenta(), ansi(3.14).red()); //console.warn('console.warn: a %s string and a black number %d', //ansi('yellow').yellow(), ansi(3.14).black());", "del_tokens": "var fs = require ( 'fs' ) ; var tty = require ( 'tty' ) ; console . log ( 'console.log: a %s string and a blue number %d' , ansi ( 'white' ) . white ( ) , ansi ( 3.14 ) . blue ( ) ) ; console . info ( 'console.info: a %s string and a green number %d' , ansi ( 'cyan' ) . cyan ( ) , ansi ( 3.14 ) . green ( ) ) ; console . error ( 'console.error: a %s string and a red number %d' , ansi ( 'magenta' ) . magenta ( ) , ansi ( 3.14 ) . red ( ) ) ; console . warn ( 'console.warn: a %s string and a black number %d' , ansi ( 'yellow' ) . yellow ( ) , ansi ( 3.14 ) . black ( ) ) ;", "commit_type": "implement"}
{"commit_tokens": ["improved", "on", "-", "line", "demo"], "add_tokens": "\"\\n throw new Error('bad callback: ' + callback);\" + \"\\n try { callback(null, message.length); }\" + \"\\n catch (err) { callback(err); }\" +", "del_tokens": "\"\\n return error('bad callback: ' + callback);\" + \"\\n callback(null, message.length);\" +", "commit_type": "improve"}
{"commit_tokens": ["using", "the", "data", "file", "name", "as", "the", "default", "title", "and", "description", "."], "add_tokens": "' <h3 id=\"title-' + i + '\">' + dataList [ i ] + '</h3>' + ' <p id=\"desc-' + i + '\">' + dataList [ i ] + '</p>' +", "del_tokens": "' <h3 id=\"title-' + i + '\">Title</h3>' + ' <p id=\"desc-' + i + '\">Desc</p>' +", "commit_type": "use"}
{"commit_tokens": ["add", "options", "exclude", "and", "multimatch"], "add_tokens": "const r1 = [ rrdir . sync ( \"test\" ) for ( const result of r1 ) { const r2 = [ await rrdir ( \"test\" , { exclude : [ \"subdir\" ] } ) , rrdir . sync ( \"test\" , { exclude : [ \"subdir\" ] } ) ] ; for ( const result of r2 ) { assert . deepStrictEqual ( result , [ { path : \"test/file1\" , directory : false , symlink : false } , ] ) ; }", "del_tokens": "const results = [ rrdir . sync ( \"test\" ) , for ( const result of results ) {", "commit_type": "add"}
{"commit_tokens": ["improve", "stack", ".", "js", "logic"], "add_tokens": "// process.env.DEBUG = 'verb:*' var stack = require ( './lib/stack' ) ;", "del_tokens": "process . env . DEBUG = 'verb' ; var stack = require ( './lib/defaults' ) ;", "commit_type": "improve"}
{"commit_tokens": ["added", ".", "log", "method", "to", "Facebook", "API", "to", "handle", "the", "case", "is_echo", "is", "enabled", "version", "increment", "."], "add_tokens": "function logIncomingInternal ( data , source , type ) { type = type || 'incoming' that . apiKey + '&type=' + type + '&platform=' + that . platform + '&v=' + VERSION + '-' + source ; / * * For use with is_echo = true just log all incoming you don ' * / that . log = function ( data ) { return logIncomingInternal ( data , 'npm' , 'all' ) ; } ;", "del_tokens": "function logIncomingInternal ( data , source ) { that . apiKey + '&type=incoming&platform=' + that . platform + '&v=' + VERSION + '-' + source ;", "commit_type": "add"}
{"commit_tokens": ["using", "req", ".", "rendrApp", "instead", "of", "req", ".", "appContext"], "add_tokens": "req . rendrApp = new App ;", "del_tokens": "req . appContext = new App ;", "commit_type": "use"}
{"commit_tokens": ["Updated", "redirects", "for", "new", "routes", "/", "contextat", "and", "/", "contextnear"], "add_tokens": "res . redirect ( '../../contextat/directory/' + req . param ( 'place' ) ) ;", "del_tokens": "res . redirect ( '../../places/' + req . param ( 'place' ) + '/context' ) ;", "commit_type": "update"}
{"commit_tokens": ["Adding", "more", "details", "about", "the", "cause", "for", "the", "notPreloaded", "error", "."], "add_tokens": "var preloadPromise = this . modulePreload ( module ) ; if ( preloadPromise . state ( ) != \"resolved\" ) { throw noderError ( \"notPreloaded\" , [ module ] , preloadPromise . result ( ) ) ;", "del_tokens": "if ( this . modulePreload ( module ) . state ( ) != \"resolved\" ) { throw noderError ( \"notPreloaded\" , [ module ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "deep", "equals", "for", "equalsMatcher"], "add_tokens": "module . exports . equalsMatcher = _ . isEqual ;", "del_tokens": "module . exports . equalsMatcher = ( expected , actual ) => expected === actual ;", "commit_type": "use"}
{"commit_tokens": ["updates", "to", "handle", "refresh", "token"], "add_tokens": "console . debug ( \"login token\" , { token } ) ; const prefs = quip . apps . getUserPreferences ( ) ; console . error ( \"ERROR in login\" , error ) ; export async function refreshToken ( ) { const auth = quip . apps . auth ( \"quip-automation-api\" ) ; await auth . refreshToken ( ) ; const token = auth . getTokenResponse ( ) ; console . debug ( \"refreshToken\" , { token } ) ; //const prefs = quip.apps.getUserPreferences(); //prefs.save({token}); } let prefs = quip . apps . getUserPreferences ( ) ; prefs . save ( { token : null } ) ; console . debug ( \"ok, logged out\" ) ; console . error ( \"ERROR in logout\" , error ) ;", "del_tokens": "const defaultRowText = index => ` ${ typeof index === \"number\" ? ` ${ index + 1 } ` : \"\" } ` ; const matchDefaultRowText = text => ( text . match ( / ^Row (\\d+)$ / ) || [ ] ) [ 1 ] ; let prefs = quip . apps . getUserPreferences ( ) ; console . error ( \"ERROR\" , error ) ; let prefs = quip . apps . getUserPreferences ( ) ; prefs . save ( { token : null } ) ; this . setState ( { error } ) ;", "commit_type": "update"}
{"commit_tokens": ["Remove", "apm", "-", "registry", "flag", "for", "init", "command"], "add_tokens": "init < name > Initialize a new Aragon module ( e . g . test . aragonpm . eth ) $ aragon - dev - cli init cool - app . aragonpm . eth chainId : 3 , string : [ 'key' , 'rpc' , 'ens-registry' ]", "del_tokens": "init < name > Initialize a new Aragon module -- apm - registry < registry > The repository registry to use for creating and publishing packages ( default : aragonpm . eth ) $ aragon - dev - cli init poll -- registry = module - corp . eth Created new module poll . module - corp . eth $ aragon - dev - cli init cool - app registry : 'aragonpm.eth' , chainId : 3 string : [ 'key' , 'rpc' , 'registry' ]", "commit_type": "remove"}
{"commit_tokens": ["fix", "strip", "drop", "escaping", "weirdness"], "add_tokens": "text += chars ; result += text ;", "del_tokens": "str = replaceEscapes ( str ) ; str = html . unescape ( str ) ; text += \" \" + _ . trim ( html . escape ( chars ) ) ; text = unreplaceEscapes ( text ) ; result += html . escape ( text ) ; str = replaceEscapes ( str ) ; str = html . unescape ( str ) ; str = unreplaceEscapes ( str ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "thing", "for", "Windows", "which", "is", "unneeded", "now"], "add_tokens": "", "del_tokens": "// TODO: windows specific component is temporary if ( process . platform === 'win32' ) { var stylesForWindow = require ( './windowStyles' ) ( NativeWindow ) ; } else { var stylesForWindow = function ( ) { } }", "commit_type": "remove"}
{"commit_tokens": ["fix", "tests", "and", "undefined", "number"], "add_tokens": "number : memo . length , startTime : startTime , endTime : endTime", "del_tokens": "number : number , startTime : startTime , endTime : endTime", "commit_type": "fix"}
{"commit_tokens": ["adding", "where", "...", "in", "support"], "add_tokens": "var val = parameter . value ( ) ; var params = this . params ; if ( util . isArray ( val ) ) { var response = val . map ( function ( v , idx ) { params . push ( v ) ; return '$' + ( params . length ) ; } ) . join ( ', ' ) ; return '(' + response + ')' ; } else { this . params . push ( val ) ; return \"$\" + params . length ; }", "del_tokens": "this . params . push ( parameter . value ( ) ) ; return \"$\" + this . params . length ;", "commit_type": "add"}
{"commit_tokens": ["Added", "optional", "video", "/", "zoneSize", "arguments", "to", "the", "webflow", ".", "js"], "add_tokens": "* @ param defaultVideoTag { DOMElement } optional reference to < video > tag * where web camera output should be rendered . If parameter is not * present a new invisible < video > tag is created . * @ param zoneSize { int } optional size of a flow zone in pixels . 8 by default function WebCamFlow ( defaultVideoTag , zoneSize ) { videoFlow = new VideoFlow ( { step : zoneSize || 8 } ) , videoTag = defaultVideoTag || window . document . createElement ( 'video' ) ;", "del_tokens": "function WebCamFlow ( ) { videoFlow = new VideoFlow ( ) , videoTag = window . document . createElement ( 'video' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "some", "checks", "for", "pluralization"], "add_tokens": "let pluralizationType = typeof pluralization ; // return translation item directly if ( pluralization === null ) { return replacedText ( ) ; } // check if pluralization value is countable if ( pluralizationType !== 'number' ) { console . warn ( 'pluralization is not a number' ) ; return replacedText ( ) ; } let translatedText = replacedText ( ) . split ( ':::' ) ; // return the left side on singular, the right side for plural // 0 has plural notation if ( pluralization === 1 ) { return translatedText [ 0 ] . trim ( ) ; } if ( translatedText . length > 1 ) { return translatedText [ 1 ] . trim ( ) ; console . warn ( 'no pluralized translation provided in ' , translation ) ; return translatedText [ 0 ] . trim ( ) ;", "del_tokens": "if ( pluralization !== null ) { // return the left side on singular, the right side for plural // 0 has plural notation if ( pluralization == 1 ) { return replacedText ( ) . split ( ':::' ) [ 0 ] . trim ( ) ; } else { return replacedText ( ) . split ( ':::' ) [ 1 ] . trim ( ) ; } // return translation item directly return replacedText ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Using", "JSONP", "since", "the", "Same", "Origin", "Policy", "won", "t", "let", "file", ":", "//", "make", "an", "XHR", "to", "github", ".", "com"], "add_tokens": "var me = this ; $ . ajax ( { url : me . url ( ) , dataType : \"jsonp\" , success : function ( data , status , xhr ) { me . set ( data . user ) ; } } ) ;", "del_tokens": "$ . getJSON ( this . url ( ) , { } , _ . bind ( function ( resp ) { this . set ( resp . user ) ; } , this ) ) ; console . log ( this . model ) ;", "commit_type": "use"}
{"commit_tokens": ["Updated", "tests", "based", "on", "refactor", "."], "add_tokens": "Device : require ( './lib/device' ) , Gateway : require ( './lib/gateway' ) , Peripheral : require ( './lib/peripheral' )", "del_tokens": "Device : require ( './lib/device' )", "commit_type": "update"}
{"commit_tokens": ["Changed", "file", "fields", "to", "be", "default", "public"], "add_tokens": "* store ( file , opts = { } ) { const rootPath = opts . private ? config . fileStorage . engines . local . privateRoot : config . fileStorage . engines . local . publicRoot ; let newPath = path . join ( rootPath , prefix , file . name + '__' + uuid ( ) ) ;", "del_tokens": "* store ( file , opts ) { let newPath = path . join ( config . fileStorage . engines . local . publicRoot , prefix , file . name + '__' + uuid ( ) ) ;", "commit_type": "change"}
{"commit_tokens": ["added", "init", "script", "for", "creating", "project", "directory"], "add_tokens": "require ( [ \"./js/core/Imports\" ] , function ( ) { require ( [ \"./js/core/Application\" , mainClass ] , function ( Application , mainClassFactory ) {", "del_tokens": "require ( [ \"./core/Imports\" ] , function ( ) { require ( [ \"./core/Application\" , mainClass ] , function ( Application , mainClassFactory ) {", "commit_type": "add"}
{"commit_tokens": ["add", "core", "css", "needn", "t", "set", "ul", "&", "li", "style", "in", "demo"], "add_tokens": "html = item . content ; outer . style . cssText = 'height:' + this . height + 'px;width:' + this . width + 'px;margin:0;padding:0;list-style:none;' ; li . className = this . type == 'dom' ? 'islider-dom' : 'islider-pic' ;", "del_tokens": "html = '<div style=\"height:100%; width:100%\">' + item . content + '</div>' ; outer . style . cssText = 'height:' + this . height + 'px;width:' + this . width + 'px;' ;", "commit_type": "add"}
{"commit_tokens": ["Use", "EPSG", "3573", "tiles", "for", "plugin", "demo"], "add_tokens": "} , \"arctic_connect@EPSG:3573\" : { name : \"arctic_connect@EPSG:3573\" , crs : \"EPSG:3573\" , proj4def : '+proj=laea +lat_0=90 +lon_0=-100 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs' , url : \"http://tiles.arcticconnect.org/osm_3573/{z}/{x}/{y}.png\" , minZoom : 0 , maxZoom : 18 , tms : false , // (Source on values?) transformation : new L . Transformation ( 1 , 20036842.762 , - 1 , 20036842.762 ) , scale : function ( zoom ) { return ( 40073685.524 / 256 ) / Math . pow ( 2 , zoom ) ; } , center : [ 0 , 0 ] , zoom : 4 , continuousWorld : true , attribution : 'Map &copy; <a href=\"http://arcticconnect.org\">ArcticConnect</a>. Data &copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' tileProjection : projectedTiles [ \"arctic_connect@EPSG:3573\" ]", "del_tokens": "tileProjection : projectedTiles [ \"jotunheimen@EPSG:32632\" ]", "commit_type": "use"}
{"commit_tokens": ["added", "motors", ".", "get", "(", "*", ")"], "add_tokens": "if ( ports == \"*\" ) return this . states ; else if ( ! ports . indexOf ( \",\" ) )", "del_tokens": "if ( ! ports . indexOf ( \",\" ) )", "commit_type": "add"}
{"commit_tokens": ["added", "sourceSampleCount", "in", "all", "sources"], "add_tokens": "this . inSegment = false ;", "del_tokens": "this . isInSegment = false ; // // frameTime and frameMetadata defaults to identity // this.frame.time = frame.time; // this.frame.metadata = frame.metadata;", "commit_type": "add"}
{"commit_tokens": ["Added", "generator", "at", "correct", "places", "and", "gave", "importance", "to", "schema", ".", "example"], "add_tokens": "faker . option ( { useDefaultValue : true } ) ; export function bodyFromSchema ( schema , payload , parser ) { let asset = null ; let body = schema . example || JSON . stringify ( faker ( schema ) , null , 2 ) ; asset = new Asset ( body ) ; asset . contentType = 'application/json' ; payload . content . push ( asset ) ;", "del_tokens": "export function bodyFromSchema ( schema , parser ) { let asset = null asset = new Asset ( JSON . stringify ( faker ( schema ) , null , 2 ) ) ; asset . attributes . set ( 'contentType' , 'application/json' ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "the", "tests", "for", "order", "-", "by"], "add_tokens": "it ( 'should order sibling nodes in normal order' , function ( ) { element = $compile ( '<treecontrol tree-model=\"treedata\" order-by=\"{{predicate}}\" reverse-order=\"{{reverse}}\">{{node.label}}</treecontrol>' ) ( $rootScope ) ; $rootScope . $digest ( ) ; } ) ; it ( 'should order sibling nodes in reverse order' , function ( ) { $rootScope . treedata = [ { label : \"a\" , children : [ ] } , { label : \"c\" , children : [ ] } , { label : \"b\" , children : [ ] } , ] ; $rootScope . predicate = 'label' ; element = $compile ( '<treecontrol tree-model=\"treedata\" order-by=\"{{predicate}}\" reverse-order=\"{{reverse}}\">{{node.label}}</treecontrol>' ) ( $rootScope ) ;", "del_tokens": "if ( 'should be able to order sibling nodes using orderBy and reverseOrder attributes' , function ( ) { element = $compile ( '<treecontrol tree-model=\"treedata\" orderBy=\"{{predicate}}\" reverseOrder=\"{{reverse}}\">{{node.label}}</treecontrol>' ) ( $rootScope ) ;", "commit_type": "fix"}
{"commit_tokens": ["Allow", "merge", "to", "be", "called", "without", "a", "context"], "add_tokens": "target [ name ] = misc . merge ( false , clone , copy ) ;", "del_tokens": "target [ name ] = this . merge ( false , clone , copy ) ;", "commit_type": "allow"}
{"commit_tokens": ["added", "feature", "to", "generate", "distinct", "colors"], "add_tokens": "// If you've already generated a color, let's pick one which is distinct if ( randomColor . previousHue ) { do { hue = util . randomBetween ( hueRange , 'integer' ) ; } while ( Math . abs ( hue - randomColor . previousHue ) < util . distinctHue ) return hue } randomColor . previousHue = h ; distinctHue : 40 , if ( typeof min === 'object' ) { shiftHue : function ( h , degrees ) { if ( typeof h === \"object\" ) { for ( var key in h ) { ( h [ key ] += degrees ) % 360 } } else if ( typeof h === \"number\" ) { ( h [ key ] += degrees ) % 360 } return h } ,", "del_tokens": "console . log ( s + ', ' + v + ' passed the test!' ) ; // this needs to accept multiple arrays too // this doesn't work all the time", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "explicit", "branches", "with", "coveralls", "service", "."], "add_tokens": "camp . route ( / ^\\/coveralls\\/([^\\/]+\\/[^\\/]+)(?:\\/(.+))?\\.(svg|png|gif|jpg)$ / , var branch = match [ 2 ] ; var format = match [ 3 ] ; var apiUrl = 'https://coveralls.io/repos/' + userRepo + '/badge.png' ; if ( branch ) { apiUrl += '?branch=' + branch ; }", "del_tokens": "camp . route ( / ^\\/coveralls\\/(.*)\\.(svg|png|gif|jpg)$ / , var format = match [ 2 ] ; var apiUrl = 'https://coveralls.io/repos/' + userRepo + '/badge.png?branch=master' ;", "commit_type": "add"}
{"commit_tokens": ["Make", "inline", "style", "buttons", "do", "something", "meaningful", "when", "no", "selection", "is", "present"], "add_tokens": "if ( this . active ( pm ) ) { if ( sel . empty ) pm . setInlineStyle ( this . style , false ) else pm . apply ( pm . tr . removeStyle ( sel . from , sel . to , this . style . type ) ) } else if ( this . dialog ) { } else { if ( sel . empty ) pm . setInlineStyle ( this . style , true ) else pm . apply ( pm . tr . addStyle ( sel . from , sel . to , this . style ) ) }", "del_tokens": "if ( this . active ( pm ) ) pm . apply ( pm . tr . removeStyle ( sel . from , sel . to , this . style . type ) ) else if ( this . dialog ) else pm . apply ( pm . tr . addStyle ( sel . from , sel . to , this . style ) )", "commit_type": "make"}
{"commit_tokens": ["Use", "the", "given", "path", "prefix", "on", "the", "API", "base", "url", "for", "requests", "."], "add_tokens": "// https://github.com/joyent/node/issues/711 introduced a bug, IMO, // where `pathname==\"/\"` even for, e.g., \"http://example.com\". Ignore // the '/' in that case. this . path = options . path || '' ; if ( ! this . path && this . url && ! ( this . url . pathname === '/' && options . url [ options . url . length - 1 ] !== '/' ) ) { this . path = this . url . pathname ; } < << << << HEAD === === = if ( self . url . port !== undefined ) { opts . port = self . url . port . toString ( ) ; } >>> >>> > Use the given path prefix on the API base url for requests . var path = opts . path + options . path ; opts . path = path ;", "del_tokens": "this . path = options . path || url . pathname || '/' ;", "commit_type": "use"}
{"commit_tokens": ["added", "more", "functions", "to", "singly", "linked", "list"], "add_tokens": "// # Needle object that contains all core data structures", "del_tokens": "// Main needle file that includes all of the data structures contained in a single Needle object", "commit_type": "add"}
{"commit_tokens": ["Move", "Class", "onto", "the", "chic", "namespace"], "add_tokens": "} ( typeof exports === 'undefined' ? ( this . chic = { } ) : exports ) ) ;", "del_tokens": "} ( typeof exports === 'undefined' ? this : exports ) ) ;", "commit_type": "move"}
{"commit_tokens": ["use", "concat", "instead", "of", "uglify", "for", "js"], "add_tokens": "} , concat : { '<%= grunt.template.today(\"yyyy-mm-dd\") %> */\\n' dist : { } , grunt . loadNpmTasks ( 'grunt-contrib-concat' ) ; grunt . registerTask ( 'default' , [ 'clean' , 'concat' , 'cssmin' , 'copy' ] ) ;", "del_tokens": "} , uglify : { '<%= grunt.template.today(\"yyyy-mm-dd\") %> */\\n' , mangle : false build : { } , grunt . loadNpmTasks ( 'grunt-contrib-uglify' ) ; grunt . registerTask ( 'default' , [ 'clean' , 'uglify' , 'cssmin' , 'copy' ] ) ;", "commit_type": "use"}
{"commit_tokens": ["Make", "large", "fractions", "actually", "work"], "add_tokens": "} else if ( group . type === \"dfrac\" ) { var numer = makeSpan ( \"mfracnum\" , makeSpan ( \"\" , buildExpression ( group . value . numer , numer ) ) ) ;", "del_tokens": "} else if ( group . type === \"frac\" ) { var numer = makeSpan ( \"mfracnum\" , buildExpression ( group . value . numer , numer ) ) ;", "commit_type": "make"}
{"commit_tokens": ["fixed", "an", "issue", "where", "new", "version", "of", "xml2js", "will", "wrap", "all", "elements", "in", "array", "."], "add_tokens": "//requirements: '(Arch == \"INTEL\") || (Arch == \"X86_64\") && (machine == \"grid-client-1\")', requirements : '(Arch == \"INTEL\") || (Arch == \"X86_64\")' , queue : 5 var terminated = 0 ; //console.dir(job); job . onevent ( function ( event ) { console . log ( event . MyType + \" on Proc:\" + event . Proc ) ; console . log ( event . MyType + \" on Proc:\" + event . Proc ) ; console . log ( event . MyType + \" on Proc:\" + event . Proc ) ; terminated ++ ; if ( terminated == 5 ) { console . log ( \"all process finished\" ) ; job . unwatch ( ) ; } htcondor . remove ( job ) ; job . unwatch ( ) ;", "del_tokens": "requirements : '(Arch == \"INTEL\") || (Arch == \"X86_64\") && (machine == \"grid-client-1\")' , queue : 1 console . dir ( job ) ; job . log . onevent ( function ( event ) { console . log ( event . MyType ) ; console . log ( event . MyType ) ; job . log . unwatch ( ) ; console . log ( event . MyType ) ; job . log . unwatch ( ) ; job . log . unwatch ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["make", "forking", "of", "eventdispatching", "configurable"], "add_tokens": "// logger: 'console', // use consoleLogger [optional] // forkDispatching: true // default is true [optional] this . options . forkDispatching = this . options . forkDispatching !== undefined ? this . options . forkDispatching : true ; if ( this . options . forkDispatching && this . storage . filename && this . storage . options ) {", "del_tokens": "// logger: 'console' // use consoleLogger [optional] if ( this . storage . filename && this . storage . options ) {", "commit_type": "make"}
{"commit_tokens": ["Add", "API", "to", "handle", "redirect", "parsing", "errors"], "add_tokens": "import { throwAsync } from './utils' ; /** @private {?function(!Error)} */ this . redirectErrorResolver_ = null ; /** @private {!Promise<!Error>} */ this . redirectErrorPromise_ = new Promise ( resolve => { this . redirectErrorResolver_ = resolve ; } ) ; / ** * @ param { function ( ! Error ) } handler * / onRedirectError ( handler ) { this . redirectErrorPromise_ . then ( handler ) ; } try { port = discoverRedirectPort ( this . win_ , this . fragment_ , requestId ) ; } catch ( e ) { throwAsync ( e ) ; this . redirectErrorResolver_ ( e ) ; }", "del_tokens": "port = discoverRedirectPort ( this . win_ , this . fragment_ , requestId ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "lodash", "-", "template", "/", "attribute", "-", "name", "-", "casing", "rule"], "add_tokens": "\"require or disallow a space before tag's closing brackets. (ex. :ok: `<input>` `<input·/>` :ng: `<input·>` `<input/>`)\",", "del_tokens": "\"require or disallow a space before tag's closing brackets. (ex. :ng: `<input·>` `<input/>`)\",", "commit_type": "add"}
{"commit_tokens": ["fixed", "jshint", "but", "not", "for", "test", "cases"], "add_tokens": "if ( name === 'grunt-cli' ) { return ; }", "del_tokens": "if ( name === 'grunt-cli' ) return ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "substring", "syntax", "ambiguity", "in", "ext", "filters"], "add_tokens": "* Some extensible filters ( such as caseIgnoreSubstringsMatch ) operate with * values formatted with the substring syntax . In order to prevent ambiguity * between '*' characters which are not escaped and any which are , we attempt * substring - style parsing on any value which contains the former . if ( str . indexOf ( '*' ) !== - 1 ) {", "del_tokens": "* Coming from the original ldapjs code , handling for a few ExtensibleFilter * rules was built into the implementation . This logic is preserved here . if ( res . rule === '2.5.13.4' || res . rule === 'caseIgnoreSubstringsMatch' ) {", "commit_type": "fix"}
{"commit_tokens": ["adding", "verbose", "to", "bridge", "mode", "and", "adding", "usage"], "add_tokens": "var verbose = args . v ? true : args . verbose ; var s = bridge ( port , opts , function ( err , b ) { process . stdout . write ( 'bridge ' + 'online.' . green + '\\n' ) ; process . stdout . write ( 'ctrl+c' . orange + ' to exit\\n' ) ; if ( verbose ) { console . log ( 'verbose!' ) ; s . on ( 'data' , function ( data ) { process . stdout . write ( JSON . stringify ( data ) + \"\\n\" ) ; } ) ; } } module . exports . usage = \"bridge\\n\" + \"\\n \" + \"Usage:\\n\" + \" pinoccio bridge\\n\" + \" -v --verbose \\n\" + \" prints all events from troop to console.\\n\" + \" --api \\n\" + \" sets the api host name to bridge too. (for local command servers)\\n\" + \"\\n\" + \"use a scout's serial as a bridge instead of wifi!.\\n\" + \"\\n\"", "del_tokens": "bridge ( port , opts , function ( err , b ) { console . log ( 'bridge online.' ) ; console . log ( 'ctrl+c to exit' ) ; }", "commit_type": "add"}
{"commit_tokens": ["Fix", "Browsersync", "from", "opening", "a", "url", "with", "?preview_theme_id", "=", "null"], "add_tokens": "var queryString = '' ; if ( envObj . theme_id && ( envObj . theme_id === parseInt ( envObj . theme_id , 10 ) ) ) { queryString = '?preview_theme_id=' + envObj . theme_id ; } proxy : 'https://' + envObj . store + queryString", "del_tokens": "proxy : 'https://' + envObj . store + '?preview_theme_id=' + envObj . theme_id", "commit_type": "fix"}
{"commit_tokens": ["Use", "identity", "with", "u", ".", "if", "s", "false", "condition"], "add_tokens": "ifElse ( predicate , trueUpdates , x => x , object )", "del_tokens": "ifElse ( predicate , trueUpdates , { } , object )", "commit_type": "use"}
{"commit_tokens": ["Change", "bellow", "spelling", "to", "below", "in", "source", "files", "instead", "of", "dist", "files", "."], "add_tokens": "below : false // position the toolbar above or below the selected text // tell me if it's above or below the selection // used in the template to place the triangle above or below scope . position . below = true ; scope . position . below = false ;", "del_tokens": "bellow : false // position the toolbar above or bellow the selected text // tell me if it's above or bellow the selection // used in the template to place the triangle above or bellow scope . position . bellow = true ; scope . position . bellow = false ;", "commit_type": "change"}
{"commit_tokens": ["Implement", "bunyan", "-", "live", "-", "logger"], "add_tokens": "var bunyan = require ( \"bunyan\" ) ; var live = require ( \"bunyan-live-logger\" ) ; var g_log = null ; var logger = function ( n ) { if ( g_log ) return g_log . child ( { testcase : n } ) ; else return null ; } ; pin : \"\" , bunyan_live_logger : true if ( credentials && credentials . bunyan_live_logger ) { g_log = bunyan . createLogger ( { name : 'testcases - tests_real' , src : true , streams : [ { level : 'trace' , stream : live ( { ready_cb : function ( ) { done ( ) ; } } ) , type : \"raw\" } ] } ) ; } else { done ( ) ; }", "del_tokens": "pin : \"\" done ( ) ;", "commit_type": "implement"}
{"commit_tokens": ["Fix", "test", "for", "an", "ajax", "POST", "request"], "add_tokens": "it ( 'is should make a POST request' , ( done ) => { let successCallback = function ( data , status ) { expect ( success ) . to . have . been . called . once ; expect ( success ) . to . have . been . called . with ( 'success' ) ; expect ( data [ 0 ] ) . to . eql ( { id : 'MLA' , name : 'Argentina' } ) ; } ; expect ( xhr . status ) . to . equal ( 200 ) ; expect ( complete ) . to . have . been . called . with ( 'success' ) ; expect ( error ) . to . not . have . been . called ( ) ; let success = chai . spy ( successCallback ) ; dataType : 'json' ,", "del_tokens": "it . skip ( 'is should make a POST request' , ( done ) => { expect ( complete ) . to . have . been . called . with ( 'error' ) ; expect ( error ) . to . have . been . called . once ; expect ( success ) . to . not . have . been . called ( ) ; let success = chai . spy ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "success", "/", "failure", "CSS", "class", "to", "example", "rows", "on", "running", "specs"], "add_tokens": "matchingRow . addClass ( 'success' ) ; resultCell . text ( 'Passed' ) ; return ; matchingRow . addClass ( 'failure' ) ;", "del_tokens": "resultCell . text ( 'Passed' ) ; return ; matchingRow . addClass ( 'danger' ) ;", "commit_type": "add"}
{"commit_tokens": ["Remove", "unnecessary", "comma", "in", "Theme", "."], "add_tokens": "}", "del_tokens": "} ,", "commit_type": "remove"}
{"commit_tokens": ["Fixing", "bug", "to", "supporting", "@import"], "add_tokens": "define ( moduleName , req ( [ moduleName ] , function ( Widget ) {", "del_tokens": "define ( 'widget/parser!' + moduleName , req ( [ 'widget/parser!' + moduleName ] , function ( Widget ) {", "commit_type": "fix"}
{"commit_tokens": ["Move", "all", "file", "related", "methods", "to", "fs"], "add_tokens": "const { isDirectory , isDirectorySync , isFile , isFileSync , uniq , flattenDeep , pick , promisify , makeArray , without , chain } = require ( './util' ) ; const $private = new Private ( ) ;", "del_tokens": "const { uniq , flattenDeep , pick , promisify , makeArray , without , chain } = require ( './util' ) ; const $private = new Private ( ) ; const fs = require ( 'fs' ) ; const { isDirectory , isDirectorySync , isFile , isFileSync } = require ( './fs' ) ;", "commit_type": "move"}
{"commit_tokens": ["changed", "to", "dropping", "code", "at", "minimize"], "add_tokens": "var parser , formatter , validator , util = ( typeof module !== 'undefined' ) ? require ( 'util' ) : ( function ( ) { ( typeof module !== 'undefined' ) && ( stream = ( function ( ) { if ( typeof module !== 'undefined' ) { if ( process . env . NODE_ENV === 'test' ) { if ( typeof Mocha !== 'undefined' ) {", "del_tokens": "var isNode , isTest , parser , formatter , validator , util = ( isNode ) ? require ( 'util' ) : ( function ( ) { ( isNode ) && ( stream = ( function ( ) { isNode = ( typeof module !== 'undefined' ) ; isTest = ( typeof Mocha !== 'undefined' ) || ( isNode && process . env . NODE_ENV === 'test' ) ; if ( isNode ) { if ( isTest ) { if ( isTest ) {", "commit_type": "change"}
{"commit_tokens": ["added", "package", "information", "for", "npm"], "add_tokens": "// Version 0.2.2", "del_tokens": "// Version 0.2", "commit_type": "add"}
{"commit_tokens": ["fixed", "the", "broken", "codacy", "check"], "add_tokens": "should ( addModeratorResult . success ) . be . ok ( ) ;", "del_tokens": "addModeratorResult . success . should . equal ( true ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "createReport", "and", "accessibilityErrorMessage", "methods", "to", "axs", ".", "Audit"], "add_tokens": "/ ** * Returns an object containing the same keys and values as the given * JSON - compatible object . ( Simply ignores any function values . ) * @ param { Object } obj * @ return { Object } * / axs . utils . namedValues = function ( obj ) { var values = { } ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) && typeof obj [ key ] != 'function' ) values [ key ] = obj [ key ] ; } return values } ;", "del_tokens": "console . log ( 'isValidTokenValue' , propertyName , value , propertyDetails , possibleValues ) ; console . log ( 'isValidBoolean' , value ) ; console . log ( 'isValidBoolean' , value , parsedValue ) ; console . log ( 'axs.utils.values' , obj ) ; console . log ( 'values' , values , obj ) ;", "commit_type": "add"}
{"commit_tokens": ["Adds", "tests", "for", "panel", "structure"], "add_tokens": "exports . lintPanelBodyWithoutPanel = function ( $ ) { var badPanelBody = $ ( '.panel-body' ) . parent ( ':not(.panel, .panel-collapse)' ) ; if ( badPanelBody . length ) { return \"`.panel-body` must have a `.panel` or `.panel-collapse` parent\" ; } } ; exports . lintPanelHeadingWithoutPanel = function ( $ ) { var badPanelHeading = $ ( '.panel-heading' ) . parent ( ':not(.panel)' ) ; if ( badPanelHeading . length ) { return \"`.panel-heading` must have a `.panel` parent\" ; } } ; exports . lintPanelFooterWithoutPanel = function ( $ ) { var badPanelFooter = $ ( '.panel-footer' ) . parent ( ':not(.panel)' ) ; if ( badPanelFooter . length ) { return \"`.panel-footer` must have a `.panel` parent\" ; } } ; exports . lintPanelTitleWithoutPanelHeading = function ( $ ) { var badPanelTitle = $ ( '.panel-title' ) . parent ( ':not(.panel-heading)' ) ; if ( badPanelTitle . length ) { return \"`.panel-title` must have a `.panel-heading` parent\" ; } } ; errs . push ( this . lintPanelBodyWithoutPanel ( $ ) ) ; errs . push ( this . lintPanelHeadingWithoutPanel ( $ ) ) ; errs . push ( this . lintPanelTitleWithoutPanelHeading ( $ ) ) ; errs . push ( this . lintPanelFooterWithoutPanel ( $ ) ) ; } , { \"cheerio\" : 1 } ] } , { } , [ 2 ] ) ;", "del_tokens": "} , { \"cheerio\" : 1 } ] } , { } , [ 2 ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "init", "when", "using", "a", "non", "-", "canonical", "version", "name"], "add_tokens": "return forest . expandVersion ( version ) . then ( ( fullVersion ) => { return forest . runIn ( fullVersion , [ 'package' , 'install' , 'elm-lang/core' ] ) . then ( ( code ) => process . exit ( code ) ) ; } ) ;", "del_tokens": "let doInit = function ( version ) { return forest . runIn ( version , [ 'package' , 'install' , 'elm-lang/core' ] ) . then ( ( code ) => process . exit ( code ) ) ; } ; if ( version === 'latest' ) { forest . getElmVersions ( ) . then ( ( versions ) => { let latest = versions . shift ( ) ; return forest . ensureInstalled ( latest ) ; } ) . then ( ( version ) => { return doInit ( version ) ; } ) . catch ( ( err ) => { if ( err . name && err . message && err . code ) { console . error ( err . message ) ; process . exit ( err . code ) ; } else { process . exit ( 1 ) ; } } ) ; } else { doInit ( version ) ; }", "commit_type": "fix"}
{"commit_tokens": ["change", "behavior", "of", "binaryAsStream", "-", "change", "source", "object", "and", "always", "return", "as", "streams"], "add_tokens": "var streamifier = require ( 'streamifier' ) ; if ( this . options . binaryAsStream ) { for ( key in binary ) { if ( binary . hasOwnProperty ( key ) ) { val . binary [ key ] = streamifier . createReadStream ( binary [ key ] , { encoding : null } ) ; } } } else { val . binary = binary ; }", "del_tokens": "val . binary = binary ;", "commit_type": "change"}
{"commit_tokens": ["Added", "test", "and", "working", "code", "to", "the", "sym", "encrypted", "integrity", "protected", "packet", "."], "add_tokens": "sym_encrypted_integrity_protected : 18 ,", "del_tokens": "sym_encrypted_and_integrity_protected : 18 ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "reference", "to", "undefined", "variable", "."], "add_tokens": "if ( authorization . bodyContentDigest && shouldIncludeContentDigest ( contentType ) ) {", "del_tokens": "if ( bodyContentDigest && shouldIncludeContentDigest ( contentType ) ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "regex", "edge", "case", "matcher", "for", "es6", "components"], "add_tokens": "module . exports = function ( name , component ) { return component . setState ( state , callback ) ; }", "del_tokens": "const reactInterceptor = function ( setStateFn , name ) { return setStateFn . call ( setStateFn , state , callback ) ; } ; module . exports = reactInterceptor ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "for", "null", "model", "relations"], "add_tokens": "if ( self . has ( key ) ) { results . push ( self . get ( key ) ) ; }", "del_tokens": "results . push ( self . get ( key ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "clickerGremlin", "click", "event", "not", "working", "for", "drag"], "add_tokens": "evt . initMouseEvent ( clickType , true , true , window , 0 , 0 , 0 , posX , posY , false , false , false , false , 0 , null ) ;", "del_tokens": "evt . initMouseEvent ( clickType , true , true , window , 0 , 0 , 0 , 0 , 0 , false , false , false , false , 0 , null ) ;", "commit_type": "fix"}
{"commit_tokens": ["Removed", "ability", "to", "manually", "pass", "in", "routes", "via", "config"], "add_tokens": "const routes = generateRoutes ( skyPagesConfig ) ;", "del_tokens": "const routes = skyPagesConfig . routes || generateRoutes ( skyPagesConfig ) ;", "commit_type": "remove"}
{"commit_tokens": ["Fixed", "IE", "problem", "with", "es6", "String", ".", "prototyp", ".", "startsWith"], "add_tokens": "if ( i . indexOf ( \"responsiveMarks$$\" ) === 0 ) { if ( item . indexOf ( \"hidden\" ) === 0 ) { //hidden-..", "del_tokens": "if ( i . startsWith ( \"responsiveMarks$$\" ) ) { if ( item . startsWith ( \"hidden\" ) ) { //hidden-..", "commit_type": "fix"}
{"commit_tokens": ["add", "server", "methods", "to", "core", ".", "socket"], "add_tokens": "'destroy' : { type : \"method\" , value : [ \"number\" ] } , 'listen' : { type : \"method\" , value : [ \"number\" , \"string\" , \"number\" ] } , 'accept' : { type : \"method\" , value : [ \"number\" ] } , 'getInfo' : { type : \"method\" , value : [ \"number\" ] }", "del_tokens": "'destroy' : { type : \"method\" , value : [ \"number\" ] }", "commit_type": "add"}
{"commit_tokens": ["Update", "to", "avoid", "403", "error", "when", "requesting", "container", "metadata", "and", "using", "ACL"], "add_tokens": "var aContainers = [ ] ; aContainers . push ( container ) ; } , function ( err ) { if ( ! err ) { o1 . _log ( 'Got ' + aContainers . count + ' containers' ) ; o1 . aContainers = aContainers ; } cb ( err ) ; } ) ;", "del_tokens": "o1 . aContainers = [ ] ; o1 . aContainers . push ( container ) ; } , cb ) ;", "commit_type": "update"}
{"commit_tokens": ["fixes", "subView", "view", "method", "assignment"], "add_tokens": "function viewMethod ( name , subView ) { var options = _ . extend ( { } , this . options , LayoutManager . prototype . options ) ; subView . view = viewMethod ; subView . view = viewMethod ; view : viewMethod ,", "del_tokens": "function view ( name , subView ) { var options = this . options ; subView . view = view ; subView . view = view ; view : view ,", "commit_type": "fix"}
{"commit_tokens": ["Fix", "so", "last", "commit", "actually", "works", "(", "a", "small", "cleanup"], "add_tokens": "// Show file list in UI synchronously ProjectManager . _renderTree ( treeJSONData ) ;", "del_tokens": "// Show file list in UI ProjectManager . _renderTree ( treeJSONData ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "for", "JHome", "single", "page", "spreads", "not", "working", "correctly"], "add_tokens": "if ( options . hasSpreads ) { index . activeRight = els . pagesActive . eq ( 1 ) . index ( ) ; index . activeLeft = index . activeRight - 1 ; } else { // Single page spreads ( JHome ) index . activeLeft = els . pagesActive . eq ( 0 ) . index ( ) ; // Note about fix: the double spread code above caused code to wrap to bottom of array . This is the fix for double spreads. index . activeRight = index . activeLeft + 1 ; } if ( ! options . hasSpreads ) { index . target = index . target - 1 ; index . targetSibling = index . targetSibling - 1 ; } // JHome - double spreads - Fix for 'is-active' pages not being correctly offset from the stars if ( ! options . hasSpreads && direction == 'forwards' && index . target == 2 ) { index . target = 1 ; index . targetSibling = 2 ; }", "del_tokens": "index . activeRight = els . pagesActive . eq ( 1 ) . index ( ) ; index . activeLeft = index . activeRight - 1 ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "Window", ".", "prototype", "since", "not", "using", "Window", "polyfill", "rework", "getPropertyValue", "to", "check", "if", "regex", "match", "is", "a", "string", "without", "array", "accessor"], "add_tokens": "getPropertyValue : function ( property ) { var lookup = property . replace ( / -([a-z]) / g , function ( match ) { match = match . charAt ? match . split ( '' ) : match ; return match [ 1 ] . toUpperCase ( ) ; } ) ; var ret = this [ lookup ] ; return ret ; window . getComputedStyle = function ( element ) {", "del_tokens": "getPropertyValue : function ( property ) { return this [ property . replace ( / -\\w / g , function ( match ) { return match [ 1 ] . toUpperCase ( ) ; } ) ] ; window . getComputedStyle = Window . prototype . getComputedStyle = function ( element ) {", "commit_type": "remove"}
{"commit_tokens": ["Use", "fs", "provided", "in", "options", "for", "all", "file", "operations"], "add_tokens": "var keys = utils . walk ( bucketPath , fs ) ; fs . mkdirpSync ( dirName ) ; fs . mkdirpSync ( destKeyPath ) ;", "del_tokens": "// fs = require('fs-extra'), mkdirp = require ( 'mkdirp' ) , if ( ! fs ) { fs = require ( 'fs-extra' ) ; } var keys = utils . walk ( bucketPath ) ; mkdirp . sync ( dirName ) ; mkdirp . sync ( destKeyPath ) ;", "commit_type": "use"}
{"commit_tokens": ["change", "2nd", "arg", "of", "onChange", "method", "."], "add_tokens": "* @ param { Boolean } listenToChildren ? Registers the callback with sub property changes as well . Property . prototype . onChange = function ( callback , listenToChildren ) { if ( listenToChildren ) {", "del_tokens": "* @ param { Object } options ? May contain the following : * listenToChildren { Boolean } - registers the callback with sub property changes as well . Property . prototype . onChange = function ( callback , options ) { if ( options && options . listenToChildren ) {", "commit_type": "change"}
{"commit_tokens": ["make", "prompt", "to", "offer", "user", "input", "as", "default"], "add_tokens": "this . composeWith ( 'jhipster:modules' , this . defaultTableName = this . options . entityConfig . entityClass ; let desiredTableName = this . defaultTableName ; replacement : prefix . replace ( '\\\\' , '' ) + desiredTableName + suffix . replace ( '\\\\' , '' ) , jhipsterFunc . updateEntityConfig ( this . options . entityConfig . filename , 'entityTableName' , desiredTableName ) ;", "del_tokens": "this . composeWith ( 'jhipster:modules' , let wantedValue = this . options . entityConfig . entityClass ; replacement : prefix . replace ( '\\\\' , '' ) + wantedValue + suffix . replace ( '\\\\' , '' ) , jhipsterFunc . updateEntityConfig ( this . options . entityConfig . filename , 'entityTableName' , wantedValue ) ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "some", "edge", "case", "on", "invalid", "availabletimes"], "add_tokens": "var time = this . _timeDimension . getAvailableTimes ( ) [ e . target . getValue ( ) ] ; if ( time ) { var date = new Date ( time ) ; this . _displayDate . innerHTML = this . _getDisplayDateFormat ( date ) ; }", "del_tokens": "var date = new Date ( this . _timeDimension . getAvailableTimes ( ) [ e . target . getValue ( ) ] ) ; this . _displayDate . innerHTML = this . _getDisplayDateFormat ( date ) ;", "commit_type": "fix"}
{"commit_tokens": ["Moved", "from", "binary", "string", "export", "to", "readable", "stream"], "add_tokens": "return canvas . stream ( format ) ;", "del_tokens": "var concat = require ( 'concat-stream' ) ; var retStream = canvas . stream ( format ) ; retStream . on ( 'error' , cb ) ; retStream . pipe ( concat ( function handleBuff ( buff ) { cb ( null , buff . toString ( 'binary' ) ) ; } ) ) ;", "commit_type": "move"}
{"commit_tokens": ["add", "auto", "updater", "with", "support", "for", "timeout", "exit", "handler"], "add_tokens": "const e = Error ( ` ${ path } ` ) ; e . userError = true ; throw e ; const e = Error ( 'Missing `start` script in `package.json`. ' + e . userError = true ; throw e ;", "del_tokens": "throw new Error ( ` ${ path } ` ) ; throw new Error ( 'Missing `start` script in `package.json`. ' +", "commit_type": "add"}
{"commit_tokens": ["Move", "stream", "write", "()", "to", "module", "."], "add_tokens": "//var tty = require('tty'); //var WritableStream = require('stream').Writable; var stream = require ( './lib/stream' ) ; options . proxy = proxy ; options . mode = mode ; options . isatty = isatty ; stream . apply ( null , arguments ) ;", "del_tokens": "var tty = require ( 'tty' ) ; var WritableStream = require ( 'stream' ) . Writable ; //var always = parse.always; //var never = parse.never; var stream = options . stream ; if ( stream instanceof WritableStream ) { if ( stream . fd == null ) { throw new Error ( 'Cannot write to stream, file descriptor not open' ) ; } var args = [ { scope : util , method : util . format , tty : isatty ( tty . isatty ( stream . fd ) , mode ) } ] ; args = args . concat ( [ ] . slice . call ( arguments , 1 ) ) ; var value = proxy . apply ( null , args ) ; stream . write ( value , function ( ) { if ( typeof options . callback == 'function' ) options . callback ( value ) ; } ) ; } else { throw new Error ( 'Stream option must be writable' ) ; }", "commit_type": "move"}
{"commit_tokens": ["add", "a", "newline", "at", "the", "end", "of", ".", "babelrc", ".", "js"], "add_tokens": "module . exports = { presets } ;", "del_tokens": "module . exports = { presets } ;", "commit_type": "add"}
{"commit_tokens": ["Change", "public", "API", "function", "from", "locationPickerSuggestions", "to", "openregisterPickerEngine"], "add_tokens": "function openregisterPickerEngine ( pathToGraph , callback ) { export default openregisterPickerEngine window . openregisterPickerEngine = openregisterPickerEngine", "del_tokens": "function locationPickerSuggestions ( pathToGraph , callback ) { export default locationPickerSuggestions window . locationPickerSuggestions = locationPickerSuggestions", "commit_type": "change"}
{"commit_tokens": ["fixed", "missing", "image", "in", "readme"], "add_tokens": "* versionUpdater v3 .11 .1", "del_tokens": "* versionUpdater v3 .11 .0", "commit_type": "fix"}
{"commit_tokens": ["update", "parser", "error", "message", "to", "show", "line", "and", "col"], "add_tokens": "throw new Error ( 'Expecting type ' + String ( type ) + ', but found ' + String ( currentToken . type ) + ' instead at line ' + currentToken . line + ' col ' + currentToken . col + '.' ) ; throw new Error ( 'Expecting type ' + String ( type ) + ', but found ' + String ( currentToken . type ) + ' instead at line ' + currentToken . line + ' col ' + currentToken . col + '.' ) ; throw new Error ( 'Expecting type ' + String ( type ) + ' of \"' + content + '\", but found \"' + String ( currentToken . value ) + '\" instead at line ' + currentToken . line + ' col ' + currentToken . col + '.' ) ;", "del_tokens": "throw new Error ( 'Expecting type ' + String ( type ) + ', but found ' + String ( currentToken . type ) + ' instead.' ) ; throw new Error ( 'Expecting type ' + String ( type ) + ', but found ' + String ( currentToken . type ) + ' instead.' ) ; throw new Error ( 'Expecting type ' + String ( type ) + ' of \"' + content + '\", but found \"' + String ( currentToken . value ) + '\" instead.' ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "gitignore", "use", "moment", "require", "that", "rollup", "can", "handle"], "add_tokens": "} //, // bs_osx_firefox_latest: { // base: 'BrowserStack', // browser: 'firefox', // os: 'OS X', // os_version: 'Sierra' // }", "del_tokens": "} , bs_osx_firefox_latest : { base : 'BrowserStack' , browser : 'firefox' , os : 'OS X' , os_version : 'Sierra' }", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "restart", "options", "."], "add_tokens": "Container . prototype . restart = function ( opts , callback ) { if ( ! callback && typeof ( opts ) === 'function' ) { callback = opts ; opts = null ; } var optsf = { } , options : opts this . modem . dial ( optsf , function ( err , data ) {", "del_tokens": "Container . prototype . restart = function ( callback ) { var opts = { } this . modem . dial ( opts , function ( err , data ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "map", "and", "added", "new", "html2canvas", ".", "js"], "add_tokens": "FIREBASE_KEY : 'omnipointment'", "del_tokens": "FIREBASE_KEY : 'prometheusjs'", "commit_type": "fix"}
{"commit_tokens": ["Add", "target", "type", "html", ".", "twig"], "add_tokens": "var TARGET_TYPES = [ 'html' , 'html.twig' , 'jade' , 'pug' , 'slm' , 'slim' , 'jsx' , 'haml' , 'less' , 'sass' , 'scss' ] ;", "del_tokens": "var TARGET_TYPES = [ 'html' , 'jade' , 'pug' , 'slm' , 'slim' , 'jsx' , 'haml' , 'less' , 'sass' , 'scss' ] ;", "commit_type": "add"}
{"commit_tokens": ["Added", "demo", "and", "create", "command"], "add_tokens": "return require ( './start' ) . default ( ) return require ( './build' ) . default ( ) } if ( cmd === 'create' ) { return require ( './create' ) . default ( process . argv [ 3 ] )", "del_tokens": "import start from './start' import build from './build' return start ( ) return build ( )", "commit_type": "add"}
{"commit_tokens": ["fix", "error", "passing", "in", "fetchModule", "add", "tests"], "add_tokens": "var testDir = path . normalize ( __dirname + \"/fs-data/\" ) ;", "del_tokens": "var testDir = path . normalize ( __dirname + \"/data/\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["changed", "client", "connection", "event", "emitted", "on", "app", "from", "connection", "myelements", ":", "connection"], "add_tokens": "app . emit ( \"myelements:connection\" , elementsEventHandler ) ; debug ( \"client connection\" ) ;", "del_tokens": "app . emit ( \"connection\" , elementsEventHandler ) ; debug ( \"myelements client connection\" ) ;", "commit_type": "change"}
{"commit_tokens": ["adds", "support", "for", "list", "of", "architectures", "in", "library", "v2", "metadata"], "add_tokens": "'sentence=Fixes the world\\n' + 'architectures=avr,particle-photon,spark-core\\n' + 'dot.notation=supported' ; expect ( desc . architectures ) . to . be . eql ( [ 'avr' , 'particle-photon' , 'spark-core' ] ) ; //expect(desc['dot']).to.equal({notation:'supported'}); expect ( desc [ 'dot.notation' ] ) . to . equal ( 'supported' ) ; name : 'abcd' , version : '1.2.3' , license : 'dummy' , author : 'Mr Big' , 'description' : 'Fixes the world' , architectures : [ 'particle-photon' , 'particle-p1' ] 'sentence=Fixes the world\\n' + 'architectures=particle-photon,particle-p1\\n' ) ;", "del_tokens": "'sentence=Fixes the world\\n' ; name : 'abcd' , version : '1.2.3' , license : 'dummy' , author : 'Mr Big' , 'description' : 'Fixes the world' 'sentence=Fixes the world\\n' ) ;", "commit_type": "add"}
{"commit_tokens": ["added", "check", "for", "null", "value"], "add_tokens": "var opts = url . parse ( req . url . replace ( rewrite . regex , rewrite . replace ) ) ; var query = ( opts . search != null ) ? opts . search : '' ; opts . path = opts . pathname + '/' + query ;", "del_tokens": "var opts = url . parse ( req . url . replace ( rewrite . regex , rewrite . replace ) ) ; opts . path = opts . pathname + '/' + opts . search ;", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "raw_asset", "helper", "to", "the", "middleware", "that", "returns", "the", "asset", "URL"], "add_tokens": "/ ** * Create a script tag ( or bunch of script tags for a manifest when serve is true ) * for a JavaScript asset * / / ** * Create a link tag ( or bunch of link tags for a manifest when serve is true ) * for a CSS asset * / } , / ** * Return the raw URL for an asset . * / raw_asset : function ( logicalPath ) { return self . prefix + '/' + ( self . assetMap [ logicalPath ] || logicalPath ) ; / ** * Get the assets required for the specified logical path . This will separate any * manifests into their individual files ( if not running with an asset map ) * / } ;", "del_tokens": "} ;", "commit_type": "add"}
{"commit_tokens": ["move", "generators", "out", "of", "main", "file", ";", "prepare", "for", "algebraic", "types"], "add_tokens": "var Lib = require ( \"./../../ramda\" ) ; var lazylist = require ( '../lazylist' ) ; var generator = Lib . generator , takeWhile = Lib . takeWhile , identity = Lib . identity ;", "del_tokens": "var Lib = require ( \"./../ramda\" ) ; var generator = Lib . generator , takeWhile = Lib . takeWhile , identity = ramda . identity ;", "commit_type": "move"}
{"commit_tokens": ["Add", "some", "documentation", "for", "configuration", "options"], "add_tokens": "// Minimum separation between adjacent nodes in the same rank // Minimum separation between edges in the same rank // Minimum separation between ranks // Number of passes to take during the ordering phase to optimize layout // Text label to display for the node // Minimum width for the node. The node will automatically be expanded if // it needs more space to enclose its label. // Minimum height for the node. The node will automatically be expanded if // it needs more space to enclose its label. // The amount of padding to add to the label when sizing the node // The amount of padding to add to the label when sizing the node // The width of the stroke used to build the shape for the node defaultFloat ( attrs , \"strokeWidth\" , 1.5 ) ; // The color to use for the stroke of the shape // The color used to fill the interior of the node's shape // The color to use for the text in the shape defaultVal ( attrs , \"fontColor\" , \"#333\" ) ; // The font to use for the node's label // The font size to use for the node's label // The width to use for the edge's line // The color to use for the edge's line defaultStr ( attrs , \"color\" , \"#333\" ) ;", "del_tokens": "defaultFloat ( attrs , \"strokeWidth\" , 1.5 ) ; defaultInt ( attrs , \"weight\" , 1 ) ; defaultVal ( attrs , \"fontColor\" , \"#333\" ) ; defaultStr ( attrs , \"color\" , \"#333\" ) ;", "commit_type": "add"}
{"commit_tokens": ["removed", "zoom", "handler", "on", "page"], "add_tokens": "function isLandscapeOrientation ( ) { return ( Math . abs ( window . orientation ) == 90 ) || window . orientation == 'landscape' ; var scaleDelta = 1 ; //TODO: base the delta, min / max value on model natural size vs window size fontSize : MakerJsPlayground . svgFontSize + 'px' , strokeWidth : MakerJsPlayground . svgStrokeWidth + 'px' , path . style . strokeWidth = ( 2 * MakerJsPlayground . svgStrokeWidth ) + 'px' ;", "del_tokens": "function getZoom ( ) { var landscape = ( Math . abs ( window . orientation ) == 90 ) || window . orientation == 'landscape' ; var zoom = ( landscape ? window . innerWidth : window . innerHeight ) / document . body . clientWidth ; MakerJsPlayground . windowZoom = Math . max ( 0.15 , Math . min ( zoom , 1 ) ) ; var scaleDelta = 1 ; MakerJsPlayground . windowZoom = 1 ; view . addEventListener ( 'touchend' , function ( ) { document . body . classList . add ( 'collapse-rendering-options' ) ; render ( ) ; } ) ; getZoom ( ) ; fontSize : ( MakerJsPlayground . windowZoom * MakerJsPlayground . svgFontSize ) + 'px' , strokeWidth : ( MakerJsPlayground . windowZoom * MakerJsPlayground . svgStrokeWidth ) + 'px' , path . style . strokeWidth = ( MakerJsPlayground . windowZoom * 2 * MakerJsPlayground . svgStrokeWidth ) + 'px' ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "more", "test", "cases", ".", "Can", "use", "marker", "to", "filter"], "add_tokens": "/ ** * The following methods correspond the S3 api . For more information visit : * http : //docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html * / marker : req . query [ 'marker' ] || null ,", "del_tokens": "marker : req . query . marker || null ,", "commit_type": "add"}
{"commit_tokens": ["Update", "component", "scaffold", "with", "better", "sink", "template", "defaults"], "add_tokens": "const sinkPageContent = ` ` ;", "del_tokens": "const sinkPageContent = ` ` ;", "commit_type": "update"}
{"commit_tokens": ["added", "support", "to", "clear", "the", "selected", "dates", "and", "allows", "to", "set", "start", "/", "end", "date", "as", "empty"], "add_tokens": "var clearLabel = \"Clear\" ; } , setClearLabel : function ( param ) { clearLabel = param ; } , setRangeDefaultList : function ( array ) { clearLabel : clearLabel ,", "del_tokens": "} , setRangeDefaultList : function ( array ) {", "commit_type": "add"}
{"commit_tokens": ["Adds", "more", "specific", "tests", "for", "Promise", "-", "returning", "methods"], "add_tokens": "return expect ( platform . discoverTagManagers ( ) ) . to . eventually . satisfy ( ( mgrs ) => { return mgrs . reduce ( ( state , mgr ) => { return state && ( mgr instanceof WirelessTagManager ) ; } , mgrs . length > 0 ) ; } ) ;", "del_tokens": "return expect ( platform . discoverTagManagers ( ) ) . to . be . fulfilled ;", "commit_type": "add"}
{"commit_tokens": ["Make", "LayerDynamo", "assume", "values", "are", "JSON", "by", "default"], "add_tokens": "parseValue ( val ) { if ( this . opt . json === false ) { return val ; } return JSON . parse ( val ) ; } . then ( ( response ) => { if ( response && response . Item ) { const { Item } = response ; this . load ( { key : Item . key . S , v : this . parseValue ( Item . v . S ) , t : Number ( Item . t . N ) , i : Item . i . BOOL , } ) ; S : this . opt . json === false ? String ( v ) : JSON . stringify ( v ) ,", "del_tokens": ". then ( ( { Item } ) => { if ( ! Item ) { emitError ( \"Malformed response from dynamoDB for key: \" + this . key ) ; return this . load ( { key : Item . key . S , v : Item . v . S , t : Number ( Item . t . N ) , i : Item . i . BOOL , } ) ; S : String ( v ) ,", "commit_type": "make"}
{"commit_tokens": ["Allow", "env", "-", "specific", "config"], "add_tokens": "var config = this . app . project . config ( this . app . env ) [ 'ember-cli-mirage' ] ; var modulePrefix = this . app . project . config ( this . app . env ) [ 'modulePrefix' ] ;", "del_tokens": "var config = this . app . project . config ( ) [ 'ember-cli-mirage' ] ; var modulePrefix = this . app . project . config ( ) [ 'modulePrefix' ] ;", "commit_type": "allow"}
{"commit_tokens": ["Fix", "week", "subDomain", "from", "a", "year", "domain"], "add_tokens": "/ *! cal-heatmap v1.1.1 (Thu Feb 28 2013 23:26:01) return parent . getWeekNumber ( new Date ( date . getFullYear ( ) , 11 , 31 ) ) ; return true ;", "del_tokens": "/ *! cal-heatmap v1.1.2 (Thu Feb 28 2013 18:27:02) return parent . getDayOfYear ( new Date ( date . getFullYear ( ) , 11 , 31 ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Change", "syntax", "of", "typeof", "and", "check", "against", "string", "."], "add_tokens": "if ( 'undefined' === typeof min || 'undefined' === typeof max )", "del_tokens": "if ( typeof ( min ) === undefined || typeof ( max ) === undefined )", "commit_type": "change"}
{"commit_tokens": ["fix", "statifier", ";", "back", "to", "adding", "/", "main", ".", "js", "to", "primary", "clientside", "module"], "add_tokens": "app . get ( '/lib/:appId/main.js' , function ( req , appId ) {", "del_tokens": "app . get ( '/lib/:appId/' , function ( req , appId ) {", "commit_type": "fix"}
{"commit_tokens": ["Adding", "some", "testing", "for", "createFromText", "and", "the", "reading", "the", "passthrough", "res", ".", "sentry", "object", "."], "add_tokens": "} , client = new raven . Client ( options ) ; client . createFromText ( 'Testing!!!' , function ( result ) { } ) ; raven . patchGlobal ( options ) ; function handle_request ( req , res ) { throw new Error ( 'broke' ) ; } connect ( function connect ( req , res ) { handle_request ( req , res ) ; } , raven_middleware ( client ) , function ( err , req , res , next ) { res . statusCode = 500 ; res . end ( JSON . stringify ( res . sentry ) ) ; } ) . listen ( 3000 ) ; //ffdasfsd.fdasfd;", "del_tokens": "} ; raven . patch_global ( options ) ; connect ( function ( req , res ) { idontexist [ 'what' ] ; } , raven_middleware ( options ) ) . listen ( 3000 ) ; ffdasfsd . fdasfd ;", "commit_type": "add"}
{"commit_tokens": ["update", "all", "interfaces", "to", "not", "munge"], "add_tokens": "'show' : { type : \"method\" , value : [ \"object\" ] } , 'close' : { type : \"method\" , value : [ ] } , 'postMessage' : { type : \"method\" , value : [ \"object\" ] } , 'message' : { type : \"event\" , value : [ \"object\" ] } , 'onClose' : { type : \"event\" , value : [ ] } 'set' : { type : \"method\" , value : [ \"string\" , \"string\" ] } , 'get' : { type : \"method\" , value : [ \"string\" ] } , 'change' : { type : \"event\" , value : [ \"string\" ] }", "del_tokens": "show : { type : \"method\" , value : [ \"object\" ] } , close : { type : \"method\" , value : [ ] } , postMessage : { type : \"method\" , value : [ \"object\" ] } , message : { type : \"event\" , value : [ \"object\" ] } , onClose : { type : \"event\" , value : [ ] } set : { type : \"method\" , value : [ \"string\" , \"string\" ] } , get : { type : \"method\" , value : [ \"string\" ] } , change : { type : \"event\" , value : [ \"string\" ] }", "commit_type": "update"}
{"commit_tokens": ["Added", "Connect", "-", "style", "middleware", "for", "routing", "slippy", "-", "map", ":", "/", "zoom", "/", "x", "/", "y", ".", "png", "images", "and", "utfgrids", ";", "also", "for", "tile", ".", "json", "too"], "add_tokens": "routes = require ( __dirname + '/lib/routes' ) , projector : projector , / ** * Routing Middleware * / route : routes", "del_tokens": "projector : projector", "commit_type": "add"}
{"commit_tokens": ["Using", "getElementType", "instead", "of", "relying", "on", ".", "type", "property", "of", "es", ".", "DocumentModeNode", "objects"], "add_tokens": "return ( ( ( node1 && node2 ) && ( node1 . getElementType ( ) === node2 . getElementType ( ) ) ) && ( node1 . getParent ( ) === node2 . getParent ( ) ) ) ;", "del_tokens": "return ( ( ( node1 && node2 ) && ( node1 . type !== undefined && node2 . type !== undefined ) && ( node1 . type === node2 . type ) ) && ( node1 . getParent ( ) === node2 . getParent ( ) ) ) ;", "commit_type": "use"}
{"commit_tokens": ["adding", "correct", "public", "key", "for", "sending", "sms"], "add_tokens": "Version : OpenPGP . js v3 .1 .0 xjMEW87lXhYJKwYBBAHaRw8BAQdAlIyAn31pcSBfq8JL + OZhxSJqNpce5kMR RT / Em2MvjTLNLGVxaCBLZXlIdWIgU01TIDxlcWguc21zQHBsYXRmb3JtLmtl eWh1Yi5hcHA + wncEEBYKACkFAlvO5V4GCwkHCAMCCRCfbznlpPf4PAQVCAoC AxYCAQIZAQIbAwIeAQAALuEBAOUe2KkUZA8ORr2i8AWOvmD3YYaZNlL2SNKS hDemF6tsAQDNBuQ9kmtK / c617kkqRDJu9PUsVvKUdf9SFqH6v + p / BM44BFvO 5 V4SCisGAQQBl1UBBQEBB0Dz1rTzNxVIZkybI8Kuc5 + X9JZebkY0iSjA2D3N cf7PSQMBCAfCYQQYFggAEwUCW87lXgkQn2855aT3 + DwCGwwAAHZSAP920Slk V4q8Z3ZY + trryvESUBpSqoWMhKJlUlhP4pvp4wEAgmTTx5Dl5K4YRvEMeh5O DZazk + YohUxifYrpNHuVjgU = = Qpzm", "del_tokens": "Version : OpenPGP . js v3 .0 .12 xjMEW1GeVRYJKwYBBAHaRw8BAQdAQv33J / 0 En2GVY2ug5Chtt3Gy / l7x + YDS lHmagHN2iqHNEUVRSCA8ZXFoQGJjei5hcHA + wncEEBYKACkFAltRnlUGCwkH CAMCCRBkr / 3 Wn8VKaQQVCAoCAxYCAQIZAQIbAwIeAQAASV4BAIiKu2nBrUxn b9jGhNNTjup0wCcBCAGNqnAokEVk6Kl6AP4gSLRfYTxh7BH + nsqeVT3lwyyQ n520BbEaXGQ0FFJBCM44BFtRnlUSCisGAQQBl1UBBQEBB0Bwbx8jPQbTMayu W01ssxLS3VyiYiJW16m9c7ubg4p + HwMBCAfCYQQYFggAEwUCW1GeVQkQZK / 9 1 p / FSmkCGwwAAH0cAQCQdWgExzXATzF / LCwqb54NLKPL2vrFQY0V / ryyi6mP fQEA / HmvD8QGC18EuOAmk3UXaWyZMnFT3Fs08dcjqKr3uAg = = NzpF", "commit_type": "add"}
{"commit_tokens": ["Remove", "a", "stray", "console", ".", "log"], "add_tokens": "code . push ( \"if(visited[u_ptr]) { break j\" + i + \"_loop; }\" )", "del_tokens": "code . push ( \"if(visited[u_ptr]) { console.log('here1'); break j\" + i + \"_loop; }\" )", "commit_type": "remove"}
{"commit_tokens": ["Fix", "arguments", "length", "with", "Yuilop", ".", "emit"], "add_tokens": "Yuilop . emit = function ( ) { var args = Array . prototype . slice . call ( arguments ) args . shift ( 'emit' ) ; this . eventEmitter . emit . apply ( this . eventEmitter , args ) ; var emitter = this . emitters [ arguments [ 0 ] ] ; args . unshift ( ) ; return emitter . apply ( this , args ) ;", "del_tokens": "Yuilop . emit = function ( name , data , callback ) { this . eventEmitter . emit ( 'emit' , name , data ) ; var emitter = this . emitters [ name ] ; return emitter . call ( this , data , callback ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "click", "to", "dial", "and", "auto", "log", "features", "into", "SettingsPanel"], "add_tokens": "import SettingsPage from '../../../src/containers/SettingsPage' ; version = { phone . version }", "del_tokens": "import SettingsPage from '../SettingsPage' ; phone = { phone }", "commit_type": "add"}
{"commit_tokens": ["Fixed", "lots", "of", "bugs", "in", "the", "serializers", "Wikitext", "and", "HTML", "look", "good"], "add_tokens": "// Make a new verion of the annotation object and push it to the stack var obj = { 'type' : annotation . type , 'range' : { 'start' : offset } } ; if ( annotation . data ) { obj . data = es . copyObject ( annotation . data ) ; } stack . push ( obj ) ; // We would just compare hashes, but the stack doesn't contain any", "del_tokens": "stack . push ( es . extendObject ( true , { } , annotation , { 'range' : { 'start' : offset } } ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "sample", "app", "use", "new", "reduxify", "package"], "add_tokens": "import reduxify from 'flux-capacitor-reduxify' import backendNotesReducer from '!babel!../../../server/reducers/notes'", "del_tokens": "import { reduxify } from 'flux-capacitor' import backendNotesReducer from '../../../server/reducers/notes'", "commit_type": "make"}
{"commit_tokens": ["Added", "support", "for", "definition", "and", "term", "list", "items"], "add_tokens": "'styles' : [ 'bullet' , 'bullet' , 'bullet' ] } , { 'type' : 'listItem' , 'attributes' : { 'styles' : [ 'number' ] } , 'content' : { 'text' : 'Test 7777777' } } , { 'type' : 'listItem' , 'attributes' : { 'styles' : [ 'number' , 'number' ] } , 'content' : { 'text' : 'Test 88888888' } } , { 'type' : 'listItem' , 'attributes' : { 'styles' : [ 'term' ] } , 'content' : { 'text' : 'Test 999999999' } } , { 'type' : 'listItem' , 'attributes' : { 'styles' : [ 'definition' ] } , 'content' : { 'text' : 'Test 0000000000' }", "del_tokens": "'styles' : [ 'number' ]", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "TSLint", "formatters"], "add_tokens": ". pipe ( tslint ( { formatter : \"prose\" } ) ) . pipe ( tslint . report ( {", "del_tokens": ". pipe ( tslint ( ) ) . pipe ( tslint . report ( \"prose\" , {", "commit_type": "add"}
{"commit_tokens": ["Add", "custom", "syling", "to", "sample", "app"], "add_tokens": "zip : \"app/res/zip/test_single-file-no-folder.zip\" , destination : \"tmp\" ,", "del_tokens": "zip : \"res/zip/test_single-file-no-folder.zip\" , destination : \"res/scratch\" ,", "commit_type": "add"}
{"commit_tokens": ["fix", "error", "with", "getting", "random", "value", "with", "parseInt"], "add_tokens": "* Date : 2015 - 03 - 23 T16 : 06 Z for ( var j = 0 , l = arr . length ; j < l ; j ++ ) { return Math . floor ( Math . random ( ) * ( count || 1000 ) ) ;", "del_tokens": "* Date : 2015 - 03 - 23 T02 : 25 Z for ( var j = 0 , l = arr . length ; i < l ; i ++ ) { return parseInt ( Math . random ( ) * ( count || 1000 ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "a", "bug", "with", "chunk", "concatting"], "add_tokens": "var targetHost = \"imap.gmail.com\" , // \"imap-mail.outlook.com\", } ) ;", "del_tokens": "var targetHost = \"imap-mail.outlook.com\" , } ) ;", "commit_type": "fix"}
{"commit_tokens": ["moved", "over", "to", "bind", ".", "jQuery"], "add_tokens": "const { bind } = require ( './index.js' ) ;", "del_tokens": "const bind = require ( './index.js' ) ;", "commit_type": "move"}
{"commit_tokens": ["Added", "the", "emit", "-", "message", "for", "devices", "being", "reconnected", "."], "add_tokens": "var DEVICE_RECONNECTING = device_events . DEVICE_RECONNECTING ; self . emit ( DEVICE_RECONNECTING , self . savedAttributes ) ;", "del_tokens": "console . log ( 'Trying to reconnect...' ) ;", "commit_type": "add"}
{"commit_tokens": ["upgrading", "to", "a", "faster", "block", "encryption"], "add_tokens": "var aes = crypto . createCipheriv ( \"AES-128-CTR\" , to . secretOut , iv ) ; var aes = crypto . createCipheriv ( \"AES-128-CTR\" , to . secretOut , iv ) ; var aes = crypto . createDecipheriv ( \"AES-128-CTR\" , secret , new Buffer ( packet . js . iv , \"hex\" ) ) ; var aes = crypto . createDecipheriv ( \"AES-128-CTR\" , packet . from . secretIn , new Buffer ( packet . js . iv , \"hex\" ) ) ;", "del_tokens": "var aes = crypto . createCipheriv ( \"AES-128-CBC\" , to . secretOut , iv ) ; var aes = crypto . createCipheriv ( \"AES-128-CBC\" , to . secretOut , iv ) ; var aes = crypto . createDecipheriv ( \"AES-128-CBC\" , secret , new Buffer ( packet . js . iv , \"hex\" ) ) ; var aes = crypto . createDecipheriv ( \"AES-128-CBC\" , packet . from . secretIn , new Buffer ( packet . js . iv , \"hex\" ) ) ;", "commit_type": "upgrade"}
{"commit_tokens": ["Fixed", "a", "bug", "in", "how", "help", "was", "aligned"], "add_tokens": "var fullCommands = [ ] ; var fullCommand = command ; fullCommand += ' ' + self . availableCommands [ command ] . arguments ; if ( fullCommand . length > self . commandMaxLength ) { self . commandMaxLength = fullCommand . length ; } fullCommands . push ( [ fullCommand , self . availableCommands [ command ] . description ] ) ; } fullCommands . forEach ( function ( command ) { var diff = ( self . commandMaxLength - command [ 0 ] . length ) ; command [ 0 ] += ' ' ; console . log ( ' %s %s' , command [ 0 ] , command [ 1 ] ) ; } )", "del_tokens": "var prettyCommand = command ; prettyCommand += ' ' + self . availableCommands [ command ] . arguments ; var diff = ( self . commandMaxLength - prettyCommand . length ) ; prettyCommand += ' ' ; // console.log(self.availableCommands[command]); console . log ( ' %s %s' , prettyCommand , self . availableCommands [ command ] . description ) ; }", "commit_type": "fix"}
{"commit_tokens": ["Add", "babel", "-", "plugin", "-", "styled", "-", "components"], "add_tokens": "options : { cacheDirectory : true , plugins : [ [ \"babel-plugin-styled-components\" , { \"displayName\" : ! PRODUCTION , } ] , ] , } ,", "del_tokens": "options : { cacheDirectory : true } ,", "commit_type": "add"}
{"commit_tokens": ["fixed", "ria", ".", "async", ".", "wait"], "add_tokens": ". complete ( function ( ) { if ( resolved [ index ] || complete ) return ; complete = true ; completer . cancel ( ) ; } ) } )", "del_tokens": ". complete ( function ( ) { if ( resolved [ index ] || complete ) return ; complete = true ; completer . cancel ( ) ; } ) } )", "commit_type": "fix"}
{"commit_tokens": ["Change", "the", "format", "slightly", "to", "make", "it", "more", "convenient", "add", "unit", "test", "."], "add_tokens": "return { name : locale , strings : strings } ; var result = { } ; locales . forEach ( function ( locale ) { result [ locale . name ] = locale . strings ; } ) ; return JSON . stringify ( result ) ;", "del_tokens": "return { locale : locale , strings : strings } ; return JSON . stringify ( locales ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "query", "params", "to", "locals", "."], "add_tokens": "var state , site , locals ; addParams ( res ) ; site = siteService . sites ( ) [ res . locals . site ] ; locals = res . locals ; function addParams ( res ) { var req = res . req ; return _ . assign ( res . locals , req . params , req . query ) ;", "del_tokens": "var state , site = siteService . sites ( ) [ res . locals . site ] , locals = res . locals ; * @ param { object } req function addParams ( req , res ) { return _ . assign ( res . locals , req . params ) ; addParams ( req , res ) ;", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "filenames", "of", "the", "culture", "files", "to", "lowercase", "and", "ensure", "the", "culture", "files", "are", "always", "request", "in", "lowercase", "regardless", "of", "the", "casing", "of", "the", "set", "cultlure", "."], "add_tokens": "* angular - auto - validate - v1 .0 .10 - 2014 - 07 - 25 cultureRetrievalPromise = $http . get ( '{0}/jcs-auto-validate_{1}.json' . format ( i18nFileRootPath , culture . toLowerCase ( ) ) ) ;", "del_tokens": "* angular - auto - validate - v1 .0 .8 - 2014 - 07 - 21 cultureRetrievalPromise = $http . get ( '{0}/jcs-auto-validate_{1}.json' . format ( i18nFileRootPath , culture ) ) ;", "commit_type": "change"}
{"commit_tokens": ["Add", "mongoose", "to", "backend", "&", "frontend", "tests", "dependencies"], "add_tokens": "var assert = require ( 'assert' ) , app = require ( '../app' ) mongoose = require ( 'mongoose' ) ; if ( ! mongoose . connection . host ) { var connection = 'mongodb://localhost/bauhausjs_test' ; mongoose . connect ( connection ) ; } var imports = { server : { app : serverMock } , security : securityMock , mongoose : { connection : mongoose . connection } } ;", "del_tokens": "var assert = require ( 'assert' ) ; var app = require ( '../app' ) ; var imports = { server : { app : serverMock } , security : securityMock } ;", "commit_type": "add"}
{"commit_tokens": ["Fixing", "parent", "regression", "on", "each", "hooks"], "add_tokens": "var parent = this . originalParent || this . parent var title = ( parent ) ? parent . fullTitle ( separator ) + separator : '' test . originalParent = this . parent", "del_tokens": "var title = ( this . parent ) ? this . parent . fullTitle ( separator ) + separator : ''", "commit_type": "fix"}
{"commit_tokens": ["fixes", "bad", "return", "from", "toJSON"], "add_tokens": "if ( action . private ) { continue ; }", "del_tokens": "if ( action . private ) { return ; }", "commit_type": "fix"}
{"commit_tokens": ["Use", "global", "ID", "field", "for", "primary", "keys", "when", "using", "relay"], "add_tokens": "fields . push ( generateField ( model . fields [ fieldName ] , null , name ) ) ; function generateField ( field , type , typeName ) { b . property ( 'init' , b . identifier ( 'type' ) , type || getType ( field , typeName ) ) , function getType ( field , parentTypeName ) { if ( field . isPrimaryKey && opts . relay ) { return b . callExpression ( b . identifier ( 'globalIdField' ) , [ b . literal ( parentTypeName ) ] ) ; }", "del_tokens": "fields . push ( generateField ( model . fields [ fieldName ] ) ) ; function generateField ( field , type ) { b . property ( 'init' , b . identifier ( 'type' ) , type || getType ( field ) ) , function getType ( field ) {", "commit_type": "use"}
{"commit_tokens": ["Added", "RESPONSE_CONTENT_TYPE", "application", "/", "xml", "(", "because", "of", "issue", "with", "GetLowestPricedOffersForASIN", "response", ")"], "add_tokens": "var RESPONSE_CONTENT_TYPE = [ 'text/xml' , 'text/xml;charset=utf-8' , 'application/xml' ] ;", "del_tokens": "var RESPONSE_CONTENT_TYPE = [ 'text/xml' , 'text/xml;charset=utf-8' ] ;", "commit_type": "add"}
{"commit_tokens": ["fix", "ie9", "and", "constant", "property"], "add_tokens": "ce . c1 = v2 ; expect ( ! ! error || ce . c1 === v1 , 'ce.c1 should not be writable' ) . to . true ( ) ;", "del_tokens": "expect ( 'c1' in ce , 'c1 should be in ce' ) . to . true ( ) ; ce . c1 = null ; expect ( error , 'ce.c1 should not be writable' ) . to . exist ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "text", "method", "to", "wrapper"], "add_tokens": "describe ( 'text' , ( ) => {", "del_tokens": "describe . skip ( 'text' , ( ) => {", "commit_type": "add"}
{"commit_tokens": ["changes", "the", "order", "of", "updateListData"], "add_tokens": "updateListData : function ( data , set ) {", "del_tokens": "updateListData : function ( set , data ) {", "commit_type": "change"}
{"commit_tokens": ["Use", "chalk", "module", "to", "colorize", "terminal", "output"], "add_tokens": "var chalk = require ( 'chalk' ) ; grunt . log . writeln ( 'File ' + chalk . cyan ( options . sourceMap ) + ' created (source map).' ) ; grunt . log . writeln ( 'File ' + chalk . cyan ( f . dest ) + ' created.' ) ;", "del_tokens": "grunt . log . writeln ( 'Source Map \"' + options . sourceMap + '\" created.' ) ; grunt . log . writeln ( 'File \"' + f . dest + '\" created.' ) ;", "commit_type": "use"}
{"commit_tokens": ["Updated", "task", "runner", "to", "build", "js", "with", "babel", "."], "add_tokens": "// =require ./bootstrap/alert.js // =require ./bootstrap/button.js // =require ./bootstrap/carousel.js // =require ./bootstrap/collapse.js // =require ./bootstrap/dropdown.js // =require ./bootstrap/modal.js // =require ./bootstrap/popover.js // =require ./bootstrap/scrollspy.js // =require ./bootstrap/tab.js // =require ./bootstrap/tooltip.js // =require ./bootstrap/util.js", "del_tokens": "//=require ./bootstrap/bootstrap.js", "commit_type": "update"}
{"commit_tokens": ["Fix", "typo", "in", "task", "description"], "add_tokens": "'Debug plumin.js using node-inspector (required as global module)' ,", "del_tokens": "'Debug prototypo.js using node-inspector (required as global module)' ,", "commit_type": "fix"}
{"commit_tokens": ["allow", "_", "and", "$", "in", "variable", "names"], "add_tokens": "return ( code >= 65 && code <= 90 ) || ( code >= 97 && code <= 122 ) || ( code === 95 ) // '_' || ( code === 36 ) // '$' while ( validChar ( peek ( ) ) ) {", "del_tokens": "return ( code >= 65 && code <= 90 ) || ( code >= 97 && code <= 122 ) ; } / ** * Match valid JS object property names . Like variable names * this is incomplete . * TODO : A better validation has to be found . * / function validProp ( c ) { return validChar ( c ) || ( c === '_' ) || ( ( c . charCodeAt ( 0 ) >= 47 ) && ( c . charCodeAt ( 0 ) <= 57 ) ) ; while ( validProp ( peek ( ) ) ) {", "commit_type": "allow"}
{"commit_tokens": ["Allow", "empty", "dns", "in", "search", "(", "e", ".", "g", ".", "enable", "rootDSE", "searches", ")"], "add_tokens": "attr . vals . push ( obj [ k ] + '' ) ;", "del_tokens": "} else if ( typeof ( obj [ k ] ) === 'string' ) { attr . vals . push ( obj [ k ] ) ; throw new TypeError ( k + ' -> ' + obj [ k ] + ' is not a string' ) ;", "commit_type": "allow"}
{"commit_tokens": ["Add", "missing", "input", "types", "and", "some", "doc"], "add_tokens": "// See http://www.w3schools.com/html/html_form_input_types.asp // See https://github.com/slorber/backspace-disabler/issues/1 var ValidInputTypes = [ 'TEXT' , 'PASSWORD' , 'FILE' , 'EMAIL' , 'SEARCH' , 'DATE' , 'NUMBER' , 'MONTH' , 'WEEK' , 'TIME' , 'DATETIME' , 'DATETIME-LOCAL' , 'TEL' , 'URL' ] ;", "del_tokens": "var ValidInputTypes = [ 'TEXT' , 'PASSWORD' , 'FILE' , 'EMAIL' , 'SEARCH' , 'DATE' ] ;", "commit_type": "add"}
{"commit_tokens": ["Use", "cross", "-", "platform", "tmpdir"], "add_tokens": "let os = require ( 'os' ) ; let path = require ( 'path' ) ; let debug = require ( 'debug' ) ( 'test' ) ; let mockdir = path . join ( os . tmpdir ( ) , 'tc-lib-validate' , 'buckets' ) ; debug ( 'Using tmpdir: ' + mockdir ) ;", "del_tokens": "let mockdir = '/tmp/tc-lib-validate/buckets' ;", "commit_type": "use"}
{"commit_tokens": ["added", "namespacing", "for", "easier", "references"], "add_tokens": "nui . addGestureListener ( Events . Gestures . Swipe . SWIPE , Events . Gestures . Swipe . types . right ) ; nui . addGestureListener ( Events . Gestures . Swipe . SWIPE , Events . Gestures . Swipe . types . left ) ; nui . addGestureListener ( Events . Gestures . Wave . WAVE , Events . Gestures . Wave . types . left ) ; nui . addGestureListener ( Events . Gestures . Wave . WAVE , Events . Gestures . Wave . types . right ) ; nui . addGestureListener ( Events . Gestures . Wave . WAVE , Events . Gestures . Wave . types . any ) ;", "del_tokens": "nui . addGestureListener ( Gestures . Swipe . SWIPE , Gestures . Swipe . types . right ) ; nui . addGestureListener ( Gestures . Swipe . SWIPE , Gestures . Swipe . types . left ) ; nui . addGestureListener ( Gestures . Wave . WAVE , Gestures . Wave . types . left ) ; nui . addGestureListener ( Gestures . Wave . WAVE , Gestures . Wave . types . right ) ; nui . addGestureListener ( Gestures . Wave . WAVE , Gestures . Wave . types . any ) ;", "commit_type": "add"}
{"commit_tokens": ["Updating", "taste", "so", "can", "pass", "in", "container", "to", "init"], "add_tokens": "init : function init ( container ) { pancakesConfig . container = container ;", "del_tokens": "init : function init ( ) {", "commit_type": "update"}
{"commit_tokens": ["add", "color", "types", "to", "globals"], "add_tokens": "DataType : { DATE : 'date' , NUMBER : 'number' , STRING : 'string' } , ColorType : { GRADIENT : 'gradient' , DISTINCT : 'distinct' , CATEGORICAL : 'categorical' , DIVERGENT : 'divergent' export default Globals ;", "del_tokens": "Type : { Date : 'date' , Number : 'number' , String : 'string' export default Definition ;", "commit_type": "add"}
{"commit_tokens": ["Move", "bulk", "to", "POST", "+", "handle", "invalid", "number", "without", "500"], "add_tokens": "app . use ( express . bodyParser ( ) ) ; app . post ( '/bulk' , function ( req , response ) { var numbers = req . body . numbers ; var country_codes = req . body . country_codes ; try { a [ number ] = get_phone_info ( number , country_code ) ; } catch ( e ) { a [ number ] = { e164 : '' , national : '' , valid : false , type : 'UNKNOWN' } ; }", "del_tokens": "app . get ( '/bulk' , function ( req , response ) { var numbers = req . param ( 'numbers' ) ; var country_codes = req . param ( 'country_codes' ) ; a [ number ] = get_phone_info ( number , country_code ) ;", "commit_type": "move"}
{"commit_tokens": ["Added", "support", "and", "examples", "for", "Spine", "events", "."], "add_tokens": "* Build at 07 - 03 - 2017 _this . onEvent = new Phaser . Signal ( ) ; _this . state . onEvent = _this . onEvent . dispatch . bind ( _this . onEvent ) ;", "del_tokens": "* Build at 23 - 12 - 2016", "commit_type": "add"}
{"commit_tokens": ["Add", "statistics", "for", "doc", "-", "locale", "endpoint", "."], "add_tokens": "'/stats/proj/tiny-project/iter/1/doc/hello.txt' , '/stats/proj/tiny-project/iter/1/doc/hello.txt/locale/en-us' , '/stats/proj/tiny-project/iter/1/doc/hello.txt/locale/fr'", "del_tokens": "'/stats/proj/tiny-project/iter/1/doc/hello.txt'", "commit_type": "add"}
{"commit_tokens": ["Implemented", "DeflateDecoder", "by", "using", "pako", "library"], "add_tokens": "var pakoInflate = require ( 'pako/lib/inflate' ) . inflate ; DeflateDecoder . prototype . decodeBlock = function ( buffer ) { return pakoInflate ( new Uint8Array ( buffer ) ) . buffer ;", "del_tokens": "/ * var Buffer = require ( 'buffer' ) ; var inflate = require ( 'inflate' ) ; var through = require ( 'through' ) ; * / DeflateDecoder . prototype . decodeBlockAsync = function ( buffer , callback ) { // through(function (data) { // this.queue(new Buffer(new Uint8Array(buffer))); // }, // function() { // this.queue(null); // }) // .pipe(inflate()) // /*.pipe(function() { // alert(arguments); // })*/ // .on(\"data\", function(data) { // buffers.push(data); // }) // .on(\"end\", function() { // var buffer = Buffer.concat(buffers); // var arrayBuffer = new ArrayBuffer(buffer.length); // var view = new Uint8Array(ab); // for (var i = 0; i < buffer.length; ++i) { // view[i] = buffer[i]; // } // callback(null, arrayBuffer); // }) // .on(\"error\", function(error) { // callback(error, null) // }); throw new Error ( \"DeflateDecoder is not yet implemented.\" ) ;", "commit_type": "implement"}
{"commit_tokens": ["Fixed", "a", "bug", "where", "options", "were", "returning", "nested", "arrays", ".", "Splice", "returns", "an", "array", "."], "add_tokens": "value = args . splice ( index , 1 ) [ 0 ] ; value = args . splice ( index , 1 ) [ 0 ] ;", "del_tokens": "value = args . splice ( index , 1 ) ; value = args . splice ( index , 1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "reinforcement", "learning", "algorithms", "upper", "confidence", "bound", "and", "thompson", "sampling"], "add_tokens": "'node_modules/ml-array-utils/src/index.js' : [ 'scale' , ] , 'node_modules/probability-distributions/index.js' : [ 'rbeta' , ] , 'probability-distributions' ,", "del_tokens": "'node_modules/ml-array-utils/src/index.js' : [ 'scale' , ] ,", "commit_type": "add"}
{"commit_tokens": ["Changed", ":", "combiner", "script", "to", "work", "with", "parse5", "DOM", "objects", "."], "add_tokens": "function removeNewLines ( str ) { return str . replace ( / \\r / g , '' ) . replace ( / \\n / g , '' ) ; } expect ( removeNewLines ( combine ( sources . template , sources [ 2 ] ) ) ) . to . equal ( removeNewLines ( sources [ 'tpl.result' ] ) ) ; it ( 'should not parse textarea contents' , function ( ) { expect ( removeNewLines ( combine ( sources . template , sources [ 1 ] ) ) ) . to . equal ( removeNewLines ( sources [ 'textarea.result' ] ) ) ; } ) ;", "del_tokens": "console . log ( combine ( sources . template , sources [ 2 ] ) ) ; // it( 'should not parse script contents', function() { // expect(combine(sources.template, sources[2])).to.equal(sources['tpl.result']); // } ); // it( 'should not parse textarea contents', function() { // expect(combine(sources.template, sources[1])).to.equal(sources['textarea.result']); // } );", "commit_type": "change"}
{"commit_tokens": ["changed", "the", "user", ":", "load_user", "command", "pattern"], "add_tokens": "seneca . act ( { role : 'user' , get : 'user' , q : q } , function ( err , data ) { if ( ! data . ok ) return done ( null , { ok : false , why : data . why } ) ; var user = data . user console . log ( 'redirect: ' , redirect )", "del_tokens": "seneca . act ( { role : 'user' , cmd : 'load_user' , q : q } , function ( err , user ) {", "commit_type": "change"}
{"commit_tokens": ["Make", "more", "commands", "set", "/", "get"], "add_tokens": "cli . command ( 'wifi-mode [mode]' ) . description ( 'Gets/sets the WiFi mode of the UFO.' ) mode ? this . setWifiMode ( mode , stop ( ) ) : this . getWifiMode ( getAndStop ( ) ) ; cli . command ( 'wifi-client-ssid [ssid]' ) ssid ? this . setWifiClientSsid ( ssid , stop ( ) ) : this . getWifiClientSsid ( getAndStop ( ) ) ;", "del_tokens": "cli . command ( 'wifi-mode <mode>' ) . description ( 'Sets the WiFi mode of the UFO.' ) this . setWifiMode ( mode , stop ( ) ) ; cli . command ( 'wifi-client-ssid <ssid>' ) this . setWifiClientSsid ( ssid , stop ( ) ) ;", "commit_type": "make"}
{"commit_tokens": ["Added", "user", "model", "/", "tests"], "add_tokens": "exports . tokens = require ( './models/tokens' ) ; exports . users = require ( './models/users' ) ;", "del_tokens": "exports . tokens = require ( './models/tokens' ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "option", "to", "show", "the", "print", "margin"], "add_tokens": "if ( this . getShowInvisibles ( ) == showInvisibles ) return ; return this . renderer . getShowInvisibles ( ) ; } ; this . setShowPrintMargin = function ( showPrintMargin ) { this . renderer . setShowPrintMargin ( showPrintMargin ) ; } ; this . getShowPrintMargin = function ( ) { return this . renderer . getShowPrintMargin ( ) ; } ; this . setPrintMarginColumn = function ( showPrintMargin ) { this . renderer . setPrintMarginColumn ( showPrintMargin ) ; } ; this . getPrintMarginColumn = function ( ) { return this . renderer . getPrintMarginColumn ( ) ;", "del_tokens": "this . $showInvisibles = true ; showInvisibles = ! ! showInvisibles ; if ( this . $showInvisibles == showInvisibles ) return ; this . $showInvisibles = showInvisibles ; return this . showInvisibles ;", "commit_type": "add"}
{"commit_tokens": ["FIXED", ":", "added", "missing", "catch", "in", "start", "game", "promise", "fixes", "silent", "errors"], "add_tokens": "this . scene . _load ( ) . then ( ( ) => this . _startScene ( ) ) . catch ( err => { console . error ( err ) ; } ) ;", "del_tokens": "this . scene . _load ( ) . then ( ( ) => this . _startScene ( ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "umdNamedDefine", "to", "webpack", "to", "make", "it", "easier", "to", "use", "in", "a", "<script", ">", "tag", "."], "add_tokens": "libraryTarget : 'umd' , umdNamedDefine : true", "del_tokens": "libraryTarget : 'umd'", "commit_type": "add"}
{"commit_tokens": ["Fix", "strange", "bug", "where", "progresses", "of", "paths", "were", "confused", "with", "eachother"], "add_tokens": "// Path reference must be created like this instead of var self = this; // Somehow the self references sometimes to incorrect instance if // created like that. var thisPath = this . _path ; thisPath . style . strokeDashoffset = state . offset ; thisPath . style . strokeDashoffset = state . offset ;", "del_tokens": "self = this ; self . _path . style . strokeDashoffset = state . offset ; self . _path . style . strokeDashoffset = state . offset ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "using", "persian", "digits", "in", "format"], "add_tokens": "jMoment . fn . doAsJalali = function ( ) { // jMoment.bindCalendarSystemAndLocale();", "del_tokens": "function hasPersianDigit ( input ) { if ( typeof input === \"string\" ) { for ( var i = 0 ; i < 10 ; i ++ ) { if ( input . indexOf ( persianMap [ i ] ) > - 1 ) return true ; } } return false ; // return /[\\u06F0-\\u06F90]+/.test(input); } function convertToEnglishNumber ( input ) { return input . replace ( / [\\u06F0-\\u06F90] / g , function ( m ) { return persianDigits . indexOf ( m ) ; } ) ; } function convertToPersianNumber ( input ) { return input . replace ( / \\d / g , function ( m ) { return persianMap [ parseInt ( m ) ] ; } ) ; } if ( hasPersianDigit ( input ) ) { input = convertToEnglishNumber ( input ) ; itsJalaliDate = true ; } if ( moment . usePersianDigits || this . usePersianDigits ) { formatted = convertToPersianNumber ( formatted ) ; } jMoment . fn . doAsJalali = function ( usePersianDigits ) { this . usingFaDigits = usePersianDigits ; this . usingFaDigits = false ;", "commit_type": "remove"}
{"commit_tokens": ["Added", "a", "PubNub", "datasource", "."], "add_tokens": "subscribe_key : newSettings [ \"subscribe_key\" ] , ssl : true", "del_tokens": "subscribe_key : newSettings [ \"subscribe_key\" ]", "commit_type": "add"}
{"commit_tokens": ["Add", "build", "version", "number", "for", "OSX"], "add_tokens": "var buildVersion = opts [ 'build-version' ] appPlist . CFBundleShortVersionString = appPlist . CFBundleVersion = appVersion } if ( buildVersion ) { appPlist . CFBundleVersion = buildVersion", "del_tokens": "appPlist . CFBundleVersion = appVersion", "commit_type": "add"}
{"commit_tokens": ["Add", "flow", "parser", "as", "an", "option", "default", "to", "babylon"], "add_tokens": "let ast ; if ( opts . useFlowParser ) { ast = flowParser . parse ( text ) ; if ( ast . errors . length > 0 ) { let msg = ast . errors [ 0 ] . message + \" on line \" + ast . errors [ 0 ] . loc . start . line if ( opts . filename ) { msg += \" in file \" + opts . filename ; } throw new Error ( msg ) ; } else { ast = recast . parse ( text , { parser : { parse : function ( source ) { return babylon . parse ( source , babylonOptions ) ; } } } ) ;", "del_tokens": "// const ast = recast.parse(text, { // parser: { // parse: function(source) { // return babylon.parse(source, babylonOptions); // } // } // }); const ast = flowParser . parse ( text ) ; if ( ast . errors . length > 0 ) { let msg = ast . errors [ 0 ] . message + \" on line \" + ast . errors [ 0 ] . loc . start . line if ( opts . filename ) { msg += \" in file \" + opts . filename ; throw new Error ( msg ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "carousel", "-", "3d", ".", "js"], "add_tokens": "* angular - carousel - 3 d * Version : 0.0 .1 angular . module ( \"carousel3d\" ) . run ( [ \"$templateCache\" , function ( $templateCache ) { $templateCache . put ( \"carousel-3d.html\" , \"<div class=\\\"carousel-3d-container\\\"><div class=\\\"carousel-3d\\\"><img ng-repeat=\\\"image in vm.ngModel track by $index\\\" ng-src=\\\"{{image.src}}\\\" class=\\\"slide-3d\\\" ng-click=\\\"vm.slideClicked($index)\\\" ng-swipe-left=\\\"vm.goPrev()\\\" ng-swipe-right=\\\"vm.goNext()\\\"></div></div>\" ) ; } ] ) ;", "del_tokens": "* angular - directive - boilerplate * Version : 0.0 .8 - 2015 - 09 - 29 T00 : 14 : 18.694 Z angular . module ( \"carousel3d\" ) . run ( [ \"$templateCache\" , function ( $templateCache ) { $templateCache . put ( \"carousel-3d.html\" , \"<div class=\\\"carousel-3d-container\\\"><div class=\\\"carousel-3d\\\"><img ng-repeat=\\\"image in vm.ngModel track by $index\\\" ng-src=\\\"{{image.src}}\\\" class=\\\"slide-3d\\\" ng-click=\\\"vm.slideClicked($index)\\\" ng-swipe-left=\\\"vm.goPrev()\\\" ng-swipe-right=\\\"vm.goNext()\\\"></div></div>\" ) ; } ] ) ;", "commit_type": "update"}
{"commit_tokens": ["Moved", "md5", "transposition", "to", "the", "manifest", "module", "."], "add_tokens": "var md5 = require ( __dirname + '/../src/md5' ) ( ) ; var manifest = new Manifest ( config , md5 , glob ) ; describe ( '#transposeWithMD5' , function ( ) { var files = [ 'test/fixture/md5test.txt' ] ; it ( 'should transpose and remain the same array length' , function ( done ) { manifest . transposeWithMD5 ( files ) . should . eventually . have . length ( 1 ) . notify ( done ) ; } ) ; it ( 'should transpose a file list into an array of objects containing the md5 sum' , function ( done ) { var expected = [ { name : 'test/fixture/md5test.txt' , hash : '77284ae4aac90cd005586850dce5fbd9' , canonical : 'test/fixture/md5test.txt' } ] ; manifest . transposeWithMD5 ( files ) . should . eventually . be . deep . include . members ( expected ) . notify ( done ) ; } ) } ) ;", "del_tokens": "var manifest = new Manifest ( config , null , glob ) ;", "commit_type": "move"}
{"commit_tokens": ["Implement", "osx", "-", "sign", "options", "hash"], "add_tokens": "opts [ 'osx-sign' ] = true // Ad-hoc", "del_tokens": "opts . sign = true // Ad-hoc", "commit_type": "implement"}
{"commit_tokens": ["fix", "the", "issue", "of", "not", "call", "alarm", "function"], "add_tokens": "exitProcess ( 'the value of ' + key + ' is a necessary object ,but get ' + obj , this . alarm ) ; exitProcess ( 'the value of ' + key + ' is a necessary file ,but not exists in ' + filePath , this . alarm ) ;", "del_tokens": "exitProcess ( 'the value of ' + key + ' is a necessary object ,but get ' + obj ) ; exitProcess ( 'the value of ' + key + ' is a necessary file ,but not exists in ' + filePath ) ;", "commit_type": "fix"}
{"commit_tokens": ["Improve", "error", "message", "when", "req", "missing", "headers", "property"], "add_tokens": "var header = getAuthorization ( req . req || req ) / ** * Get the Authorization header from request object . * @ private * / function getAuthorization ( req ) { if ( ! req . headers || typeof req . headers !== 'object' ) { throw new TypeError ( 'argument req is required to have headers property' ) } return req . headers . authorization }", "del_tokens": "var header = ( req . req || req ) . headers . authorization", "commit_type": "improve"}
{"commit_tokens": ["Updated", "to", "tinyg", ".", "io", "example", ".", "Corrected", "pointer", "to", "latest", "hacked", "node", "-", "serialport", "."], "add_tokens": "self . emit ( \"error\" , { serialPortError : err } ) ; var writeCallback = function ( err , results ) { if ( err ) console . error ( \"WRITE ERROR: \" , err ) ; } if ( callback === undefined ) callback = writeCallback ; if ( part . match ( / ^\\s*$ / ) ) //|| self._configuration.qr < 4 self . _configuration . qr -- ; console . log ( \">>QR: \" , self . _configuration . qr ) ;", "del_tokens": "self . emit ( \"error\" , err ) ; if ( part . match ( / ^\\s*$ / ) || self . configuration . qr < 4 ) self . configuration . qr -- ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "typing", "tests", "so", "that", "they", "work", "on", "ipads"], "add_tokens": "async function clearAndType ( element , text ) { await element . clear ( ) ; await element . type ( text ) ; } await clearAndType ( el , text1 ) ; await clearAndType ( els [ 0 ] , text1 ) ; await clearAndType ( els [ 1 ] , text2 ) ; await clearAndType ( els [ 0 ] , text1 ) ; await clearAndType ( el , text1 ) ; await clearAndType ( els [ 0 ] , text1 ) ; await clearAndType ( els [ 1 ] , text2 ) ; await clearAndType ( el , text1 ) ;", "del_tokens": "await el . type ( text1 ) ; await els [ 0 ] . type ( text1 ) ; await els [ 1 ] . type ( text2 ) ; await els [ 0 ] . type ( text1 ) ; await el . type ( text1 ) ; await els [ 0 ] . type ( text1 ) ; await els [ 1 ] . type ( text2 ) ; await el . type ( text1 ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "a", "ReferenceError", ":", "relationship", "is", "not", "defined", "bug"], "add_tokens": "record . meta = extend ( { } , record . meta , fromRelationship . meta ) ;", "del_tokens": "record . meta = extend ( { } , record . meta , relationship . meta ) ;", "commit_type": "fix"}
{"commit_tokens": ["removed", "socket", "and", "head", "logs"], "add_tokens": "backend = backend || redisBackend ( ) ; // TODO: If no backend is specified just instantiate a static proxy. log . info ( { headers : req . headers } , \"upgrade to websockets\" ) ;", "del_tokens": "backend = backend || redisBackend ( ) ; log . info ( { headers : req . headers , socket : socket , head : head } , \"upgrade to websockets\" ) ;", "commit_type": "remove"}
{"commit_tokens": ["Add", "support", "for", "sound", "listing", "in", "player", "."], "add_tokens": "if ( timestamp ) { / ** * @ ngdoc method * @ name list * @ methodOf coa . audio . service : player * @ return { Array } A list of sound names loaded . * @ description * * Get the list of loaded sound names . * / function list ( ) { return Object . keys ( audio ) ; } list : list ,", "del_tokens": "if ( typeof ( DEBUG ) !== \"undefined\" && DEBUG ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "more", "descriptive", "error", "message"], "add_tokens": "throw new Error ( 'Expected ' + srcAbs + ' to start with ' + srcBaseAbs ) ;", "del_tokens": "throw new Error ( ) ;", "commit_type": "add"}
{"commit_tokens": ["Update", "ndef", "-", "text", ".", "js"], "add_tokens": "if ( utf16 ) { return util . bytesToString ( data . slice ( languageCodeLength + 1 ) ) ; var utf8 = \"\" ; utf8 += String . fromCharCode ( c ) ; utf8 += String . fromCharCode ( ( ( c & 0x1F ) << 6 ) | ( char2 & 0x3F ) ) ; utf8 += String . fromCharCode ( ( ( c & 0x0F ) << 12 ) | return utf8 ;", "del_tokens": "// TODO need to deal with UTF in the future // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\")); var decodedString = util . bytesToString ( data . slice ( languageCodeLength + 1 ) ) ; if ( typeof decodedString !== 'undefined' && typeof decodedString !== 'null' && strlen ( decodedString ) > 0 ) { return decodedString ; decodedString = \"\" ; decodedString += String . fromCharCode ( c ) ; decodedString += String . fromCharCode ( ( ( c & 0x1F ) << 6 ) | ( char2 & 0x3F ) ) ; decodedString += String . fromCharCode ( ( ( c & 0x0F ) << 12 ) | return decodedString ;", "commit_type": "update"}
{"commit_tokens": ["Updated", "README", "with", "Bitbucket", "SSH", "details", ";", "fixed", "typo"], "add_tokens": "{ name : \"longitude\" , type : \"real\" } ,", "del_tokens": "{ name : \"longitude\" , type : \" real\" } ,", "commit_type": "update"}
{"commit_tokens": ["Fixed", "the", "bug", "on", "creating", "a", "Model", "."], "add_tokens": "/ ** * Module Dependencies * / var Util = require ( 'util' ) ; * @ param { String } collectionName exports . createModel = function ( collectionName , attributes ) { function Model ( ) { var args = Array . prototype . slice . apply ( arguments ) ; args . unshift ( attributes ) ; args . unshift ( collectionName ) ; this . constructor . super_ . apply ( this , args ) ; } Util . inherits ( Model , exports . Model ) ; Model . collectionName = collectionName ; Model . idAttribute = exports . Model . getId ( attributes ) ; models [ collectionName ] = Model ; return Model ;", "del_tokens": "* @ param { String } name exports . createModel = function ( name , attributes ) { var model = new exports . Model ( name , attributes ) ; models [ name ] = model ; return model ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "github", "twitter", "and", "facebook", "trackers", "and", "improve", "activation", "of", "oauth", "services"], "add_tokens": "\"./tracker.chrome\" , \"./tracker.facebook\" , \"./tracker.twitter\" , \"./tracker.github\" , \"./tracker.ping\" ,", "del_tokens": "\"./tracker.ping\" ,", "commit_type": "add"}
{"commit_tokens": ["Moved", "files", "from", "src", "/", "to", "lib", "/"], "add_tokens": "let compile = require ( './lib/compile' ) , serve = require ( './lib/serve' )", "del_tokens": "let compile = require ( './src/scripts/compile' ) , serve = require ( './src/scripts/serve' )", "commit_type": "move"}
{"commit_tokens": ["add", "client", "type", "in", "handshake", "message"], "add_tokens": "this . checkClient = opts . checkClient ; if ( typeof this . checkClient === 'function' ) { if ( ! msg || ! msg . sys || ! this . checkClient ( msg . sys . type , msg . sys . version ) ) {", "del_tokens": "this . checkVersion = opts . checkVersion ; if ( typeof this . checkVersion === 'function' ) { if ( ! msg || ! msg . sys || ! msg . sys . version || ! this . checkVersion ( msg . sys . version ) ) {", "commit_type": "add"}
{"commit_tokens": ["Fix", "bug", "preventing", "scroll", "buttons", "on", "large", "screens"], "add_tokens": "this . delegateEvents ( _ . extend ( { 'click .viz' : 'onClickCursor' } , this . events ) ) ;", "del_tokens": "this . delegateEvents ( { 'click .viz' : 'onClickCursor' } ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "check", "to", "see", "that", "callback", "exists"], "add_tokens": "if ( this [ key ] ) { this . listenTo ( this . listenables [ key ] , key , this [ key + \"Default\" ] || key ) ; }", "del_tokens": "this . listenTo ( this . listenables [ key ] , key , this [ key + \"Default\" ] || key ) ;", "commit_type": "add"}
{"commit_tokens": ["add", "property", "to", "schema", "to", "specify", "REST", "api"], "add_tokens": "states : createViews ( views ) , REST : true", "del_tokens": "states : createViews ( views )", "commit_type": "add"}
{"commit_tokens": ["add", "topology", "name", "to", "instance", "tag"], "add_tokens": "tagParams . Tags . push ( { Key : 'nscale-system' , Value : system . name + '-' + system . topology . name } ) ;", "del_tokens": "tagParams . Tags . push ( { Key : 'nscale-system' , Value : system . name } ) ;", "commit_type": "add"}
{"commit_tokens": ["fix", "SVG", "sizing", "in", "Firefox"], "add_tokens": "return ( this . _el . viewBox . baseVal || { } ) . width || this . width ; return ( this . _el . viewBox . baseVal || { } ) . height || this . height ;", "del_tokens": "return this . _el . viewBox . baseVal . width || this . width ; return this . _el . viewBox . baseVal . height || this . height ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "unable", "to", "add", "a", "listener", "for", "an", "event", "with", "port", "override"], "add_tokens": "/ ** * Verify if exist an event with the specified UDP port and at least one listener * @ param { String } event The event * @ param { Number } port The UDP port * @ return { String } The already registered event with the specified UDP port if it has at least a listener or undefined if the UDP port is not assigned to another event * @ private * / EventEmitter . prototype . fullDefined = function fullDefined ( event , port ) { if ( this . hasReceiver ( event ) && this . hasListeners ( event ) ) { return this . hasEventWithPort ( event , port ) ; } return null ; } ; var duplicated = this . fullDefined ( event , this . events [ event ] ) ;", "del_tokens": "var duplicated = this . hasEventWithPort ( event , this . events [ event ] ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "hostname", "and", "log", "version", "to", "record"], "add_tokens": "const LOG_VERSION = 1 ; // increment when log format changes const HOSTNAME = require ( 'os' ) . hostname ( ) ; pid : this . _process . pid , host : HOSTNAME , v : LOG_VERSION", "del_tokens": "pid : this . _process . pid", "commit_type": "add"}
{"commit_tokens": ["Adding", "database", "index", "to", "dbtrace"], "add_tokens": "if ( ! context ) { return null ; const { hostname , port , connectionName , db } = context . options ; connectionName , db", "del_tokens": "let hostname , port , connectionName ; if ( context && context . options ) { hostname = context . options . host ; port = context . options . port ; connectionName = context . options . connectionName ; connectionName", "commit_type": "add"}
{"commit_tokens": ["Fix", "remark", ".", "js", "plugin", "activation", "condition"], "add_tokens": "return typeof remark === \"object\" && typeof slideshow === \"object\" ;", "del_tokens": "return typeof remark == \"object\" && slideshow === \"object\" ;", "commit_type": "fix"}
{"commit_tokens": ["updated", "README", "and", "API", "list", ";", "removed", "xor"], "add_tokens": "aliasFor ( \"identity\" ) . is ( \"I\" ) ;", "del_tokens": "// A function wrapping the boolean `^` operator. Note that unlike the underlying operator, though, it // aways returns `true` or `false`. R . xor = _ ( function ( a , b ) { return ! ! ( a ^ b ) ; } ) ; // A function wrapping a call to the given function in a `^` operation. It will return `true` when the // functions return logically opposite results, and `false` otherwise. var xorFn = R . xorFn = _ ( function ( f , g ) { return function ( ) { return ! ! ( f . apply ( this , arguments ) ^ g . apply ( this , arguments ) ) ; } ; } ) ;", "commit_type": "update"}
{"commit_tokens": ["Add", "popover", "to", "the", "list", "of", "semantically", "relevant", "attributes"], "add_tokens": "* Copyright ( c ) 2014 , 2015 Hauke Henningsen < sqrt @ entless . org > 'alt' , 'label' , 'placeholder' , 'title' , 'tooltip' , 'data-info' , 'popover'", "del_tokens": "* Copyright ( c ) 2014 Hauke Henningsen < sqrt @ entless . org > 'alt' , 'label' , 'placeholder' , 'title' , 'tooltip' , 'data-info' ,", "commit_type": "add"}
{"commit_tokens": ["fix", "a", "bug", "about", "platform", "detection"], "add_tokens": ": ( platform . match ( / (?:webos|android) / ) || platform . match ( / mac|win|linux / ) || [ DEFAULT_PLATFORM ] ) [ 0 ] ;", "del_tokens": ": ( ua . match ( / (?:webos|android) / ) || platform . match ( / mac|win|linux / ) || [ DEFAULT_PLATFORM ] ) [ 0 ] ;", "commit_type": "fix"}
{"commit_tokens": ["use", "notify", "to", "alert", "of", "changes", "so", "we", "can", "tear", "down", "earlier"], "add_tokens": "canReflect . onValue ( compute , change , \"notify\" ) ; canReflect . offValue ( compute , change , \"notify\" ) ;", "del_tokens": "canReflect . onValue ( compute , change , \"domUI\" ) ; canReflect . offValue ( compute , change , \"domUI\" ) ;", "commit_type": "use"}
{"commit_tokens": ["added", "new", "example", "and", "changed", "newItemFn", "format"], "add_tokens": "var counter = 15 ; var newItems = [ ] ; var id = counter ++ ; var item = { id : id , name : query , category : \"shoes\" } ; newItems . push ( item ) ; deferred . resolve ( item ) ; } , 500 ) ; return deferred . promise ; } , 500 ) ; function getOptionsById ( selectedAs ) { deferred . resolve ( data . concat ( newItems ) ) } , 500 ) ;", "del_tokens": "deferred . resolve ( newItem ) ; } , 1000 ) ; return deferred . promise ; } ; var newItem = { id : 0 , name : \"SavedItem\" , category : \"shoes\" } , 1000 ) ; function getOptionsById ( querySelectAs ) { deferred . resolve ( data . concat ( newItem ) ) } , 1000 ) ;", "commit_type": "add"}
{"commit_tokens": ["Updated", "tests", "to", "work", "with", "0559b29"], "add_tokens": "for ( var type in specifications ) { var value = specifications [ type ] . compressible it ( type + ' should' + ( value ? ' ' : ' not ' ) + 'be compressible' , function ( ) { assert . equal ( compressible ( type ) , value ) }", "del_tokens": "specifications . forEach ( function ( type ) { var value = type . compressible it ( type . mime + ' should' + ( value ? ' ' : ' not ' ) + 'be compressible' , function ( ) { assert . equal ( compressible ( type . mime ) , value ) } )", "commit_type": "update"}
{"commit_tokens": ["added", "done", "callback", "to", "renderer", "start", "method", "."], "add_tokens": "/ ** * @ param done An optional callback function that gets executed when the springy algorithm stops , * either because it ended or because stop ( ) was called . * / Renderer . prototype . start = function ( done ) { } , done ) ;", "del_tokens": "Renderer . prototype . start = function ( ) { } ) ;", "commit_type": "add"}
{"commit_tokens": ["Added", "a", "type", "check", "to", "properly", "wrap", "polygon", "and", "polyline", "arrays"], "add_tokens": "geometries : ( TYPE === 'POLYGON' || TYPE === 'POLYLINE' ) ? [ oftype . map ( justCoords ) ] : oftype . map ( justCoords ) ,", "del_tokens": "geometries : oftype . map ( justCoords ) ,", "commit_type": "add"}
{"commit_tokens": ["Fix", "this", "on", "bound", "functions"], "add_tokens": "messaging . getLoop ( local . get . bind ( null , res . headers . location ) , q . defer ( messaging . getLoop , local . get . bind ( null , res . headers . location ) ) ; messaging . getLoop ( local . get . bind ( null , res . headers . location ) , messaging . getLoop ( local . get . bind ( null , res . headers . location ) ,", "del_tokens": "messaging . getLoop ( local . get . bind ( res . headers . location ) , q . defer ( messaging . getLoop , local . get . bind ( res . headers . location ) ) ; messaging . getLoop ( local . get . bind ( res . headers . location ) , messaging . getLoop ( local . get . bind ( res . headers . location ) ,", "commit_type": "fix"}
{"commit_tokens": ["Added", "margin", "-", "top", "to", "lookup", "pills", "without", "an", "icon"], "add_tokens": "'<span class=\"slds-pill slds-pill--bare\"{{marginTop}}>' + '<span class=\"slds-pill slds-pill--bare\"{{marginTop}}>' + . replace ( '{{marginTop}}' , ( self . settings . objectIconUrl !== '' ) ? '' : ' style=\"margin-top: 3px\"' ) . replace ( '{{marginTop}}' , ( self . settings . objectIconUrl !== '' ) ? '' : ' style=\"margin-top: 3px\"' )", "del_tokens": "'<span class=\"slds-pill slds-pill--bare\">' + '<span class=\"slds-pill slds-pill--bare\">' +", "commit_type": "add"}
{"commit_tokens": ["Fix", "path", "handling", "for", "windows"], "add_tokens": "const fullBase = base . endsWith ( SEP ) ? base : base + SEP ; let relative = path . substr ( fullBase . length ) ; if ( relative . startsWith ( SEP ) ) relative = relative . substr ( 1 ) ; return relative . replace ( / \\\\ / g , '/' ) ;", "del_tokens": "const fullBase = base . endsWith ( SEP ) ? base + SEP : base ; const relative = path . substr ( fullBase . length ) ; if ( relative . startsWith ( SEP ) ) return relative . substr ( 1 ) ; return relative ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "description", "Readme", ".", "md"], "add_tokens": "return bluff ( salute ( method . bind ( null , path , query , data ) ) ) / ** * Simulate salute behavious . * * @ param { Function } cb * @ see https : //github.com/bredele/salute * @ api private * / function salute ( cb ) { let value try { value = cb ( ) if ( value instanceof Error ) value = Promise . reject ( value ) } catch ( e ) { value = Promise . reject ( e ) } return value }", "del_tokens": "let value try { value = method ( path , query , data ) if ( value instanceof Error ) value = Promise . reject ( value ) } catch ( e ) { value = Promise . reject ( e ) } return bluff ( value )", "commit_type": "add"}
{"commit_tokens": ["Fixing", "issue", "with", "selecting", "rectangle", "not", "sizing", "correctly"], "add_tokens": "let lastSize ; // This accounts for the spacing between selected lines if ( lastSize ) { size . h += s . y - ( lastSize . y + lastSize . h ) ; } lastSize = s ;", "del_tokens": "", "commit_type": "fix"}
{"commit_tokens": ["added", "no", "-", "shadow", "rule"], "add_tokens": "function staticCompiled ( bodyCollection , timeStep , adaptiveTimeStepWeight ) { max = bodyCollection . length ; var body = bodyCollection [ i ] ; var coefficient = timeStep / body . mass ; body . velocity . x += coefficient * body . force . x ; body . velocity . y += coefficient * body . force . y ;", "del_tokens": "function staticCompiled ( bodies , timeStep , adaptiveTimeStepWeight ) { max = bodies . length ; var body = bodies [ i ] ; var coeff = timeStep / body . mass ; body . velocity . x += coeff * body . force . x ; body . velocity . y += coeff * body . force . y ;", "commit_type": "add"}
{"commit_tokens": ["make", "change", "condition", "to", "include", "any", "non", "-", "null", "value"], "add_tokens": "if ( value != null ) {", "del_tokens": "if ( value || value === 0 ) {", "commit_type": "make"}
{"commit_tokens": ["added", "linear", "-", "gradient", "-", "image", "()"], "add_tokens": ", nib = require ( '../' ) . include ( nib . path )", "del_tokens": ". set ( 'paths' , [ __dirname + '/../lib' ] )", "commit_type": "add"}
{"commit_tokens": ["Creates", "the", "deploy", "folder", "if", "it", "doesn", "t", "exist", "already"], "add_tokens": "conn . exec ( 'mkdir -p /tmp/remote_script/; rm -rf /tmp/remote-script/*; tar -x -C /tmp/remote-script' , function ( err , rstdin ) {", "del_tokens": "conn . exec ( 'rm -rf /tmp/remote-script/*; tar -x -C /tmp/remote-script' , function ( err , rstdin ) {", "commit_type": "create"}
{"commit_tokens": ["Adding", "concurrency", "control", "and", "graceful", "shutdown", "support"], "add_tokens": "Colors . wrap ( Colors . cyan , ' %d %s skipped' ) this . writer . write ( Colors . wrap ( Colors . magenta , ' %d max concurrent tests' ) , stats . maxConcurrency )", "del_tokens": "Colors . wrap ( Colors . cyan , ' ' ) + Colors . wrap ( Colors . cyan , ' %d %s skipped' )", "commit_type": "add"}
{"commit_tokens": ["Added", "landing", "page", "and", "navigation"], "add_tokens": "import { Link } from 'react-router' ; import { Menu , MenuItem } from '../../src/components/Menu' ; import { Grid , GridColumn } from '../../src/components/Grid' ; < div className = \"header\" > < Grid > < GridColumn span = { 2 } > < Link to = \"/\" > < Logo / > < / Link > < / GridColumn > < GridColumn span = { 8 } > < Menu > < Link to = \"/components\" > < MenuItem text = \"Components\" / > < / Link > < MenuItem text = \"Style Guide\" / > < / Menu > < / GridColumn > < / Grid > < / div >", "del_tokens": "< div className = \"header\" > < a href = \"http://weave.works\" > < Logo / > < / a > < / div >", "commit_type": "add"}
{"commit_tokens": ["Fixed", "thisArg", "bug", "(", "array", "-", "filter", "array", "-", "map", ")", "and", "added", "tests"], "add_tokens": "if ( ! isMethodCall ( t , declaration . init , 'filter' ) || declaration . init . arguments . length !== 1 ) {", "del_tokens": "if ( ! isMethodCall ( t , declaration . init , 'filter' ) ) {", "commit_type": "fix"}
{"commit_tokens": ["add", "check", "for", "pm2", "env", "/", "master", "mode"], "add_tokens": "if ( cluster . isMaster || process . env . NODE_APP_INSTANCE === 0 || process . env . SPM_MASTER_MODE === 1 ) ) {", "del_tokens": "if ( cluster . isMaster ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "host", "param", "to", "utp", "symmetric", "client"], "add_tokens": "host : this . host", "del_tokens": "address : this . host", "commit_type": "fix"}
{"commit_tokens": ["Add", "log", "methods", "for", "each", "level", "."], "add_tokens": "var name = 'mock-info-logger' ; log . info ( 'mock info message' ) ; var name = 'mock-info-logger' ; log . info ( 'mock info message' ) ; var name = 'mock-info-logger' ; log . info ( 'mock %s message' , 'info' ) ; it ( 'should ignore info with error level' , function ( done ) { var name = 'mock-info-logger' ; var conf = { name : name , level : logger . ERROR } ; log . info ( 'mock %s message to ignore' , 'info' ) ;", "del_tokens": "var name = 'mock-logger' ; log . info ( 'a mock info message' ) ; var name = 'mock-logger' ; log . info ( 'a mock info message' ) ; var name = 'mock-logger' ; log . info ( 'a mock %s message' , 'info' ) ; it ( 'should ignore trace with info level' , function ( done ) { var name = 'mock-logger' ; var conf = { name : name } ; var log = logger ( conf ) ; log . trace ( 'a mock %s message' , 'trace' ) ; done ( ) ; } ) ; it ( 'should ignore debug with info level' , function ( done ) { var name = 'mock-logger' ; var conf = { name : name } ; log . debug ( 'a mock %s message' , 'debug' ) ;", "commit_type": "add"}
{"commit_tokens": ["fixed", "loading", "the", "app", "build", "configuration"], "add_tokens": "let path = require ( 'path' ) ; appDependencies = require ( path . resolve ( '.' , 'app/build.js' ) ) ;", "del_tokens": "appDependencies = require ( './app/build.js' ) ;", "commit_type": "fix"}
{"commit_tokens": ["fixed", "nodes", "/", "edges", "iterators"], "add_tokens": "function cloneEdge ( edge ) { edge [ k ] = ( copy [ k ] || '' ) . toString ( ) ; var aCopies = a . map ( cloneNode ) aCopies . forEach ( fun ) ; a . forEach ( function ( n , i ) { checkNode ( n , aCopies [ i ] ) ; } ) ; return self ; var aCopies = a . map ( cloneEdge ) aCopies . forEach ( fun ) ; a . forEach ( function ( e , i ) { checkEdge ( e , aCopies [ i ] ) ; } ) ; return self ;", "del_tokens": "function cloneEdge ( node ) { edge [ k ] = copy [ k ] . toString ( ) ; return a . map ( cloneNode ) . forEach ( fun ) . forEach ( checkNode ) ; return a . map ( cloneEdge ) . forEach ( fun ) . forEach ( checkEdge ) ;", "commit_type": "fix"}
{"commit_tokens": ["Fix", "a", "misspelled", "variable", "in", "a", "test", "."], "add_tokens": "this . fontInactiveEventCalled_ = 0 ; self . fontInactiveEventCalled_ ++ ; assertEquals ( 0 , this . fontInactiveEventCalled_ ) ; assertEquals ( 0 , this . fontInactiveEventCalled_ ) ; assertEquals ( 1 , this . fontInactiveEventCalled_ ) ; assertEquals ( 0 , this . fontInactiveEventCalled_ ) ; assertEquals ( 3 , this . fontInactiveEventCalled_ ) ; assertEquals ( 1 , this . fontInactiveEventCalled_ ) ; assertEquals ( 3 , this . fontInactiveEventCalled_ ) ;", "del_tokens": "this . fontInactvieEventCalled_ = 0 ; self . fontInactvieEventCalled_ ++ ; assertEquals ( 0 , this . fontInactvieEventCalled_ ) ; assertEquals ( 0 , this . fontInactvieEventCalled_ ) ; assertEquals ( 1 , this . fontInactvieEventCalled_ ) ; assertEquals ( 0 , this . fontInactvieEventCalled_ ) ; assertEquals ( 3 , this . fontInactvieEventCalled_ ) ; assertEquals ( 1 , this . fontInactvieEventCalled_ ) ; assertEquals ( 3 , this . fontInactvieEventCalled_ ) ;", "commit_type": "fix"}
{"commit_tokens": ["use", "locals", "[", "__this__", "]", "to", "refer", "to", "the", "current", "entry"], "add_tokens": "return locals [ '__this__' ] . get ( env , data ) ; return this . value ( { __this__ : this } , env , data , index ) ; return this . attributes [ name ] . get ( { __this__ : this } , env , data ) ; attrs [ attr . id ] = attr . get ( { __this__ : this } , env , data ) ;", "del_tokens": "return locals [ '_this' ] . get ( env , data ) ; return this . value ( { _this : this } , env , data , index ) ; return this . attributes [ name ] . get ( { _this : this } , env , data ) ; attrs [ attr . id ] = attr . get ( { _this : this } , env , data ) ;", "commit_type": "use"}
{"commit_tokens": ["add", "ie", "launcher", "and", "sauce", "cfg", "change"], "add_tokens": ", recordScreenshots : false port : 5757 , logfile : 'sauce_connect.log'", "del_tokens": ", recordScreenshots : true tunnelIdentifier : process . env . TRAVIS_JOB_NUMBER", "commit_type": "add"}
{"commit_tokens": ["Fix", "test", "issues", "related", "to", "upgraded", "jest"], "add_tokens": "if ( dependency ) this . options . onEnable . call ( dependency , e ) if ( dependency ) this . options . onDisable . call ( dependency , e )", "del_tokens": "this . options . onEnable . call ( dependency , e ) this . options . onDisable . call ( dependency , e )", "commit_type": "fix"}
{"commit_tokens": ["Added", "test", "coverage", "for", "stringify", "of", "ISODate", ".", "Removed", "support", "for", "BSONDate", "as", "this", "is", "not", "a", "valid", "MongoShell", "syntax", "(", "will", "require", "major", "version", "bump", ")", "."], "add_tokens": "context ( 'when providing a Date' , function ( ) { it ( 'correctly converts to an ISODate' , function ( ) { var res = parser . parseFilter ( \"{test: Date('2017-01-01T12:35:31.000Z')}\" ) ; var stringified = parser . stringify ( res ) ; assert . equal ( stringified , \"{test: ISODate('2017-01-01T12:35:31.000Z')}\" ) ; } ) ; } ) ; context ( 'when providing an ISODate' , function ( ) { it ( 'correctly converts to an ISODate' , function ( ) { var res = parser . parseFilter ( \"{test: ISODate('2017-01-01T12:35:31.000Z')}\" ) ; var stringified = parser . stringify ( res ) ; assert . equal ( stringified , \"{test: ISODate('2017-01-01T12:35:31.000Z')}\" ) ; } ) ; } ) ;", "del_tokens": "it ( 'should support BSONDate' , function ( ) { assert . deepEqual ( convert ( 'BSONDate(\"2017-01-01T12:35:31.000Z\")' ) , { $date : '2017-01-01T12:35:31.000Z' } ) ; } ) ;", "commit_type": "add"}
{"commit_tokens": ["Allow", "xranges", "in", "hyphen", "range", "and", "dtrt"], "add_tokens": "[ '1 2' , [ [ '>=1.0.0-0' , '<2.0.0-0' , '>=2.0.0-0' , '<3.0.0-0' ] ] ] , [ '1.2 - 3.4.5' , [ [ '>=1.2.0-0' , '<=3.4.5' ] ] ] , [ '1.2.3 - 3.4' , [ [ '>=1.2.3' , '<3.5.0-0' ] ] ]", "del_tokens": "[ '1 2' , [ [ '>=1.0.0-0' , '<2.0.0-0' , '>=2.0.0-0' , '<3.0.0-0' ] ] ]", "commit_type": "allow"}
{"commit_tokens": ["use", "latest", "commit", "hash", "in", "semver"], "add_tokens": "var exec = require ( 'child_process' ) . exec ; var build = 0 ; gulp . task ( 'git-head' , function ( cb ) { exec ( 'git rev-parse HEAD' , function ( err , stdout , stderr ) { build = stdout . substr ( 0 , 7 ) ; cb ( err ) ; } ) } ) gulp . task ( 'scripts' , [ 'git-head' ] , function ( ) { build : build", "del_tokens": "function build ( ) { return moment ( ) . format ( \"YYYYMMDD\" ) + \".\" + ( moment ( ) . diff ( moment ( ) . startOf ( 'day' ) , 'seconds' ) ) ; } gulp . task ( 'scripts' , function ( ) { build : build ( )", "commit_type": "use"}
{"commit_tokens": ["Create", "new", "empty", "data", ".", "xml", "templates"], "add_tokens": "const companyTemplate = path . join ( data , 'templates/company.xml' ) const productTemplate = path . join ( data , 'templates/product.xml' )", "del_tokens": "const companyTemplate = path . join ( data , 'data.xml' ) const productTemplate = path . join ( path . join ( data , 'product' ) , 'data.xml' )", "commit_type": "create"}
{"commit_tokens": ["Improve", "mouse", "event", "generation", "reflecting", "the", "status", "of", "mouse", "buttons"], "add_tokens": "// Dispach mouse event for scroll var newEvent ; newEvent = new MouseEvent ( 'mousemove' , event ) ; newEvent = document . createEvent ( 'MouseEvents' ) ; 'mousemove' , event . bubbles , event . cancelable , event . view , event . detail , chart . canvas . dispatchEvent ( newEvent ) ; beforeInit : function ( chart ) { var canvas = chart . canvas ; var listener = function ( event ) { chart . lastMouseMoveEvent = event ; } ; canvas . addEventListener ( 'mousedown' , listener ) ; canvas . addEventListener ( 'mouseup' , listener ) ; chart . mouseButtonListener = listener ; } , var canvas = chart . canvas ; var listener = chart . mouseButtonListener ; canvas . removeEventListener ( 'mousedown' , listener ) ; canvas . removeEventListener ( 'mouseup' , listener ) ;", "del_tokens": "// Dispach mouse event for scroll chart . canvas . dispatchEvent ( event ) ; var newEvent = document . createEvent ( 'MouseEvents' ) ; event . type , event . bubbles , event . cancelable , event . view , event . detail , chart . canvas . dispatchEvent ( newEvent ) ;", "commit_type": "improve"}
{"commit_tokens": ["add", "save", "and", "load", "cookiejar", "from", "file"], "add_tokens": "var login = function ( ) { } ; jar : jar , jar . _jar = CookieJar . deserializeSync ( json ) ;", "del_tokens": "var defaultOptions = { cookieJson : null } ; if ( options ) defaultOptions = utils . mergeOptions ( defaultOptions , options ) ; var login = function ( ) { var that = this ; if ( defaultOptions . cookieJson ) that . setCookieJarJSON ( defaultOptions . cookieJson ) ; } ; login . prototype . options = defaultOptions ; jar : true , jar . _jar = CookieJar . deserializeSync ( json ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "tests", "for", "CREATE", "and", "DROP", "on", "MMSQL", "client"], "add_tokens": "// MSSQL does not return any information about CREATE queries if ( dbClient === 'sqlserver' ) { expect ( results ) . to . have . length ( 0 ) ; return ; } expect ( result ) . to . have . property ( 'rowCount' ) . to . eql ( undefined ) ; // MSSQL does not return any information about DROP queries if ( dbClient === 'sqlserver' ) { expect ( results ) . to . have . length ( 0 ) ; return ; } expect ( result ) . to . have . property ( 'rowCount' ) . to . eql ( undefined ) ;", "del_tokens": "// MSSQL does not return row count // so this value is based in the number of rows if ( dbClient === 'sqlserver' ) { expect ( result ) . to . have . property ( 'rowCount' ) . to . eql ( 0 ) ; } else { expect ( result ) . to . have . property ( 'rowCount' ) . to . eql ( undefined ) ; } // MSSQL does not return row count // so this value is based in the number of rows if ( dbClient === 'sqlserver' ) { expect ( result ) . to . have . property ( 'rowCount' ) . to . eql ( 0 ) ; } else { expect ( result ) . to . have . property ( 'rowCount' ) . to . eql ( undefined ) ; }", "commit_type": "fix"}
{"commit_tokens": ["fix", "disabled", "button", "in", "vault", ".", "js"], "add_tokens": "< button class = \"btn btn-primary px-4\" id = \"sign-tx\" disabled > < i class = \"fas fa-sign-in-alt\" > < / i > SIGN THIS < / button > < button class = \"btn btn-primary\" id = \"back-to-app\" > < i class = \"fas fa-mobile-alt\" > < / i > Back to app < / button > document . getElementById ( 'main' ) . innerHTML = tmpl ; const transactionCancelSignBtn = document . getElementById ( 'cancel-sign-tx' ) ; const backToAppBtn = document . getElementById ( 'back-to-app' ) ; transactionCancelSignBtn . disabled = false ; transactionSignBtn . addEventListener ( 'click' , signTransaction ) ; transactionCancelSignBtn . addEventListener ( 'click' , ( ) => self . close ( ) ) ; backToAppBtn . addEventListener ( 'click' , ( ) => self . close ( ) ) ;", "del_tokens": "< button class = \"btn btn-primary px-4\" id = \"sign-tx\" disable = \"disable\" > < i class = \"fas fa-sign-in-alt\" > < / i > SIGN THIS < / button > < button class = \"btn btn-primary\" > < i class = \"fas fa-mobile-alt\" > < / i > Back to app < / button > document . getElementById ( 'keyhub-root' ) . innerHTML = tmpl ; document . getElementById ( 'sign-tx' ) . addEventListener ( 'click' , signTransaction )", "commit_type": "fix"}
{"commit_tokens": ["Removed", "old", "dbQuery", "calls", "to", "native", "mongo"], "add_tokens": "db . products . find ( { productPublished : 'true' } ) . toArray ( ( err , products ) => {", "del_tokens": "exports . dbQuery ( db . products , { productPublished : 'true' } , null , null , ( err , products ) => { // run the DB query exports . dbQuery = ( db , query , sort , limit , callback ) => { if ( sort && limit ) { db . find ( query ) . sort ( sort ) . limit ( parseInt ( limit ) ) . toArray ( ( err , results ) => { if ( err ) { console . error ( colors . red ( err ) ) ; } callback ( null , results ) ; } ) ; } else { db . find ( query ) . toArray ( ( err , results ) => { if ( err ) { console . error ( colors . red ( err ) ) ; } callback ( null , results ) ; } ) ; } } ;", "commit_type": "remove"}
{"commit_tokens": ["fix", "node", "10", "and", "12"], "add_tokens": "serialize : function ( value ) { parseValue : function ( value ) { parseLiteral : function ( ast ) {", "del_tokens": "serialize ( value ) { parseValue ( value ) { parseLiteral ( ast ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "prototypical", "inheritance", "with", "statics", "."], "add_tokens": "if ( Object . setPrototypeOf ) { Object . setPrototypeOf ( Subclass , this ) ; } else { Subclass . __proto__ = this ; } addStatics ( proto , Subclass ) ; addStatics ( proto . static , Subclass ) ; function addStatics ( statics , Subclass ) { Object . keys ( statics ) . forEach ( function ( key ) { var descriptor = Object . getOwnPropertyDescriptor ( statics , key ) ;", "del_tokens": "extendStatics ( this , Subclass ) ; extendStatics ( proto , Subclass ) ; extendStatics ( proto . static , Subclass ) ; function extendStatics ( Class , Subclass ) { Object . keys ( Class ) . forEach ( function ( key ) { var descriptor = Object . getOwnPropertyDescriptor ( Class , key ) ;", "commit_type": "use"}
{"commit_tokens": ["remove", "unneeded", "prop", "in", "sample"], "add_tokens": "function MyComponennt ( { t } ) {", "del_tokens": "function MyComponennt ( { t , initialI18nStore } ) {", "commit_type": "remove"}
{"commit_tokens": ["added", "testers", "command", "to", "list", "testers", "status", "/", "details"], "add_tokens": "'returns the locations list JSON' : function ( err , data ) { 'when gets the testers list GET request' : { topic : function ( server ) { get ( '/testers' , server , this . callback ) ; } , 'returns the testers list JSON' : function ( err , data ) { if ( err ) throw err ; data = JSON . parse ( data ) ; assert . deepEqual ( data , ResponseObjects . testers ) ; } } ,", "del_tokens": "'returns the location list JSON' : function ( err , data ) {", "commit_type": "add"}
{"commit_tokens": ["Added", "support", "for", "passing", "a", "function", "as", "the", "log", "option", "instead", "of", "using", "console", ".", "log", "."], "add_tokens": "var log = options . log ? ( _ . isFunction ( options . log ) ? options . log : console . log ) : false ; log ( \"iterations:\" , i , \"training error:\" , error ) ; this . log = opts . log ? ( _ . isFunction ( opts . log ) ? opts . log : console . log ) : false ; this . log ( \"iterations:\" , this . i , \"training error:\" , error ) ;", "del_tokens": "var log = options . log || false ; console . log ( \"iterations:\" , i , \"training error:\" , error ) ; this . log = opts . log || false ; console . log ( \"iterations:\" , this . i , \"training error:\" , error ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "a", "scope", "in", "the", "example", "."], "add_tokens": "wizard : true , scope : 'warcraft'", "del_tokens": "wizard : true", "commit_type": "add"}
{"commit_tokens": ["Add", "support", "for", "JSON", ".", "parse", "reviver"], "add_tokens": "module . exports . special = { types : Object . keys ( module . exports . inflate ) , keys : Object . keys ( module . exports . deflate ) } ; / ** * @ api private * / module . exports . isSpecial = function isSpecial ( value ) { return module . exports . special . types . indexOf ( module . exports . type ( value ) ) > - 1 ; } ; / ** * @ api private * / module . exports . isObject = function isObject ( value ) { return module . exports . type ( value ) === 'Object' ;", "del_tokens": "module . exports . isObject = function isObject ( val ) { return module . exports . type ( val ) === 'Object' ;", "commit_type": "add"}
{"commit_tokens": ["Update", "mapper", "due", "to", "changes", "in", "grammar"], "add_tokens": "const orderArguments = limit => ( values ) => { if ( ! values || values . length === 0 ) { const sinlge = values . length === 1 || values . slice ( 1 ) . every ( isAbsent ) ; return [ values [ 1 ] , values [ 0 ] , ... values . slice ( 2 , limit ) ] ; } ; const orderRollArguments = orderArguments ( 3 ) ; const orderWodRollArguments = orderArguments ( 5 ) ; const values = orderRollArguments ( map ( result ) ) ; const values = orderWodRollArguments ( map ( result ) ) ;", "del_tokens": "function orderArguments ( values ) { if ( ! values ) { const sinlge = values . length === 1 || ( values . length === 2 && isAbsent ( values [ 1 ] ) ) ; return [ values [ 1 ] , values [ 0 ] , ... values . slice ( 2 , 5 ) ] ; } const values = orderArguments ( map ( result ) ) ; const values = orderArguments ( map ( result ) ) ;", "commit_type": "update"}
{"commit_tokens": ["added", "slightly", "better", "error", "logging"], "add_tokens": "self . client . emit ( 'error' , new Error ( 'Invalid response code ' + res . statusCode + ' from tracker ' + requestUrl ) ) self . client . emit ( 'error' , new Error ( message + ' (connecting to tracker ' + requestUrl + ')' ) )", "del_tokens": "self . client . emit ( 'error' , new Error ( 'Invalid response code ' + res . statusCode + ' from tracker' ) ) self . client . emit ( 'error' , new Error ( message ) )", "commit_type": "add"}
{"commit_tokens": ["Remove", "console", "muting", "from", "minitest", "-", "it", "s", "actually", "a", "bad", "idea"], "add_tokens": "Suite . prototype . run = function ( context ) {", "del_tokens": "Suite . prototype . run = function ( context ) { muteConsole ( ) ; this . log = originalLog ; this . error = originalError ; unmuteConsole ( ) ; unmuteConsole ( ) ; muteConsole ( ) ; var originalLog = console . log ; var originalError = console . error ; var originalInfo = console . info ; var originalWarn = console . warn ; var muteConsole = function ( ) { console . log = function ( ) { } ; console . error = function ( ) { } ; console . info = function ( ) { } ; console . warn = function ( ) { } ; } ; var unmuteConsole = function ( ) { console . log = originalLog ; console . error = originalError ; console . info = originalInfo ; console . warn = originalWarn ; }", "commit_type": "remove"}
{"commit_tokens": ["Added", "hammer", "hanging", "man", "and", "shooting", "star", "patterns", "to", "bearish", "and", "bullish", "indicators", "."], "add_tokens": "import BearishHammerStick from './BearishHammerStick' ; import BearishInvertedHammerStick from './BearishInvertedHammerStick' ; import HangingMan from './HangingMan' ; import HangingManUnconfirmed from './HangingManUnconfirmed' ; import ShootingStar from './ShootingStar' ; import ShootingStarUnconfirmed from './ShootingStarUnconfirmed' ; let bearishPatterns = [ new BearishEngulfingPattern ( ) , new BearishHarami ( ) , new BearishHaramiCross ( ) , new EveningDojiStar ( ) , new EveningStar ( ) , new BearishMarubozu ( ) , new ThreeBlackCrows ( ) , new BearishHammerStick ( ) , new BearishInvertedHammerStick ( ) , new HangingMan ( ) , new HangingManUnconfirmed ( ) , new ShootingStar ( ) , new ShootingStarUnconfirmed ( ) , ] ;", "del_tokens": "let bearishPatterns = [ new BearishEngulfingPattern ( ) , new BearishHarami ( ) , new BearishHaramiCross ( ) , new EveningDojiStar ( ) , new EveningStar ( ) , new BearishMarubozu ( ) , new ThreeBlackCrows ( ) ] ;", "commit_type": "add"}
{"commit_tokens": ["Update", "postRequest", "signature", "to", "allow", "options", "to", "be", "passed"], "add_tokens": "postRequest ( this . options . accessUrl , payload , this . options , function ( error , response , body ) { function postRequest ( url , payload , params , callback ) { for ( var customHeaderName in params . customHeaders ) { req . setHeader ( customHeaderName , params . customHeaders [ customHeaderName ] ) ;", "del_tokens": "postRequest . call ( this , this . options . accessUrl , payload , function ( error , response , body ) { function postRequest ( url , payload , callback ) { for ( var customHeaderName in this . options . customHeaders ) { req . setHeader ( customHeaderName , this . options . customHeaders [ customHeaderName ] ) ;", "commit_type": "update"}
{"commit_tokens": ["Removed", "ngn", "-", "core", "filter", "so", "it", "will", "load", "."], "add_tokens": "if ( fs . existsSync ( mod ) ) {", "del_tokens": "if ( _mod !== 'ngn-core' && fs . existsSync ( mod ) ) {", "commit_type": "remove"}
{"commit_tokens": ["Removing", "script", "-", "dynamic", "for", "Firefox", "compatibility"], "add_tokens": "value : \"sandbox allow-same-origin allow-modals allow-scripts; default-src 'none'; base-uri 'none'; form-action 'none'; frame-ancestors 'none'; manifest-src 'self'; style-src 'self'; img-src 'self'; media-src 'self'; font-src 'self'; frame-src 'none'; worker-src blob: data:; child-src blob: data:; script-src blob: 'self' 'sha384-rPMBYwDhb6zrv3/mO71SlMxpVbRnWUX4Brw4sLnlTGd3OcEFZjcRHS0L2yTUHq4Q'; connect-src 'self' https://nxt1.vault.keyhub.app; require-sri-for script style\" ,", "del_tokens": "value : \"sandbox allow-same-origin allow-modals allow-scripts; default-src 'none'; base-uri 'none'; form-action 'none'; frame-ancestors 'none'; manifest-src 'self'; style-src 'self'; img-src 'self'; media-src 'self'; font-src 'self'; frame-src 'none'; worker-src blob: data:; child-src blob: data:; script-src 'self' blob: 'sha384-rPMBYwDhb6zrv3/mO71SlMxpVbRnWUX4Brw4sLnlTGd3OcEFZjcRHS0L2yTUHq4Q' 'strict-dynamic'; connect-src 'self' https://nxt1.vault.keyhub.app; require-sri-for script style\" ,", "commit_type": "remove"}
{"commit_tokens": ["add", "socket", ".", "io", "and", "send", "cookie", "info", "to", "chrome", "extension"], "add_tokens": "var socketIOLogger = log4js . getLogger ( 'socket.io' ) ; var cookie = require ( 'cookie' ) ; result . cookiesData = cookie . parse ( query . c ) ; // logger.debug(result); socketIOLogger . info ( result ) ; log4js . addAppender ( require ( '../lib/log4js-socket-io-appender' ) . appender ( io ) , 'socket.io' ) ; io . on ( 'connection' , function ( socket ) { //socketIOLogger.trace('user connected'); socket . on ( 'disconnect' , function ( ) {", "del_tokens": "var socketIoLogger = log4js . getLogger ( 'socket.io' ) ; var serveStatic = require ( 'koa-static' ) ; app . use ( serveStatic ( __dirname + '/../client' ) ) ; logger . debug ( result ) ; io . on ( 'connection' , function ( ) { socketIoLogger . trace ( 'user connected' ) ; io . on ( 'disconnect' , function ( ) {", "commit_type": "add"}
{"commit_tokens": ["Add", "regex", "string", "for", "Mac", "and", "Windows", "line", "endings", "."], "add_tokens": "/ ** * Windows or Mac style line endings shouldn ' * However , I was unable to parse the CSS without adding a carriage return . * To avoid conflicting with a build on a Linux system I added a check to make sure we ' * / const IS_WIN_OR_MAC = ( process . platform == \"win32\" || process . platform == \"darwin\" ) const CSS_PARSE_REGEX = IS_WIN_OR_MAC ? / \\-(.*)\\:before.*\\r\\n\\s*content: \"(.*)\" / gm : / \\-(.*)\\:before.*\\n\\s*content: \"(.*)\" / gm", "del_tokens": "const util = require ( 'util' ) const CSS_PARSE_REGEX = / \\-(.*)\\:before.*\\n\\s*content: \"(.*)\" / gm", "commit_type": "add"}
{"commit_tokens": ["Remove", "always", "false", "if", "statement"], "add_tokens": "// Pure request error (bad connection, wrong url, etc)", "del_tokens": "// Pure request error (bad connection, wrong url, etc) if ( error ) { return { errorType : 0 , error : error } ; }", "commit_type": "remove"}
{"commit_tokens": ["fixes", "tspan", "update", "race", "condition"], "add_tokens": ". attr ( \"dominant-baseline\" , \"alphabetic\" ) . style ( \"baseline-shift\" , \"0%\" ) . attr ( \"opacity\" , 0 ) . call ( tspanStyle ) . merge ( tspans ) . transition ( t ) . delay ( that . _delay ) . call ( tspanStyle )", "del_tokens": ". attr ( \"dominant-baseline\" , \"alphabetic\" ) . style ( \"baseline-shift\" , \"0%\" ) . attr ( \"opacity\" , 0 ) . call ( tspanStyle ) . transition ( t ) . delay ( that . _delay )", "commit_type": "fix"}
{"commit_tokens": ["Adds", "toggleSelect", "/", "Collapse", "methods"], "add_tokens": "node . toggleSelect ( ) ; node . toggleCollapse ( ) ;", "del_tokens": "// Toggle selected state if ( node . selected ( ) ) { node . deselect ( ) ; } else { node . select ( ) ; } var node = getNodeFromTitleDOMElement ( event . target ) ; // Toggle selected state if ( node . collapsed ( ) ) { node . expand ( ) ; } else { node . collapse ( ) ; }", "commit_type": "add"}
{"commit_tokens": ["make", "sure", "setImmediate", "is", "a", "function"], "add_tokens": "var nextTick = typeof setImmediate === 'function' && setImmediate || process . nextTick ;", "del_tokens": "var nextTick = setImmediate || process . nextTick ;", "commit_type": "make"}
{"commit_tokens": ["Fix", "to", "catch", "redis", "module", "s", "double", "-", "submit", "of", "wrapped", "commands", ".", "ID", "mismatch", "was", "preventing", "trace", "ends", "from", "being", "detected", "."], "add_tokens": "if ( ! data [ id ] && ! cmd . __iopipeTraceId ) {", "del_tokens": "if ( ! cmd . __iopipeTraceId ) { // console.log('applying id to command!', id); } if ( ! data [ id ] ) { // console.log('@@@@@'); // console.log('timestamp', new Date().getTime()); // console.log(id, data[id].name, data[id].request.key); // console.log('cmd,', cmd); // console.log('@@@@@'); // //console.log('CALLED!', id, cmd, arguments)", "commit_type": "fix"}
{"commit_tokens": ["Fixed", "a", "bug", "in", "aSearchColumns", "logic"], "add_tokens": "var searchArray = [ ] , customColumns = _u . isArray ( self . aSearchColumns ) && ! _u . isEmpty ( self . aSearchColumns ) && global ; _u . each ( customColumns ? self . aSearchColumns : requestQuery . columns , function ( column ) { if ( customColumns || column . searchable === 'true' ) { var colName = sanitize ( customColumns ? column : column . name ) , searchVal = sanitize ( global ? requestQuery . search . value : column . search . value ) ; if ( colName && searchVal ) { searchArray . push ( self . dbType === 'postgres' ? buildILIKESearch ( colName , searchVal ) : buildLIKESearch ( colName , searchVal ) ) ; }", "del_tokens": "var searchArray = [ ] ; _u . each ( requestQuery . columns , function ( column , i ) { var colName = sanitize ( self . aSearchColumns [ i ] || column . name ) , searchVal = sanitize ( global ? requestQuery . search . value : column . search . value ) ; if ( colName && searchVal && column . searchable === 'true' ) { searchArray . push ( self . dbType === 'postgres' ? buildILIKESearch ( colName , searchVal ) : buildLIKESearch ( colName , searchVal ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "raw", "version", "of", "fetch"], "add_tokens": "return fetch . raw ( url , {", "del_tokens": "return get ( url , {", "commit_type": "add"}
{"commit_tokens": ["Updated", "the", "intellisense", "for", "latest", "version", "of", "typescript", "."], "add_tokens": "var elPageContent = ( document . querySelector ( \"input[id$='RichHtmlField_hiddenDisplay']\" ) || document . querySelector ( \"input[id$='TextField_spSave']\" ) ) ; // Return true, if the content element exists return elPageContent != null ;", "del_tokens": "var elPageContent = document . querySelector ( \"input[id$='RichHtmlField_hiddenDisplay']\" ) ; // Return true, if the content elements were found return elWPContent != null && elPageContent != null ;", "commit_type": "update"}
{"commit_tokens": ["Fix", "race", "condiiton", "with", "boides", "in", "physics", "-", "collider"], "add_tokens": "if ( ! ( this . el . body && this . el . body . world ) ) return", "del_tokens": "if ( ! this . el . body ) return", "commit_type": "fix"}
{"commit_tokens": ["Add", "Promise", ".", "promisifyAll", "()", "and", ".", "asCallback", "()"], "add_tokens": "const extendStaticMembers = require ( './static-members' ) ; const extendInstaceMembers = require ( './instance-members' ) ; extendStaticMembers ( Promise ) ; extendInstaceMembers ( Promise ) ; module . exports = Promise ;", "del_tokens": "import './static-members' ; import './instance-members' ;", "commit_type": "add"}
{"commit_tokens": ["Use", "wp", "-", "error", "module", "for", "common", "Error", "handling", "logic"], "add_tokens": "var WPError = require ( 'wp-error' ) ; var wpe = WPError ( xhr . params , statusCode , body ) ; reject ( xhr , wpe ) ;", "del_tokens": "var err = new Error ( ) ; err . statusCode = statusCode ; for ( var i in body ) err [ i ] = body [ i ] ; if ( body . error ) err . name = toTitle ( body . error ) + 'Error' ; reject ( xhr , err ) ; function toTitle ( str ) { if ( ! str || 'string' !== typeof str ) return '' ; return str . replace ( / ((^|_)[a-z]) / g , function ( $1 ) { return $1 . toUpperCase ( ) . replace ( '_' , '' ) ; } ) ; }", "commit_type": "use"}
{"commit_tokens": ["fixed", "a", "minor", "bug", "when", ".", "This", "occurs", "with", "jack4it", "/", "system", "-", "less"], "add_tokens": "if ( typeof module . importers == 'undefined' || module . importers . length === 0 ) {", "del_tokens": "if ( module . importers . length === 0 ) {", "commit_type": "fix"}
{"commit_tokens": ["Use", "relative", "path", "to", "link", "to", "tf", "shared", "libs"], "add_tokens": "await symlink ( path . relative ( path . dirname ( destLibPath ) , depsLibTensorFlowPath ) , destLibPath ) ; await symlink ( path . relative ( path . dirname ( destFrameworkLibPath ) , depsLibTensorFlowFrameworkPath ) , destFrameworkLibPath ) ;", "del_tokens": "await symlink ( depsLibTensorFlowPath , destLibPath ) ; await symlink ( depsLibTensorFlowFrameworkPath , destFrameworkLibPath ) ;", "commit_type": "use"}
{"commit_tokens": ["Make", "path", "absolute", "for", "the", "includePaths"], "add_tokens": "address . replace ( 'file:' , '' ) . replace ( '.js' , '' )", "del_tokens": "path . relative ( file . base , address . replace ( 'file:' , '' ) . replace ( '.js' , '' ) )", "commit_type": "make"}
{"commit_tokens": ["Make", "the", "startAt", "numbering", "an", "options", "field"], "add_tokens": "QueryBuilder . prototype . toParam = function ( options ) { var block , blocks , i , old , result , _ref5 ; if ( options == null ) { options = void 0 ; } old = this . options ; if ( options != null ) { this . options = _extend ( { } , this . options , options ) ; if ( this . options . numberedParameters || ( ( options != null ? options . numberedParametersStartAt : void 0 ) != null ) ) { this . options = old ;", "del_tokens": "QueryBuilder . prototype . toParam = function ( startNumberingAt ) { var block , blocks , i , result , _ref5 ; if ( startNumberingAt == null ) { startNumberingAt = void 0 ; if ( this . options . numberedParameters || ( startNumberingAt != null ) ) { if ( startNumberingAt != null ) { i = startNumberingAt ; }", "commit_type": "make"}
{"commit_tokens": ["Fix", "bug", "with", "escaped", "curly", "brackets", "in", "last", "segment"], "add_tokens": "const template = 'http://example.com/{type}?brackets=\\\\{\\\\}&page={first}'", "del_tokens": "const template = 'http://example.com/{type}?brackets=\\\\{}&page={first}'", "commit_type": "fix"}
{"commit_tokens": ["adding", "filename", "option", "for", "jade", "server", "side", "render", "-", "required", "if", "includes", "are", "used"], "add_tokens": "server = compiler . compile ( template , { filename : filename // Required for includes and used for debugging. } ) ; filename : filename // Required for includes and used for debugging.", "del_tokens": "server = compiler . compile ( template ) ; filename : filename // Used for debugging.", "commit_type": "add"}
{"commit_tokens": ["add", "colors", "module", "use", "log", "with", "color", "."], "add_tokens": ", fs = require ( 'fs' ) , colors = require ( 'colors' ) ;", "del_tokens": ", fs = require ( 'fs' ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "var", "instead", "of", "const", "on", "server"], "add_tokens": "var ROUTES = [", "del_tokens": "const ROUTES = [", "commit_type": "use"}
{"commit_tokens": ["Fix", "build", "broken", "by", "typings"], "add_tokens": ". map ( name => path_1 . join ( location , name ) ) . filter ( path => fs_1 . lstatSync ( path ) . isDirectory ( ) ) . map ( directory => { comparison . diffSet . filter ( diff => diff . state !== \"equal\" ) . map ( diff => { right : \"<-\" } ) ) . then ( differences => process . exit ( differences . filter ( differenceCount => differenceCount > 0 ) . length ) ) ;", "del_tokens": ". map ( ( name ) => path_1 . join ( location , name ) ) . filter ( ( path ) => fs_1 . lstatSync ( path ) . isDirectory ( ) ) . map ( ( directory ) => { comparison . diffSet . filter ( ( diff ) => diff . state !== \"equal\" ) . map ( ( diff ) => { right : \"<-\" , } ) ) . then ( ( differences ) => process . exit ( differences . filter ( ( differenceCount ) => differenceCount > 0 ) . length ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["Added", "symlinks", "copy", "in", "copySync"], "add_tokens": "function copySync ( src , dest , filter , recursive ) { recursive = recursive || false ; var stats = recursive ? fs . lstatSync ( src ) : fs . statSync ( src ) , copySync ( src + \"/\" + content , dest + \"/\" + content , filter , true ) ; } else if ( recursive && stats . isSymbolicLink ( ) ) { var srcPath = fs . readlinkSync ( src ) ; fs . symlinkSync ( srcPath , dest ) ;", "del_tokens": "function copySync ( src , dest , filter ) { var stats = fs . lstatSync ( src ) , copySync ( src + \"/\" + content , dest + \"/\" + content , filter ) ;", "commit_type": "add"}
{"commit_tokens": ["Use", "Cly", "to", "execute", "shell", "commands", "."], "add_tokens": "cly = require ( 'cly' ) ; cly . exec ( command , true , cb ) ;", "del_tokens": "child_process = require ( 'child_process' ) ; function _exec ( command , cb ) { child = child_process . exec ( command , function ( err , stdout , stderr ) { if ( err ) { console . error ( stderr ) ; // mask error as ok, to allow async.series to execute all tasks cb ( null , err ) ; } else { console . log ( stdout ) ; cb ( null , { status : 'ok' } ) ; } } ) ; } _exec ( command , cb ) ;", "commit_type": "use"}
{"commit_tokens": ["Make", "nested", "content", "test", "fail", "by", "introducing", "objects", "that", "don", "t", "get", "converted", "to", "immutable", "yet", "."], "add_tokens": "predicate : function ( array , args , innerArray , obj ) { args . push ( obj ) ; // Get an object in there too specifiers : [ JSC . array ( ) , JSC . object ( ) ] predicate : function ( array , args , innerArray , obj ) { args . push ( obj ) ; // Get an object in there too specifiers : [ JSC . array ( ) , JSC . object ( ) ]", "del_tokens": "predicate : function ( array , args , innerArray ) { specifiers : [ JSC . array ( ) ] predicate : function ( array , args , innerArray ) { specifiers : [ JSC . array ( ) ]", "commit_type": "make"}
{"commit_tokens": ["added", "filterCount", "to", "FilterTree", ".", "prototype"], "add_tokens": "var FilterNode = Base . extend ( 'FilterNode' , {", "del_tokens": "var FilterNode = Base . extend ( {", "commit_type": "add"}
{"commit_tokens": ["fix", "mime", "-", "type", "detection", "by", "properly", "replacing", "whitespace", "in", "filenames"], "add_tokens": "var fileName = file . name . replace ( / \\ / g , \"_\" ) ;", "del_tokens": "var fileName = file . name . replace ( / [^\\w] / g , \"_\" ) ;", "commit_type": "fix"}
{"commit_tokens": ["add", "start", "/", "stop", "/", "remove", "hooks", "on", "kCore", "emitter"], "add_tokens": "Port = require ( 'kevoree-entities' ) . Port ; // the component is not related to the current platform, just add the input for the channel", "del_tokens": "Port = require ( 'kevoree-entities' ) . Port , Kotlin = require ( 'kevoree-kotlin' ) ; // the component is not related to the current platform, just add the input the channel", "commit_type": "add"}
{"commit_tokens": ["added", "some", "docs", "(", "mousecaptor", ".", "js", ")"], "add_tokens": "* { @ link startZooming } with the event delta as parameter . * @ param { event } event A 'wheel' mouse event . / ** * Will start computing the scene X and Y , until { @ link stopDrag } is * triggered . * / / ** * Stops computing the scene position . * / / ** * Computes the position of the scene , relatively to the mouse position , and * dispatches a \"drag\" event . * / / ** * Will start computing the scene zoom ratio , until { @ link stopZooming } is * triggered . * @ param { number } delta The delta from the mouse event that triggered the * zoom . * / / ** * Stops computing the scene zooming ratio . * / / ** * Computes the zooming ratio of the scene , relatively to the last mouse * event delta received , and dispatches a \"zooming\" event . * /", "del_tokens": "* startZooming ( ) with the event delta as parameter . * @ param { event } event A 'down' mouse event .", "commit_type": "add"}
{"commit_tokens": ["Changed", "the", "way", "typeOf", "(", "Object", ")", "worked"], "add_tokens": "if ( Class === Object ) { return context . subjectType === \"Object\" ; }", "del_tokens": "if ( Class === Object ) { // If we're checking for an object, primitive types are treated as objects. // This is not true in pure JavaScript, but since you can write // var num = 3; num.toString(); I think it's legitimate to treat them as objects. return true ; }", "commit_type": "change"}
{"commit_tokens": ["adding", "support", "for", "agree", "to", "terms", "in", "register"], "add_tokens": "var agree = args . a || args . agree ; if ( ! agree ) ask . push ( module . exports . questions . agreed_to_tc ) ; } , \"agreed_to_tc\" : { key : \"agreed_to_tc\" , question : \"agree to the terms and privacy policy? https://pinocc.io/terms and https://pinocc.io/privacy \\n(y/n):\" , cb : function ( input , next ) { input = ( input || '' ) . trim ( ) . toLowerCase ( ) ; if ( input === \"y\" ) { next ( 1 ) ; } else { if ( input !== 'n' ) console . log ( 'please enter y for yes or n for no' ) ; else console . log ( 'aww man but we are super nice people!' ) process . exit ( ) ; } } + \" -a --agree\\n\" + \" agree to terms and privacy policy https://pinocc.io/terms and https://pinocc.io/privacy\\n\"", "del_tokens": "", "commit_type": "add"}
{"commit_tokens": ["moving", "test", "to", "bottom", "of", "layout"], "add_tokens": "< Optimized / >", "del_tokens": "< Optimized / >", "commit_type": "move"}
{"commit_tokens": ["adds", "force", "method", "to", "question"], "add_tokens": "if ( msg [ msg . length - 1 ] !== '?' ) msg += '?' ; return '<Question \"' + msg + '\" <' + val + '>>' ; / ** * Force the question to be asked . * * ` ` ` js * question . options . force = true ; * question . isForced ( ) ; * //=> true * ` ` ` * @ return { Boolean } * @ api public * / Question . prototype . force = function ( ) { this . options . force = true ; return this ; } ;", "del_tokens": "if ( msg [ msg . length - 1 ] !== '?' ) { msg += '?' ; } var answer = '<' + val + '>' ; return '<Question \"' + msg + '\" ' + answer + '>' ;", "commit_type": "add"}
{"commit_tokens": ["Removed", "iframe", "removal", ".", "This", "was", "causing", "issues", "for", "Firefox", "under", "certain", "conditions", ".", "I", "don", "t", "think", "it", "will", "cause", "any", "issues", "other", "than", "potentially", "make", "a", "mess", "of", "the", "DOM", "(", "big", "deal?", ")"], "add_tokens": "* jQuery File Download Plugin v1 .3 .3", "del_tokens": "* jQuery File Download Plugin v1 .3 .2 if ( $iframe ) { $iframe . remove ( ) ; }", "commit_type": "remove"}
{"commit_tokens": ["change", "test", "platform", "(", "same", "as", "browser", "sol", ")"], "add_tokens": "'platform' : 'OS X 10.10' , 'version' : '8.0' ,", "del_tokens": "'platform' : 'OS X 10.11' , 'version' : '9.0' ,", "commit_type": "change"}
{"commit_tokens": ["fixed", "bugs", "in", "internal", "utility", "functions"], "add_tokens": "return ( pluginB . priority || 0 ) - ( pluginA . priority || 0 ) ;", "del_tokens": "return pluginB . priority - pluginA . priority ;", "commit_type": "fix"}
{"commit_tokens": ["Add", "config", "support", "for", "checking", "for", "thrown", "errors"], "add_tokens": "Chai . should ( ) ; let expect = expected [ index ] , result ; if ( expect === \"An error\" ) { result = ( ) => getOpts . apply ( null , args ) ; assert . throw ( result , \"Attempting to reassign option\" ) ; } else { result = getOpts . apply ( null , args ) ; assert . deepEqual ( result , expected [ index ] ) ; }", "del_tokens": "let result = getOpts . apply ( null , args ) ; assert . deepEqual ( result , expected [ index ] ) ;", "commit_type": "add"}
{"commit_tokens": ["Add", "inDegree", "and", "outDegree", "to", "nodes"], "add_tokens": "function inDegree ( ) { return inEdges ( ) . length ; } function outDegree ( ) { return outEdges ( ) . length ; } function edges ( ) { return inEdges ( ) . concat ( outEdges ( ) ) ; } inDegree : inDegree , outDegree : outDegree ,", "del_tokens": "function edges ( ) { return inEdges ( ) . concat ( outEdges ( ) ) ; }", "commit_type": "add"}
{"commit_tokens": ["improving", "frame", "color", "for", "terminal", "theme"], "add_tokens": ", frame : colors . brightGreen", "del_tokens": ", frame : colors . blue", "commit_type": "improve"}
{"commit_tokens": ["Fixed", ":", "Allow", "type", "on", "return", "or", "parameter", "type", "to", "be", "a", "class", "if", "superclass", "or", "protocol", "declared", "it", "as", "id"], "add_tokens": "if ( returnType !== types [ 0 ] && ! ( returnType === 'id' && node . returntype . typeisclass ) ) if ( parameterType !== types [ i ] && ! ( parameterType === 'id' && nodeArguments [ i - 1 ] . type . typeisclass ) ) compiler . addWarning ( createMessage ( \"Conflicting parameter types in implementation of '\" + selector + \"': '\" + parameterType + \"' vs '\" + types [ i ] + \"'\" , nodeArguments [ i - 1 ] . type || nodeArguments [ i - 1 ] . identifier , compiler . source ) ) ;", "del_tokens": "if ( returnType !== types [ 0 ] ) if ( parameterType !== types [ i ] ) compiler . addWarning ( createMessage ( \"Conflicting parameter types in implementation of '\" + selector + \"': '\" + parameterType + \"' vs '\" + types [ i ] + \"'\" , node . arguments [ i - 1 ] . type || node . arguments [ i - 1 ] . identifier , compiler . source ) ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "paper", ">>", "resetCells", "()", "so", "that", "links", "are", "added", "always", "after", "elements", "and", "then", "resorted", "according", "to", "z"], "add_tokens": "// Make all the events fired in the `cells` collection available. if ( ! json . cells ) { throw new Error ( 'Graph JSON must contain cells array.' ) ;", "del_tokens": "this . set ( 'paper' , new Backbone . Model ) ; // Make all the events fired in either the `paper` model or the `cells` collection available if ( ! json . paper || ! json . cells ) { throw new Error ( 'Graph JSON must contain paper and cells properties.' ) ;", "commit_type": "fix"}
{"commit_tokens": ["fix", "long", "polling", "bug", "."], "add_tokens": "longpolling = consumer . fetchCount !== 0 ;", "del_tokens": "longpolling = consumer . fetchCount !== 1 ;", "commit_type": "fix"}
{"commit_tokens": ["update", "jsdoc", "with", "new", "methods", "by", "running", "YUIdoc"], "add_tokens": "* Triggers the given event on this . * * @ method trigger * @ method on * * @ method off *", "del_tokens": "* Trigger the given event on this .", "commit_type": "update"}
{"commit_tokens": ["Fixed", "AMD", "anonymous", "module", "support", "and", "overloading", "static", "accessor", "methods"], "add_tokens": "define ( [ ] , factory ) ; root = typeof ( root ) !== 'undefined' ? root : { } ; return root ;", "del_tokens": "define ( 'JOII' , [ ] , factory ) ;", "commit_type": "fix"}
{"commit_tokens": ["Changed", "Math", ".", "pi", "to", "Math", ".", "PI", ".", "Now", "tests", "are", "ok", "."], "add_tokens": "L . setOptions ( this , options ) ; / ** * * @ method _project * / _project : function ( ) { } , / ** * Update the path * @ method _update * / _update : function ( ) { this . _setPath ( ) ; } , / ** * Set the Path * @ method _setPath * / _setPath : function ( ) { this . _path . setAttribute ( 'd' , this . getPathString ( ) ) ; } , return ( ( value / 40075017 ) * 360 ) / Math . cos ( ( Math . PI / 180 ) * this . _latlng . lat ) ;", "del_tokens": "L . Path . prototype . initialize . call ( this , options ) ; return ( ( value / 40075017 ) * 360 ) / Math . cos ( L . LatLng . DEG_TO_RAD * this . _latlng . lat ) ;", "commit_type": "change"}
{"commit_tokens": ["Added", "the", "ability", "to", "build", "registry", "containers", "."], "add_tokens": "var registryBuilder = require ( './registryBuilder' ) ( config , os . platform ( ) ) ; out . stdout ( '--> building' ) ; var func ; if ( cdef . repositoryUrl ) { func = builder . build ; } else if ( cdef . specific . name ) { func = registryBuilder . build ; } func ( mode , system , cdef , out , function ( err , specific ) { cdef . specific . imageTag = specific . imageTag ;", "del_tokens": "out . stdout ( 'building' ) ; builder . build ( mode , system , cdef , out , function ( err , specific ) {", "commit_type": "add"}
{"commit_tokens": ["fixed", "the", "whole", "instance", "stuff"], "add_tokens": "this . model = TodoModel ; this . view = TodoView ; this . store = TodoStore ;", "del_tokens": "this . model = TodoModel . sub ( ) ; this . view = TodoView . sub ( ) ; this . store = TodoStore . sub ( ) ;", "commit_type": "fix"}
{"commit_tokens": ["added", "query", "support", "to", "get", "devices"], "add_tokens": "var fetch = { } ; // Loop through parameters to update device for ( var param in req . query ) { // console.log(param, req.params[param]); fetch [ param ] = req . query [ param ] ; } if ( req . query . online ) { fetch [ \"online\" ] = Boolean ( ( req . query . online == \"true\" ) ) ; } devices . find ( fetch , function ( err , devicedata ) {", "del_tokens": "devices . find ( { // uuid: {\"$regex\":req.params.uuid,\"$options\":\"i\"} } , function ( err , devicedata ) {", "commit_type": "add"}
{"commit_tokens": ["Fixed", "multi", "-", "same", "-", "arg", "query", "and", "async", "loading"], "add_tokens": "if ( typeof uri === 'string' || Array . isArray ( uri ) ) { if ( uri . query && ( typeof uri . query === 'object' ) && nested < 4 ) { // Loaded sources in order return _ . reduce ( sources , function ( promise , src ) { return promise . then ( function ( ) { return tilelive . loadAsync ( src . uri ) . then ( function ( handler ) { src . handler = handler ; return true ; } ) ; } ) ; } , BBPromise . resolve ( ) ) . return ( sources ) ; } ;", "del_tokens": "if ( typeof uri === 'string' ) { if ( uri . query && ( typeof uri . query === 'object' ) && nested < 2 ) { return BBPromise . all ( _ . map ( sources , function ( src ) { return tilelive . loadAsync ( src . uri ) . then ( function ( handler ) { src . handler = handler ; return true ; } ) ; } ) ) . return ( sources ) ; } ;", "commit_type": "fix"}
{"commit_tokens": ["Make", "logClientError", "to", "use", "v3", "endpoint"], "add_tokens": "` ${ this . url } ` ,", "del_tokens": "` ${ this . getBaseRoute ( ) } ` ,", "commit_type": "make"}
{"commit_tokens": ["Add", "support", "for", "block", "src", "argument"], "add_tokens": "var code ; if ( ! ! blk . kwargs . src ) { code = fs . readFileSync ( blk . kwargs . src , \"utf8\" ) ; } else { code = blk . body ; }", "del_tokens": "var code = blk . body ;", "commit_type": "add"}
{"commit_tokens": ["adding", "on", "-", "exit", "feature"], "add_tokens": "* on process exit , instead of ( or in addition to ) writing to the console , throw all the exceptions that were caught by the test var test = new UnitTest ( testResults ) process . on ( 'exit' , function ( ) { if ( ! testResults . tester . resultsAccessed ) { test . writeConsole ( ) throw Error ( \"Deadunit test results never accessed - something is amiss...\" ) } } ) return test", "del_tokens": "return new UnitTest ( testResults )", "commit_type": "add"}
{"commit_tokens": ["Fix", "silent", "-", "error", "deprecation", "."], "add_tokens": "var SilentError = require ( 'silent-error' ) ;", "del_tokens": "var SilentError = this . project . require ( 'ember-cli/lib/errors/silent' ) ;", "commit_type": "fix"}
{"commit_tokens": ["remove", "clear", "since", "background", "is", "solid"], "add_tokens": "this . _ctx . fillStyle = 'white' ; this . _ctx . fillRect ( 0 , 0 , 160 , 144 ) ;", "del_tokens": "this . clear ( ) ; clear ( ) { this . _ctx . fillStyle = 'white' ; this . _ctx . fillRect ( 0 , 0 , 160 , 144 ) ; }", "commit_type": "remove"}
{"commit_tokens": ["added", "support", "for", "additional", "header", "values", "in", "content", "type"], "add_tokens": "if ( response . type . includes ( 'application/json' ) ) { if ( request . body && xhr . getResponseHeader ( 'Content-Type' ) . includes ( 'application/json' ) ) {", "del_tokens": "if ( response . type === 'application/json' ) { if ( request . body && xhr . getResponseHeader ( 'Content-Type' ) === 'application/json' ) {", "commit_type": "add"}
{"commit_tokens": ["fix", "url", "parameters", "when", "dockerHostName", "is", "not", "available"], "add_tokens": "if ( ! err && dockerHostName ) {", "del_tokens": "if ( ! err ) {", "commit_type": "fix"}
{"commit_tokens": ["moving", "casper", "attestation", "to", "SSL", "endpoint"], "add_tokens": "} else if ( result && + result . code === 200 && result . attestation ) { return cb ( null , result . attestation )", "del_tokens": "} else if ( result && + result . code === 200 ) { return cb ( null , result . signedAttestation )", "commit_type": "move"}
{"commit_tokens": ["add", "safe", "check", "for", "classList", "property", "svg", "element", "could", "not", "have", "it", "on", "some", "browser"], "add_tokens": "} else if ( e . target . classList && e . target . classList . contains ( builderParams . optionClass ) && panel . contains ( e . target ) ) { if ( e . target . classList && e . target . classList . contains ( builderParams . optionClass ) ) {", "del_tokens": "} else if ( e . target . classList . contains ( builderParams . optionClass ) && panel . contains ( e . target ) ) { if ( e . target . classList . contains ( builderParams . optionClass ) ) {", "commit_type": "add"}
{"commit_tokens": ["Changed", ":", "date", "format", "at", "import", "to", "ease", "readbility"], "add_tokens": "time : this . model . getFormattedDate ( '{yyyy}/{MM}/{dd} {HH}:{mm}' ) , start : this . model . getFormattedStartDate ( '{yyyy}/{MM}/{dd} {HH}:{mm}' ) , end : this . model . getFormattedEndDate ( '{yyyy}/{MM}/{dd} {HH}:{mm}' ) ,", "del_tokens": "time : this . model . getFormattedDate ( '{MM}/{dd}/{yyyy} {HH}:{mm}' ) , start : this . model . getFormattedStartDate ( '{MM}/{dd}/{yyyy} {HH}:{mm}' ) , end : this . model . getFormattedEndDate ( '{MM}/{dd}/{yyyy} {HH}:{mm}' ) ,", "commit_type": "change"}
{"commit_tokens": ["Updating", "server", "to", "only", "write", "pid", "if", "it", "successfully", "listens"], "add_tokens": "http . createServer ( app ) . listen ( 8000 , function ( ) { fs . writeFileSync ( pidFile , process . pid , 'utf-8' ) ; } ) ;", "del_tokens": "http . createServer ( app ) . listen ( 8000 ) ; fs . writeFileSync ( pidFile , process . pid , 'utf-8' ) ;", "commit_type": "update"}
{"commit_tokens": ["add", "strict", "and", "remove", "should"], "add_tokens": "/* jslint node: true */ 'use strict' ; module . exports = require ( './lib/sodium' ) ;", "del_tokens": "module . exports = require ( './lib/sodium' ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "streaming", "tests", "for", "engines", "that", "don", "t", "have", "simple", "_id", "creation"], "add_tokens": "assert . deepEqual ( data . a , 1 ) engine . create ( { a : 1 , } , function ( err , existingEntity ) { assert . equal ( data . a , 2 ) assert . equal ( existingEntity . _id , data . _id ) engine . write ( { _id : existingEntity . _id , a : 2 } ) engine . end ( ) } ) assert . equal ( data . a , 2 ) engine . write ( { _id : 1 , a : 2 } )", "del_tokens": "assert . deepEqual ( data , { _id : 1 , a : 1 } ) engine . create ( { _id : 1 , a : 1 , } , function ( ) { assert . deepEqual ( data , { _id : 1 , a : 2 } ) } ) engine . write ( { _id : 1 , a : 2 } ) engine . end ( ) assert . deepEqual ( data , { _id : 3 , a : 2 } ) engine . write ( { _id : 3 , a : 2 } )", "commit_type": "fix"}
{"commit_tokens": ["Make", "ISO", "Date", "string", "TZ", "safe"], "add_tokens": "Date . UTC ( 2013 , 2 , 1 , 8 , 4 , 6 , 3 ) ) ;", "del_tokens": "// TODO: make this test not Central time dependent 2013 , 2 , 1 , 2 , 4 , 6 , 3 ) ,", "commit_type": "make"}
{"commit_tokens": ["Fixed", "to", "all", "actually", "work"], "add_tokens": "var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' . split ( '' ) ; if ( item === array [ i ] ) {", "del_tokens": "if ( item === i ) {", "commit_type": "fix"}
{"commit_tokens": ["Add", "ability", "to", "spy", "on", "cordova", ".", "require", "modules", "."], "add_tokens": "contentSync = require ( '../www/sync' ) , execSpy ; beforeEach ( function ( ) { // spy on any cordova.required module just like any other jasmine spy. execSpy = spyOn ( cordova . required , 'cordova/exec' ) ; } ) ; var sync = contentSync . sync ( { src : 'dummySrc' } ) ; expect ( sync ) . toEqual ( jasmine . any ( contentSync . ContentSync ) ) ; } ) ; it ( 'should delegate to exec' , function ( ) { var sync = contentSync . sync ( { src : 'dummySrc' } ) ; // simple expect ( execSpy ) . toHaveBeenCalled ( ) ; // detailed expect ( execSpy ) . toHaveBeenCalledWith ( jasmine . any ( Function ) , null , 'Sync' , 'sync' , jasmine . any ( Object ) ) ;", "del_tokens": "content = cordova . require ( './www/sync' ) ; var options = { src : 'dummySrc' } ; var sync = content . sync ( options ) ; expect ( sync ) . toEqual ( jasmine . any ( content . ContentSync ) ) ;", "commit_type": "add"}
{"commit_tokens": ["Fix", "tests", "&", "update", "installation", "instructions"], "add_tokens": "syntax : 'bootstrap'", "del_tokens": "stylesheet : 'bootstrap'", "commit_type": "fix"}
{"commit_tokens": ["changed", "associate", "(", "ObjID", ")", "-", ">", "identify", "(", "String", ")"], "add_tokens": ", name : { type : String , index : true } session . identify = Identify . bind ( session ) ; function Identify ( name ) { update . session ( this , { $set : { name : name } } , ( err ) => { log . error ( 'session.associate: name save error' , err ) ;", "del_tokens": ", site_id : { type : mongoose . Schema . Types . ObjectId , index : true } session . associate = ID_Update . bind ( session ) ; function ID_Update ( site_id ) { update . session ( this , { $set : { site_id : site_id } } , ( err ) => { log . error ( 'site_id save error' , err ) ;", "commit_type": "change"}
{"commit_tokens": ["use", "envs", "and", "sane", "defaults", "for", "rabbitmq"], "add_tokens": "this . hostname = process . env . RABBITMQ_HOSTNAME || 'localhost' this . port = process . env . RABBITMQ_PORT || 5672 this . username = process . env . RABBITMQ_USERNAME this . password = process . env . RABBITMQ_PASSWORD", "del_tokens": "this . hostname = 'localhost' this . port = 32777 // this.username = 'guest' // this.password = 'guest'", "commit_type": "use"}
{"commit_tokens": ["Add", "auth", "check", "for", "passwords"], "add_tokens": "const auth = Promise . promisify ( require ( '../middleware/auth.js' ) ) ; return message ; return auth ( req , res ) . then ( function userIsAuthenticated ( ) { message . currentPassword = attr . currentPassword ; message . username = req . user . id ; return message ; } ) ; } ) . then ( function updateBackend ( message ) {", "del_tokens": "} else if ( req . user ) { message . currentPassword = attr . currentPassword ; message . username = req . user . id ; } else { throw new Errors . HttpStatusError ( 401 , 'authentication is required' ) ;", "commit_type": "add"}
{"commit_tokens": ["changed", "assign", "key", "value", "to", "recursive", "method", "instead", "of", "loop", ".", "not", "sure", "this", "bought", "anything", "though"], "add_tokens": "var key = keychain . shift ( ) ; // build the current object we need to store data if ( ! currentObj [ key ] ) { currentObj [ key ] = _ . isArray ( key ) ? [ ] : { } ; } if ( keychain . length === 0 ) { // if it's the last key in the chain, assign the value directly if ( _ . isArray ( currentObj [ key ] ) ) { currentObj [ key ] . push ( value ) ; } else { currentObj [ key ] = value ; } else { // recursive parsing of the array assignKeyValue ( currentObj [ key ] , keychain , value ) ;", "del_tokens": "// Loop through each part of the key chain for ( var i = 0 ; i <= keyLength ; i ++ ) { // get the current key var key = keychain [ i ] ; if ( ! currentObj [ key ] ) { currentObj [ key ] = _ . isArray ( key ) ? [ ] : { } ; } if ( i === keyLength ) { // if it's the last key in the chain, assign the value directly if ( _ . isArray ( currentObj [ key ] ) ) { currentObj [ key ] . push ( value ) ; } else { currentObj [ key ] = value ; } currentObj = currentObj [ key ] ;", "commit_type": "change"}
{"commit_tokens": ["Remove", "unnecessary", "methods", "that", "check", "if", "disabled", "from", "service"], "add_tokens": "return ! this . get ( '_disabled' ) ; isPageTrackEnabled ( ) { return ! this . get ( '_defaultPageTrackDisabled' ) ; isIdentifyUserEnabled ( ) { return ! this . get ( '_defaultIdentifyUserDisabled' ) ;", "del_tokens": "return ! this . isDisabled ( ) ; } , isDisabled ( ) { return this . get ( '_disabled' ) ; pageTrackEnabled ( ) { return ! this . pageTrackDisabled ( ) ; } , pageTrackDisabled ( ) { return this . get ( '_defaultPageTrackDisabled' ) ; identifyUserEnabled ( ) { return ! this . identifyUserDisabled ( ) ; } , identifyUserDisabled ( ) { return this . get ( '_defaultIdentifyUserDisabled' ) ;", "commit_type": "remove"}
